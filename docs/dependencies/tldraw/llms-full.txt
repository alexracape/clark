# tldraw SDK features

--------

# Accessibility

Tldraw includes accessibility features for keyboards and assistive technologies. The SDK announces shape selections to screen readers, supports keyboard navigation between shapes, respects reduced motion preferences, and provides hooks for custom shapes to supply descriptive text.

## Screen reader announcements

When users select shapes, tldraw announces the selection to screen readers through a live region. The announcement includes the shape type, any descriptive text, and the shape's position in reading order.

For a single shape selection, the announcement follows this pattern: "[description], [shape type]. [position] of [total]". For example, selecting an image with alt text might announce "A team photo, image. 3 of 7". Multiple selections announce the count: "4 shapes selected".

The announcement system uses the [`DefaultA11yAnnouncer`](/reference/tldraw/reference/tldraw/DefaultA11yAnnouncer) component, which renders a visually hidden live region that screen readers monitor for changes. The [`useA11y`](/reference/tldraw/reference/tldraw/useA11y) hook provides programmatic access to announce custom messages:

```tsx
import { Tldraw, useA11y } from 'tldraw'
import 'tldraw/tldraw.css'

function CustomAnnouncement() {
	const a11y = useA11y()

	const handleCustomAction = () => {
		a11y.announce({ msg: 'Custom action completed', priority: 'polite' })
	}

	return <button onClick={handleCustomAction}>Do action</button>
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw>
				<CustomAnnouncement />
			</Tldraw>
		</div>
	)
}
```

The `priority` option accepts `'polite'` or `'assertive'`. Polite announcements wait for a pause in speech, while assertive announcements interrupt immediately.

> See the [screen reader accessibility example](/examples/ui/screen-reader-accessibility) for custom shape descriptions and announcements.

## Keyboard navigation

Users can navigate between shapes using the keyboard. Tab moves focus to the next shape in reading order, and Shift+Tab moves to the previous shape. Arrow keys with Ctrl/Cmd move selection to the nearest shape in that direction.

Tldraw determines reading order by analyzing shape positions on the canvas. Shapes are grouped into rows based on their vertical position, then sorted left-to-right within each row. This creates a natural top-to-bottom, left-to-right reading order similar to text. You can access this order programmatically with [`Editor.getCurrentPageShapesInReadingOrder`](/reference/editor/reference/editor/Editor#getCurrentPageShapesInReadingOrder).

A "Skip to main content" link appears when users Tab into the editor, allowing keyboard users to jump directly to the first shape on the canvas.

### Excluding shapes from keyboard navigation

Exclude custom shapes from keyboard navigation by overriding [`ShapeUtil.canTabTo`](/reference/editor/reference/editor/ShapeUtil#canTabTo):

```tsx
class DecorativeShapeUtil extends ShapeUtil<DecorativeShape> {
	// Decorative shapes don't receive keyboard focus
	canTabTo() {
		return false
	}

	// ...
}
```

Shapes that return `false` from `canTabTo()` are skipped during Tab navigation and excluded from reading order calculations.

## Shape descriptions for screen readers

When a shape is selected, the announcement includes descriptive text from two sources: the shape's text content and its ARIA descriptor. [`ShapeUtil.getText`](/reference/editor/reference/editor/ShapeUtil#getText) returns the shape's primary text content, while [`ShapeUtil.getAriaDescriptor`](/reference/editor/reference/editor/ShapeUtil#getAriaDescriptor) provides alternative text specifically for accessibility purposes.

For most shapes, `getText()` is sufficient. The default implementation returns `undefined`, which produces announcements with just the shape type and position.

### Providing alt text for media shapes

Image and video shapes support an `altText` property that `getAriaDescriptor()` returns. Users can set alt text through the media toolbar when an image or video is selected:

```tsx
// Setting alt text programmatically
editor.updateShapes([
	{
		id: imageShape.id,
		type: 'image',
		props: { altText: 'A diagram showing the system architecture' },
	},
])
```

### Custom shape descriptions

Custom shapes can provide screen reader descriptions by overriding [`ShapeUtil.getAriaDescriptor`](/reference/editor/reference/editor/ShapeUtil#getAriaDescriptor):

```tsx
class CardShapeUtil extends ShapeUtil<CardShape> {
	getAriaDescriptor(shape: CardShape) {
		// Return a description that makes sense when read aloud
		return `${shape.props.title}: ${shape.props.summary}`
	}

	// ...
}
```

If your shape has visible text, override [`ShapeUtil.getText`](/reference/editor/reference/editor/ShapeUtil#getText) instead. The announcement system checks `getAriaDescriptor()` first, then falls back to `getText()`:

```tsx
class NoteShapeUtil extends ShapeUtil<NoteShape> {
	getText(shape: NoteShape) {
		return shape.props.content
	}

	// ...
}
```

## Reduced motion

The SDK respects user motion preferences through the `animationSpeed` user preference. When set to 0, animations are disabled. By default, this value matches the operating system's `prefers-reduced-motion` setting.

Use [`usePrefersReducedMotion`](/reference/tldraw/reference/tldraw/usePrefersReducedMotion) in custom shape components to check whether to show animations:

```tsx
import { usePrefersReducedMotion } from 'tldraw'

function AnimatedIndicator() {
	const prefersReducedMotion = usePrefersReducedMotion()

	if (prefersReducedMotion) {
		return <StaticIndicator />
	}

	return <PulsingIndicator />
}
```

The hook returns `true` when:

- The `animationSpeed` preference is 0 (the default when the OS prefers reduced motion)
- When used outside an editor context, the operating system's reduced motion preference is enabled

Users can toggle reduced motion through the accessibility menu under Help.

> See the [reduced motion example](/examples/configuration/reduced-motion) for a custom shape that respects motion preferences.

## Enhanced accessibility mode

The `enhancedA11yMode` user preference adds visible labels to UI elements that normally rely on icons alone. When enabled, the style panel shows text labels for each section like "Color", "Opacity", and "Align", making the interface more navigable for users who need additional context.

Toggle this setting programmatically:

```tsx
editor.user.updateUserPreferences({
	enhancedA11yMode: true,
})
```

## Disabling keyboard shortcuts

Some users prefer or require keyboard shortcuts to be disabled, particularly when using assistive technologies that have their own keyboard commands. The `areKeyboardShortcutsEnabled` preference controls this:

```tsx
editor.user.updateUserPreferences({
	areKeyboardShortcutsEnabled: false,
})
```

When disabled, tldraw's keyboard shortcuts don't interfere with assistive technology shortcuts. Basic navigation with Tab and arrow keys still works for shape selection.

## Accessibility menu

The default UI includes an accessibility submenu under Help with toggles for:

| Setting                     | Effect                                        |
| --------------------------- | --------------------------------------------- |
| Reduce motion               | Disables animations                           |
| Keyboard shortcuts          | Enables or disables tldraw keyboard shortcuts |
| Enhanced accessibility mode | Shows visible labels on UI elements           |

You can use these components individually to build custom accessibility controls:

```tsx
import {
	ToggleReduceMotionItem,
	ToggleKeyboardShortcutsItem,
	ToggleEnhancedA11yModeItem,
} from 'tldraw'
```

See [`AccessibilityMenu`](/reference/tldraw/reference/tldraw/AccessibilityMenu) for the default implementation.

## Best practices for custom shapes

When building custom shapes, consider these accessibility guidelines:

**Provide meaningful descriptions.** Override `getAriaDescriptor()` or `getText()` to give screen reader users context about what the shape contains. A shape labeled "card" is less useful than "Meeting notes: Q4 planning session".

**Use semantic HTML where possible.** The shape's `component()` renders inside an HTML container. Use appropriate heading levels, lists, and other semantic elements rather than styled divs.

**Support keyboard interaction.** If your shape has interactive elements, ensure they're focusable and operable with the keyboard. Use standard focus indicators and ARIA attributes where needed.

**Respect motion preferences.** Check `usePrefersReducedMotion()` before showing animations. Provide static alternatives for animated content.

**Consider contrast.** Shape colors must meet WCAG contrast requirements against typical backgrounds. The default color styles are designed with accessibility in mind.

For more on creating custom shapes, see [Custom shapes](/docs/shapes).

## Debugging accessibility

Enable the `a11y` debug flag to log accessibility announcements to the console:

```tsx
import { debugFlags } from '@tldraw/editor'

debugFlags.a11y.set(true)
```

With this flag enabled, the console shows each announcement and logs the accessible name of elements as they receive keyboard focus. This is useful for verifying that your custom shapes provide appropriate descriptions.

--------

# Actions

Actions are named operations that users trigger from menus, keyboard shortcuts, or custom UI. Each action bundles an identifier, display metadata (label, icon, keyboard shortcut), and a handler function. Actions let you define operations like "undo", "group", or "export as PNG" once and invoke them from multiple places with consistent behavior.

```tsx
import { Tldraw, TLUiOverrides } from 'tldraw'
import 'tldraw/tldraw.css'

const overrides: TLUiOverrides = {
	actions(editor, actions, helpers) {
		// Add a custom action
		actions['show-selection-count'] = {
			id: 'show-selection-count',
			label: 'action.show-selection-count',
			kbd: 'shift+c',
			onSelect(source) {
				const count = editor.getSelectedShapeIds().length
				helpers.addToast({ title: `${count} shapes selected` })
			},
		}
		return actions
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw overrides={overrides} />
		</div>
	)
}
```

The `@tldraw/tldraw` package includes about 80 default actions covering editing, arrangement, export, zoom, and preferences. You can override any of these or add your own through the `overrides` prop.

## How actions work

Actions live in a React context provided by `ActionsProvider`. When the UI mounts, it registers all default actions, applies any overrides you've provided, and makes them available through the `useActions` hook. Menus and toolbars look up actions by ID and render them with their labels, icons, and keyboard shortcuts.

Each action has an `onSelect` handler that receives a source parameter indicating where it was triggered:

```tsx
const actions = useActions()
const duplicateAction = actions['duplicate']

// Trigger programmatically
duplicateAction.onSelect('toolbar')
```

Keyboard shortcuts are bound automatically. The `useKeyboardShortcuts` hook parses each action's `kbd` property and registers hotkey handlers. When a shortcut fires, it calls the action's `onSelect` with `'kbd'` as the source.

## Action structure

The `TLUiActionItem` interface defines what an action contains:

```typescript
interface TLUiActionItem {
	id: string
	label?: string | { [key: string]: string }
	icon?: string | React.ReactElement
	kbd?: string
	readonlyOk?: boolean
	checkbox?: boolean
	isRequiredA11yAction?: boolean
	onSelect(source: TLUiEventSource): Promise<void> | void
}
```

| Property               | Description                                                                                                                                                   |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`                   | Unique identifier for the action (e.g., `'duplicate'`, `'zoom-in'`)                                                                                           |
| `label`                | Translation key for display text. Can be a string or an object mapping contexts to different keys (see [Context-sensitive labels](#context-sensitive-labels)) |
| `icon`                 | Icon name from tldraw's icon set, or a custom React element                                                                                                   |
| `kbd`                  | Keyboard shortcut string. Use commas to separate platform alternatives: `'cmd+g,ctrl+g'` binds Cmd+G on Mac and Ctrl+G elsewhere                              |
| `readonlyOk`           | When `true`, the action works in readonly mode. Defaults to `false`                                                                                           |
| `checkbox`             | When `true`, renders as a toggle with a checkmark indicator in menus                                                                                          |
| `isRequiredA11yAction` | When `true`, the keyboard shortcut works even when shortcuts are normally disabled (e.g., while editing a shape). Used for accessibility actions              |
| `onSelect`             | Handler called when the action is triggered. Receives a `source` parameter indicating the trigger origin (`'kbd'`, `'menu'`, `'toolbar'`, etc.)               |

## Accessing actions

Use the `useActions` hook to get all registered actions:

```typescript
import { useActions } from 'tldraw'

function MyComponent() {
	const actions = useActions()

	return (
		<button onClick={() => actions['undo'].onSelect('toolbar')}>
			Undo
		</button>
	)
}
```

The hook returns a record mapping action IDs to action objects. You can iterate over it to build custom menus or filter actions by property.

## Default actions

The default actions cover most editing operations you'd expect in a canvas application. Here are some common categories:

**Editing**: `undo`, `redo`, `duplicate`, `delete`, `copy`, `cut`, `paste`

**Grouping**: `group`, `ungroup`

**Arrangement**: `bring-to-front`, `bring-forward`, `send-backward`, `send-to-back`, `align-left`, `align-center-horizontal`, `align-right`, `distribute-horizontal`, `distribute-vertical`

**Export**: `export-as-svg`, `export-as-png`, `copy-as-svg`, `copy-as-png`

**Zoom**: `zoom-in`, `zoom-out`, `zoom-to-100`, `zoom-to-fit`, `zoom-to-selection`

**Preferences**: `toggle-dark-mode`, `toggle-snap-mode`, `toggle-grid`, `toggle-focus-mode`

Each action includes appropriate guards. For example, `group` checks that multiple shapes are selected before enabling, and arrangement actions verify that shapes can be reordered.

## Overriding actions

Pass an `overrides` prop to customize actions. The override function receives the editor, the default actions, and helper utilities:

```typescript
import { Tldraw, TLUiOverrides } from 'tldraw'

const overrides: TLUiOverrides = {
	actions(editor, actions, helpers) {
		// Modify existing action
		actions['duplicate'].kbd = 'cmd+shift+d,ctrl+shift+d'

		// Disable an action by removing it
		delete actions['print']

		return actions
	},
}

function App() {
	return <Tldraw overrides={overrides} />
}
```

### Modifying behavior

To change what an action does, replace its `onSelect` handler:

```typescript
const overrides: TLUiOverrides = {
	actions(editor, actions, helpers) {
		const originalDuplicate = actions['duplicate'].onSelect

		actions['duplicate'].onSelect = async (source) => {
			console.log('Duplicating shapes...')
			await originalDuplicate(source)
			console.log('Done!')
		}

		return actions
	},
}
```

You can call the original handler before or after your custom logic, or replace it entirely.

### Adding custom actions

Add new actions by inserting them into the actions record:

```typescript
const overrides: TLUiOverrides = {
	actions(editor, actions, helpers) {
		actions['my-custom-action'] = {
			id: 'my-custom-action',
			label: 'action.my-custom-action',
			kbd: 'cmd+shift+k,ctrl+shift+k',
			icon: 'external-link',
			onSelect(source) {
				const shapes = editor.getSelectedShapes()
				console.log('Custom action on', shapes.length, 'shapes')
			},
		}

		return actions
	},
}
```

Custom actions integrate with the keyboard shortcut system automatically. To add them to menus, you'll also need to override the menu components.

### Using helper utilities

The override function receives a `helpers` object with useful utilities:

```typescript
const overrides: TLUiOverrides = {
	actions(editor, actions, helpers) {
		actions['show-toast'] = {
			id: 'show-toast',
			label: 'action.show-toast',
			onSelect(source) {
				helpers.addToast({
					title: 'Hello!',
					description: 'This is a custom action.',
				})
			},
		}

		return actions
	},
}
```

Available helpers:

| Helper                  | Description                          |
| ----------------------- | ------------------------------------ |
| `addToast`              | Show a toast notification            |
| `removeToast`           | Remove a specific toast              |
| `clearToasts`           | Remove all toasts                    |
| `addDialog`             | Open a dialog                        |
| `removeDialog`          | Close a specific dialog              |
| `clearDialogs`          | Close all dialogs                    |
| `msg`                   | Get a translated string by key       |
| `isMobile`              | Boolean indicating mobile breakpoint |
| `insertMedia`           | Open file picker and insert media    |
| `replaceImage`          | Replace selected image with new file |
| `replaceVideo`          | Replace selected video with new file |
| `printSelectionOrPages` | Print selection or all pages         |
| `cut`                   | Cut selected shapes to clipboard     |
| `copy`                  | Copy selected shapes to clipboard    |
| `paste`                 | Paste from clipboard                 |
| `copyAs`                | Copy shapes as SVG or PNG            |
| `exportAs`              | Export shapes as SVG, PNG, or JSON   |
| `getEmbedDefinition`    | Get embed info for a URL             |

## Keyboard shortcuts

Shortcuts use a simple string format with modifier keys separated by `+`. Use commas to specify alternatives for different platforms:

```typescript
kbd: 'cmd+g,ctrl+g' // Cmd+G on Mac, Ctrl+G elsewhere
kbd: 'shift+1' // Shift+1 on all platforms
kbd: 'cmd+shift+s,ctrl+shift+s' // Cmd+Shift+S on Mac, Ctrl+Shift+S elsewhere
```

Available modifiers are `cmd`, `ctrl`, `shift`, and `alt`. Special keys include `del`, `backspace`, `enter`, `escape`, and arrow keys.

Shortcuts are disabled when a menu is open, a shape is being edited, the editor has a crashing error, or the user has disabled keyboard shortcuts in preferences. Actions marked with `isRequiredA11yAction: true` bypass this check for accessibility purposes.

## Actions in menus

The default UI uses `TldrawUiMenuActionItem` to render actions in menus:

```typescript
import { TldrawUiMenuActionItem, TldrawUiMenuGroup } from 'tldraw'

function CustomMenu() {
	return (
		<TldrawUiMenuGroup id="edit">
			<TldrawUiMenuActionItem actionId="undo" />
			<TldrawUiMenuActionItem actionId="redo" />
			<TldrawUiMenuActionItem actionId="duplicate" />
		</TldrawUiMenuGroup>
	)
}
```

This component looks up the action by ID and renders it with the correct label, icon, shortcut hint, and disabled state. For toggle actions, use `TldrawUiMenuActionCheckboxItem` which displays a checkmark when active.

## Context-sensitive labels

Some actions show different labels depending on where they appear. The `label` property can be an object mapping context names to translation keys:

```typescript
actions['export-as-svg'] = {
	id: 'export-as-svg',
	label: {
		default: 'action.export-as-svg',
		menu: 'action.export-as-svg.short',
		'context-menu': 'action.export-as-svg.short',
	},
	// ...
}
```

The menu component uses the appropriate label based on its context. If no specific label exists for a context, it falls back to `default`.

## Tracking action usage

The `source` parameter tells you where the action was triggered. Use this for analytics:

```tsx
actions['custom-action'] = {
	id: 'custom-action',
	label: 'action.custom',
	kbd: 'cmd+k,ctrl+k',
	onSelect(source) {
		trackEvent('custom-action', { source })
		// source: 'kbd', 'menu', 'context-menu', 'toolbar', 'quick-actions', 'zoom-menu', etc.
	},
}
```

## Related examples

- [Action overrides](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/action-overrides) — Add custom actions and modify existing action shortcuts using the overrides prop.
- [Keyboard shortcuts](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/keyboard-shortcuts) — Change keyboard shortcuts for tools and actions.
- [Custom menus](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-menus) — Build custom menus that use actions with proper labels and shortcuts.

--------

# Animation

The animation system controls smooth transitions for shapes and camera movements. Shape animations handle properties like position, rotation, and opacity. Camera animations manage viewport transitions for panning and zooming.

Shape animations run independently and can be interrupted or replaced. Camera animations integrate with the camera system and respect user animation speed preferences for accessibility.

## How it works

Animations in tldraw use the tick system to drive frame-by-frame updates. On each tick, active animations calculate elapsed time, apply easing functions to determine progress, and interpolate between start and end values.

The editor emits `tick` events at the browser's animation frame rate. The animation methods handle all of this internally: when you call `animateShape()` or `setCamera()` with animation options, the editor subscribes to tick events, calculates progress using the easing function, and updates the shape or camera state until the animation completes.

Camera animations respect the user's animation speed preference, which can be set to zero to disable animations entirely. Shape animations do not check this preference. If you need reduced motion support for shape animations, check `editor.user.getAnimationSpeed()` yourself and skip the animation when it returns zero.

## Shape animations

Shape animations enable smooth transitions for individual shape properties. The editor tracks each animating shape independently, allowing multiple concurrent animations that can be interrupted or replaced.

Use `animateShape()` to animate a single shape or `animateShapes()` to animate multiple shapes simultaneously:

```typescript
import { createShapeId, EASINGS } from 'tldraw'

const shapeId = createShapeId('myshape')

editor.animateShape(
	{ id: shapeId, type: 'geo', x: 200, y: 100 },
	{ animation: { duration: 500, easing: EASINGS.easeOutCubic } }
)
```

### Animated properties

The animation system handles interpolation for core shape properties that are common across all shape types. These built-in properties use linear interpolation (lerp) to calculate intermediate values between the start and end states:

- `x` - Horizontal position
- `y` - Vertical position
- `opacity` - Shape transparency (0 to 1)
- `rotation` - Shape rotation angle in radians

For shape-specific properties like width, height, or custom values, shape utilities can define their own interpolation logic by implementing the `getInterpolatedProps()` method. This allows each shape type to control how its unique properties animate. For example, box shapes interpolate their dimensions:

```typescript
getInterpolatedProps(startShape: Shape, endShape: Shape, t: number) {
  return {
    ...endShape.props,
    w: lerp(startShape.props.w, endShape.props.w, t),
    h: lerp(startShape.props.h, endShape.props.h, t),
  }
}
```

### Animation lifecycle

Each animation receives a unique ID when started. The editor maintains a map of shape IDs to animation IDs to track which shapes are currently animating.

You can interrupt animations in two ways. Calling `updateShapes()` on an animating shape cancels its animation and immediately applies the new values. Starting a new animation for a shape automatically cancels any existing animation for that shape.

User interactions always take precedence over ongoing animations. If you drag a shape that's currently animating, the animation stops and the shape responds to your input immediately.

## Camera animations

Camera animations move the viewport smoothly using easing functions. These animations integrate with the camera system and can be interrupted by user input like panning or zooming.

### Viewport animations

The `setCamera()` method accepts an animation option to smoothly transition to a new camera position:

```typescript
editor.setCamera(
	{ x: 0, y: 0, z: 1 },
	{ animation: { duration: 320, easing: EASINGS.easeInOutCubic } }
)
```

Camera animations automatically stop when the user interacts with the viewport through mouse wheel, pinch gestures, or keyboard navigation.

### Zooming to bounds

Use `zoomToBounds()` to animate the camera so a specific area fills the viewport. This is useful for focusing on shapes, navigating between sections, or implementing slideshow-style transitions:

```typescript
const bounds = { x: 0, y: 0, w: 800, h: 600 }
editor.zoomToBounds(bounds, { animation: { duration: 500 } })
```

You can also specify a target zoom level and inset padding:

```typescript
editor.zoomToBounds(bounds, {
	animation: { duration: 500 },
	targetZoom: 1, // zoom to 100%
	inset: 50, // padding around the bounds in pixels
})
```

The `zoomToFit()` method is a convenience wrapper that zooms to fit all shapes on the current page:

```typescript
editor.zoomToFit({ animation: { duration: 200 } })
```

### Camera slide

The `slideCamera()` method creates momentum-based camera movement that gradually decelerates:

```typescript
editor.slideCamera({
	speed: 2,
	direction: { x: 1, y: 0 },
	friction: 0.1,
})
```

This method respects the user's animation speed preference. If animation speed is set to zero, the slide animation is disabled.

## Easing functions

Easing functions control the rate of change during animations, making movements feel natural rather than mechanical. Choose an easing based on the interaction: use `easeOut` variants when responding to user actions (the animation starts fast and settles), `easeIn` for exits or dismissals (gradual start, quick finish), and `easeInOut` for autonomous movements like camera transitions (smooth start and end).

The editor provides these easing functions in `EASINGS`:

- `linear` - Constant rate of change, useful for progress indicators
- `easeInQuad`, `easeOutQuad`, `easeInOutQuad` - Subtle, gentle curves
- `easeInCubic`, `easeOutCubic`, `easeInOutCubic` - Balanced, natural-feeling motion
- `easeInQuart`, `easeOutQuart`, `easeInOutQuart` - More pronounced acceleration
- `easeInQuint`, `easeOutQuint`, `easeInOutQuint` - Strong acceleration curves
- `easeInSine`, `easeOutSine`, `easeInOutSine` - Very gentle, sinusoidal curves
- `easeInExpo`, `easeOutExpo`, `easeInOutExpo` - Dramatic, exponential curves

Shape animations default to `linear` easing. Camera animations default to `easeInOutCubic`. For shape animations responding to user actions, `easeOutCubic` or `easeOutQuad` often feel more responsive since the animation starts fast and settles gradually.

## User preferences

Camera animations check `editor.user.getAnimationSpeed()` before running. This value multiplies animation durations, so users can speed up, slow down, or disable animations entirely.

When animation speed is zero, camera methods like `setCamera()`, `slideCamera()`, `zoomToBounds()`, and `zoomToFit()` skip the animation and jump immediately to the final position. Shape animations via `animateShape()` and `animateShapes()` do not check this preference automatically. If you need reduced motion support for shape animations, check the animation speed yourself:

```typescript
if (editor.user.getAnimationSpeed() > 0) {
	editor.animateShape(
		{ id: shapeId, type: 'geo', x: 200, y: 100 },
		{ animation: { duration: 500 } }
	)
} else {
	editor.updateShape({ id: shapeId, type: 'geo', x: 200, y: 100 })
}
```

## Related examples

The [slideshow example](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/slideshow) uses camera animations to smoothly transition between slides using `zoomToBounds` with animation options. The [camera options example](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/camera-options) demonstrates camera constraints and animations for bounded canvas experiences.

--------

# Assets

Assets are external resources like images, videos, and bookmarks that shapes display on the canvas. They're stored as separate records in the store and referenced by ID from shapes. This lets you reuse the same image across multiple shapes without duplicating data, and swap out storage backends without touching your shapes.

The SDK includes three asset types: image, video, and bookmark. Each asset record holds metadata (dimensions, MIME type, source URL) while the actual file lives wherever you want to put it. You provide upload and resolve handlers that tell tldraw how to store files and fetch them for rendering.

## How it works

### Asset records and the store

Assets live in the store alongside shapes and pages. Each asset record contains metadata (dimensions, MIME type, name) but not the actual file bytes—those live in your storage backend.

When someone drops an image onto the canvas, tldraw creates two records: an asset record with dimensions and metadata, and a shape record with position and size. The shape references the asset through its `assetId` property. Multiple shapes can reference the same asset, so deleting one image shape won't remove the asset if other shapes still use it.

Asset records have a `props` object for type-specific properties and a `meta` object for your custom data. The `src` property in props holds the URL returned by your upload handler—this can be an HTTP URL, a data URL, or any string your resolve handler understands.

### Asset types

The SDK defines three built-in asset types.

**Image assets** store raster images like PNG, JPEG, or GIF. They track width, height, MIME type, animation status, and file size. The `isAnimated` flag is true for animated GIFs.

```typescript
const imageAsset: TLImageAsset = {
	id: 'asset:image123' as TLAssetId,
	typeName: 'asset',
	type: 'image',
	props: {
		w: 1920,
		h: 1080,
		name: 'photo.jpg',
		isAnimated: false,
		mimeType: 'image/jpeg', // can be null if unknown
		src: 'https://storage.example.com/uploads/photo.jpg', // can be null before upload
		fileSize: 245000, // optional
	},
	meta: {},
}
```

**Video assets** store video files like MP4 or WebM. They have the same structure as image assets: dimensions, MIME type, source URL, and `isAnimated` (which is typically true for videos).

```typescript
const videoAsset: TLVideoAsset = {
	id: 'asset:video456' as TLAssetId,
	typeName: 'asset',
	type: 'video',
	props: {
		w: 1920,
		h: 1080,
		name: 'clip.mp4',
		isAnimated: true,
		mimeType: 'video/mp4',
		src: 'https://storage.example.com/uploads/clip.mp4',
		fileSize: 5242880,
	},
	meta: {},
}
```

**Bookmark assets** store web page previews. When someone pastes a URL, tldraw fetches metadata from the page and creates a bookmark that renders as a preview card.

```typescript
const bookmarkAsset: TLBookmarkAsset = {
	id: 'asset:bookmark1' as TLAssetId,
	typeName: 'asset',
	type: 'bookmark',
	props: {
		title: 'Example Website',
		description: 'A great example of web design',
		image: 'https://example.com/preview.jpg',
		favicon: 'https://example.com/favicon.ico',
		src: 'https://example.com',
	},
	meta: {},
}
```

### The TLAssetStore interface

[`TLAssetStore`](/reference/tlschema/reference/tlschema/TLAssetStore) defines how tldraw talks to your storage backend. You provide an implementation when creating the editor, and tldraw calls your handlers whenever someone adds or accesses assets.

The default behavior depends on your store setup:

- **In-memory only** (default): [`inlineBase64AssetStore`](/reference/editor/reference/editor/inlineBase64AssetStore) converts images to data URLs—quick for prototyping but doesn't persist across sessions
- **With [`persistenceKey`](/docs/persistence#The-persistenceKey-prop)**: Assets are stored in the browser's [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) alongside other document data
- **With a [sync server](/docs/sync)**: Implement `TLAssetStore` to upload files to a storage service like S3, Google Cloud Storage, or your own API

The interface has three methods:

| Method    | Purpose                                           |
| --------- | ------------------------------------------------- |
| `upload`  | Store a file and return its URL                   |
| `resolve` | Return the URL to use when rendering an asset     |
| `remove`  | Clean up files when assets are deleted (optional) |

The **upload** method receives an asset record (with metadata already populated) and the File to store. Return an object with `src` (the URL) and optionally `meta` (custom metadata to merge into the asset record). You also get an AbortSignal for cancellation.

```typescript
async upload(asset: TLAsset, file: File, abortSignal?: AbortSignal): Promise<{ src: string; meta?: JsonObject }>
```

The **resolve** method receives an asset and a [`TLAssetContext`](/reference/tlschema/reference/tlschema/TLAssetContext) describing how the asset is being displayed. Return the URL to use for rendering, or null if unavailable. This is where you can get clever—return optimized thumbnails when zoomed out, high-resolution images for export, or add authentication tokens.

```typescript
resolve(asset: TLAsset, ctx: TLAssetContext): Promise<string | null> | string | null
```

The **remove** method receives asset IDs that are no longer needed—clean up the stored files to free space. This method is optional.

```typescript
async remove(assetIds: TLAssetId[]): Promise<void>
```

Here's a minimal implementation that converts files to data URLs (good for prototyping, not so great for production):

```typescript
import { Tldraw, TLAssetStore } from 'tldraw'
import 'tldraw/tldraw.css'

const assetStore: TLAssetStore = {
	async upload(asset, file) {
		const dataUrl = await new Promise<string>((resolve) => {
			const reader = new FileReader()
			reader.onload = () => resolve(reader.result as string)
			reader.readAsDataURL(file)
		})
		return { src: dataUrl }
	},

	resolve(asset, ctx) {
		return asset.props.src
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw assets={assetStore} />
		</div>
	)
}
```

### The TLAssetContext

When resolving assets, tldraw gives you a [`TLAssetContext`](/reference/tlschema/reference/tlschema/TLAssetContext) with information about the current render environment. Use this to optimize asset delivery.

| Property                  | Type             | Description                                                                                                       |
| ------------------------- | ---------------- | ----------------------------------------------------------------------------------------------------------------- |
| `screenScale`             | `number`         | How much the asset is scaled relative to native dimensions. A 1000px image rendered at 500px has screenScale 0.5. |
| `steppedScreenScale`      | `number`         | screenScale rounded to the nearest power of 2, useful for tiered caching.                                         |
| `dpr`                     | `number`         | Device pixel ratio. Retina displays are 2 or 3.                                                                   |
| `networkEffectiveType`    | `string \| null` | Browser's connection type: 'slow-2g', '2g', '3g', or '4g'.                                                        |
| `shouldResolveToOriginal` | `boolean`        | True when exporting or copy-pasting. Return full quality.                                                         |

Here's a resolve handler that serves optimized images based on context—notice how you can tailor the response to network conditions and zoom level:

```typescript
resolve(asset, ctx) {
	const baseUrl = asset.props.src
	if (!baseUrl) return null

	// For exports, always return original
	if (ctx.shouldResolveToOriginal) {
		return baseUrl
	}

	// On slow connections, serve lower quality
	if (ctx.networkEffectiveType === 'slow-2g' || ctx.networkEffectiveType === '2g') {
		return `${baseUrl}?quality=low`
	}

	// Serve resolution appropriate for current zoom
	const targetWidth = Math.ceil(asset.props.w * ctx.steppedScreenScale * ctx.dpr)
	return `${baseUrl}?w=${targetWidth}`
}
```

## Key components

### Editor asset methods

The [`Editor`](/reference/editor/reference/editor/Editor) class provides methods for managing assets:

| Method                      | Description                               |
| --------------------------- | ----------------------------------------- |
| [`Editor.createAssets`](/reference/editor/reference/editor/Editor#createAssets)    | Add asset records to the store            |
| [`Editor.updateAssets`](/reference/editor/reference/editor/Editor#updateAssets)    | Update existing assets with partial data  |
| [`Editor.deleteAssets`](/reference/editor/reference/editor/Editor#deleteAssets)    | Remove assets and call the remove handler |
| [`Editor.getAsset`](/reference/editor/reference/editor/Editor#getAsset)        | Get an asset by ID                        |
| [`Editor.getAssets`](/reference/editor/reference/editor/Editor#getAssets)       | Get all assets in the store               |
| [`Editor.resolveAssetUrl`](/reference/editor/reference/editor/Editor#resolveAssetUrl) | Resolve an asset ID to a renderable URL   |

Asset operations happen outside the undo/redo history since they're typically part of larger operations like pasting images—you don't want "undo" to magically un-upload a file.

```typescript
// Create an asset
editor.createAssets([imageAsset])

// Update an asset (only provide changed fields)
editor.updateAssets([{ id: imageAsset.id, type: 'image', props: { name: 'new-name.jpg' } }])

// Get an asset with type safety
const asset = editor.getAsset<TLImageAsset>(imageAsset.id)

// Resolve to a URL for rendering
const url = await editor.resolveAssetUrl(imageAsset.id, { screenScale: 0.5 })

// Delete assets
editor.deleteAssets([imageAsset.id])
```

### Shape and asset relationships

Shapes reference assets through an `assetId` property in their props. Image shapes, video shapes, and bookmark shapes all follow this pattern. The shape stores position, size, rotation, and crop settings while the asset stores the media metadata and source URL.

This separation pays off:

- Update an asset's `src` and every shape referencing it updates immediately
- Duplicate a shape without duplicating storage
- Implement lazy loading where assets only load when shapes become visible

When you delete an asset, shapes referencing it fall back to displaying the URL directly or show a placeholder.

## Extension points

### Custom storage backends

Implement [`TLAssetStore`](/reference/tlschema/reference/tlschema/TLAssetStore) to integrate with any storage backend. For local development, convert files to data URLs. For production, upload to S3, Google Cloud Storage, or your own API—whatever works for you.

Here's an example that uploads to a custom API:

```typescript
const assetStore: TLAssetStore = {
	async upload(asset, file, abortSignal) {
		const formData = new FormData()
		formData.append('file', file)
		formData.append('assetId', asset.id)

		const response = await fetch('/api/upload', {
			method: 'POST',
			body: formData,
			signal: abortSignal,
		})

		const { url, uploadedAt } = await response.json()
		return {
			src: url,
			meta: { uploadedAt }, // Custom metadata gets merged into the asset
		}
	},

	resolve(asset, ctx) {
		// Add auth token for private content
		const token = getAuthToken()
		return `${asset.props.src}?token=${token}`
	},

	async remove(assetIds) {
		await fetch('/api/assets', {
			method: 'DELETE',
			body: JSON.stringify({ ids: assetIds }),
		})
	},
}
```

### Custom asset types

You can define custom asset types by extending [`TLBaseAsset`](/reference/tlschema/reference/tlschema/TLBaseAsset). Create a validator with [`createAssetValidator`](/reference/tlschema/reference/tlschema/createAssetValidator), then implement shapes that reference your custom assets.

Custom asset types follow the same storage lifecycle as built-in types. Your upload, resolve, and remove handlers need to support them, and your custom shapes handle the rendering.

### Asset validation and migrations

Asset records use the migration system to evolve their schema. Each asset type has its own migration sequence that handles adding properties, renaming fields, and validating data. When you load a document with old asset records, migrations transform them to the current schema automatically.

Validators ensure asset data matches the expected structure at runtime. The [`assetValidator`](/reference/tlschema/reference/tlschema/assetValidator) uses a discriminated union on the `type` field. If you're creating custom asset types, create validators following the same pattern and add migration sequences to handle schema changes.

## Related examples

- [Hosted images](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/hosted-images) - Implement a TLAssetStore that uploads images to a server
- [Local images](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/local-images) - Create image shapes from local asset records
- [Local videos](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/local-videos) - Create video shapes from local asset records
- [Asset options](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/asset-props) - Control allowed asset types, max size, and dimensions
- [Static assets](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/static-assets) - Pre-load custom fonts and icons

--------

# Bindings

Bindings create persistent relationships between shapes. When you draw an arrow to a rectangle, a binding stores that connection so the arrow stays attached when you move the rectangle. Bindings power features like arrows that follow shapes, stickers that stick to other shapes, and layout constraints that keep shapes aligned.

The SDK handles bookkeeping for you: when you delete a shape, its bindings are cleaned up automatically, and lifecycle hooks let bound shapes react to changes.

## How it works

When you create a binding, the editor stores it as a record with `fromId` and `toId` fields pointing to shape IDs. The editor maintains an index of all bindings touching each shape, making queries efficient. When either shape changes position, transforms, or gets deleted, the binding's `BindingUtil` receives callbacks that can update the bound shapes accordingly.

The system handles several scenarios automatically:

- When a shape is deleted, all its bindings are removed and the remaining shapes receive isolation callbacks
- When shapes are copied, only bindings between copied shapes are duplicated
- When shapes are moved to different pages, cross-page bindings are automatically removed
- When bound shapes are transformed together, the binding maintains their relationship

The bindings index is a computed value that updates incrementally as bindings change, providing fast lookups without scanning all records.

## Key concepts

### Directional relationships

Every binding has direction. The `fromId` points to the source shape, and the `toId` points to the target shape. For arrows, the arrow is always the "from" shape and the shape it points to is the "to" shape. This directionality determines which lifecycle hooks fire and lets the system know which shape "owns" the relationship.

The distinction matters when shapes change. If you move a rectangle that an arrow points to, the arrow's `onAfterChangeToShape` hook fires. If you move the arrow itself, its `onAfterChangeFromShape` hook fires. Both hooks can update the arrow's position, but they're called in different contexts.

### Binding records

A binding record contains just enough information to identify the relationship and store relationship-specific data:

```typescript
interface TLBaseBinding<Type, Props> {
	id: TLBindingId
	typeName: 'binding'
	type: Type
	fromId: TLShapeId
	toId: TLShapeId
	props: Props
	meta: JsonObject
}
```

The `props` field holds binding-specific data. Arrow bindings store the normalized anchor point on the target shape and whether the attachment is "precise" or should snap to the shape's edge. Custom bindings can store any data appropriate to the relationship type.

### BindingUtil lifecycle

Each binding type implements a `BindingUtil` class that responds to events throughout the binding's lifetime. The lifecycle hooks fall into several categories:

**Creation and changes** - `onBeforeCreate`, `onAfterCreate`, `onBeforeChange`, and `onAfterChange` fire when the binding record itself is modified. These hooks can return new binding records to override the changes.

**Shape changes** - `onAfterChangeFromShape` and `onAfterChangeToShape` fire when the bound shapes change. These are the most commonly used hooks for keeping shapes synchronized. Arrow bindings use these to update the arrow's position and parent when the target shape moves.

**Deletion and isolation** - `onBeforeDelete` and `onAfterDelete` fire when the binding is removed. More importantly, `onBeforeIsolateFromShape` and `onBeforeIsolateToShape` fire before a binding is removed due to separation (deletion, copy, or duplication). Isolation hooks let shapes "bake in" the binding's current state before it disappears.

**Batch completion** - `onOperationComplete` fires after all binding operations in a transaction finish. This is useful for computing aggregate updates across multiple related bindings.

### Isolation vs deletion

Isolation callbacks handle a specific problem: when an arrow's target shape is deleted, the arrow shouldn't suddenly point to empty space. The `onBeforeIsolateFromShape` hook lets the arrow update its terminal position to match the current attachment point before the binding is removed. The arrow then appears to "let go" of the shape naturally.

Isolation also occurs during copy and duplicate operations. If you copy an arrow but not its target, the copied arrow needs to convert its binding into a fixed position. The isolation callback handles this transformation.

Use isolation callbacks for consistency updates that should happen whenever shapes separate. Use deletion callbacks for actions specific to deletion, like removing a sticker when its parent shape is deleted.

## API patterns

### Creating bindings

Create bindings using `editor.createBinding()` or `editor.createBindings()`. You must provide the binding type, fromId, and toId. The BindingUtil supplies default props.

```typescript
editor.createBinding({
	type: 'arrow',
	fromId: arrowShape.id,
	toId: targetShape.id,
	props: {
		terminal: 'end',
		normalizedAnchor: { x: 0.5, y: 0.5 },
		isPrecise: false,
		isExact: false,
		snap: 'none',
	},
})
```

### Querying bindings

The editor provides several methods for finding bindings:

```typescript
// Get a specific binding by ID
const binding = editor.getBinding(bindingId)

// Get all bindings where this shape is the source
const outgoing = editor.getBindingsFromShape(shape.id, 'arrow')

// Get all bindings where this shape is the target
const incoming = editor.getBindingsToShape(shape.id, 'arrow')

// Get all bindings involving this shape (either direction)
const all = editor.getBindingsInvolvingShape(shape.id, 'arrow')
```

### Updating and deleting bindings

Update bindings with partials, just like shapes:

```typescript
editor.updateBinding({
	id: binding.id,
	props: { normalizedAnchor: { x: 0.8, y: 0.2 } },
})
```

Delete bindings directly or let the system remove them automatically when shapes are deleted. Pass `isolateShapes: true` to trigger isolation callbacks:

```typescript
editor.deleteBinding(binding.id, { isolateShapes: true })
```

### Controlling which shapes can bind

Shapes control whether they accept bindings by implementing `canBind()` in their ShapeUtil:

```typescript
class MyShapeUtil extends ShapeUtil<MyShape> {
	canBind({ fromShapeType, toShapeType, bindingType }: TLShapeUtilCanBindOpts) {
		// Only allow arrow bindings where this shape is the target
		return bindingType === 'arrow' && toShapeType === this.type
	}
}
```

The editor calls both shapes' `canBind()` methods before creating a binding. If either returns false, the binding is not created.

## Extension points

Custom binding types let you create new kinds of relationships between shapes. The process involves defining the binding's data structure, implementing its behavior, and registering it with the editor.

### Defining the binding type

First, extend the type system to include your binding's props. Use TypeScript's module augmentation to add your binding type to the global binding props map:

```typescript
declare module 'tldraw' {
	export interface TLGlobalBindingPropsMap {
		myBinding: {
			anchor: VecModel
			strength: number
		}
	}
}
```

### Implementing BindingUtil

Create a class extending `BindingUtil` with your binding type. At minimum, implement `getDefaultProps()`. Add lifecycle hooks based on what behavior you need:

```typescript
class MyBindingUtil extends BindingUtil<MyBinding> {
	static override type = 'myBinding'

	override getDefaultProps() {
		return { anchor: { x: 0.5, y: 0.5 }, strength: 1 }
	}

	override onAfterChangeToShape({ binding, shapeAfter }) {
		// Update the "from" shape when the "to" shape moves
	}

	override onBeforeIsolateFromShape({ binding }) {
		// Bake in current state before the binding is removed
	}
}
```

### Registering the binding

Pass your BindingUtil to the editor via the `bindingUtils` prop:

```tsx
<Tldraw bindingUtils={[MyBindingUtil]} />
```

## Related examples

The examples app includes several binding implementations that demonstrate different use cases:

- **[Sticker bindings](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/sticker-bindings)** - Shapes that stick to other shapes and follow them when moved. Demonstrates `onAfterChangeToShape` for position updates and `onBeforeDeleteToShape` for cascading deletion.
- **[Pin bindings](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/pin-bindings)** - Pins that connect networks of shapes together, moving them as a group. Demonstrates `onOperationComplete` for computing aggregate updates across multiple related bindings.
- **[Layout bindings](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/layout-bindings)** - Constraining shapes to layout positions. Demonstrates using bindings to enforce spatial relationships between shapes.

--------

# Camera system

The camera system controls how users view and navigate the infinite canvas. It manages viewport position and zoom level, and transforms coordinates between screen space and page space. The editor uses these transformations to map mouse positions to canvas locations and render shapes at any zoom level.

The camera handles user input for panning and zooming, supports constraints for bounded experiences, and provides methods for programmatic movement with smooth animations. It also integrates with collaboration features for real-time viewport following.

## How it works

The camera represents the viewport's position and zoom using three values: `x` and `y` for position in page space, and `z` for zoom level. A zoom of `1` means 100%, `0.5` is 50%, and `2` is 200%. The camera's x and y coordinates represent the top-left corner of the viewport in page coordinates.

The camera transforms between two coordinate spaces:

- **Screen space** - Browser pixels from the document origin
- **Page space** - The infinite canvas coordinate system

The `screenToPage()` method converts mouse positions to canvas coordinates, while `pageToScreen()` converts canvas coordinates to screen positions:

```typescript
const pagePoint = editor.screenToPage({ x: event.clientX, y: event.clientY })
const screenPoint = editor.pageToScreen({ x: shape.x, y: shape.y })
```

The camera responds to user input through mouse wheel, trackpad gestures, keyboard shortcuts, and touch events. The `wheelBehavior` option determines whether scrolling pans or zooms the viewport.

## Camera options

Camera behavior is configured through `TLCameraOptions`:

```typescript
editor.setCameraOptions({
	isLocked: false,
	wheelBehavior: 'pan',
	panSpeed: 1,
	zoomSpeed: 1,
	zoomSteps: [0.1, 0.25, 0.5, 1, 2, 4, 8],
})
```

The `isLocked` option prevents all camera movement, useful for fixed-viewport experiences.

The `wheelBehavior` option determines how mouse wheel or trackpad scroll affects the viewport: `'pan'` for navigating large diagrams, `'zoom'` for detail work, or `'none'` to disable wheel interaction.

The `panSpeed` and `zoomSpeed` multipliers adjust input sensitivity. Values below 1 slow down movement, values above 1 speed it up.

The `zoomSteps` array defines discrete zoom levels. The first value sets minimum zoom, the last sets maximum zoom, and intermediate values determine snap points for zoom controls.

## Camera constraints

Camera constraints limit where users can navigate. Use them for presentations, guided experiences, or applications with fixed content areas:

```typescript
editor.setCameraOptions({
	constraints: {
		bounds: { x: 0, y: 0, w: 1920, h: 1080 },
		padding: { x: 50, y: 50 },
		origin: { x: 0.5, y: 0.5 },
		initialZoom: 'fit-min',
		baseZoom: 'default',
		behavior: 'inside',
	},
})
```

The `bounds` define the constrained area in page space. The camera restricts panning outside this rectangle based on the `behavior` setting.

The `padding` adds screen space margin inside the viewport, preventing content from touching the screen edges.

The `origin` determines how bounds are positioned within the viewport when using `'fixed'` behavior. Values of `{ x: 0.5, y: 0.5 }` center the bounds, while `{ x: 0, y: 0 }` aligns to the top-left.

### Zoom fitting

The `initialZoom` and `baseZoom` options control how content fits the viewport:

- `'default'`: 100% zoom, showing content at actual size
- `'fit-min'`: Fit the smaller axis, ensuring all bounds are visible
- `'fit-max'`: Fit the larger axis, potentially cropping content
- `'fit-x'`: Fit horizontally, filling the viewport width
- `'fit-y'`: Fit vertically, filling the viewport height
- `'fit-x-100'`: Fit horizontally or use 100%, whichever is smaller
- `'fit-y-100'`: Fit vertically or use 100%, whichever is smaller
- `'fit-min-100'`: Fit the smaller axis or use 100%, whichever is smaller
- `'fit-max-100'`: Fit the larger axis or use 100%, whichever is smaller

The `initialZoom` sets the starting zoom when the camera resets. The `baseZoom` defines the reference point for zoom steps, affecting how zoom in/out operations scale relative to the viewport.

### Constraint behaviors

The `behavior` option controls how bounds constrain camera movement:

- `'free'`: Bounds are ignored, allowing unlimited panning
- `'fixed'`: Bounds are positioned at the origin regardless of pan attempts
- `'inside'`: Bounds must stay completely within the viewport
- `'outside'`: Bounds must stay touching the viewport edges
- `'contain'`: Uses `'fixed'` when zoomed out and `'inside'` when zoomed in

Set behavior per axis for asymmetric constraints:

```typescript
behavior: {
  x: 'free',    // Horizontal panning unrestricted
  y: 'inside',  // Vertical panning keeps bounds visible
}
```

## Camera methods

The editor provides methods for programmatic camera control. All methods accept an optional options object with:

- `animation` - add smooth transitions with `duration` and `easing`
- `immediate` - move the camera immediately rather than on the next tick
- `force` - move the camera even when `isLocked` is true

### Basic navigation

Move the camera to a specific position and zoom:

```typescript
editor.setCamera({ x: -500, y: -300, z: 1.5 })
```

Center the viewport on a point:

```typescript
editor.centerOnPoint({ x: 1000, y: 500 })
```

Zoom in or out. Both methods accept an optional screen point to zoom toward:

```typescript
editor.zoomIn()
editor.zoomOut()
editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })
```

### Zoom to content

Focus the camera on shapes or bounds:

```typescript
// Fit all shapes on the current page
editor.zoomToFit()

// Fit the current selection
editor.zoomToSelection()

// Reset zoom to 100% (or initial zoom if constraints are set)
editor.resetZoom()

// Fit specific bounds with padding
const bounds = { x: 0, y: 0, w: 1000, h: 800 }
editor.zoomToBounds(bounds, { inset: 100 })
```

The `zoomToBounds` method accepts `inset` to add padding around the bounds and `targetZoom` to limit the maximum zoom level.

### Animated movement

Add smooth transitions using the `animation` option. The `EASINGS` object provides common easing functions:

```typescript
import { EASINGS } from 'tldraw'

editor.setCamera(
	{ x: 0, y: 0, z: 1 },
	{
		animation: {
			duration: 500,
			easing: EASINGS.easeInOutCubic,
		},
	}
)
```

Camera animations stop automatically when users pan or zoom, ensuring user input takes precedence over programmatic movement. You can also stop camera animations at any time with the editor's `stopCameraAnimation()` method.

### Momentum scrolling

Create momentum-based camera movement:

```typescript
editor.slideCamera({
	speed: 2,
	direction: { x: 1, y: 0 },
	friction: 0.1,
	speedThreshold: 0.01,
})
```

The `speed` and `direction` control initial velocity. The `friction` value determines how fast the camera decelerates (higher friction stops movement faster). The `speedThreshold` sets the minimum speed before the animation stops completely. Use this for kinetic scrolling or to continue movement after gesture completion.

## Collaboration features

The camera system integrates with collaboration through user following. When following another user, the camera tracks their viewport position and zoom.

User following respects the follower's viewport size. If aspect ratios differ, the system adjusts zoom to keep the followed user's content visible while maintaining the follower's viewport dimensions.

See [User following](/docs/user-following) for implementation details.

## Related examples

- **[Camera options](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/camera-options)** - Configure the camera's options and constraints including zoom behavior, pan speed, and camera bounds.
- **[Image annotator](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/image-annotator)** - An image annotator that demonstrates how to configure camera options for fixed-viewport annotation apps.
- **[Slideshow (fixed camera)](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/slideshow)** - A simple slideshow app with a fixed camera using camera constraints.
- **[Lock camera zoom](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/lock-camera-zoom)** - Lock the camera at a specific zoom level using the camera controls API.
- **[Zoom to bounds](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/zoom-to-bounds)** - Programmatically zoom the camera to specific bounds using the editor's `zoomToBounds` method.
- **[Scrollable container](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/scroll)** - Use the editor inside a scrollable container with proper mousewheel event handling.

--------

# Click detection

In tldraw, the click detection system lets you respond to double, triple, and quadruple clicks. The [`ClickManager`](/reference/editor/reference/editor/ClickManager) tracks consecutive pointer down events using a state machine, dispatching click events when timing and distance thresholds are met.

This powers text editing features like word selection on double-click and paragraph selection on triple-click. You can use these events to add custom multi-click behaviors in your own shapes and tools.

## How it works

When a pointer down event occurs, the manager either starts a new sequence or advances to the next click level. Each state has a timeout that determines how long to wait for the next click before settling on the current level.

Two timeout durations control the detection speed. The first click uses `doubleClickDurationMs` (450ms by default), giving users time to initiate a double-click sequence. Subsequent clicks use the shorter `multiClickDurationMs` (200ms by default), requiring faster input for triple and quadruple clicks. This pattern matches common operating system behavior.

### State transitions

The click state machine progresses through these states:

| State              | Description                                |
| ------------------ | ------------------------------------------ |
| `idle`             | No active click sequence                   |
| `pendingDouble`    | First click registered, waiting for second |
| `pendingTriple`    | Second click registered, waiting for third |
| `pendingQuadruple` | Third click registered, waiting for fourth |
| `pendingOverflow`  | Fourth click registered, waiting for fifth |
| `overflow`         | More than four clicks detected             |

When a pointer down event arrives, the state advances to the next pending state and sets a timeout. If the timeout expires before the next click, the manager dispatches a settle event for the current click level and returns to idle. If another pointer down arrives before the timeout, the state advances and a click event is dispatched immediately.

### Distance validation

Consecutive clicks must occur within a maximum distance of 40 pixels (screen space). If pointer down events are farther apart, the click sequence resets to idle.

### Click event phases

Click events are dispatched with a `phase` property indicating when in the sequence the event fired:

| Phase    | When it fires                                                  |
| -------- | -------------------------------------------------------------- |
| `down`   | Immediately when a multi-click is detected during pointer down |
| `up`     | During pointer up for multi-clicks that are still pending      |
| `settle` | When the timeout expires without further clicks                |

The phase system lets tools and shapes respond at different points in the click sequence. For example, the hand tool waits for the `settle` phase before zooming in—this avoids triggering a zoom if the user is about to triple-click.

### Movement cancellation

If the pointer moves too far during a pending click sequence, the system cancels the sequence and returns to idle. This prevents multi-click detection during click-drag operations. The movement threshold differs for coarse pointers (touchscreens) and fine pointers (mouse, stylus).

## Handling click events

Tools receive click events through handler methods defined in the [`TLEventHandlers`](/reference/editor/reference/editor/TLEventHandlers) interface. Here's a complete example of a custom tool that zooms in on double-click:

```tsx
import { StateNode, TLClickEventInfo, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

class ZoomTool extends StateNode {
	static override id = 'zoom'

	override onDoubleClick(info: TLClickEventInfo) {
		if (info.phase !== 'settle') return
		this.editor.zoomIn(info.point, { animation: { duration: 200 } })
	}

	override onTripleClick(info: TLClickEventInfo) {
		if (info.phase !== 'settle') return
		this.editor.zoomOut(info.point, { animation: { duration: 200 } })
	}
}

const customTools = [ZoomTool]

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				tools={customTools}
				onMount={(editor) => {
					editor.setCurrentTool('zoom')
				}}
			/>
		</div>
	)
}
```

Tools can handle [`StateNode.onDoubleClick`](/reference/editor/reference/editor/StateNode#onDoubleClick), [`StateNode.onTripleClick`](/reference/editor/reference/editor/StateNode#onTripleClick), and [`StateNode.onQuadrupleClick`](/reference/editor/reference/editor/StateNode#onQuadrupleClick) events. Each receives a [`TLClickEventInfo`](/reference/editor/reference/editor/TLClickEventInfo) object with details about the click.

Shape utilities handle double-clicks through the [`ShapeUtil.onDoubleClick`](/reference/editor/reference/editor/ShapeUtil#onDoubleClick) method. Return a partial shape object to apply changes:

```tsx
override onDoubleClick(shape: MyShape) {
	return {
		id: shape.id,
		type: shape.type,
		props: { expanded: !shape.props.expanded },
	}
}
```

The [`TLClickEventInfo`](/reference/editor/reference/editor/TLClickEventInfo) type includes these properties:

| Property    | Type                                                    | Description                                            |
| ----------- | ------------------------------------------------------- | ------------------------------------------------------ |
| `type`      | `'click'`                                               | Event type identifier                                  |
| `name`      | `'double_click' \| 'triple_click' \| 'quadruple_click'` | Which multi-click event this is                        |
| `point`     | `VecLike`                                               | Pointer position in client space                       |
| `pointerId` | `number`                                                | Unique identifier for the pointer                      |
| `button`    | `number`                                                | Mouse button (0 = left, 1 = middle, 2 = right)         |
| `phase`     | `'down' \| 'up' \| 'settle'`                            | When in the click sequence this fired                  |
| `target`    | `'canvas' \| 'selection' \| 'shape' \| 'handle'`        | What was clicked                                       |
| `shape`     | `TLShape \| undefined`                                  | The shape, when target is `'shape'` or `'handle'`      |
| `handle`    | `TLHandle \| undefined`                                 | The handle, when target is `'handle'`                  |
| `shiftKey`  | `boolean`                                               | Whether Shift was held                                 |
| `altKey`    | `boolean`                                               | Whether Alt/Option was held                            |
| `ctrlKey`   | `boolean`                                               | Whether Control was held                               |
| `metaKey`   | `boolean`                                               | Whether Meta/Command was held                          |
| `accelKey`  | `boolean`                                               | Platform accelerator key (Cmd on Mac, Ctrl on Windows) |

## Timing configuration

Click timing is configured through the editor's [options](/docs/options):

| Option                  | Default | Description                                              |
| ----------------------- | ------- | -------------------------------------------------------- |
| `doubleClickDurationMs` | 450ms   | Time window for the first click to become a double-click |
| `multiClickDurationMs`  | 200ms   | Time window for subsequent clicks in the sequence        |

## Related examples

- [Canvas events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/canvas-events) — logs pointer events including click sequences to understand the event flow
- [Custom double-click behavior](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-double-click-behavior) — overrides the default double-click handler in the SelectTool
- [Custom shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-shape) — implements `onDoubleClick` and other click handlers in custom shapes

--------

# Clipboard

The clipboard lets you copy, cut, and paste shapes within a single editor or between different editor instances. When you copy shapes, the editor serializes them along with their bindings and assets into a [`TLContent`](/reference/editor/reference/editor/TLContent) object. This format preserves document structure and relationships so shapes paste correctly elsewhere.

## How clipboard operations work

Clipboard operations have two flows: extracting content (copy/cut) and placing content (paste).

### Extracting content

When you copy or cut shapes, the editor calls [`Editor.getContentFromCurrentPage`](/reference/editor/reference/editor/Editor#getContentFromCurrentPage) to serialize them into a [`TLContent`](/reference/editor/reference/editor/TLContent) object:

```ts
const content = editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
// content contains shapes, bindings, assets, and schema
```

This method collects the selected shapes and their descendants, gathers bindings between them, and includes any referenced assets. Root shapes (those whose parents aren't in the selection) get transformed to page coordinates so they paste at the correct position.

The method keeps only bindings where both the `fromId` and `toId` shapes are in the copied set. This prevents dangling references to shapes that won't exist in the pasted content.

### Placing content

[`Editor.putContentOntoCurrentPage`](/reference/editor/reference/editor/Editor#putContentOntoCurrentPage) handles paste operations. It takes [`TLContent`](/reference/editor/reference/editor/TLContent) and reconstructs shapes on the current page:

```ts
// Paste at a specific point
editor.putContentOntoCurrentPage(content, {
	point: { x: 100, y: 100 },
	select: true,
})

// Paste and preserve original positions
editor.putContentOntoCurrentPage(content, {
	preservePosition: true,
})
```

The method migrates the content through the store's schema system to handle version differences, remaps shape and binding IDs to prevent collisions, and finds an appropriate parent for the pasted shapes.

The parent selection logic works like this: if shapes are selected when pasting, the editor finds the selected shape with the fewest ancestors and uses its parent. This creates intuitive behavior where pasting with a frame selected places shapes inside the frame, while pasting with shapes on the page pastes beside them. When pasting at a specific point (like the cursor position), the editor looks for an appropriate parent at that location.

### Browser clipboard integration

The editor writes clipboard data in multiple formats. For HTML-aware applications, it embeds serialized [`TLContent`](/reference/editor/reference/editor/TLContent) in a `<div data-tldraw>` element. For plain text, it extracts text from text shapes. This multi-format approach preserves tldraw-specific data while staying compatible with other applications.

The clipboard uses a versioned format with compression. Version 3 (the current format) stores assets as plain JSON and compresses other data using LZ compression. This reduces payload size while keeping asset information quickly accessible.

When pasting, the editor tries the browser's Clipboard API first because it preserves metadata that the clipboard event API strips out. If that fails, it falls back to reading from the paste event's clipboard data. The editor handles images, files, URLs, HTML, and plain text, routing each through the appropriate handler.

### Asset resolution

Before writing to the clipboard, the editor calls [`Editor.resolveAssetsInContent`](/reference/editor/reference/editor/Editor#resolveAssetsInContent) to convert asset references into data URLs:

```ts
const content = editor.getContentFromCurrentPage(editor.getSelectedShapeIds())
const resolved = await editor.resolveAssetsInContent(content)
// resolved.assets now contain data URLs instead of asset references
```

This embeds images and videos directly in the clipboard data rather than relying on URLs that might not be accessible when pasting elsewhere. The resolved content becomes fully portable across editor instances.

### Cut operations

Cut combines copy and delete. The editor first copies the selected shapes to the clipboard, then deletes the originals. This order ensures the clipboard has the data before shapes disappear, preventing data loss if the copy fails.

## Content structure

The [`TLContent`](/reference/editor/reference/editor/TLContent) type defines the clipboard payload:

```ts
interface TLContent {
	shapes: TLShape[]
	bindings: TLBinding[] | undefined
	rootShapeIds: TLShapeId[]
	assets: TLAsset[]
	schema: SerializedSchema
}
```

- `shapes` contains all copied shapes in serialized form
- `rootShapeIds` identifies which shapes have no parent in the copied set, distinguishing top-level shapes from nested children
- `bindings` holds relationships between shapes, like arrows connected to boxes
- `assets` includes images, videos, and other external resources
- `schema` preserves the store schema version, enabling migration when pasting content from a different editor version

## Position handling

[`Editor.putContentOntoCurrentPage`](/reference/editor/reference/editor/Editor#putContentOntoCurrentPage) offers flexible positioning:

- By default, shapes paste at a slight offset from their original position, making it clear that new shapes were created
- When pasting with the shift key pressed (or with paste-at-cursor mode enabled), shapes paste at the cursor position
- The `preservePosition` option places shapes at their exact stored coordinates, skipping offset calculation entirely

The editor uses `preservePosition` internally when moving shapes between pages, where position preservation matters.

## ID remapping

Shape and binding IDs get remapped during paste to prevent collisions with existing shapes. The editor creates a mapping from old IDs to new IDs, then updates all references throughout the pasted content: parent-child relationships, binding endpoints, and asset references all get the new IDs.

The `preserveIds` option disables remapping. This is useful when duplicating pages where you need to maintain specific IDs.

## External content handling

For non-tldraw content (images, URLs, plain text), use [`Editor.putExternalContent`](/reference/editor/reference/editor/Editor#putExternalContent) to route it through registered handlers:

```ts
// Paste files at a specific point
await editor.putExternalContent({
	type: 'files',
	files: droppedFiles,
	point: { x: 100, y: 200 },
})

// Paste a URL
await editor.putExternalContent({
	type: 'url',
	url: 'https://example.com/image.png',
	point: editor.inputs.getCurrentPagePoint(),
})

// Paste text
await editor.putExternalContent({
	type: 'text',
	text: 'Hello world',
	point: { x: 100, y: 100 },
})
```

Register custom handlers with [`Editor.registerExternalContentHandler`](/reference/editor/reference/editor/Editor#registerExternalContentHandler) to customize how different content types are processed. See [External content](/sdk-features/external-content) for details on the handler system.

## Related examples

- [Custom paste behavior](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-paste) shows how to customize paste by registering an external content handler that changes where pasted shapes are positioned.
- [External content sources](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/external-content-sources) shows how to handle different content types when pasting into tldraw, including custom handling for HTML content.

--------

# Collaboration

The `@tldraw/sync` package provides real-time multiplayer collaboration for tldraw. Multiple users can edit the same document simultaneously, see each other's cursors, and follow each other's viewports. The sync system handles connection management, conflict resolution, and presence synchronization automatically.

Collaboration requires a server component to coordinate changes between clients. Use tldraw's demo server for prototyping, or run your own server for production.

## Quick start with the demo server

The fastest way to add multiplayer is with `useSyncDemo`. This hook connects to a hosted demo server that handles synchronization:

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	const store = useSyncDemo({ roomId: 'my-room-id' })

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw store={store} />
		</div>
	)
}
```

Anyone who opens the app with the same `roomId` will see the same document and each other's cursors. The demo server is great for prototyping, but data is deleted after a day and rooms are publicly accessible by ID. Don't use it in production.

## Production setup with useSync

For production, use the `useSync` hook with your own server:

```tsx
import { useSync } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function Room({ roomId }: { roomId: string }) {
	const store = useSync({
		uri: `wss://your-server.com/sync/${roomId}`,
		assets: myAssetStore,
	})

	if (store.status === 'loading') {
		return <div>Connecting...</div>
	}

	if (store.status === 'error') {
		return <div>Connection error: {store.error.message}</div>
	}

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw store={store.store} />
		</div>
	)
}
```

The `useSync` hook returns a `RemoteTLStoreWithStatus` object with three possible states:

| Status          | Description                                                    |
| --------------- | -------------------------------------------------------------- |
| `loading`       | Establishing connection and performing initial sync            |
| `synced-remote` | Connected and syncing. Includes `store` and `connectionStatus` |
| `error`         | Connection failed. Includes `error` with details               |

### Asset storage

Production setups require an asset store for handling images, videos, and other files:

```tsx
const myAssetStore: TLAssetStore = {
	upload: async (asset, file) => {
		const response = await fetch('/api/upload', {
			method: 'POST',
			body: file,
		})
		const { url } = await response.json()
		return { src: url }
	},
	resolve: (asset, context) => {
		// context includes dpr, networkEffectiveType, and shouldResolveToOriginal
		return asset.props.src
	},
}

const store = useSync({
	uri: `wss://your-server.com/sync/${roomId}`,
	assets: myAssetStore,
})
```

See the [Assets](/docs/assets) documentation for more on implementing asset stores.

## User identity

By default, users get a random name and color. To customize this, pass `userInfo`:

```tsx
const store = useSyncDemo({
	roomId: 'my-room',
	userInfo: {
		id: 'user-123',
		name: 'Alice',
		color: '#ff0000',
	},
})
```

For dynamic user info that updates during the session, use an atom:

```tsx
import { atom } from 'tldraw'

const userInfo = atom('userInfo', {
	id: 'user-123',
	name: 'Alice',
	color: '#ff0000',
})

// Later, update the user info
userInfo.set({ ...userInfo.get(), name: 'Alice (away)' })

const store = useSyncDemo({
	roomId: 'my-room',
	userInfo,
})
```

### Integrating with useTldrawUser

If you need to let users edit their preferences through tldraw's UI, use `useTldrawUser`:

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { useState } from 'react'
import { TLUserPreferences, Tldraw, useTldrawUser } from 'tldraw'

export default function App({ roomId }: { roomId: string }) {
	const [userPreferences, setUserPreferences] = useState<TLUserPreferences>({
		id: 'user-123',
		name: 'Alice',
		color: 'coral',
		colorScheme: 'dark',
	})

	const store = useSyncDemo({ roomId, userInfo: userPreferences })
	const user = useTldrawUser({ userPreferences, setUserPreferences })

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw store={store} user={user} />
		</div>
	)
}
```

## Connection status

When using `useSync`, the store object includes connection status information:

```tsx
const store = useSync({ uri, assets })

if (store.status === 'synced-remote') {
	// store.connectionStatus is 'online' or 'offline'
	console.log('Connection:', store.connectionStatus)
}
```

The connection status reflects the WebSocket connection state. When offline, changes are queued locally and sync when the connection resumes.

## Custom presence

The presence system controls what information is shared with other users. By default, it includes cursor position, selected shapes, and viewport bounds. You can customize this with `getUserPresence`:

```tsx
import { getDefaultUserPresence } from 'tldraw'

const store = useSyncDemo({
	roomId: 'my-room',
	getUserPresence(store, user) {
		const defaults = getDefaultUserPresence(store, user)
		if (!defaults) return null

		return {
			...defaults,
			// Remove camera/viewport to disable follow functionality
			camera: undefined,
		}
	},
})
```

Return `null` from `getUserPresence` to hide this user's presence entirely. This is useful for spectator modes where you want a user to observe without appearing in the room.

## Authentication

To add authentication, generate the WebSocket URI dynamically:

```tsx
const store = useSync({
	uri: async () => {
		const token = await getAuthToken()
		return `wss://your-server.com/sync/${roomId}?token=${token}`
	},
	assets: myAssetStore,
})
```

The `uri` option accepts a function that returns a string or Promise. This runs when establishing the connection and on reconnection, so tokens can refresh automatically.

## Running your own server

For production, you'll need to run a sync server. The `@tldraw/sync-core` package provides `TLSocketRoom` for server-side room management.

We provide a complete Cloudflare Workers template that includes:

- WebSocket sync via Durable Objects (one per room)
- Asset storage with R2
- Bookmark unfurling for URL previews
- Production-ready architecture that scales automatically

Get started with the template:

```bash
npx create-tldraw@latest --template sync-cloudflare
```

Or copy the relevant pieces to your existing infrastructure. The template handles the complexity of room lifecycle, connection management, and state persistence.

### Server architecture

The sync server uses a room-based model:

1. Each document has a unique room ID
2. Clients connect via WebSocket to their room
3. The server maintains one `TLSocketRoom` per active room
4. Changes broadcast to all connected clients in real-time
5. The server is authoritative for conflict resolution

```
┌─────────┐     ┌─────────────────┐     ┌─────────┐
│ Client  │────▶│   TLSocketRoom  │◀────│ Client  │
└─────────┘     │   (per room)    │     └─────────┘
                └────────┬────────┘
                         │
                    ┌────▼────┐
                    │ Storage │
                    └─────────┘
```

## Custom shapes and bindings

If you use custom shapes or bindings, register them with the sync hooks using schema options:

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import { MyCustomShapeUtil } from './MyCustomShape'
import { MyCustomBindingUtil } from './MyCustomBinding'

const customShapes = [MyCustomShapeUtil]
const customBindings = [MyCustomBindingUtil]

export default function App({ roomId }: { roomId: string }) {
	const store = useSyncDemo({
		roomId,
		shapeUtils: customShapes,
		bindingUtils: customBindings,
	})

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw store={store} shapeUtils={customShapes} bindingUtils={customBindings} />
		</div>
	)
}
```

Pass the shape and binding utilities to both the sync hook (for schema registration) and the Tldraw component (for rendering). If they don't match, shapes may fail to sync or render correctly.

## Building custom sync

The `@tldraw/sync` package handles many complexities: connection management, reconnection, conflict resolution, and protocol versioning. For most applications, it's the right choice. However, you might need custom sync when integrating with existing infrastructure, using a different transport (like WebRTC), or implementing specialized conflict resolution.

tldraw's store provides the primitives you need to build your own sync layer.

### Listening to changes

The store's `listen` method notifies you when records change:

```tsx
const unsubscribe = editor.store.listen(
	(entry) => {
		// entry.changes contains all modifications
		// entry.source is 'user' (local) or 'remote'
		console.log('Changes:', entry.changes)
	},
	{ source: 'user', scope: 'document' }
)

// Later: stop listening
unsubscribe()
```

Filter options narrow what changes you receive:

| Filter   | Values                                           | Description               |
| -------- | ------------------------------------------------ | ------------------------- |
| `source` | `'user'`, `'remote'`, `'all'`                    | Who made the change       |
| `scope`  | `'document'`, `'session'`, `'presence'`, `'all'` | What type of data changed |

For sync, you typically want `source: 'user'` (only local changes) and `scope: 'document'` (only persistent data).

### Change structure

Changes arrive as a `RecordsDiff` object with three categories:

```tsx
interface RecordsDiff<R> {
	added: Record<string, R> // New records
	updated: Record<string, [from: R, to: R]> // Changed records (before/after)
	removed: Record<string, R> // Deleted records
}
```

Each entry is keyed by record ID. For updates, you get both the previous and current state, which is useful for conflict detection or generating patches.

### Applying remote changes

When you receive changes from other clients, wrap them in `mergeRemoteChanges`:

```tsx
function applyRemoteChanges(records: TLRecord[], deletedIds: TLRecord['id'][]) {
	editor.store.mergeRemoteChanges(() => {
		if (records.length > 0) {
			editor.store.put(records)
		}
		if (deletedIds.length > 0) {
			editor.store.remove(deletedIds)
		}
	})
}
```

This marks the changes as `'remote'` source, so your own listener won't echo them back to the server. It also batches the operations into a single history entry.

### Snapshots and serialization

For initial sync or persistence, serialize the entire store:

```tsx
// Get all document records as a plain object
const data = editor.store.serialize('document')
// Returns: { 'shape:abc': {...}, 'page:xyz': {...}, ... }

// Get a snapshot with schema information (recommended for persistence)
const snapshot = editor.store.getStoreSnapshot('document')
// Returns: { store: {...}, schema: {...} }

// Restore from snapshot (handles migrations automatically)
editor.store.loadStoreSnapshot(snapshot)
```

The snapshot format includes schema information, so tldraw can automatically migrate old data when your schema evolves.

### Presence records

User presence (cursors, selections, viewports) uses special `instance_presence` records:

```tsx
import { InstancePresenceRecordType } from 'tldraw'

// Create a presence record for a remote user
const presence = InstancePresenceRecordType.create({
	id: InstancePresenceRecordType.createId(
		editor.store.id // Store ID identifies this client
	),
	userId: 'user-123',
	userName: 'Alice',
	color: '#ff6b6b',
	currentPageId: editor.getCurrentPageId(),
	cursor: { x: 100, y: 200, type: 'default', rotation: 0 },
	selectedShapeIds: [],
	camera: { x: 0, y: 0, z: 1 },
	screenBounds: { x: 0, y: 0, w: 1920, h: 1080 },
	lastActivityTimestamp: Date.now(),
	chatMessage: '',
	brush: null,
	scribbles: [],
	followingUserId: null,
	meta: {},
})

// Add to store
editor.store.put([presence])

// Update cursor position
editor.store.update(presence.id, (record) => ({
	...record,
	cursor: { ...record.cursor, x: 150, y: 250 },
}))

// Remove when user disconnects
editor.store.remove([presence.id])
```

Listen for presence changes separately from document changes:

```tsx
editor.store.listen(
	(entry) => {
		// Broadcast presence to other clients
		sendPresence(entry.changes)
	},
	{ source: 'user', scope: 'presence' }
)
```

### Example: simple broadcast sync

Here's a minimal example using a WebSocket for broadcast sync (no conflict resolution):

```tsx
import { Tldraw, createTLStore, defaultShapeUtils, TLRecord } from 'tldraw'

function App() {
	const [store] = useState(() => createTLStore({ shapeUtils: defaultShapeUtils }))
	const wsRef = useRef<WebSocket | null>(null)

	useEffect(() => {
		const ws = new WebSocket('wss://your-server.com/room/123')
		wsRef.current = ws

		// Send local changes to server
		const unsubscribe = store.listen(
			(entry) => {
				ws.send(
					JSON.stringify({
						type: 'changes',
						added: Object.values(entry.changes.added),
						updated: Object.values(entry.changes.updated).map(([, to]) => to),
						removed: Object.keys(entry.changes.removed),
					})
				)
			},
			{ source: 'user', scope: 'document' }
		)

		// Apply remote changes
		ws.onmessage = (event) => {
			const msg = JSON.parse(event.data)
			if (msg.type === 'changes') {
				store.mergeRemoteChanges(() => {
					if (msg.added.length || msg.updated.length) {
						store.put([...msg.added, ...msg.updated])
					}
					if (msg.removed.length) {
						store.remove(msg.removed)
					}
				})
			}
		}

		return () => {
			unsubscribe()
			ws.close()
		}
	}, [store])

	return <Tldraw store={store} />
}
```

This example omits important concerns like initial state sync, reconnection handling, and conflict resolution. For production use, consider starting with `@tldraw/sync` and customizing it, or studying its implementation for guidance on handling these edge cases.

## Related examples

- [Multiplayer sync](/examples/collaboration/sync-demo) — Basic multiplayer setup with the demo server
- [Custom user](/examples/collaboration/sync-custom-user) — Setting custom user identity for multiplayer
- [Custom presence](/examples/collaboration/sync-custom-presence) — Customizing presence data sent to collaborators
- [Custom shapes](/examples/collaboration/sync-custom-shape) — Syncing custom shapes with multiplayer

--------

# Coordinates

The editor uses three coordinate systems: screen space, viewport space, and page space. When you move the mouse over the canvas, the browser gives you screen coordinates. To create a shape at that location, you need to convert those coordinates to page space.

The editor provides methods to convert between these coordinate systems. You'll use these when building custom tools, positioning DOM overlays, or responding to pointer events.

## The three coordinate systems

### Screen space

Screen space uses pixel coordinates from the browser window's top-left corner. These are the values you get from `MouseEvent.clientX` and `MouseEvent.clientY`. Screen coordinates include any space outside the editor container, like browser chrome or other page content.

### Viewport space

Viewport space uses pixel coordinates from the editor container's top-left corner. This accounts for where the editor sits on the page. If the editor is embedded in a scrollable element or positioned away from the browser's origin, viewport coordinates differ from screen coordinates by that offset.

The editor tracks the container's position in `editor.getViewportScreenBounds()`.

### Page space

Page space is the infinite canvas itself. A shape at `x: 100, y: 200` stays at those coordinates regardless of how the user pans or zooms. All shape positions are stored in page space.

The camera determines which part of page space is visible. When you zoom in, the same page-space region takes up more screen pixels. When you pan, different page-space coordinates come into view.

## Coordinate transformations

### Screen to page space

Use `editor.screenToPage()` to convert screen coordinates to page coordinates:

```typescript
// Convert mouse event coordinates to page space
const pagePoint = editor.screenToPage({ x: event.clientX, y: event.clientY })

// Create a shape at the clicked location
editor.createShape({
	type: 'geo',
	x: pagePoint.x,
	y: pagePoint.y,
	props: { w: 100, h: 100, geo: 'rectangle' },
})
```

This is the most common transformation. It accounts for the editor container's position, the camera position, and the zoom level.

### Page to screen space

Use `editor.pageToScreen()` to convert page coordinates to screen coordinates:

```typescript
// Convert shape position to screen coordinates
const shape = editor.getShape(shapeId)
const screenPoint = editor.pageToScreen({ x: shape.x, y: shape.y })

// Position a DOM element at the shape's screen location
element.style.left = `${screenPoint.x}px`
element.style.top = `${screenPoint.y}px`
```

Use this when positioning DOM elements relative to shapes on the canvas.

### Page to viewport space

Use `editor.pageToViewport()` to convert page coordinates to viewport coordinates:

```typescript
// Get viewport coordinates for a page point
const viewportPoint = editor.pageToViewport({ x: 500, y: 300 })

// Check if a point is visible in the viewport
const viewportBounds = editor.getViewportScreenBounds()
const isVisible =
	viewportPoint.x >= 0 &&
	viewportPoint.x <= viewportBounds.w &&
	viewportPoint.y >= 0 &&
	viewportPoint.y <= viewportBounds.h
```

This is like `pageToScreen()` but relative to the editor container rather than the browser window. Use this for canvas rendering or when you don't care about the editor's position on the page.

## Viewport bounds

Use `editor.getViewportScreenBounds()` to get the editor container's position and size in screen space:

```typescript
const screenBounds = editor.getViewportScreenBounds()
// screenBounds.x, screenBounds.y - container position in screen space
// screenBounds.w, screenBounds.h - container dimensions in pixels
```

Use `editor.getViewportPageBounds()` to get the visible area in page space:

```typescript
const pageBounds = editor.getViewportPageBounds()
// pageBounds.x, pageBounds.y - top-left corner of visible area in page space
// pageBounds.w, pageBounds.h - visible area dimensions in page units
```

The page bounds change when the user pans or zooms. At higher zoom levels, the visible page-space area is smaller.

## Using the inputs manager

The editor's inputs manager tracks the current pointer position in both coordinate systems. This is useful when you need to access the pointer position from anywhere in your code:

```typescript
// Get the current pointer position
const screenPoint = editor.inputs.getCurrentScreenPoint()
const pagePoint = editor.inputs.getCurrentPagePoint()

// Get the position where the current drag started
const originScreenPoint = editor.inputs.getOriginScreenPoint()
const originPagePoint = editor.inputs.getOriginPagePoint()
```

In custom tools, you can also convert the event's `point` property (which is in screen space) to page space:

```typescript
editor.on('event', (event) => {
	if (event.type === 'pointer' && event.name === 'pointer_down') {
		const pagePoint = editor.screenToPage(event.point)
		// Use pagePoint for shape manipulation
	}
})
```

### Positioning custom overlays

To position a DOM element over a shape, convert the shape's page coordinates to screen coordinates. Then subtract the viewport's screen position to get coordinates relative to the editor container:

```typescript
const shape = editor.getShape(shapeId)
const screenBounds = editor.getViewportScreenBounds()
const screenPoint = editor.pageToScreen({ x: shape.x, y: shape.y })

// Position relative to the editor container
overlay.style.left = `${screenPoint.x - screenBounds.x}px`
overlay.style.top = `${screenPoint.y - screenBounds.y}px`
```

## Related examples

- [Reactive inputs](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/reactive-inputs) - Display page and screen coordinates reactively as the pointer moves.
- [Selection UI](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/selection-ui) - Use selection bounds in screen space to position custom UI around shapes.

--------

# Culling

The culling system optimizes rendering performance by hiding shapes that are outside the viewport.

Culled shapes remain in the DOM but have their `display` property set to `none`, so they don't incur any rendering cost. The system uses incremental derivations to track visibility changes efficiently as the camera moves or shapes change. Performance stays consistent even with thousands of shapes on the canvas.

## Using the culling APIs

The editor provides two methods for working with culled shapes:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function CullingExample() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					// Get shapes outside the viewport (before selection filtering)
					const notVisible = editor.getNotVisibleShapes()

					// Get shapes that should not render (excludes selected/editing shapes)
					const culled = editor.getCulledShapes()

					console.log('Not visible:', notVisible.size)
					console.log('Actually culled:', culled.size)
				}}
			/>
		</div>
	)
}
```

Use [`Editor.getNotVisibleShapes`](/reference/editor/reference/editor/Editor#getNotVisibleShapes) to get all shapes whose bounds don't intersect the viewport. Use [`Editor.getCulledShapes`](/reference/editor/reference/editor/Editor#getCulledShapes) to get the final set of shapes that won't render. The difference between these is that `getCulledShapes` excludes selected shapes and the shape currently being edited, so users can always see what they're working with.

## How it works

The culling system operates in two layers.

The first layer identifies all shapes whose page bounds don't intersect with the viewport. This calculation iterates through every shape on the current page and performs a bounds collision check. The comparison is fast enough to run reactively.

The second layer refines this set by removing shapes that should remain visible despite being outside the viewport. Selected shapes and the currently editing shape are never culled. This means users can scroll a shape partially or fully out of view while still seeing and interacting with it.

## Shape-level control

Each shape type can opt out of culling by overriding the `canCull` method on its ShapeUtil. By default, `canCull` returns `true`, so most shapes participate in culling.

```tsx
import { ShapeUtil, TLBaseShape, RecordProps, T, Rectangle2d } from 'tldraw'

type MyShape = TLBaseShape<'my-shape', { w: number; h: number; hasGlow: boolean }>

class MyShapeUtil extends ShapeUtil<MyShape> {
	static override type = 'my-shape' as const
	static override props: RecordProps<MyShape> = {
		w: T.number,
		h: T.number,
		hasGlow: T.boolean,
	}

	getDefaultProps(): MyShape['props'] {
		return { w: 100, h: 100, hasGlow: false }
	}

	getGeometry(shape: MyShape) {
		return new Rectangle2d({ width: shape.props.w, height: shape.props.h, isFilled: true })
	}

	override canCull(shape: MyShape): boolean {
		// Shapes with glow effects shouldn't be culled because
		// the glow might be visible even when the shape bounds aren't
		if (shape.props.hasGlow) {
			return false
		}
		return true
	}

	component(shape: MyShape) {
		return <div style={{ width: shape.props.w, height: shape.props.h }} />
	}

	indicator(shape: MyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

When `canCull` returns `false`, the culling system treats that shape as always visible regardless of its position.

Common reasons to disable culling:

- Shapes with visual effects (shadows, glows) that extend beyond their bounds
- Shapes that measure their DOM content and need to stay rendered
- Shapes with animations that should continue even when off-screen

## Related examples

- **[Size from DOM](/examples/shapes/size-from-dom)** - A shape that disables culling because it measures its DOM element to determine size.

--------

# Cursor chat

Cursor chat lets users send short messages that appear as bubbles near their cursor. It's designed for quick, ephemeral communication during collaborative sessions—a fast "look here" or "nice work" that doesn't interrupt the canvas workflow.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					// Start chatting programmatically
					editor.updateInstanceState({ isChatting: true })

					// Or set a message directly
					editor.updateInstanceState({
						chatMessage: 'Hello from the canvas!',
					})
				}}
			/>
		</div>
	)
}
```

Cursor chat only appears when collaboration UI is enabled. On desktop, users press `/` to open the chat input, type their message (up to 64 characters), and press Enter to send. The message follows their cursor for a few seconds, then fades away.

## Chat state

Chat state lives in instance state with two properties:

| Property      | Type      | Description                             |
| ------------- | --------- | --------------------------------------- |
| `isChatting`  | `boolean` | Whether the user is actively typing     |
| `chatMessage` | `string`  | The current message (max 64 characters) |

Read the current state with [`Editor.getInstanceState`](/reference/editor/reference/editor/Editor#getInstanceState):

```tsx
const { isChatting, chatMessage } = editor.getInstanceState()
```

Update it with [`Editor.updateInstanceState`](/reference/editor/reference/editor/Editor#updateInstanceState):

```tsx
// Start chatting
editor.updateInstanceState({ isChatting: true })

// Update the message
editor.updateInstanceState({ chatMessage: 'Looking at this shape' })

// Stop chatting and clear the message
editor.updateInstanceState({ isChatting: false, chatMessage: '' })
```

Both properties are ephemeral—they don't persist to storage or survive page reloads.

## How it works

When a user starts chatting:

1. The `CursorChatBubble` component renders an input field at the cursor position
2. The input tracks the cursor via `pointermove` events
3. As the user types, `chatMessage` updates in instance state
4. When they press Enter or the input loses focus, `isChatting` becomes `false`
5. The message displays for 2 seconds, then clears automatically

Messages time out after 5 seconds while typing, or 2 seconds after the user stops.

## Keyboard shortcuts

The default keyboard action for cursor chat is `/`. You can find it under the action ID `open-cursor-chat`:

```tsx
import { Tldraw, useActions } from 'tldraw'

function ChatButton() {
	const actions = useActions()

	return (
		<button onClick={() => actions['open-cursor-chat'].onSelect('menu')}>Open cursor chat</button>
	)
}
```

Inside the chat input:

| Key      | Action                                                            |
| -------- | ----------------------------------------------------------------- |
| `Enter`  | Clear input (if content exists) or stop chatting (if input empty) |
| `Escape` | Stop chatting                                                     |

## Presence synchronization

In multiplayer sessions, chat messages synchronize automatically through presence records. The `chatMessage` field in [`TLInstancePresence`](/reference/tlschema/reference/tlschema/TLInstancePresence) contains the message other users see:

```tsx
import { InstancePresenceRecordType, Tldraw } from 'tldraw'

// Creating a remote user's presence with a chat message
const peerPresence = InstancePresenceRecordType.create({
	id: InstancePresenceRecordType.createId(editor.store.id),
	currentPageId: editor.getCurrentPageId(),
	userId: 'peer-1',
	userName: 'Alice',
	cursor: { x: 100, y: 200, type: 'default', rotation: 0 },
	chatMessage: 'Check out this arrow!',
})

editor.store.mergeRemoteChanges(() => {
	editor.store.put([peerPresence])
})
```

The presence derivation automatically includes the local user's `chatMessage` from instance state. Changes broadcast to other users automatically.

## Customizing the chat bubble

You can replace the default chat bubble by providing a custom `CursorChatBubble` component:

```tsx
import { Tldraw, TLUiComponents, useEditor, track } from 'tldraw'
import 'tldraw/tldraw.css'

const CustomCursorChat = track(function CustomCursorChat() {
	const editor = useEditor()
	const { isChatting, chatMessage } = editor.getInstanceState()

	if (!isChatting && !chatMessage) return null

	return (
		<div
			style={{
				position: 'fixed',
				bottom: 20,
				left: '50%',
				transform: 'translateX(-50%)',
				padding: '8px 16px',
				background: editor.user.getColor(),
				borderRadius: 8,
				color: 'white',
			}}
		>
			{isChatting ? 'Typing...' : chatMessage}
		</div>
	)
})

const components: TLUiComponents = {
	CursorChatBubble: CustomCursorChat,
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={components} />
		</div>
	)
}
```

For customizing how remote users' chat messages appear, override the `CollaboratorCursor` component instead. See [Cursors](/sdk-features/cursors) for details.

## Availability

Cursor chat requires:

- Collaboration enabled (`editor.store.props.collaboration !== undefined`)
- A non-touch device (disabled on mobile/tablet)

Check availability before triggering chat programmatically:

```tsx
const hasCollaboration = editor.store.props.collaboration !== undefined
const isTouchDevice = editor.getInstanceState().isCoarsePointer

if (hasCollaboration && !isTouchDevice) {
	editor.updateInstanceState({ isChatting: true })
}
```

## Related articles

- [Cursors](/sdk-features/cursors) — Cursor types, colors, and collaborator cursor customization
- [Collaboration](/sdk-features/collaboration) — Presence synchronization and multiplayer setup
- [User preferences](/sdk-features/user-preferences) — User colors and identity

## Related examples

- [User presence](/examples/collaboration/user-presence) — Display collaborator cursors and chat messages

--------

# Cursors

The cursor system controls what cursor users see when interacting with the canvas. The current cursor is stored in instance state and changes automatically as users hover over different elements or use different tools. You can also set the cursor manually for custom tools.

## Cursor state

The cursor state consists of a type and a rotation angle. Access it through [`Editor.getInstanceState`](/reference/editor/reference/editor/Editor#getInstanceState):

```typescript
const { type, rotation } = editor.getInstanceState().cursor
```

The `type` determines the visual appearance—like `'default'`, `'grab'`, or `'nwse-resize'`. The `rotation` is an angle in radians that rotates the cursor icon. Rotation is mainly used for resize and rotate cursors so they align with the shape being manipulated.

## Cursor types

tldraw supports these cursor types:

| Type            | Description                                    |
| --------------- | ---------------------------------------------- |
| `default`       | Standard pointer arrow                         |
| `pointer`       | Hand indicating clickable element              |
| `cross`         | Crosshair for precise positioning              |
| `grab`          | Open hand for draggable content                |
| `grabbing`      | Closed hand while dragging                     |
| `text`          | I-beam for text editing                        |
| `move`          | Four-way arrow for moving elements             |
| `zoom-in`       | Magnifying glass with plus                     |
| `zoom-out`      | Magnifying glass with minus                    |
| `ew-resize`     | Horizontal resize (east-west)                  |
| `ns-resize`     | Vertical resize (north-south)                  |
| `nesw-resize`   | Diagonal resize (northeast-southwest)          |
| `nwse-resize`   | Diagonal resize (northwest-southeast)          |
| `resize-edge`   | Edge resize (used for edge handles)            |
| `resize-corner` | Corner resize (used for corner handles)        |
| `nesw-rotate`   | Rotation handle (northeast-southwest position) |
| `nwse-rotate`   | Rotation handle (northwest-southeast position) |
| `senw-rotate`   | Rotation handle (southeast-northwest position) |
| `swne-rotate`   | Rotation handle (southwest-northeast position) |
| `rotate`        | General rotation cursor                        |
| `none`          | Hidden cursor                                  |

Static cursors like `default`, `pointer`, and `grab` use CSS cursor values directly. Dynamic cursors like the resize and rotate types render as custom SVGs with rotation applied.

## Setting the cursor

Use [`Editor.setCursor`](/reference/editor/reference/editor/Editor#setCursor) to change the cursor:

```typescript
editor.setCursor({ type: 'cross', rotation: 0 })
```

You can update just the type or just the rotation—the other property keeps its current value:

```typescript
// Change only the type
editor.setCursor({ type: 'grab' })

// Change only the rotation
editor.setCursor({ type: 'nwse-resize', rotation: Math.PI / 4 })
```

### Cursor rotation

Rotation is specified in radians. When users resize or rotate shapes that are themselves rotated, the cursor rotates to match:

```typescript
// Get the selection's rotation and apply it to a resize cursor
const selectionRotation = editor.getSelectionRotation()
editor.setCursor({
	type: 'nwse-resize',
	rotation: selectionRotation,
})
```

This keeps the cursor aligned with the shape's edges rather than the screen axes. The default tools handle cursor rotation automatically. You only need to set it manually for custom tools.

## Cursors in custom tools

Custom tools typically set the cursor when entering a state and reset it when exiting:

```typescript
import { StateNode } from 'tldraw'

export class MyCustomTool extends StateNode {
	static override id = 'my-tool'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onExit() {
		this.editor.setCursor({ type: 'default', rotation: 0 })
	}
}
```

For tools with child states, each state can set its own cursor. A drawing state might use `'cross'`, while a dragging state uses `'grabbing'`.

## Cursor colors

Dynamic cursors (resize and rotate types) adapt to the current color scheme. In light mode, the cursor style color is set to black. In dark mode, it's set to white. The SVG patterns themselves have fixed black and white fills for contrast. This happens automatically through the internal `useCursor` hook.

## Collaborator cursors

In multiplayer sessions, each user's cursor appears on other users' canvases. These remote cursors use the user's presence color—a randomly assigned color from the user color palette.

### User color palette

When a user first loads tldraw, they're assigned a random color from this palette:

```typescript
const USER_COLORS = [
	'#FF802B',
	'#EC5E41',
	'#F2555A',
	'#F04F88',
	'#E34BA9',
	'#BD54C6',
	'#9D5BD2',
	'#7B66DC',
	'#02B1CC',
	'#11B3A3',
	'#39B178',
	'#55B467',
]
```

You can read or change a user's color through user preferences:

```typescript
// Get the user's color
const color = editor.user.getColor()

// Set a specific color
editor.user.updateUserPreferences({ color: '#FF802B' })
```

### Rendering collaborator cursors

Remote cursors render through the `CollaboratorCursor` component. The default implementation ([`DefaultCursor`](/reference/editor/reference/editor/DefaultCursor)) displays:

- The cursor icon in the user's color
- The user's name as a label below the cursor
- Any active chat message in a bubble

You can customize this by providing your own `CollaboratorCursor` component through [`TLEditorComponents`](/reference/editor/reference/editor/TLEditorComponents):

```tsx
import { Tldraw, TLEditorComponents, TLCursorProps } from 'tldraw'
import 'tldraw/tldraw.css'

function CustomCursor({ point, color, name, zoom }: TLCursorProps) {
	if (!point) return null

	return (
		<div
			style={{
				position: 'absolute',
				transform: `translate(${point.x}px, ${point.y}px) scale(${1 / zoom})`,
			}}
		>
			<div
				style={{
					width: 16,
					height: 16,
					borderRadius: '50%',
					backgroundColor: color,
				}}
			/>
			{name && <span style={{ color }}>{name}</span>}
		</div>
	)
}

const components: TLEditorComponents = {
	CollaboratorCursor: CustomCursor,
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={components} />
		</div>
	)
}
```

### Cursor position in presence

Collaborator cursor positions are stored in presence records ([`TLInstancePresence`](/reference/tlschema/reference/tlschema/TLInstancePresence)). The cursor field includes position, type, and rotation:

```typescript
{
  cursor: {
    x: number
    y: number
    type: TLCursorType
    rotation: number
  } | null
}
```

The editor automatically broadcasts cursor position updates to other users in the same room. Cursor position is null when the user's pointer is outside the canvas.

## Related articles

- [Cursor chat](/sdk-features/cursor-chat) - Send ephemeral chat messages at the cursor position
- [Tools](/sdk-features/tools) - Learn how tools handle input and set cursors
- [Collaboration](/sdk-features/collaboration) - User presence and multiplayer features
- [User preferences](/sdk-features/user-preferences) - Manage user colors and other preferences
- [UI components](/sdk-features/ui-components) - Customize the collaborator cursor component

## Related examples

- [Custom tool](/examples/shapes/tools/custom-tool) - Build a custom tool with cursor handling
- [User presence](/examples/collaboration/user-presence) - Display collaborator cursors and presence

--------

# Deep links

Deep links serialize editor state into URL-safe strings. They let users share links that open the editor at specific locations: individual shapes, viewport positions, or entire pages.

The simplest way to enable deep links is with the `deepLinks` prop:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw persistenceKey="example" deepLinks />
		</div>
	)
}
```

With `deepLinks` enabled, the URL updates as users navigate. Anyone opening the URL sees the same page and viewport position.

For more control, use the editor methods directly: `createDeepLink()` generates URLs with encoded state, `navigateToDeepLink()` moves the editor to a specified location, and `registerDeepLinkListener()` updates URLs automatically as users navigate.

## Deep link types

| Type       | Purpose                      | Encoded prefix | Example use case                  |
| ---------- | ---------------------------- | -------------- | --------------------------------- |
| `shapes`   | Links to specific shapes     | `s`            | Share selected shapes with a team |
| `viewport` | Links to a bounding box view | `v`            | Share current viewport position   |
| `page`     | Links to a specific page     | `p`            | Navigate to a particular page     |

Shape links focus the editor on specific elements. Viewport links preserve the exact camera position and zoom level. Page links navigate to particular pages in multi-page documents.

## How it works

Deep links are encoded as compact strings with a single-character prefix identifying the type:

- Shape links (`s`) encode shape IDs separated by dots: `s<id1>.<id2>.<id3>`
- Viewport links (`v`) encode bounding box coordinates: `v<x>.<y>.<w>.<h>` with optional page ID
- Page links (`p`) encode a page ID: `p<pageId>`

All IDs are URL-encoded to handle special characters. The default query parameter is `d`, but you can customize this. When navigating to a shapes deep link, the editor switches to the page containing the most shapes and zooms to fit them. Viewport links set the camera to the exact specified bounds.

## API methods

### createDeepLink

Creates a URL with a deep link query parameter encoding the current viewport and page:

```typescript
// Create a link to the current viewport
const url = editor.createDeepLink()
navigator.clipboard.writeText(url.toString())
```

Specify a target to link to specific shapes:

```typescript
// Link to currently selected shapes
const url = editor.createDeepLink({
	to: { type: 'shapes', shapeIds: editor.getSelectedShapeIds() },
})
```

### navigateToDeepLink

Navigates the editor to the location specified by a deep link URL or object:

```typescript
// Navigate using the current URL's query parameter
editor.navigateToDeepLink()

// Navigate to a specific URL
editor.navigateToDeepLink({ url: 'https://example.com?d=v100.100.200.200' })

// Navigate directly to shapes
editor.navigateToDeepLink({
	type: 'shapes',
	shapeIds: ['shape:abc' as TLShapeId, 'shape:xyz' as TLShapeId],
})
```

### registerDeepLinkListener

Sets up automatic URL updates as the viewport changes. The listener debounces updates (500ms by default) to avoid excessive history entries:

```typescript
// Use default behavior (updates window.location)
const unlisten = editor.registerDeepLinkListener()

// Custom change handler with longer debounce
const unlisten = editor.registerDeepLinkListener({
	onChange(url) {
		window.history.replaceState({}, document.title, url.toString())
	},
	debounceMs: 1000,
})

// Clean up when done
unlisten()
```

You can also enable this via the `deepLinks` prop on the Tldraw component instead of calling this method directly.

## Related examples

- **[Deep links](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/deep-links)** - Demonstrates how to use the `deepLinks` prop to enable URL-based navigation and how to create, parse, and handle deep links manually using the editor methods.

--------

# Default shapes

The tldraw package includes thirteen shape types that cover common diagramming and whiteboarding needs. Each shape type has a corresponding [`ShapeUtil`](/reference/editor/reference/editor/ShapeUtil) that defines its rendering, geometry, and interaction behavior. You can use these shapes as-is, configure their behavior through options, or use them as reference when building custom shapes.

## Shape overview

The default shapes loosely fall into five categories based on their primary function:

| Category   | Shape types                           | Description                                                           |
| ---------- | ------------------------------------- | --------------------------------------------------------------------- |
| Text       | `text`, `note`                        | Text labels and sticky notes                                          |
| Drawing    | `geo`, `draw`, `line`, `highlight`    | Freehand strokes, multi-point lines, geometric shapes, and highlights |
| Media      | `image`, `video`, `bookmark`, `embed` | External content and media files                                      |
| Structural | `frame`, `group`                      | Organization and containment                                          |
| Connectors | `arrow`                               | Lines that connect shapes together                                    |

## Basic shapes

### Geo

The geo shape renders geometric primitives with optional text labels. It supports 20 different geometric forms—rectangles, ellipses, triangles, stars, polygons, directional arrows, and special shapes like clouds and hearts. Geo shapes can display rich text labels with configurable alignment, making them the foundation for flowcharts, diagrams, and annotated illustrations.

For complete documentation on geometric forms, label positioning, tool interactions, and configuration, see [Geo shape](/sdk-features/geo-shape).

Quick reference:

| Property        | Type                            | Description                                     |
| --------------- | ------------------------------- | ----------------------------------------------- |
| `geo`           | `TLGeoShapeGeoStyle`            | The geometric form                              |
| `w`             | `number`                        | Width in pixels                                 |
| `h`             | `number`                        | Height in pixels                                |
| `richText`      | `TLRichText`                    | Text label displayed inside the shape           |
| `color`         | `TLDefaultColorStyle`           | Stroke/outline color                            |
| `labelColor`    | `TLDefaultColorStyle`           | Text label color (separate from stroke)         |
| `fill`          | `TLDefaultFillStyle`            | Fill style (`none`, `semi`, `solid`, `pattern`) |
| `dash`          | `TLDefaultDashStyle`            | Stroke pattern                                  |
| `size`          | `TLDefaultSizeStyle`            | Size preset affecting stroke width              |
| `font`          | `TLDefaultFontStyle`            | Font family for the label                       |
| `align`         | `TLDefaultHorizontalAlignStyle` | Horizontal text alignment                       |
| `verticalAlign` | `TLDefaultVerticalAlignStyle`   | Vertical text alignment                         |
| `growY`         | `number`                        | Additional vertical space for text overflow     |
| `url`           | `string`                        | Optional hyperlink URL                          |
| `scale`         | `number`                        | Scale factor applied to the shape               |

### Text

The text shape displays formatted text content with automatic sizing. Text shapes resize to fit their content by default, or you can set them to a fixed width with text wrapping. The shape supports rich text formatting including bold, italic, and other inline styles.

For a complete guide to text shapes, including auto-size vs fixed-width modes, the text tool's interaction patterns, and configuration options, see [Text shape](/sdk-features/text-shape).

```tsx
editor.createShape({
	type: 'text',
	x: 100,
	y: 100,
	props: {
		richText: toRichText('Hello world'),
		color: 'black',
		size: 'm',
		font: 'draw',
		textAlign: 'start',
		autoSize: true,
		w: 200,
	},
})
```

Quick reference:

| Property    | Type                      | Description                                     |
| ----------- | ------------------------- | ----------------------------------------------- |
| `richText`  | `TLRichText`              | The text content with formatting                |
| `color`     | `TLDefaultColorStyle`     | Text color                                      |
| `size`      | `TLDefaultSizeStyle`      | Font size preset (`s`, `m`, `l`, `xl`)          |
| `font`      | `TLDefaultFontStyle`      | Font family (`draw`, `sans`, `serif`, `mono`)   |
| `textAlign` | `TLDefaultTextAlignStyle` | Horizontal alignment (`start`, `middle`, `end`) |
| `autoSize`  | `boolean`                 | When true, shape resizes to fit content         |
| `w`         | `number`                  | Width when autoSize is false                    |
| `scale`     | `number`                  | Scale factor applied to the shape               |

### Note

The note shape renders as a sticky note with a colored background and rich text content. Notes have special interaction behaviors: clone handles on the edges let you quickly create adjacent notes, and keyboard shortcuts navigate between them. Notes have a fixed base size but grow vertically to fit their content.

For a complete guide to note interactions, clone handles, keyboard navigation, and configuration, see [Note shape](/sdk-features/note-shape).

```tsx
editor.createShape({
	type: 'note',
	x: 100,
	y: 100,
	props: {
		color: 'yellow',
		labelColor: 'black',
		richText: toRichText('Remember this'),
		size: 'm',
		font: 'draw',
		align: 'middle',
		verticalAlign: 'middle',
	},
})
```

## Drawing shapes

### Draw

The draw shape captures freehand strokes and straight line segments. It supports pressure-sensitive input from pens and styluses, automatic shape closing, angle snapping when holding Shift, and hybrid freehand/straight-line drawing modes. Points are stored in a delta-encoded base64 format for efficiency.

For complete documentation on the draw shape and draw tool, including drawing modes, pen support, angle snapping, and programmatic creation, see the [Draw shape](/sdk-features/draw-shape) article.

Quick reference:

| Property     | Type                   | Description                                                |
| ------------ | ---------------------- | ---------------------------------------------------------- |
| `color`      | `TLDefaultColorStyle`  | Stroke color                                               |
| `fill`       | `TLDefaultFillStyle`   | Fill style (applies when `isClosed` is true)               |
| `dash`       | `TLDefaultDashStyle`   | Stroke pattern                                             |
| `size`       | `TLDefaultSizeStyle`   | Stroke width preset                                        |
| `segments`   | `TLDrawShapeSegment[]` | Array of segments with `type` and base64-encoded `path`    |
| `isComplete` | `boolean`              | Whether the user has finished drawing this stroke          |
| `isClosed`   | `boolean`              | Whether the path forms a closed shape                      |
| `isPen`      | `boolean`              | Whether drawn with a stylus (enables pressure-based width) |

### Line

The line shape creates multi-point lines with draggable handles. Unlike draw shapes, line shapes have explicit control points that you can manipulate after creation. Each point has an ID and index for ordering, allowing points to be added, removed, or repositioned. Lines support both straight segments and smooth cubic spline interpolation.

```tsx
editor.createShape({
	type: 'line',
	x: 100,
	y: 100,
	props: {
		color: 'black',
		dash: 'solid',
		size: 'm',
		spline: 'line',
		points: {
			a1: { id: 'a1', index: 'a1', x: 0, y: 0 },
			a2: { id: 'a2', index: 'a2', x: 100, y: 50 },
			a3: { id: 'a3', index: 'a3', x: 200, y: 0 },
		},
		scale: 1,
	},
})
```

Properties:

| Property | Type                               | Description                                                   |
| -------- | ---------------------------------- | ------------------------------------------------------------- |
| `color`  | `TLDefaultColorStyle`              | Stroke color                                                  |
| `dash`   | `TLDefaultDashStyle`               | Stroke pattern                                                |
| `size`   | `TLDefaultSizeStyle`               | Stroke width preset                                           |
| `spline` | `TLLineShapeSplineStyle`           | Interpolation: `line` for straight, `cubic` for curves        |
| `points` | `Record<string, TLLineShapePoint>` | Dictionary of control points with IDs, indices, and positions |
| `scale`  | `number`                           | Scale factor applied to the shape                             |

Line shapes don't have configuration options. The line tool's behavior is controlled through tool configuration rather than the shape utility.

### Highlight

The highlight shape works like draw but renders semi-transparently for marking up content. It simulates a highlighter pen, rendering with configurable opacity layers that create the characteristic translucent appearance. Like draw shapes, highlights support pressure-sensitive input and automatic shape splitting for long strokes.

```tsx
editor.createShape({
	type: 'highlight',
	x: 100,
	y: 100,
	props: {
		color: 'yellow',
		size: 'l',
		segments: [],
		isComplete: true,
		isPen: false,
		scale: 1,
	},
})
```

Properties:

| Property     | Type                   | Description                                  |
| ------------ | ---------------------- | -------------------------------------------- |
| `color`      | `TLDefaultColorStyle`  | Highlight color (yellow, green, blue, etc.)  |
| `size`       | `TLDefaultSizeStyle`   | Stroke width preset                          |
| `segments`   | `TLDrawShapeSegment[]` | Array of segments with base64-encoded points |
| `isComplete` | `boolean`              | Whether the user has finished this stroke    |
| `isPen`      | `boolean`              | Whether drawn with a stylus                  |
| `scale`      | `number`               | Scale factor applied to the shape            |
| `scaleX`     | `number`               | Horizontal scale factor for lazy resize      |
| `scaleY`     | `number`               | Vertical scale factor for lazy resize        |

Configuration options:

| Option              | Type     | Default | Description                                                                                     |
| ------------------- | -------- | ------- | ----------------------------------------------------------------------------------------------- |
| `maxPointsPerShape` | `number` | `600`   | Maximum points before starting a new shape. Same behavior as draw shapes.                       |
| `underlayOpacity`   | `number` | `0.82`  | Opacity of the underlay (background layer). Combined with overlay creates the highlight effect. |
| `overlayOpacity`    | `number` | `0.35`  | Opacity of the overlay (foreground layer). Lower values create a more subtle highlight.         |

```tsx
const ConfiguredHighlightUtil = HighlightShapeUtil.configure({
	maxPointsPerShape: 800,
	underlayOpacity: 0.7,
	overlayOpacity: 0.4,
})
```

## Media shapes

### Image

The image shape displays raster images with support for cropping, flipping, and animation control. Images link to asset records that store the actual image data (either as base64 or URLs). The shape maintains aspect ratio during resize and supports circular cropping for profile photos or decorative effects.

```tsx
editor.createShape({
	type: 'image',
	x: 100,
	y: 100,
	props: {
		w: 400,
		h: 300,
		assetId: 'asset:abc123' as TLAssetId,
		url: '',
		crop: null,
		flipX: false,
		flipY: false,
		playing: true,
		altText: 'Description for accessibility',
	},
})
```

Properties:

| Property  | Type                  | Description                                                     |
| --------- | --------------------- | --------------------------------------------------------------- |
| `w`       | `number`              | Display width in pixels                                         |
| `h`       | `number`              | Display height in pixels                                        |
| `assetId` | `TLAssetId \| null`   | Reference to asset record containing image data                 |
| `url`     | `string`              | Direct URL (used when no asset)                                 |
| `crop`    | `TLShapeCrop \| null` | Crop region with `topLeft`, `bottomRight` (0-1), and `isCircle` |
| `flipX`   | `boolean`             | Mirror the image horizontally                                   |
| `flipY`   | `boolean`             | Mirror the image vertically                                     |
| `playing` | `boolean`             | Whether animated images (GIFs) should play                      |
| `altText` | `string`              | Accessibility description                                       |

Image shapes don't have configuration options. Image handling behavior is controlled through the editor's asset management system.

### Video

The video shape displays video content with playback controls. Like images, videos link to asset records. The shape tracks playback position and state, and supports autoplay for automatic playback when the shape becomes visible.

```tsx
editor.createShape({
	type: 'video',
	x: 100,
	y: 100,
	props: {
		w: 640,
		h: 480,
		assetId: 'asset:video123' as TLAssetId,
		url: '',
		time: 0,
		playing: false,
		autoplay: true,
		altText: 'Video description',
	},
})
```

Properties:

| Property   | Type                | Description                            |
| ---------- | ------------------- | -------------------------------------- |
| `w`        | `number`            | Display width in pixels                |
| `h`        | `number`            | Display height in pixels               |
| `assetId`  | `TLAssetId \| null` | Reference to asset record              |
| `url`      | `string`            | Direct URL (used when no asset)        |
| `time`     | `number`            | Current playback position in seconds   |
| `playing`  | `boolean`           | Whether the video is currently playing |
| `autoplay` | `boolean`           | Whether to start playing automatically |
| `altText`  | `string`            | Accessibility description              |

Configuration options:

| Option     | Type      | Default | Description                                     |
| ---------- | --------- | ------- | ----------------------------------------------- |
| `autoplay` | `boolean` | `true`  | Default autoplay behavior for new video shapes. |

```tsx
const ConfiguredVideoUtil = VideoShapeUtil.configure({
	autoplay: false,
})
```

### Bookmark

The bookmark shape displays a URL as a card with metadata including title, description, and preview image. Bookmarks are created when you paste URLs onto the canvas. The editor fetches metadata from the URL and stores it in an associated asset record. Bookmark shapes have fixed dimensions and can't be resized.

```tsx
editor.createShape({
	type: 'bookmark',
	x: 100,
	y: 100,
	props: {
		url: 'https://example.com',
		assetId: 'asset:bookmark123' as TLAssetId,
		w: 300,
		h: 320,
	},
})
```

Properties:

| Property  | Type                | Description                                             |
| --------- | ------------------- | ------------------------------------------------------- |
| `url`     | `string`            | The bookmarked URL                                      |
| `assetId` | `TLAssetId \| null` | Reference to asset containing title, description, image |
| `w`       | `number`            | Width (fixed, not user-resizable)                       |
| `h`       | `number`            | Height (fixed, not user-resizable)                      |

Bookmark shapes don't have configuration options. URL metadata fetching is handled by the editor's external content handlers.

### Embed

The embed shape displays interactive content from external services (YouTube, Figma, CodeSandbox, and more) within an iframe. When you paste a URL from a supported service, tldraw automatically converts it to an interactive embed with appropriate dimensions.

For complete documentation on supported services, URL transformation, iframe security, custom embed definitions, and interaction modes, see [Embed shape](/sdk-features/embed-shape).

```tsx
editor.createShape({
	type: 'embed',
	x: 100,
	y: 100,
	props: {
		url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
		w: 560,
		h: 315,
	},
})
```

Properties:

| Property | Type     | Description                                          |
| -------- | -------- | ---------------------------------------------------- |
| `url`    | `string` | The original URL (converted to embed URL internally) |
| `w`      | `number` | Width of the embed container                         |
| `h`      | `number` | Height of the embed container                        |

## Structural shapes

### Frame

The frame shape provides a visual container for organizing shapes. Shapes inside a frame are clipped to its bounds and move with the frame when it's repositioned. Frames display a header with the frame's name, and optionally colored borders and backgrounds. They're useful for creating sections, organizing content into logical groups, or defining artboard-like regions for export.

```tsx
editor.createShape({
	type: 'frame',
	x: 100,
	y: 100,
	props: {
		w: 800,
		h: 600,
		name: 'Header Section',
		color: 'blue',
	},
})
```

Properties:

| Property | Type                  | Description                                           |
| -------- | --------------------- | ----------------------------------------------------- |
| `w`      | `number`              | Frame width in pixels                                 |
| `h`      | `number`              | Frame height in pixels                                |
| `name`   | `string`              | Label displayed in the frame header                   |
| `color`  | `TLDefaultColorStyle` | Color for border and header (when colors are enabled) |

Configuration options:

| Option           | Type      | Default | Description                                                                                     |
| ---------------- | --------- | ------- | ----------------------------------------------------------------------------------------------- |
| `showColors`     | `boolean` | `false` | When true, frames display colored borders and header backgrounds based on the `color` property. |
| `resizeChildren` | `boolean` | `false` | When true, resizing the frame also scales the frame's children proportionally.                  |

When `showColors` is enabled, the frame's `color` property becomes a style that users can change from the style panel. When disabled, all frames appear with the same neutral styling.

```tsx
const ConfiguredFrameUtil = FrameShapeUtil.configure({
	showColors: true,
	resizeChildren: true,
})
```

### Group

The group shape logically combines multiple shapes without visual representation. Groups let you move and transform shapes together while preserving their relative positions. The group's geometry is computed as the union of all child shapes' geometries. Groups are created through the editor API rather than directly, and they delete themselves automatically when their last child is removed or ungrouped.

```tsx
// Create a group from selected shapes
editor.groupShapes(editor.getSelectedShapeIds())

// Ungroup a group
editor.ungroupShapes([groupId])

// Access group children
const children = editor.getSortedChildIdsForParent(groupId)
```

Groups have no visual properties; their `props` object is empty. All visual characteristics come from their child shapes. Their geometry is the union of all child geometries. Groups delete themselves automatically when the last child is removed, and arrows can't bind to them. Double-click a group to enter it and edit children directly.

Group shapes don't have configuration options.

## Connectors

### Arrow

The arrow shape creates lines that can bind to other shapes. Arrows automatically update when their connected shapes move, maintaining the visual connection. They support two routing modes: `arc` for smooth curves controlled by a bend parameter, and `elbow` for right-angle routing that navigates around obstacles. Arrows can display text labels positioned along their length, and offer multiple arrowhead styles for both terminals.

The arrow binding system creates connections automatically when arrow terminals are dragged near other shapes. Bindings can be "precise" (connecting to a specific point) or "imprecise" (connecting to the shape's center or edge).

```tsx
editor.createShape({
	type: 'arrow',
	x: 100,
	y: 100,
	props: {
		kind: 'arc',
		start: { x: 0, y: 0 },
		end: { x: 200, y: 100 },
		bend: 0,
		color: 'black',
		fill: 'none',
		dash: 'solid',
		size: 'm',
		arrowheadStart: 'none',
		arrowheadEnd: 'arrow',
		font: 'draw',
		richText: toRichText(''),
		labelPosition: 0.5,
		labelColor: 'black',
		scale: 1,
		elbowMidPoint: 0.5,
	},
})
```

Properties:

| Property         | Type                         | Description                                             |
| ---------------- | ---------------------------- | ------------------------------------------------------- |
| `kind`           | `TLArrowShapeKind`           | Routing mode: `arc` for curved, `elbow` for right-angle |
| `start`          | `VecModel`                   | Start terminal position (relative to shape origin)      |
| `end`            | `VecModel`                   | End terminal position                                   |
| `bend`           | `number`                     | Curvature for arc arrows (0 = straight)                 |
| `color`          | `TLDefaultColorStyle`        | Stroke color                                            |
| `fill`           | `TLDefaultFillStyle`         | Fill style (for arrowheads)                             |
| `dash`           | `TLDefaultDashStyle`         | Stroke pattern                                          |
| `size`           | `TLDefaultSizeStyle`         | Stroke width preset                                     |
| `arrowheadStart` | `TLArrowShapeArrowheadStyle` | Start terminal style                                    |
| `arrowheadEnd`   | `TLArrowShapeArrowheadStyle` | End terminal style                                      |
| `font`           | `TLDefaultFontStyle`         | Font family for label                                   |
| `richText`       | `TLRichText`                 | Optional text label                                     |
| `labelPosition`  | `number`                     | Label position along arrow (0 = start, 1 = end)         |
| `labelColor`     | `TLDefaultColorStyle`        | Label text color                                        |
| `scale`          | `number`                     | Scale factor                                            |
| `elbowMidPoint`  | `number`                     | Position of the midpoint handle for elbow arrows        |

The available arrowhead styles are: `none`, `arrow`, `triangle`, `square`, `dot`, `pipe`, `diamond`, `inverted`, `bar`

Configuration options:

Arrows have extensive configuration options that control snap behavior, timing, and rendering:

| Option                                      | Type                                 | Default                              | Description                                                                                          |
| ------------------------------------------- | ------------------------------------ | ------------------------------------ | ---------------------------------------------------------------------------------------------------- |
| `expandElbowLegLength`                      | `Record<TLDefaultSizeStyle, number>` | `{ s: 28, m: 36, l: 44, xl: 66 }`    | How far elbow arrows extend from target shapes, per size.                                            |
| `minElbowLegLength`                         | `Record<TLDefaultSizeStyle, number>` | Based on stroke width × 3            | Minimum length of an elbow arrow's leg segment.                                                      |
| `minElbowHandleDistance`                    | `number`                             | `16`                                 | Minimum screen pixels between two elbow handles. Closer handles are hidden.                          |
| `arcArrowCenterSnapDistance`                | `number`                             | `16`                                 | Screen pixels at which arc arrows snap to target shape centers. Set to 0 to disable.                 |
| `elbowArrowCenterSnapDistance`              | `number`                             | `24`                                 | Screen pixels at which elbow arrows snap to target shape centers.                                    |
| `elbowArrowEdgeSnapDistance`                | `number`                             | `20`                                 | Screen pixels at which elbow arrows snap to target shape edges.                                      |
| `elbowArrowPointSnapDistance`               | `number`                             | `24`                                 | Screen pixels at which elbow arrows snap to directional points (top, right, bottom, left) of shapes. |
| `elbowArrowAxisSnapDistance`                | `number`                             | `16`                                 | Screen pixels at which elbow arrows snap to axes through shape centers.                              |
| `labelCenterSnapDistance`                   | `number`                             | `10`                                 | Screen pixels at which arrow labels snap to the arrow's center when dragged.                         |
| `elbowMidpointSnapDistance`                 | `number`                             | `10`                                 | Screen pixels at which elbow midpoint handles snap to the midpoint between shapes.                   |
| `elbowMinSegmentLengthToShowMidpointHandle` | `number`                             | `20`                                 | Minimum segment length before showing the midpoint drag handle.                                      |
| `hoverPreciseTimeout`                       | `number`                             | `600`                                | Milliseconds to wait while hovering before switching to precise targeting.                           |
| `pointingPreciseTimeout`                    | `number`                             | `320`                                | Milliseconds to wait while pointing/dragging before switching to precise targeting.                  |
| `shouldBeExact`                             | `(editor: Editor) => boolean`        | Returns `editor.inputs.getAltKey()`  | Function determining whether arrows stop exactly at pointer vs. at shape edges.                      |
| `shouldIgnoreTargets`                       | `(editor: Editor) => boolean`        | Returns `editor.inputs.getCtrlKey()` | Function determining whether to skip binding to target shapes.                                       |
| `showTextOutline`                           | `boolean`                            | `true`                               | Whether to show a text outline on arrow labels for readability.                                      |

```tsx
const ConfiguredArrowUtil = ArrowShapeUtil.configure({
	arcArrowCenterSnapDistance: 24,
	hoverPreciseTimeout: 400,
	showTextOutline: false,
	shouldBeExact: (editor) => editor.inputs.getAltKey() || editor.inputs.getShiftKey(),
})
```

## Common properties

All shapes share base properties defined in `TLBaseShape`:

```typescript
interface TLBaseShape {
	id: TLShapeId
	type: string
	x: number // Position relative to parent
	y: number
	rotation: number // Rotation in radians
	index: IndexKey // Fractional index for z-ordering
	parentId: TLParentId // Page ID or parent shape ID
	isLocked: boolean
	opacity: number // 0-1
	props: object // Shape-specific properties
	meta: object // Custom metadata (for your application)
}
```

Most shapes also support common style properties through the style system:

| Style   | Values                                | Description       |
| ------- | ------------------------------------- | ----------------- |
| `color` | `black`, `grey`, `light-violet`, etc. | Stroke/text color |
| `fill`  | `none`, `semi`, `solid`, `pattern`    | Fill style        |
| `dash`  | `solid`, `dashed`, `dotted`, `draw`   | Stroke pattern    |
| `size`  | `s`, `m`, `l`, `xl`                   | Size preset       |
| `font`  | `draw`, `sans`, `serif`, `mono`       | Font family       |

## Using configured shapes

To use configured shape utilities, pass them to the `shapeUtils` prop when initializing tldraw. Configured utilities replace the default utilities for their shape type:

```tsx
import { Tldraw, ArrowShapeUtil, FrameShapeUtil, NoteShapeUtil } from 'tldraw'
import 'tldraw/tldraw.css'

const ConfiguredArrowUtil = ArrowShapeUtil.configure({
	showTextOutline: false,
	hoverPreciseTimeout: 400,
})

const ConfiguredFrameUtil = FrameShapeUtil.configure({
	showColors: true,
})

const ConfiguredNoteUtil = NoteShapeUtil.configure({
	resizeMode: 'scale',
})

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw shapeUtils={[ConfiguredArrowUtil, ConfiguredFrameUtil, ConfiguredNoteUtil]} />
		</div>
	)
}
```

You can also extend shape utilities to add custom behavior beyond configuration options. See the [custom shapes](/docs/shapes) guide for details.

## Related examples

- [Custom shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-shape): Create a custom shape utility to understand how default shapes are implemented.
- [Custom styles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-styles): Add custom style properties similar to those used by default shapes.
- [Shape options](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-options): Configure shape utility behavior using the configure() method.

--------

# Drag and drop

The drag and drop system lets shapes respond when other shapes are dragged over them. Frames use this to reparent shapes when you drag them inside. You can use the same callbacks in your [`ShapeUtil`](/reference/editor/reference/editor/ShapeUtil) to build custom container shapes, slot-based layouts, or any shape that should react to shapes being dragged over it.

```tsx
import { ShapeUtil, TLShape, TLDragShapesOutInfo } from 'tldraw'

class MyContainerShapeUtil extends ShapeUtil<MyContainerShape> {
	static override type = 'my-container' as const

	// Called when shapes are first dragged into this shape
	override onDragShapesIn(shape: MyContainerShape, draggingShapes: TLShape[]) {
		// Reparent the shapes to become children of this container
		this.editor.reparentShapes(draggingShapes, shape.id)
	}

	// Called when shapes are dragged out of this shape
	override onDragShapesOut(
		shape: MyContainerShape,
		draggingShapes: TLShape[],
		info: TLDragShapesOutInfo
	) {
		// If not dragging into another shape, move back to the page
		if (!info.nextDraggingOverShapeId) {
			this.editor.reparentShapes(draggingShapes, this.editor.getCurrentPageId())
		}
	}

	// ... other required methods
}
```

## Drag callbacks

When a user drags shapes across the canvas, the editor tracks which shape (if any) is under the cursor. Your shape util can implement these callbacks to respond:

| Callback           | When it fires                                                                     |
| ------------------ | --------------------------------------------------------------------------------- |
| `onDragShapesIn`   | Shapes are first dragged over this shape                                          |
| `onDragShapesOver` | Shapes continue being dragged over this shape (on an interval, when cursor moves) |
| `onDragShapesOut`  | Shapes are dragged away from this shape                                           |
| `onDropShapesOver` | Shapes are dropped onto this shape                                                |

The callbacks receive the target shape (the one being dragged over), an array of the shapes being dragged, and an info object with context about the drag operation.

### onDragShapesIn

Called once when shapes first enter this shape's bounds. Use it to reparent shapes into a container:

```typescript
override onDragShapesIn(shape: MyContainerShape, draggingShapes: TLShape[]) {
	// Only reparent if not already a child
	const newShapes = draggingShapes.filter((s) => s.parentId !== shape.id)
	if (newShapes.length > 0) {
		this.editor.reparentShapes(newShapes, shape.id)
	}
}
```

### onDragShapesOver

Called on an interval while shapes are being dragged over this shape, but only when the cursor moves. Use it for visual feedback or grid snapping:

```typescript
override onDragShapesOver(shape: MyGridShape, draggingShapes: TLShape[]) {
	// Snap shapes to grid cells while dragging
	for (const dragging of draggingShapes) {
		const snappedX = Math.round(dragging.x / CELL_SIZE) * CELL_SIZE
		const snappedY = Math.round(dragging.y / CELL_SIZE) * CELL_SIZE

		if (dragging.x !== snappedX || dragging.y !== snappedY) {
			this.editor.updateShape({
				id: dragging.id,
				type: dragging.type,
				x: snappedX,
				y: snappedY,
			})
		}
	}
}
```

### onDragShapesOut

Called when shapes are dragged away from this shape. Use it to reparent shapes back to the page:

```typescript
override onDragShapesOut(
	shape: MyContainerShape,
	draggingShapes: TLShape[],
	info: TLDragShapesOutInfo
) {
	// Check if we're dragging into another container
	if (info.nextDraggingOverShapeId) {
		// Let the next container handle it
		return
	}

	// Reparent back to the page
	const children = draggingShapes.filter((s) => s.parentId === shape.id)
	if (children.length > 0) {
		this.editor.reparentShapes(children, this.editor.getCurrentPageId())
	}
}
```

### onDropShapesOver

Called when shapes are dropped (mouse up) while over this shape. Use it for finalization logic:

```typescript
override onDropShapesOver(shape: MySlotShape, draggingShapes: TLShape[]) {
	// Lock shapes in place after dropping
	for (const dragging of draggingShapes) {
		this.editor.updateShape({
			id: dragging.id,
			type: dragging.type,
			isLocked: true,
		})
	}
}
```

## The info object

All drag callbacks receive an info object with context about the drag operation. The exact type varies by callback:

| Callback           | Info type                 |
| ------------------ | ------------------------- |
| `onDragShapesIn`   | [`TLDragShapesInInfo`](/reference/editor/reference/editor/TLDragShapesInInfo)   |
| `onDragShapesOver` | [`TLDragShapesOverInfo`](/reference/editor/reference/editor/TLDragShapesOverInfo) |
| `onDragShapesOut`  | [`TLDragShapesOutInfo`](/reference/editor/reference/editor/TLDragShapesOutInfo)  |
| `onDropShapesOver` | [`TLDropShapesOverInfo`](/reference/editor/reference/editor/TLDropShapesOverInfo) |

All info types share these common properties:

| Property                     | Description                                           |
| ---------------------------- | ----------------------------------------------------- |
| `initialDraggingOverShapeId` | The shape that was under the cursor when drag started |
| `initialParentIds`           | Map of each shape's parent ID at drag start           |
| `initialIndices`             | Map of each shape's z-index at drag start             |

Some callbacks have additional properties:

| Property                  | Available in      | Description                              |
| ------------------------- | ----------------- | ---------------------------------------- |
| `prevDraggingOverShapeId` | `onDragShapesIn`  | The previous shape that was dragged over |
| `nextDraggingOverShapeId` | `onDragShapesOut` | The next shape being dragged into        |

The `initialParentIds` and `initialIndices` maps let you restore shapes to their original positions. Frames use this to preserve z-ordering when shapes are dragged back to their original parent.

## Determining what's under the cursor

The editor automatically determines which shape is being dragged over by checking which shape's geometry contains the cursor point. It tests shapes from front to back and returns the first hit.

Only shapes that implement drag callbacks are considered as drop targets. If your shape util doesn't override any drag callbacks, shapes will pass through it when being dragged.

## Controlling which shapes can be dropped

Use the [`ShapeUtil.canReceiveNewChildrenOfType`](/reference/editor/reference/editor/ShapeUtil#canReceiveNewChildrenOfType) method to control which shape types your container accepts:

```typescript
override canReceiveNewChildrenOfType(shape: MyContainerShape, type: TLShape['type']) {
	// Only accept specific shape types
	return type === 'my-item' || type === 'geo'
}
```

You must check this yourself in your drag callbacks. The editor does not call it automatically.

## Example: slot container

Here's a complete example of a slot-based container that accepts dropped shapes:

```tsx
import {
	HTMLContainer,
	Rectangle2d,
	ShapeUtil,
	TLBaseShape,
	TLDragShapesOutInfo,
	TLShape,
	T,
} from 'tldraw'

type SlotContainerShape = TLBaseShape<'slot-container', { slots: number }>

class SlotContainerShapeUtil extends ShapeUtil<SlotContainerShape> {
	static override type = 'slot-container' as const
	static override props = { slots: T.number }

	getDefaultProps() {
		return { slots: 4 }
	}

	getGeometry(shape: SlotContainerShape) {
		return new Rectangle2d({
			width: shape.props.slots * 100,
			height: 100,
			isFilled: true,
		})
	}

	override canReceiveNewChildrenOfType(_shape: SlotContainerShape, type: string) {
		return type === 'geo' || type === 'text'
	}

	override onDragShapesIn(shape: SlotContainerShape, draggingShapes: TLShape[]) {
		const newShapes = draggingShapes.filter((s) => s.parentId !== shape.id)
		if (newShapes.length > 0) {
			this.editor.reparentShapes(newShapes, shape.id)
		}
	}

	override onDragShapesOut(
		shape: SlotContainerShape,
		draggingShapes: TLShape[],
		info: TLDragShapesOutInfo
	) {
		if (!info.nextDraggingOverShapeId) {
			const children = draggingShapes.filter((s) => s.parentId === shape.id)
			this.editor.reparentShapes(children, this.editor.getCurrentPageId())
		}
	}

	component(shape: SlotContainerShape) {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#f0f0f0',
					border: '2px dashed #ccc',
					display: 'grid',
					gridTemplateColumns: `repeat(${shape.props.slots}, 100px)`,
				}}
			>
				{Array.from({ length: shape.props.slots }).map((_, i) => (
					<div
						key={i}
						style={{
							width: 100,
							height: 100,
							borderRight: i < shape.props.slots - 1 ? '1px dashed #ccc' : undefined,
						}}
					/>
				))}
			</HTMLContainer>
		)
	}

	indicator(shape: SlotContainerShape) {
		return <rect width={shape.props.slots * 100} height={100} />
	}
}
```

## External content

For handling content dragged from outside the browser (files, URLs, images), see [External content handling](/docs/sdk-features/external-content). The callbacks on this page are for shape-to-shape drag and drop within the canvas.

## Related examples

- [Drag and drop](/examples/shapes/tools/drag-and-drop) - Custom shapes that can be dragged onto each other.
- [Drag and drop tray](/examples/ui/drag-and-drop-tray) - Drag items from a custom UI into the canvas.

## Related docs

- [External content handling](/docs/sdk-features/external-content) - Handle files, URLs, and other content dragged from outside the browser.
- [Parenting and ancestors](/docs/sdk-features/parenting) - Learn about parent-child relationships and the [`Editor.reparentShapes`](/reference/editor/reference/editor/Editor#reparentShapes) method.

--------

# Draw shape

The draw shape captures freehand strokes and straight line segments. It supports pressure-sensitive input, automatic shape closing, angle snapping, and hybrid freehand/straight-line drawing modes. The draw tool detects pen and stylus input and produces variable-width strokes that respond to pressure.

## Drawing modes

The draw tool supports two segment types that you can switch between while drawing:

| Mode     | Trigger                  | Behavior                                                         |
| -------- | ------------------------ | ---------------------------------------------------------------- |
| Freehand | Default                  | Captures natural hand motion with optional pressure sensitivity  |
| Straight | Hold Shift while drawing | Creates straight line segments that snap to 15° angle increments |

You can mix both modes in a single stroke. Start drawing freehand, then hold Shift to switch to straight lines. Release Shift to return to freehand. Each mode change creates a new segment in the shape.

### Freehand drawing

Freehand mode captures your natural hand motion. The tool records points as you drag and interpolates them into smooth curves. When you draw with a pen or stylus, the tool captures pressure data and produces variable-width strokes.

The stroke appearance depends on the dash style:

- **Draw** style uses the freehand algorithm to create organic, hand-drawn strokes with natural width variation
- **Solid**, **dashed**, and **dotted** styles render uniform-width strokes

### Straight line mode

Hold Shift while drawing to create straight line segments. The line snaps to 15° angle increments relative to the previous point, making it easy to draw horizontal, vertical, and diagonal lines.

Release Shift to continue with freehand drawing from the current endpoint. The transition creates a smooth connection between the straight segment and the freehand stroke.

### Extending previous strokes

If you've already drawn a stroke and want to continue from it, hold Shift and click to connect. The draw tool creates a straight line segment from the previous stroke's endpoint to your click position. Continue holding Shift and drag to extend with more straight segments, or release Shift to switch to freehand.

This connect-the-dots behavior only activates when you Shift+click after completing a previous stroke with the same draw tool session. It won't connect across different shapes or after switching tools.

## Pen and stylus support

The draw tool distinguishes between mouse/touch input and pen/stylus input. When it detects a pen or stylus, it enables pressure-sensitive rendering:

| Input type  | Pressure behavior                                                  |
| ----------- | ------------------------------------------------------------------ |
| Mouse/touch | Simulates pressure based on velocity—faster strokes appear thinner |
| Pen/stylus  | Uses actual pressure data for variable stroke width                |

The tool detects stylus input through the pressure value in pointer events. Values between 0 and 0.5 (exclusive) or between 0.5 and 1 (exclusive) indicate stylus input, as mice report exactly 0.5.

The shape stores pen detection in the `isPen` property. This affects how the stroke renders—pen strokes use a different stroke profile optimized for real pressure data.

## Automatic shape closing

Draw shapes can automatically close when you bring the endpoint near the starting point. This creates filled shapes when combined with a fill style other than "none".

The shape closes when:

- The path length exceeds 4× the stroke width
- The endpoint is within 2× the stroke width of the starting point

When a shape closes, the shape sets `isClosed` to true and fills according to its fill style. Highlight shapes don't support closing.

## Line snapping

When drawing straight lines with Shift held, you can snap to previous segments in the current stroke. This helps create precise geometric constructions:

- Enable snap mode in user preferences, or hold Ctrl (when snap mode is disabled) to temporarily enable snapping
- Hold Ctrl (when snap mode is enabled) to temporarily disable snapping
- The tool snaps to the nearest point on previous straight segments within 8 pixels (adjusted for zoom)

Visual snap indicators appear when snapping is active.

## Angle snapping

Straight line segments snap to 15° increments (24 divisions of a full circle). This makes it easy to draw:

- Horizontal lines (0°, 180°)
- Vertical lines (90°, 270°)
- 45° diagonals
- 30° and 60° angles for isometric-style drawings

Hold Ctrl while in straight line mode to disable angle snapping temporarily.

## Dynamic resize mode

When dynamic resize mode is enabled in user preferences, new draw shapes scale inversely with zoom level. Drawing while zoomed out creates shapes that appear the same size on screen as they would at 100% zoom. The shape's `scale` property stores this adjustment.

Access dynamic resize mode through [`Editor.user`](/reference/editor/reference/editor/Editor#user):

```typescript
// Check current mode
const isDynamic = editor.user.getIsDynamicResizeMode()

// Enable dynamic resize mode
editor.user.updateUserPreferences({ isDynamicResizeMode: true })
```

## Shape properties

Draw shapes store their path data in an efficient delta-encoded base64 format. The first point uses full Float32 precision (12 bytes), with subsequent points stored as Float16 deltas (6 bytes each).

| Property     | Type                   | Description                                                |
| ------------ | ---------------------- | ---------------------------------------------------------- |
| `color`      | `TLDefaultColorStyle`  | Stroke color                                               |
| `fill`       | `TLDefaultFillStyle`   | Fill style (applies when `isClosed` is true)               |
| `dash`       | `TLDefaultDashStyle`   | Stroke pattern: `draw`, `solid`, `dashed`, `dotted`        |
| `size`       | `TLDefaultSizeStyle`   | Stroke width preset: `s`, `m`, `l`, `xl`                   |
| `segments`   | `TLDrawShapeSegment[]` | Array of segments with `type` and base64-encoded `path`    |
| `isComplete` | `boolean`              | Whether the user has finished drawing this stroke          |
| `isClosed`   | `boolean`              | Whether the path forms a closed shape                      |
| `isPen`      | `boolean`              | Whether drawn with a stylus (enables pressure-based width) |
| `scale`      | `number`               | Scale factor applied to the shape                          |
| `scaleX`     | `number`               | Horizontal scale factor for lazy resize                    |
| `scaleY`     | `number`               | Vertical scale factor for lazy resize                      |

Each segment has a `type` of `'free'` or `'straight'` and a `path` containing the encoded point data with x, y, and z (pressure) values.

## Configuration options

Configure the draw shape utility to adjust behavior:

| Option              | Type     | Default | Description                                              |
| ------------------- | -------- | ------- | -------------------------------------------------------- |
| `maxPointsPerShape` | `number` | `600`   | Maximum points before automatically starting a new shape |

```tsx
import { DrawShapeUtil } from 'tldraw'

const ConfiguredDrawUtil = DrawShapeUtil.configure({
	maxPointsPerShape: 1000,
})
```

When a stroke exceeds the maximum point count, the draw tool completes the current shape and creates a new one at the current position. This prevents performance issues with very long strokes.

## Creating draw shapes programmatically

To create a draw shape through the editor API, you need to encode the point data:

```tsx
import { b64Vecs, createShapeId } from '@tldraw/editor'

// Define your points with x, y, and z (pressure)
const points = [
	{ x: 0, y: 0, z: 0.5 },
	{ x: 50, y: 30, z: 0.5 },
	{ x: 100, y: 10, z: 0.5 },
]

editor.createShape({
	id: createShapeId(),
	type: 'draw',
	x: 100,
	y: 100,
	props: {
		color: 'black',
		fill: 'none',
		dash: 'draw',
		size: 'm',
		segments: [
			{
				type: 'free',
				path: b64Vecs.encodePoints(points),
			},
		],
		isComplete: true,
		isClosed: false,
		isPen: false,
		scale: 1,
		scaleX: 1,
		scaleY: 1,
	},
})
```

The `b64Vecs.encodePoints` function converts an array of point objects to the delta-encoded base64 format. Use `b64Vecs.decodePoints` to read points back from a segment's path.

## Stroke rendering

The draw shape uses a freehand stroke algorithm to render organic-looking lines. The algorithm applies:

- **Streamline**: Smooths the path by pulling points toward the stroke's center
- **Smoothing**: Applies curve fitting for natural-looking strokes
- **Thinning**: Varies stroke width based on velocity (for mouse) or pressure (for pen)

When `dash` is set to `'draw'`, the shape renders using the full freehand algorithm. Other dash styles use simpler uniform-width strokes with the appropriate dash pattern.

At low zoom levels, the shape automatically switches to solid rendering for performance. This happens when the zoom level is below 50% and also below a threshold based on stroke width (`zoomLevel < 1.5 / strokeWidth`).

## Geometry

The shape's geometry depends on its content:

- **Single point (dot)**: Returns a [`Circle2d`](/reference/editor/reference/editor/Circle2d) centered at the point with radius equal to the stroke width
- **Closed path**: Returns a [`Polygon2d`](/reference/editor/reference/editor/Polygon2d) that can be filled
- **Open path**: Returns a [`Polyline2d`](/reference/editor/reference/editor/Polyline2d) following the stroke's center line

The geometry uses the processed stroke points (after applying streamline and smoothing), not the raw input points.

## Related shapes

- **[Highlight](/sdk-features/default-shapes#highlight)**: Uses the same point capture system but renders semi-transparently for marking up content
- **[Line](/sdk-features/default-shapes#line)**: Creates editable multi-point lines with draggable handles

## Related articles

- [Default shapes](/sdk-features/default-shapes) — Overview of all built-in shapes
- [Tools](/sdk-features/tools) — How tools handle user input
- [Styles](/sdk-features/styles) — Working with shape styles like color and size

--------

# Edge scrolling

Edge scrolling automatically pans the camera when you drag shapes toward the viewport edges. This lets you move shapes across the canvas without releasing the drag to scroll manually.

The system activates only during drag operations. It requires three conditions: you must be dragging (not panning), the camera must be unlocked, and the pointer must be within a proximity zone at the viewport edge.

## How it works

Tools that support edge scrolling call `editor.edgeScrollManager.updateEdgeScrolling(elapsed)` on every tick during drag operations. The manager checks the pointer position against the viewport bounds and calculates a proximity factor for each axis.

When the pointer enters the edge scroll zone, the manager tracks elapsed time. After a configurable delay, scrolling starts and gradually accelerates using an easing function. The camera moves on each tick until the pointer leaves the edge zone or the drag ends.

```typescript
override onTick({ elapsed }: TLTickEventInfo) {
	editor.edgeScrollManager.updateEdgeScrolling(elapsed)
}
```

The built-in select tool uses edge scrolling in three states: Translating (moving shapes), Brushing (selection box), and Resizing (dragging handles).

## Edge detection

The manager determines edge proximity by comparing the pointer position to the viewport bounds. An edge scroll zone extends inward from each screen edge by a distance defined in `editor.options.edgeScrollDistance` (default: 8 pixels).

### Proximity calculation

When the pointer enters this zone, the manager calculates a proximity factor from 0 to 1 based on how deeply the pointer penetrates the zone. At the zone boundary, the factor is 0. At the screen edge (or beyond), it reaches 1. Each axis is calculated independently.

### Touch input

For touch input, the system expands the effective pointer size using `editor.options.coarsePointerWidth` (default: 12 pixels). The expanded pointer area is centered on the touch point, making edge scrolling easier to trigger on mobile devices.

### Inset handling

Edge detection respects screen insets from the editor's instance state. When an edge has an inset (like a toolbar or panel), that edge's scroll zone starts at the inset boundary rather than at the physical screen edge. This prevents scrolling when dragging near UI elements.

The insets array follows CSS convention: `[top, right, bottom, left]`. A truthy value means that edge has an inset and won't trigger edge scrolling.

## Scrolling behavior

Once the pointer enters the edge zone, the manager waits for `editor.options.edgeScrollDelay` milliseconds (default: 200ms) before starting to scroll. This delay prevents accidental scrolling when the pointer briefly crosses the edge.

After the delay, scrolling begins with gradual acceleration controlled by `editor.options.edgeScrollEaseDuration` (default: 200ms). The manager applies `EASINGS.easeInCubic` to create smooth acceleration from zero to full speed.

### Speed calculation

The scroll speed combines several factors. The base speed comes from `editor.options.edgeScrollSpeed` (default: 25 pixels per tick) multiplied by the user preference from `editor.user.getEdgeScrollSpeed()` (default: 1).

The proximity factor (0 to 1) scales speed based on how close the pointer is to the screen edge. Scrolling is slower near the zone boundary and faster at the edge itself.

On smaller displays, a screen size factor of 0.612 applies when that viewport dimension is below 1000 pixels. This reduces speed independently for each axis. The final scroll delta divides by the current zoom level to maintain consistent canvas-space velocity.

```typescript
const pxSpeed = editor.user.getEdgeScrollSpeed() * editor.options.edgeScrollSpeed
const screenSizeFactorX = screenBounds.w < 1000 ? 0.612 : 1
const screenSizeFactorY = screenBounds.h < 1000 ? 0.612 : 1
const scrollDeltaX = (pxSpeed * proximityFactor.x * screenSizeFactorX) / zoomLevel
const scrollDeltaY = (pxSpeed * proximityFactor.y * screenSizeFactorY) / zoomLevel
```

### Conditions for scrolling

The manager only moves the camera when all these conditions are met:

- The editor is dragging (`editor.inputs.getIsDragging()` returns true)
- The editor is not panning (`editor.inputs.getIsPanning()` returns false)
- The camera is not locked (`editor.getCameraOptions().isLocked` is false)
- The proximity factor is non-zero for at least one axis

If any condition fails, scrolling stops and the internal duration timer resets.

## Configuration options

You can customize edge scrolling through the editor's options:

| Option                   | Default | Description                                        |
| ------------------------ | ------- | -------------------------------------------------- |
| `edgeScrollDelay`        | 200     | Milliseconds to wait before starting scroll        |
| `edgeScrollEaseDuration` | 200     | Milliseconds to accelerate from zero to full speed |
| `edgeScrollSpeed`        | 25      | Base scroll speed in pixels per tick               |
| `edgeScrollDistance`     | 8       | Width of the edge scroll zone in pixels            |
| `coarsePointerWidth`     | 12      | Expanded pointer size for touch input (pixels)     |

Set these options when creating the editor:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const options = {
	edgeScrollSpeed: 50, // Double the default speed
	edgeScrollDelay: 100, // Start scrolling sooner
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw options={options} />
		</div>
	)
}
```

### User preferences

Users can adjust edge scroll speed through `editor.user.getEdgeScrollSpeed()`, which returns a multiplier that defaults to 1 and persists across sessions. This affects all edge scrolling uniformly without changing the base configuration.

## Tool integration

To add edge scrolling to your custom tool, call `updateEdgeScrolling()` in the tick handler. The manager reads the pointer position and drag state from the editor's input system, so you only need to pass the elapsed time.

```typescript
import { StateNode, TLTickEventInfo } from '@tldraw/editor'

export class CustomDragState extends StateNode {
	static override id = 'dragging'

	override onTick({ elapsed }: TLTickEventInfo) {
		this.editor.edgeScrollManager.updateEdgeScrolling(elapsed)
	}
}
```

The manager tracks whether edge scrolling is active using `getIsEdgeScrolling()`. This returns true when the pointer is in the edge zone and scrolling has started (after the delay).

Only call `updateEdgeScrolling()` during states where edge scrolling makes sense. The built-in select tool calls it during translating, brushing, and resizing, but not during idle or pointing states.

## Related examples

See the [custom tool](/examples/shapes/tools/custom-tool) example for building tools that can implement edge scrolling. For complex tools with multiple states, see the [tool with child states](/examples/shapes/tools/tool-with-child-states) example.

--------

# Editor

The [`Editor`](/reference/editor/reference/editor/Editor) class is the main way of controlling tldraw's editor. It provides methods for creating, reading, updating, and deleting shapes; managing selection and history; controlling the camera; and responding to user input. By design, the editor's surface area is very large—almost everything is available through it.

Need to create some shapes? Use [`Editor.createShapes`](/reference/editor/reference/editor/Editor#createShapes). Need to delete them? Use [`Editor.deleteShapes`](/reference/editor/reference/editor/Editor#deleteShapes). Want a sorted array of every shape on the current page? Use [`Editor.getCurrentPageShapesSorted`](/reference/editor/reference/editor/Editor#getCurrentPageShapesSorted). The editor is your primary interface for interacting with the canvas.

## Accessing the editor

You can access the editor in two ways:

1. From the [`Tldraw`](/reference/tldraw/reference/tldraw/Tldraw) component's `onMount` callback:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					// Your editor code here
					editor.createShape({ type: 'geo', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}
```

2. Via the [`useEditor`](/reference/editor/reference/editor/useEditor) hook, which must be called from within the [`Tldraw`](/reference/tldraw/reference/tldraw/Tldraw) component tree:

```tsx
function InsideOfContext() {
	const editor = useEditor()
	// Your editor code here
	return null
}

function App() {
	return (
		<Tldraw>
			<InsideOfContext />
		</Tldraw>
	)
}
```

## Architecture overview

The editor orchestrates several interconnected systems. Understanding how they fit together helps when building on top of tldraw.

### Store

The editor holds document data in its [`Editor.store`](/reference/editor/reference/editor/Editor#store) property. The store is a reactive database containing records for shapes, pages, bindings, assets, and editor state. All records are JSON-serializable.

```ts
// Access a shape record directly from the store
const shape = editor.store.get(shapeId)

// Listen to store changes
editor.store.listen((entry) => {
	console.log('Changed:', entry.changes)
})
```

The store is reactive: when data changes, the UI updates automatically. The editor wraps the store with higher-level methods like `createShapes()` and `deleteShapes()`, so you rarely need to interact with it directly.

See [Store](/sdk-features/store) for details on working with the store directly.

### Signals

Tldraw uses a signals-based reactive system. The editor exposes many of its internal values as signals—methods like `editor.getSelectedShapeIds()` and `editor.getCurrentPageShapes()` return reactive values that update automatically when the underlying state changes.

```tsx
import { track, useEditor } from 'tldraw'

const SelectedCount = track(function SelectedCount() {
	const editor = useEditor()
	return <div>{editor.getSelectedShapeIds().length} shapes selected</div>
})
```

The `track` higher-order component automatically subscribes to signals accessed during render. When those signals change, the component re-renders.

See [Signals](/sdk-features/signals) for the full reactive API.

### State chart

The editor uses a hierarchical state machine for handling user interactions. Tools like the select tool, draw tool, and hand tool are implemented as [`StateNode`](/reference/editor/reference/editor/StateNode) instances. Each node can have child states, and the active state determines how the editor responds to events.

```ts
// Change the current tool
editor.setCurrentTool('draw')
editor.setCurrentTool('hand')

// Check the current tool
editor.getCurrentToolId() // 'select', 'draw', 'hand', etc.

// Check the full state path
editor.root.getPath() // 'root.select.idle', 'root.draw.drawing', etc.

// Check if a state is active
editor.isIn('select') // true if select tool is active
editor.isIn('select.idle') // true if in idle state of select tool

// Check if any of several states are active
editor.isInAny('select.idle', 'hand.idle') // true if in either state
```

#### State transitions

Tools transition between child states as the user interacts. For example, the select tool has states like `idle`, `pointing`, `brushing`, and `translating`. When you click and drag on the canvas, the state might flow like this:

1. `select.idle` — waiting for input
2. `select.pointing` — pointer down, waiting to see if this is a click or drag
3. `select.brushing` — dragging to create a selection box
4. `select.idle` — pointer up, back to waiting

Each state handles events differently. The `idle` state responds to `pointer_down` by transitioning to `pointing`. The `brushing` state responds to `pointer_move` by updating the brush bounds and `pointer_up` by completing the selection.

#### Event flow

Events flow from the root state down through active children. When you press a key or move the pointer, the editor dispatches an event that each active state can handle:

```ts
// Events bubble through: root → select → idle
// Each state can:
// - Handle the event and stop propagation
// - Handle the event and let it continue
// - Ignore the event entirely
```

States define handlers for events like `onPointerDown`, `onPointerMove`, `onKeyDown`, and `onEnter`/`onExit` for state transitions. The active state chain determines which handlers run.

See [Tools](/sdk-features/tools) for building custom tools.

### Managers

The editor delegates specialized functionality to manager classes:

| Manager                     | Responsibility                                |
| --------------------------- | --------------------------------------------- |
| [`HistoryManager`](/reference/editor/reference/editor/HistoryManager)         | Undo/redo stack and history marks             |
| [`SnapManager`](/reference/editor/reference/editor/SnapManager)            | Shape snapping during transforms              |
| FocusManager                | Focus state and keyboard event handling       |
| [`TextManager`](/reference/editor/reference/editor/TextManager)            | Text measurement and layout                   |
| [`FontManager`](/reference/editor/reference/editor/FontManager)            | Font loading and management                   |
| TickManager                 | Animation frame scheduling                    |
| [`InputsManager`](/reference/editor/reference/editor/InputsManager)          | Pointer position and modifier key tracking    |
| [`ClickManager`](/reference/editor/reference/editor/ClickManager)           | Click, double-click, and long-press detection |
| [`ScribbleManager`](/reference/editor/reference/editor/ScribbleManager)        | Brush and scribble interactions               |
| [`EdgeScrollManager`](/reference/editor/reference/editor/EdgeScrollManager)      | Auto-scroll at viewport edges                 |
| [`UserPreferencesManager`](/reference/editor/reference/editor/UserPreferencesManager) | User settings persistence                     |

Access managers through the editor instance:

```ts
// Mark history for undo
editor.markHistoryStoppingPoint('my-action')

// Check snap points
editor.snaps.getIndicators()
```

## Working with shapes

Shapes are the content on your canvas. Each shape has a type, position, rotation, and type-specific props.

### Creating shapes

```ts
// Create a shape with auto-generated ID
editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	props: {
		geo: 'rectangle',
		w: 200,
		h: 150,
		color: 'blue',
	},
})

// Create with a specific ID
import { createShapeId } from 'tldraw'

const id = createShapeId('my-shape')
editor.createShape({
	id,
	type: 'geo',
	x: 100,
	y: 100,
})
```

### Reading shapes

```ts
// Get a shape by ID
const shape = editor.getShape(shapeId)

// Get all shapes on the current page
const shapes = editor.getCurrentPageShapes()

// Get selected shapes
const selected = editor.getSelectedShapes()
```

### Updating shapes

```ts
editor.updateShape({
	id: shape.id,
	type: shape.type, // Required
	x: 200,
	props: {
		color: 'red',
	},
})
```

### Deleting shapes

```ts
// Delete by ID
editor.deleteShapes([shapeId])

// Delete by shape record
editor.deleteShapes([shape])
```

See [Shapes](/sdk-features/shapes) for the complete shape system.

## Selection

The editor tracks which shapes are selected. Selection drives many operations—transform handles, copy/paste, delete, and more.

```ts
// Select shapes
editor.select(shapeId)
editor.select(shapeId1, shapeId2)

// Add to selection
editor.setSelectedShapes([...editor.getSelectedShapeIds(), newId])

// Clear selection
editor.selectNone()

// Select all on current page
editor.selectAll()

// Get selection
editor.getSelectedShapeIds()
editor.getSelectedShapes()
```

See [Selection](/sdk-features/selection) for selection details.

## History

The editor maintains an undo/redo stack through its history manager. Changes to the store accumulate until you create a mark, which becomes an undo stopping point.

```ts
// Mark before an operation
editor.markHistoryStoppingPoint('rotate shapes')
editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 4)

// Undo returns to the mark
editor.undo()

// Redo reapplies changes
editor.redo()
```

See [History](/sdk-features/history) for the full history API.

## Transactions

Use [`Editor.run`](/reference/editor/reference/editor/Editor#run) to batch changes into a single transaction. This improves performance and reduces intermediate renders.

```ts
editor.run(() => {
	editor.createShapes(shapes)
	editor.sendToBack(shapes)
	editor.selectNone()
})
```

The `run` method also accepts options for controlling history:

```ts
// Ignore changes (don't add to undo stack)
editor.run(
	() => {
		editor.updateShape({ id, type: 'geo', x: 100 })
	},
	{ history: 'ignore' }
)

// Allow editing locked shapes
editor.run(
	() => {
		editor.updateShapes(lockedShapes)
	},
	{ ignoreShapeLock: true }
)
```

See [History](/sdk-features/history) for more on how transactions interact with undo/redo.

## Camera and viewport

The editor manages a camera that determines which part of the infinite canvas is visible. The camera has x, y, and z (zoom) coordinates.

```ts
// Move camera to specific coordinates
editor.setCamera({ x: 0, y: 0, z: 1 })

// Zoom controls
editor.zoomIn()
editor.zoomOut()
editor.resetZoom()

// Fit content in view
editor.zoomToFit()
editor.zoomToSelection()

// Center on a point
editor.centerOnPoint({ x: 500, y: 500 })

// Lock the camera
editor.setCameraOptions({ isLocked: true })
```

The viewport is the visible area of the canvas. Get its bounds in screen or page coordinates:

```ts
// Screen coordinates (component size)
editor.getViewportScreenBounds()

// Page coordinates (what's visible on the canvas)
editor.getViewportPageBounds()
```

See [Camera](/sdk-features/camera) and [Coordinates](/sdk-features/coordinates) for the full camera API.

## Input state

The [`Editor.inputs`](/reference/editor/reference/editor/Editor#inputs) object tracks the user's current input state: cursor position, pressed keys, drag state, and more. All values on the inputs object are reactive signals—when you access them inside a tracked component or computed, your code automatically re-runs when those values change.

```ts
// Cursor position in page coordinates (reactive)
editor.inputs.getCurrentPagePoint()

// Cursor position in screen coordinates (reactive)
editor.inputs.getCurrentScreenPoint()

// Where the current drag started (reactive)
editor.inputs.getOriginPagePoint()

// Interaction state (reactive)
editor.inputs.getIsDragging()
editor.inputs.getIsPointing()
editor.inputs.getIsPinching()

// Modifier keys (reactive)
editor.inputs.getShiftKey()
editor.inputs.getCtrlKey()
editor.inputs.getAltKey()
```

See [Input handling](/sdk-features/input-handling) for input details.

## Instance state

The editor maintains per-instance state in a [`TLInstance`](/reference/tlschema/reference/tlschema/TLInstance) record. This includes which page is current, whether the editor is in readonly mode, the current tool, tool lock state, and UI state.

```ts
// Get instance state
const instance = editor.getInstanceState()

// Update instance state
editor.updateInstanceState({ isReadonly: true })

// Enable tool lock (keeps current tool active after creating shapes)
editor.updateInstanceState({ isToolLocked: true })
```

See [Tools](/sdk-features/tools#tool-lock) for more on tool lock.

Each page also has instance state ([`TLInstancePageState`](/reference/tlschema/reference/tlschema/TLInstancePageState)) tracking selection, hovered shape, and editing shape for that page:

```ts
// Get current page state
const pageState = editor.getCurrentPageState()
```

## User preferences

User preferences are shared across all editor instances. They control things like color scheme and locale.

```ts
// Turn on dark mode
editor.user.updateUserPreferences({ colorScheme: 'dark' })

// Use system color scheme
editor.user.updateUserPreferences({ colorScheme: 'system' })

// Get current preferences
editor.user.getUserPreferences()
```

See [User preferences](/sdk-features/user-preferences) for all preference options.

## Side effects

Register callbacks to respond to record lifecycle events. Side effects let you maintain relationships, enforce constraints, or sync external state.

```ts
// After a shape is created
editor.sideEffects.registerAfterCreateHandler('shape', (shape) => {
	if (shape.type === 'arrow') {
		console.log('Arrow created:', shape.id)
	}
})

// Before a shape is deleted
editor.sideEffects.registerBeforeDeleteHandler('shape', (shape) => {
	// Return false to prevent deletion
})
```

See [Side effects](/sdk-features/side-effects) for the complete API.

## Events

The editor receives events through [`Editor.dispatch`](/reference/editor/reference/editor/Editor#dispatch). You typically don't call this directly—the canvas handles DOM events and dispatches them for you. But you can listen for events on the editor:

```ts
editor.on('event', (info) => {
	if (info.name === 'pointer_down') {
		console.log('Pointer down at', info.point)
	}
})
```

See [Events](/sdk-features/events) for event types.

## Related examples

- **[Controlling the canvas](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/api)** — Create and manipulate shapes, selection, and camera through the editor API.
- **[Minimal editor](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/only-editor)** — Use `TldrawEditor` for a bare-bones editor without default shapes or UI.
- **[Sublibraries](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/exploded)** — Compose tldraw from individual sublibraries for full customization.
- **[Canvas events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/canvas-events)** — Listen to editor events including pointer, keyboard, and shape changes.
- **[Editor focus](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/editor-focus)** — Control editor focus state.

--------

# Embed shape

The embed shape displays interactive content from external services within an iframe. When you paste a URL from a supported service onto the canvas, tldraw automatically converts it to an embed with the appropriate dimensions and settings.

## Creating embeds

Paste a supported URL onto the canvas, or create an embed shape programmatically:

```tsx
editor.createShape({
	type: 'embed',
	x: 100,
	y: 100,
	props: {
		url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
		w: 560,
		h: 315,
	},
})
```

The embed system recognizes URLs from supported services and converts them to their embeddable equivalents. A YouTube watch URL becomes an embed URL automatically.

## Supported services

| Service         | Hostnames                    | Resizable | Aspect ratio locked |
| --------------- | ---------------------------- | --------- | ------------------- |
| tldraw          | tldraw.com, beta.tldraw.com  | Yes       | No                  |
| Figma           | figma.com                    | Yes       | No                  |
| YouTube         | youtube.com, youtu.be        | Yes       | Yes                 |
| Google Maps     | google.com/maps              | Yes       | No                  |
| Google Calendar | calendar.google.com          | Yes       | No                  |
| Google Slides   | docs.google.com/presentation | Yes       | No                  |
| CodeSandbox     | codesandbox.io               | Yes       | No                  |
| CodePen         | codepen.io                   | Yes       | No                  |
| Scratch         | scratch.mit.edu              | No        | No                  |
| Val Town        | val.town                     | Yes       | No                  |
| GitHub Gist     | gist.github.com              | Yes       | No                  |
| Replit          | replit.com                   | Yes       | No                  |
| Felt            | felt.com                     | Yes       | No                  |
| Spotify         | open.spotify.com             | Yes       | No                  |
| Vimeo           | vimeo.com, player.vimeo.com  | Yes       | Yes                 |
| Observable      | observablehq.com             | Yes       | No                  |
| Desmos          | desmos.com                   | Yes       | No                  |

Each service has default dimensions appropriate for its content type. YouTube embeds default to 800×450 (16:9), while Spotify defaults to 720×500.

## Interacting with embeds

Embed shapes behave differently from other shapes because they contain live interactive content.

**Locked embeds**: When an embed shape is locked, you can interact with the content inside—play videos, scroll through code, use the embedded application—without accidentally moving the shape. This is the recommended way to use embeds for viewing content.

**Unlocked embeds**: When an embed is unlocked, clicking on it selects the shape rather than interacting with the content. To interact with an unlocked embed, double-click to enter editing mode or hold Shift while clicking to interact directly.

**Editing mode**: In editing mode, pointer events pass through to the iframe. You can scroll, click buttons, and interact with the embedded content. Click outside the shape or press Escape to exit editing mode.

## URL transformation

The embed system converts user-facing URLs to embed URLs automatically. When you paste `https://www.youtube.com/watch?v=dQw4w9WgXcQ`, the embed shape stores the original URL and renders `https://www.youtube.com/embed/dQw4w9WgXcQ`.

Each embed definition includes two transformation functions:

- `toEmbedUrl`: Converts a shareable URL to an embeddable URL
- `fromEmbedUrl`: Converts an embed URL back to the original URL

This bidirectional transformation means the shape can display the original URL to users while rendering the embed version internally.

## Fallback to bookmarks

When you paste a URL that isn't recognized as embeddable, the embed shape falls back to rendering as a [bookmark](/sdk-features/default-shapes#bookmark). The shape's geometry changes to match the bookmark dimensions, and a link card replaces the iframe.

You can check whether a URL is embeddable before creating a shape:

```tsx
import { getEmbedInfo, DEFAULT_EMBED_DEFINITIONS } from 'tldraw'

const embedInfo = getEmbedInfo(DEFAULT_EMBED_DEFINITIONS, 'https://youtube.com/watch?v=abc123')

if (embedInfo) {
	// URL is embeddable
	console.log(embedInfo.definition.title) // "YouTube"
	console.log(embedInfo.embedUrl) // "https://www.youtube.com/embed/abc123"
} else {
	// URL is not embeddable, will render as bookmark
}
```

## Iframe security

Embeds run in sandboxed iframes with restricted permissions. The default sandbox settings are:

| Permission                                | Default | Description                                       |
| ----------------------------------------- | ------- | ------------------------------------------------- |
| `allow-scripts`                           | Yes     | Allow JavaScript execution                        |
| `allow-same-origin`                       | Yes     | Allow access to same-origin storage and APIs      |
| `allow-forms`                             | Yes     | Allow form submission                             |
| `allow-popups`                            | Yes     | Allow opening new windows (for linking to source) |
| `allow-downloads`                         | No      | Block file downloads                              |
| `allow-modals`                            | No      | Block modal dialogs like `window.prompt()`        |
| `allow-pointer-lock`                      | No      | Block pointer lock API                            |
| `allow-top-navigation`                    | No      | Block navigating away from tldraw                 |
| `allow-storage-access-by-user-activation` | No      | Block access to parent storage                    |

Individual embed definitions can override these defaults. YouTube embeds allow `allow-presentation` for fullscreen video. Tldraw embeds allow `allow-top-navigation` so users can open rooms in new tabs.

GitHub Gist embeds receive special handling: they use `srcDoc` instead of `src` to load the gist script, with an additional security check that restricts gist IDs to hexadecimal characters only. This prevents JSONP callback attacks.

## Custom embed definitions

Replace or extend the default embed definitions using `EmbedShapeUtil.setEmbedDefinitions()`:

```tsx
import { Tldraw, EmbedShapeUtil, DEFAULT_EMBED_DEFINITIONS } from 'tldraw'
import 'tldraw/tldraw.css'

// Add a custom embed definition
const myEmbedDefinitions = [
	...DEFAULT_EMBED_DEFINITIONS,
	{
		type: 'myservice',
		title: 'My Service',
		hostnames: ['myservice.com'],
		width: 600,
		height: 400,
		doesResize: true,
		toEmbedUrl: (url) => {
			const match = url.match(/myservice\.com\/item\/(\w+)/)
			if (match) {
				return `https://myservice.com/embed/${match[1]}`
			}
			return undefined
		},
		fromEmbedUrl: (url) => {
			const match = url.match(/myservice\.com\/embed\/(\w+)/)
			if (match) {
				return `https://myservice.com/item/${match[1]}`
			}
			return undefined
		},
		embedOnPaste: true,
	},
]

// Set before mounting the editor
EmbedShapeUtil.setEmbedDefinitions(myEmbedDefinitions)

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw />
		</div>
	)
}
```

### Embed definition properties

| Property                | Type                                   | Required | Description                                                               |
| ----------------------- | -------------------------------------- | -------- | ------------------------------------------------------------------------- |
| `type`                  | `string`                               | Yes      | Unique identifier for this embed type                                     |
| `title`                 | `string`                               | Yes      | Display name shown in the UI                                              |
| `hostnames`             | `string[]`                             | Yes      | URL hostnames to match (supports glob patterns like `*.youtube.com`)      |
| `width`                 | `number`                               | Yes      | Default width in pixels                                                   |
| `height`                | `number`                               | Yes      | Default height in pixels                                                  |
| `doesResize`            | `boolean`                              | Yes      | Whether the shape can be resized                                          |
| `toEmbedUrl`            | `(url: string) => string \| undefined` | Yes      | Convert shareable URL to embed URL                                        |
| `fromEmbedUrl`          | `(url: string) => string \| undefined` | Yes      | Convert embed URL to shareable URL                                        |
| `minWidth`              | `number`                               | No       | Minimum width when resizing                                               |
| `minHeight`             | `number`                               | No       | Minimum height when resizing                                              |
| `isAspectRatioLocked`   | `boolean`                              | No       | Lock aspect ratio when resizing                                           |
| `canEditWhileLocked`    | `boolean`                              | No       | Allow interaction when shape is locked (default: true)                    |
| `overridePermissions`   | `TLEmbedShapePermissions`              | No       | Custom iframe sandbox permissions                                         |
| `backgroundColor`       | `string`                               | No       | Background color for the embed container                                  |
| `overrideOutlineRadius` | `number`                               | No       | Custom border radius (Spotify uses 12px)                                  |
| `embedOnPaste`          | `boolean`                              | No       | When true, URLs are auto-converted to embeds on paste                     |
| `instructionLink`       | `string`                               | No       | Help URL for services requiring setup (like Google Calendar public links) |

## Embed-on-paste behavior

By default, pasting a URL from a supported service creates an embed shape. Set `embedOnPaste: false` in the embed definition to create a bookmark instead.

The tldraw embed definition uses `embedOnPaste: false` because nested tldraw canvases are blocked when the current page is already inside an iframe (to prevent infinite nesting).

## Shape properties

| Property | Type     | Description                                          |
| -------- | -------- | ---------------------------------------------------- |
| `url`    | `string` | The original URL (converted to embed URL internally) |
| `w`      | `number` | Width of the embed container                         |
| `h`      | `number` | Height of the embed container                        |

## SVG export

Embed shapes render as blank rectangles in SVG exports. The iframe content can't be captured directly, so exports show a placeholder with the embed's background color and border radius.

## Related

- [Default shapes](/sdk-features/default-shapes) — Overview of all built-in shape types
- [Bookmark shape](/sdk-features/default-shapes#bookmark) — URL link cards (fallback for non-embeddable URLs)
- [External content handling](/sdk-features/external-content) — Handling pasted and dropped content
- [Embedded example](/examples/misc/embedded) — Interactive example of embedding tldraw

--------

# Environment detection

The tldraw SDK provides two objects for detecting the user's environment: `tlenv` for fixed browser and platform information, and `tlenvReactive` for values that change during a session (like whether the user is using touch input). We use these internally to work around browser quirks, and you can use them in custom shapes or tools.

## Static environment: tlenv

The `tlenv` object contains values detected at page load. These don't change during a session.

```typescript
import { tlenv } from 'tldraw'

// Browser detection
tlenv.isSafari // true if Safari (excluding Chrome on iOS)
tlenv.isFirefox // true if Firefox
tlenv.isChromeForIos // true if Chrome running on iOS

// Platform detection
tlenv.isIos // true if iPad or iPhone
tlenv.isAndroid // true if Android device
tlenv.isDarwin // true if macOS

// Capability detection
tlenv.hasCanvasSupport // true if Promise and HTMLCanvasElement exist
```

### Common patterns

**Platform-specific keyboard shortcuts:**

```typescript
// Use Cmd on Mac, Ctrl elsewhere
const accelKey = tlenv.isDarwin ? e.metaKey : e.ctrlKey
```

**Mobile detection:**

```typescript
const isMobile = tlenv.isIos || tlenv.isAndroid
if (isMobile) {
	// Adjust UI for mobile
}
```

**Browser-specific workarounds:**

```typescript
// Safari needs extra time for SVG image export
if (tlenv.isSafari) {
	await new Promise((r) => setTimeout(r, 250))
}
```

## Reactive environment: tlenvReactive

The `tlenvReactive` atom contains values that can change during a session, like the current pointer type. Use `useValue` to subscribe to changes in React components.

```tsx
import { tlenvReactive, useValue } from 'tldraw'

function TouchFriendlyButton() {
	const { isCoarsePointer } = useValue(tlenvReactive)

	return (
		<button style={{ padding: isCoarsePointer ? 16 : 8 }}>
			{/* Larger touch target when using touch input */}
			Click me
		</button>
	)
}
```

### Coarse pointer detection

The `isCoarsePointer` value tracks whether the user is currently using touch input. We detect this two ways: by listening to the `(any-pointer: coarse)` media query, and by checking `pointerType` on each pointer event. This dual approach handles devices that support both mouse and touch—like laptops with touchscreens—where the user might switch input methods mid-session.

```typescript
import { tlenvReactive, react } from 'tldraw'

// Access the current value directly
const isCoarse = tlenvReactive.get().isCoarsePointer

// Subscribe to changes outside React
react('pointer type changed', () => {
	const { isCoarsePointer } = tlenvReactive.get()
	console.log('Coarse pointer:', isCoarsePointer)
})
```

Note: We force fine pointer mode on Firefox desktop regardless of the actual input device, since Firefox's coarse pointer reporting is unreliable there.

## Browser quirks we handle

Here's a sample of what we use environment detection for internally.

**Safari** has the most workarounds. SVG-to-image export fails silently unless we add a 250ms delay after loading the image—a WebKit bug that's been open for years. We also draw minimap triangles four times because Safari's WebGL implementation sometimes drops draw calls. Text outlines render incorrectly, so we disable them entirely on Safari.

**iOS** coalesced pointer events are broken (they report wrong coordinates), so we skip them entirely and use individual events. We also handle the virtual keyboard differently since iOS doesn't fire standard resize events.

**Firefox** desktop's `(any-pointer: coarse)` media query reports false positives when a touchscreen is present but not in use. We force fine pointer mode on Firefox desktop to avoid jumpy UI.

**Chrome for iOS** has its own print implementation that doesn't trigger the standard `beforeprint` event, so we detect it and handle printing manually.

--------

# Error handling

The editor uses multiple layers of React error boundaries to isolate failures. When a shape throws during render, only that shape shows a fallback. The rest of the editor keeps working. This matters because custom shapes are a common extension point, and third-party code should not crash the whole experience.

## Error boundary layers

Error boundaries exist at three levels:

**Application level.** Wraps the entire editor. If something throws here, we show a full-screen error with options to refresh or reset local data. This is the last resort.

**Shape level.** Each shape renders inside its own boundary. A broken shape disappears, but the user can still interact with everything else. ShapeUtil code is the most likely place for bugs, especially in custom shapes.

**Indicator level.** Selection indicators have their own boundaries, separate from shape content. A shape can render correctly even if its indicator throws, and vice versa.

```tsx
// The editor automatically wraps your content
<TldrawEditor>
	<OptionalErrorBoundary fallback={ErrorFallback}>
		{/* Your shapes, each with their own boundary */}
		<Shape>
			<OptionalErrorBoundary fallback={ShapeErrorFallback}>
				{/* Shape content */}
			</OptionalErrorBoundary>
		</Shape>
	</OptionalErrorBoundary>
</TldrawEditor>
```

## Default fallbacks

Each boundary level has a default fallback component.

`DefaultErrorFallback` shows a modal with the error message and stack trace. It tries to render the canvas behind the modal so users can see their work is probably still there. The modal offers buttons to copy the error, refresh the page, or reset local data.

`DefaultShapeErrorFallback` renders an empty div with the class `tl-shape-error-boundary`. The shape vanishes, but nothing else breaks. Style this class if you want broken shapes to be more visible.

`DefaultShapeIndicatorErrorFallback` renders a red circle where the selection outline would be. It signals that something went wrong without disrupting selection behavior.

## Customizing error components

Replace any error fallback through the `components` prop:

```tsx
import { Tldraw, TLErrorFallbackComponent, TLShapeErrorFallbackComponent } from 'tldraw'

const MyErrorFallback: TLErrorFallbackComponent = ({ error, editor }) => {
	return (
		<div className="my-error-screen">
			<h1>Oops!</h1>
			<p>{error instanceof Error ? error.message : String(error)}</p>
			<button onClick={() => window.location.reload()}>Refresh</button>
		</div>
	)
}

const MyShapeErrorFallback: TLShapeErrorFallbackComponent = ({ error }) => {
	return <div className="broken-shape">This shape failed to render</div>
}

;<Tldraw
	components={{
		ErrorFallback: MyErrorFallback,
		ShapeErrorFallback: MyShapeErrorFallback,
	}}
/>
```

Set a fallback to `null` to disable the error boundary at that level. Errors will propagate to the parent boundary instead.

## Crash handling

When the editor encounters a fatal error during event processing, it enters a crashed state. Listen for this with the `crash` event:

```tsx
editor.on('crash', ({ error }) => {
	console.error('Editor crashed:', error)
	// Report to error tracking service
})
```

When crashed, the editor stops processing new events to prevent further damage. The error boundary displays the fallback UI, giving users options to recover.

## Error annotations

The SDK can attach debugging metadata to errors. Use `getErrorAnnotations` to retrieve tags and extra context, which is useful for error tracking services like Sentry:

```tsx
import { getErrorAnnotations, TLErrorFallbackComponent } from 'tldraw'

const MyErrorFallback: TLErrorFallbackComponent = ({ error }) => {
	const annotations = error instanceof Error ? getErrorAnnotations(error) : null

	// Send to error tracking
	if (annotations) {
		Sentry.setTags(annotations.tags)
		Sentry.setExtras(annotations.extras)
	}

	return (
		<div>
			<h1>Something went wrong</h1>
			<pre>{JSON.stringify(annotations, null, 2)}</pre>
		</div>
	)
}
```

Annotations include `tags` (key-value pairs for categorization) and `extras` (additional context data).

## ErrorBoundary component

Use the exported `ErrorBoundary` component directly in your own code:

```tsx
import { ErrorBoundary, TLErrorFallbackComponent } from 'tldraw'

const MyFallback: TLErrorFallbackComponent = ({ error }) => (
	<div>Error: {error instanceof Error ? error.message : String(error)}</div>
)

function MyComponent() {
	return (
		<ErrorBoundary fallback={MyFallback} onError={(error) => console.error('Caught:', error)}>
			<RiskyComponent />
		</ErrorBoundary>
	)
}
```

The `fallback` prop accepts a component that receives `{ error: unknown; editor?: Editor }`. The `onError` callback fires when an error is caught, before the fallback renders.

## API reference

### Components

| Component                     | Props                              | Description                           |
| ----------------------------- | ---------------------------------- | ------------------------------------- |
| `ErrorFallback`               | `{ error, editor? }`               | Application-level error screen        |
| `ShapeErrorFallback`          | `{ error }`                        | Per-shape error placeholder           |
| `ShapeIndicatorErrorFallback` | `{ error }`                        | Selection indicator error placeholder |
| `ErrorBoundary`               | `{ fallback, onError?, children }` | Reusable error boundary component     |

### Types

| Type                                     | Description                                          |
| ---------------------------------------- | ---------------------------------------------------- |
| `TLErrorFallbackComponent`               | `ComponentType<{ error: unknown; editor?: Editor }>` |
| `TLShapeErrorFallbackComponent`          | `ComponentType<{ error: any }>`                      |
| `TLShapeIndicatorErrorFallbackComponent` | `ComponentType<{ error: unknown }>`                  |
| `TLErrorBoundaryProps`                   | Props for the ErrorBoundary component                |

### Functions

| Function                     | Description                                          |
| ---------------------------- | ---------------------------------------------------- |
| `getErrorAnnotations(error)` | Retrieve tags and extras attached to an error object |

### Events

| Event   | Payload              | Description                                |
| ------- | -------------------- | ------------------------------------------ |
| `crash` | `{ error: unknown }` | Fired when the editor enters crashed state |

## Related examples

- **[Error boundary](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/error-boundary)** — Customize ShapeErrorFallback to display a custom message when shapes throw errors.
- **[Custom error capture](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-error-capture)** — Override ErrorFallback to create a custom error screen with annotations for debugging.

--------

# Events

The editor emits events for user interactions, state changes, and lifecycle moments. You subscribe using `on()` and `off()` methods inherited from EventEmitter. Events range from low-level input (pointer moves, key presses) to high-level changes (shapes created, camera moved). Use them to build analytics, sync external state, or extend editor behavior.

## Subscribing to events

The `Editor` extends EventEmitter and provides typed event subscriptions:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					editor.on('event', (info) => {
						console.log('Event:', info.type, info.name)
					})
				}}
			/>
		</div>
	)
}
```

Unsubscribe by calling `off()` with the same handler:

```tsx
const handleEvent = (info) => {
	console.log('Event:', info.type)
}

editor.on('event', handleEvent)
editor.off('event', handleEvent)
```

Always unsubscribe when your component unmounts to prevent memory leaks. In React, return a cleanup function from your effect:

```tsx
useEffect(() => {
	const handleChange = (entry) => {
		console.log('Store changed:', entry.changes)
	}

	editor.on('change', handleChange)
	return () => editor.off('change', handleChange)
}, [editor])
```

## Event categories

### Input events

The `event` and `before-event` events fire for all user interactions. Each receives a [`TLEventInfo`](/reference/editor/reference/editor/TLEventInfo) object describing the input.

```tsx
editor.on('event', (info) => {
	if (info.type === 'pointer' && info.name === 'pointer_down') {
		console.log('Clicked at', info.point)
	}
})
```

The `before-event` fires before the event reaches the tool state machine. Use it to inspect or log events before processing. The `event` fires after tool processing completes.

Input events have different types:

| Type       | Names                                                                                     | Description                         |
| ---------- | ----------------------------------------------------------------------------------------- | ----------------------------------- |
| `pointer`  | `pointer_down`, `pointer_move`, `pointer_up`, `right_click`, `middle_click`, `long_press` | Mouse, touch, and pen interactions  |
| `click`    | `double_click`, `triple_click`, `quadruple_click`                                         | Multi-click sequences               |
| `keyboard` | `key_down`, `key_up`, `key_repeat`                                                        | Keyboard input                      |
| `wheel`    | `wheel`                                                                                   | Scroll wheel and trackpad scrolling |
| `pinch`    | `pinch_start`, `pinch`, `pinch_end`                                                       | Two-finger pinch gestures           |
| `zoom`     | —                                                                                         | Programmatic zoom events            |

Pointer events include the target—what the pointer is over:

```tsx
editor.on('event', (info) => {
	if (info.type === 'pointer' && info.name === 'pointer_down') {
		switch (info.target) {
			case 'canvas':
				console.log('Clicked empty canvas')
				break
			case 'shape':
				console.log('Clicked shape:', info.shape.id)
				break
			case 'selection':
				console.log('Clicked selection bounds')
				break
			case 'handle':
				console.log('Clicked handle on:', info.shape.id)
				break
		}
	}
})
```

### Shape events

Shape events fire when shapes change. These are convenience wrappers around store changes—you can also use the `change` event to track all store modifications.

| Event            | Payload       | Description                      |
| ---------------- | ------------- | -------------------------------- |
| `created-shapes` | `TLRecord[]`  | Shapes were added                |
| `edited-shapes`  | `TLRecord[]`  | Shapes were modified             |
| `deleted-shapes` | `TLShapeId[]` | Shapes were removed              |
| `edit`           | None          | Fires alongside any of the above |

```tsx
editor.on('created-shapes', (shapes) => {
	console.log('Created:', shapes.map((s) => s.type).join(', '))
})

editor.on('deleted-shapes', (ids) => {
	console.log('Deleted:', ids.length, 'shapes')
})
```

### Store changes

The `change` event fires whenever the store updates. It receives a [`HistoryEntry`](/reference/store/reference/store/HistoryEntry) containing the diff and source:

```tsx
editor.on('change', (entry) => {
	const { added, updated, removed } = entry.changes

	for (const record of Object.values(added)) {
		if (record.typeName === 'shape') {
			console.log('Added shape:', record.type)
		}
	}

	for (const [from, to] of Object.values(updated)) {
		if (from.typeName === 'shape') {
			console.log('Updated shape:', from.id)
		}
	}

	for (const record of Object.values(removed)) {
		if (record.typeName === 'shape') {
			console.log('Removed shape:', record.id)
		}
	}
})
```

The `source` property indicates where the change originated:

```tsx
editor.on('change', (entry) => {
	if (entry.source === 'user') {
		// Change from local user interaction
		scheduleAutosave()
	} else if (entry.source === 'remote') {
		// Change from collaboration sync
	}
})
```

### Frame events

Two events fire on every animation frame:

| Event   | Payload  | Description                   |
| ------- | -------- | ----------------------------- |
| `tick`  | `number` | Milliseconds since last tick  |
| `frame` | `number` | Milliseconds since last frame |

```tsx
editor.on('tick', (elapsed) => {
	// Update animations, physics, etc.
	updateParticleSystem(elapsed)
})
```

These fire frequently (60+ times per second). Keep handlers fast to avoid dropping frames.

### Lifecycle events

| Event     | Payload              | Description                  |
| --------- | -------------------- | ---------------------------- |
| `mount`   | None                 | Editor finished initializing |
| `dispose` | None                 | Editor is being cleaned up   |
| `crash`   | `{ error: unknown }` | Editor encountered an error  |
| `update`  | None                 | Editor state updated         |

```tsx
editor.on('mount', () => {
	console.log('Editor ready')
})

editor.on('crash', ({ error }) => {
	reportError(error)
})
```

### UI and camera events

| Event                   | Payload                   | Description                    |
| ----------------------- | ------------------------- | ------------------------------ |
| `resize`                | `BoxModel`                | Viewport dimensions changed    |
| `stop-camera-animation` | None                      | Camera animation interrupted   |
| `stop-following`        | None                      | Stopped following another user |
| `select-all-text`       | `{ shapeId: TLShapeId }`  | Triple-clicked to select text  |
| `place-caret`           | `{ shapeId, point }`      | Text caret positioned          |
| `max-shapes`            | `{ name, pageId, count }` | Page reached shape limit       |

```tsx
editor.on('resize', (bounds) => {
	console.log('Canvas size:', bounds.w, 'x', bounds.h)
})

editor.on('max-shapes', ({ pageId, count }) => {
	showWarning(`Page has reached the ${count} shape limit`)
})
```

## UI events

The `Tldraw` component's `onUiEvent` prop captures high-level UI interactions separately from canvas events. This includes toolbar selections, menu actions, and keyboard shortcuts.

```tsx
<Tldraw
	onUiEvent={(name, data) => {
		console.log('UI event:', name, data)
	}}
/>
```

UI events track actions like selecting tools, grouping shapes, toggling dark mode, and zooming. They fire regardless of whether the action came from a click or keyboard shortcut. For the full list of events, see [`TLUiEventMap`](/reference/tldraw/reference/tldraw/TLUiEventMap).

## Listening to store changes directly

For fine-grained control over store subscriptions, use `editor.store.listen()` instead of editor events:

```tsx
const cleanup = editor.store.listen(
	(entry) => {
		// Handle changes
	},
	{ source: 'user', scope: 'all' }
)

// Later, unsubscribe
cleanup()
```

The `listen()` method accepts filter options:

- `source`: `'user'`, `'remote'`, or `'all'`—filter by change origin
- `scope`: `'all'`, `'document'`, `'session'`, or `'presence'`—filter by record scope

See [Side effects](/docs/side-effects) for registering handlers that can intercept and modify changes.

## Related examples

- **[Canvas events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/canvas-events)** - Log pointer, keyboard, and wheel events as you interact with the canvas.
- **[Store events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/store-events)** - Track shape creation, updates, and deletion through store change events.
- **[UI events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/ui-events)** - Capture high-level UI interactions like tool selection and menu actions.

--------

# External content handling

The external content system handles content from outside the editor: pasted text, dropped files, embedded URLs, and more. You register handlers for specific content types, and the editor routes incoming content to the appropriate handler.

```tsx
import { Tldraw, Editor, defaultHandleExternalTextContent } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	function handleMount(editor: Editor) {
		editor.registerExternalContentHandler('text', async (content) => {
			// Check if this is HTML content
			const htmlSource = content.sources?.find((s) => s.type === 'text' && s.subtype === 'html')
			if (htmlSource) {
				// Handle HTML specially
				const center = content.point ?? editor.getViewportPageBounds().center
				editor.createShape({
					type: 'text',
					x: center.x,
					y: center.y,
					props: { text: 'Custom HTML handling!' },
				})
			} else {
				// Fall back to default behavior
				await defaultHandleExternalTextContent(editor, content)
			}
		})
	}

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw onMount={handleMount} />
		</div>
	)
}
```

## How it works

Two systems handle external content: content handlers and asset handlers.

**Content handlers** transform external content into shapes. When a user pastes text, drops an image, or embeds a URL, the content handler for that type processes the data and creates shapes on the canvas.

**Asset handlers** process external assets into asset records. When an image file arrives, the asset handler extracts dimensions, uploads the file, and returns an asset record with the uploaded URL. The content handler then creates a shape referencing that asset.

The flow works like this:

1. Content arrives (paste, drop, or API call)
2. The editor calls `putExternalContent` with the content object
3. The registered handler for that content type processes it
4. The handler creates shapes, assets, or both

## Content types

The system supports these content types:

### Text

Text content comes from clipboard paste operations. The handler receives `text` (plain text), optional `html` (HTML markup), and `point` (where to place the content). The default handler creates text shapes, detecting right-to-left languages and handling multi-line text.

```typescript
interface TLTextExternalContent {
	type: 'text'
	text: string
	html?: string
	point?: VecLike
	sources?: TLExternalContentSource[]
}
```

### Files

File content represents one or more files dropped onto the canvas. The handler receives an array of `File` objects and validates file types and sizes before creating shapes.

```typescript
interface TLFilesExternalContent {
	type: 'files'
	files: File[]
	point?: VecLike
	ignoreParent?: boolean
}
```

The default handler creates temporary previews for images, uploads the files, and creates image or video shapes arranged horizontally from the drop point.

### File replace

File replace content handles replacing an existing image or video shape's asset. This is used when a user drags a new file onto an existing image shape.

```typescript
interface TLFileReplaceExternalContent {
	type: 'file-replace'
	file: File
	shapeId: TLShapeId
	isImage: boolean
	point?: VecLike
}
```

The default handler validates the file, creates a new asset, and updates the target shape to reference the new asset while preserving any existing crop settings.

### URLs

URL content represents a URL to insert. The default handler checks if the URL matches a known embed pattern (YouTube, Twitter, etc.) and creates an embed shape. Otherwise, it fetches Open Graph metadata and creates a bookmark shape.

```typescript
interface TLUrlExternalContent {
	type: 'url'
	url: string
	point?: VecLike
}
```

### SVG text

SVG text content handles raw SVG markup. The handler parses the SVG, extracts dimensions, creates an image asset, and inserts an image shape.

```typescript
interface TLSvgTextExternalContent {
	type: 'svg-text'
	text: string
	point?: VecLike
}
```

### Embeds

Embed content creates embed shapes for embeddable URLs like YouTube videos. This content type is usually invoked by the URL handler when it detects an embeddable URL.

```typescript
interface TLEmbedExternalContent<EmbedDefinition> {
	type: 'embed'
	url: string
	embed: EmbedDefinition
	point?: VecLike
}
```

### tldraw and excalidraw content

These handlers process serialized content from other tldraw editors or Excalidraw. The `tldraw` handler calls `putContentOntoCurrentPage` to insert shapes. The `excalidraw` handler converts Excalidraw shapes to tldraw equivalents.

```typescript
interface TLTldrawExternalContent {
	type: 'tldraw'
	content: TLContent
	point?: VecLike
}
```

## Asset handling

Asset handlers turn external files and URLs into asset records. There are two asset handler types:

| Type   | Input         | Output                                  |
| ------ | ------------- | --------------------------------------- |
| `file` | `File` object | Image or video asset record             |
| `url`  | URL string    | Bookmark asset with Open Graph metadata |

The `file` handler extracts dimensions and file size, uploads the file via `editor.uploadAsset`, and returns an asset record. The `url` handler fetches the page's Open Graph metadata (title, description, image) and creates a bookmark asset.

```typescript
editor.registerExternalAssetHandler('file', async ({ file, assetId }) => {
	const size = await MediaHelpers.getImageSize(file)

	const asset = {
		id: assetId ?? AssetRecordType.createId(),
		type: 'image' as const,
		typeName: 'asset' as const,
		props: {
			name: file.name,
			src: '',
			w: size.w,
			h: size.h,
			mimeType: file.type,
			isAnimated: false,
			fileSize: file.size,
		},
		meta: {},
	}

	const result = await editor.uploadAsset(asset, file)
	asset.props.src = result.src

	return AssetRecordType.create(asset)
})
```

## API methods

| Method                           | Purpose                                                 |
| -------------------------------- | ------------------------------------------------------- |
| `registerExternalContentHandler` | Register a handler for a content type                   |
| `registerExternalAssetHandler`   | Register a handler for an asset type                    |
| `putExternalContent`             | Process external content through the registered handler |
| `getAssetForExternalContent`     | Create an asset from external content                   |

Use `putExternalContent` to programmatically insert content:

```typescript
// Insert text at a specific point
editor.putExternalContent({
	type: 'text',
	text: 'Hello, world!',
	point: { x: 100, y: 100 },
})

// Insert a URL (creates embed or bookmark)
editor.putExternalContent({
	type: 'url',
	url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
	point: { x: 200, y: 200 },
})
```

Use `getAssetForExternalContent` when you need an asset without creating a shape:

```typescript
const asset = await editor.getAssetForExternalContent({
	type: 'file',
	file: myFile,
})
```

Remove a handler by passing `null`:

```typescript
editor.registerExternalContentHandler('text', null)
```

## Customizing handlers

Register a new handler to replace the default behavior for any content type. Your handler receives the content object and can create shapes, insert assets, or do anything else.

To extend rather than replace, call the default handler from your custom handler:

```typescript
import { defaultHandleExternalTextContent } from 'tldraw'

editor.registerExternalContentHandler('text', async (content) => {
	// Custom handling for HTML
	const htmlSource = content.sources?.find((s) => s.type === 'text' && s.subtype === 'html')
	if (htmlSource) {
		const center = content.point ?? editor.getViewportPageBounds().center
		editor.createShape({
			type: 'my-html-shape',
			x: center.x,
			y: center.y,
			props: { html: htmlSource.data },
		})
		return
	}

	// Fall back to default for plain text
	await defaultHandleExternalTextContent(editor, content)
})
```

The default handlers are exported from `@tldraw/tldraw`:

- `defaultHandleExternalTextContent`
- `defaultHandleExternalFileContent`
- `defaultHandleExternalUrlContent`
- `defaultHandleExternalSvgTextContent`
- `defaultHandleExternalEmbedContent`
- `defaultHandleExternalTldrawContent`
- `defaultHandleExternalExcalidrawContent`
- `defaultHandleExternalFileAsset`
- `defaultHandleExternalUrlAsset`
- `defaultHandleExternalFileReplaceContent`

## Related examples

- [External content sources](/examples/data/assets/external-content-sources) - Handle pasted HTML by creating custom shapes.
- [Hosted images](/examples/data/assets/hosted-images) - Upload images to your own server using a custom asset store.

--------

# Focus

Focus determines whether the editor receives keyboard shortcuts, scroll wheel gestures, and pointer move events. When focused, these inputs go to the editor. When unfocused, they pass through to the rest of your page.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw autoFocus={true} />
		</div>
	)
}
```

## Controlling focus

Use [`Editor.focus`](/reference/editor/reference/editor/Editor#focus) and [`Editor.blur`](/reference/editor/reference/editor/Editor#blur) to programmatically control focus:

```typescript
editor.focus()
editor.blur()
editor.getIsFocused() // true or false
```

Both methods accept options to control whether the container element should also receive or lose DOM focus:

```typescript
editor.focus({ focusContainer: false })
editor.blur({ blurContainer: false })
```

### Focus/blur options

| Method  | Option           | Default | Description                                             |
| ------- | ---------------- | ------- | ------------------------------------------------------- |
| `focus` | `focusContainer` | `true`  | Whether to also dispatch a DOM focus event to container |
| `blur`  | `blurContainer`  | `true`  | Whether to also dispatch a DOM blur event to container  |

## Why focus is separate from DOM focus

The editor tracks focus separately from the browser's DOM focus. The browser's focus model isn't reliable enough for an editor like tldraw. Iframes aren't considered descendants of their parent elements, many menus are portalled into different parts of the document tree, and the document's active element can be unpredictable.

The editor maintains its own `isFocused` state in the instance record. This lets you distinguish between "editor focus" (whether the editor responds to keyboard shortcuts) and "element focus" (which HTML element is active in the DOM).

When `isFocused` changes, the editor adds or removes the `tl-container__focused` CSS class on the container. Use this class for styling instead of `:focus` or `:focus-within` pseudo-selectors, which can't reliably detect editor focus.

## Auto-focus

The `autoFocus` prop controls whether the editor focuses when it mounts. It defaults to `true`. Set it to `false` when embedding the editor in a page where you don't want it to capture keyboard input immediately.

```tsx
<Tldraw autoFocus={false} />
```

## Focus ring visibility

The editor manages focus ring visibility for accessibility. Focus rings appear around focused elements during keyboard navigation but are hidden during mouse interactions.

When you press Tab, ArrowUp, or ArrowDown, the editor removes the `tl-container__no-focus-ring` class to show focus rings. Mouse clicks add the class back to hide them. Focus rings also stay hidden during shape editing.

## Completing interactions on blur

When you call `editor.blur()`, it calls `editor.complete()` to finish any ongoing interaction like a drag or draw operation. This prevents the editor from being left in an incomplete state when focus is lost.

## Multiple editors

When you have multiple editors on the same page, you'll need to manage focus yourself. The browser's DOM focus alone isn't enough to reliably switch which editor receives keyboard input.

```tsx
function MultipleEditors() {
	const [editors, setEditors] = useState<Editor[]>([])

	function handleEditorFocus(focusedEditor: Editor) {
		for (const editor of editors) {
			if (editor === focusedEditor) {
				editor.focus()
			} else {
				editor.blur()
			}
		}
	}

	return (
		<>
			<div onFocus={() => editors[0] && handleEditorFocus(editors[0])}>
				<Tldraw autoFocus={false} onMount={(e) => setEditors((prev) => [...prev, e])} />
			</div>
			<div onFocus={() => editors[1] && handleEditorFocus(editors[1])}>
				<Tldraw autoFocus={false} onMount={(e) => setEditors((prev) => [...prev, e])} />
			</div>
		</>
	)
}
```

## Related examples

- [Editor focus](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/editor-focus) - Control editor focus with focus and blur methods.
- [Multiple editors](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/multiple) - Manage focus between multiple tldraw instances.

--------

# Geo shape

The geo shape is one of the default shapes in tldraw. It renders geometric primitives with optional text labels. Geo shapes support 20 different geometric forms—from basic shapes like rectangles and ellipses to specialized forms like stars, clouds, and directional arrows. They can display rich text labels with configurable alignment. These capabilities make geo shapes the foundation for flowcharts, diagrams, and annotated illustrations.

## Geometric forms

The geo shape supports a variety of built-in forms, grouped by type:

### Basic shapes

| Form        | Description                                  |
| ----------- | -------------------------------------------- |
| `rectangle` | Four-sided shape with right angles (default) |
| `ellipse`   | Oval or circular shape                       |
| `triangle`  | Three-sided shape pointing upward            |
| `diamond`   | Square rotated 45 degrees                    |
| `oval`      | Stadium shape (rectangle with rounded ends)  |

### Polygons

| Form       | Description                 |
| ---------- | --------------------------- |
| `pentagon` | Five-sided regular polygon  |
| `hexagon`  | Six-sided regular polygon   |
| `octagon`  | Eight-sided regular polygon |
| `star`     | Five-pointed star           |

### Parallelograms

| Form        | Description                                   |
| ----------- | --------------------------------------------- |
| `rhombus`   | Parallelogram slanted to the right            |
| `rhombus-2` | Parallelogram slanted to the left             |
| `trapezoid` | Four-sided shape with parallel top and bottom |

### Directional arrows

| Form          | Description                   |
| ------------- | ----------------------------- |
| `arrow-up`    | Block arrow pointing upward   |
| `arrow-down`  | Block arrow pointing downward |
| `arrow-left`  | Block arrow pointing left     |
| `arrow-right` | Block arrow pointing right    |

### Special shapes

| Form        | Description                                    |
| ----------- | ---------------------------------------------- |
| `cloud`     | Organic cloud shape with randomly varied bumps |
| `heart`     | Heart shape                                    |
| `x-box`     | Rectangle with an X through it                 |
| `check-box` | Rectangle with a checkmark inside              |

## Creating geo shapes

Create a geo shape using [`Editor.createShape`](/reference/editor/reference/editor/Editor#createShape):

```tsx
import { toRichText } from 'tldraw'

editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	props: {
		geo: 'rectangle',
		w: 200,
		h: 150,
		color: 'blue',
		fill: 'solid',
		dash: 'draw',
		size: 'm',
	},
})
```

### Adding text labels

Geo shapes support rich text labels positioned inside the shape:

```tsx
editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	props: {
		geo: 'ellipse',
		w: 200,
		h: 150,
		richText: toRichText('Process step'),
		labelColor: 'black',
		align: 'middle',
		verticalAlign: 'middle',
		font: 'draw',
	},
})
```

The label text automatically wraps within the shape bounds. When text overflows the shape height, the shape grows vertically to accommodate it. The `growY` property tracks this additional height.

### Changing the geometric form

Switch between forms by updating the `geo` property:

```tsx
// Change a rectangle to an ellipse
editor.updateShape({
	id: shapeId,
	type: 'geo',
	props: {
		geo: 'ellipse',
	},
})
```

You can also set the default geometric form for the geo tool by updating the style for the next shape:

```tsx
import { GeoShapeGeoStyle } from 'tldraw'

// Set the default geo style to star
editor.setStyleForNextShapes(GeoShapeGeoStyle, 'star')
```

## Using the geo tool

The geo tool creates shapes through click or click-and-drag interactions.

### Click to create

Click anywhere on the canvas to create a shape at the default size. The shape centers on your click position. Different geometric forms have different default sizes:

| Form    | Default size |
| ------- | ------------ |
| `star`  | 200 × 190    |
| `cloud` | 300 × 180    |
| Other   | 200 × 200    |

### Click and drag to create

Click and drag to create a shape at a custom size. The shape's corner follows your pointer as you drag. Release to complete the shape.

### Editing labels

Press Enter while a geo shape is selected to edit its label. The shape enters edit mode, allowing you to type or modify the rich text content. Press Escape to exit edit mode.

### Tool lock

When tool lock is enabled (via the toolbar or [`Editor.setCurrentTool`](/reference/editor/reference/editor/Editor#setCurrentTool)), you can create multiple shapes without returning to the select tool after each one.

## Shape properties

| Property        | Type                            | Description                                         |
| --------------- | ------------------------------- | --------------------------------------------------- |
| `geo`           | `TLGeoShapeGeoStyle`            | The geometric form                                  |
| `w`             | `number`                        | Width in pixels                                     |
| `h`             | `number`                        | Height in pixels                                    |
| `richText`      | `TLRichText`                    | Text label displayed inside the shape               |
| `color`         | `TLDefaultColorStyle`           | Stroke/outline color                                |
| `labelColor`    | `TLDefaultColorStyle`           | Text label color (separate from stroke)             |
| `fill`          | `TLDefaultFillStyle`            | Fill style: `none`, `semi`, `solid`, `pattern`      |
| `dash`          | `TLDefaultDashStyle`            | Stroke pattern: `draw`, `solid`, `dashed`, `dotted` |
| `size`          | `TLDefaultSizeStyle`            | Size preset affecting stroke width                  |
| `font`          | `TLDefaultFontStyle`            | Font family for the label                           |
| `align`         | `TLDefaultHorizontalAlignStyle` | Horizontal text alignment                           |
| `verticalAlign` | `TLDefaultVerticalAlignStyle`   | Vertical text alignment                             |
| `growY`         | `number`                        | Additional vertical space for text overflow         |
| `url`           | `string`                        | Optional hyperlink URL                              |
| `scale`         | `number`                        | Scale factor applied to the shape                   |

## Configuration options

Configure the geo shape utility to adjust rendering behavior:

| Option            | Type      | Default | Description                                                                                      |
| ----------------- | --------- | ------- | ------------------------------------------------------------------------------------------------ |
| `showTextOutline` | `boolean` | `true`  | Whether to show a text outline (using the canvas background color) to improve label readability. |

```tsx
import { GeoShapeUtil } from 'tldraw'

const ConfiguredGeoUtil = GeoShapeUtil.configure({
	showTextOutline: false,
})
```

Pass the configured utility to the `shapeUtils` prop:

```tsx
<Tldraw shapeUtils={[ConfiguredGeoUtil]} />
```

## Label positioning

The `align` and `verticalAlign` properties control where labels appear within the shape:

### Horizontal alignment

| Value    | Position              |
| -------- | --------------------- |
| `start`  | Left edge of shape    |
| `middle` | Horizontally centered |
| `end`    | Right edge of shape   |

### Vertical alignment

| Value    | Position            |
| -------- | ------------------- |
| `start`  | Top of shape        |
| `middle` | Vertically centered |
| `end`    | Bottom of shape     |

When the label text exceeds the shape's height, the shape automatically grows by adding to `growY`. The shape never shrinks below its original `h` value to accommodate shorter text—instead, `growY` returns to 0.

## Resizing behavior

Geo shapes resize from any corner or edge handle. When resizing a shape with a label:

- The shape respects a minimum unscaled size of 51 × 51 pixels when it contains text
- The shape won't shrink smaller than the label's required dimensions
- `growY` resets to 0 when you resize, letting the shape recalculate the needed height

## Special interactions

### Rectangle/checkbox toggle

Double-click a rectangle while holding Alt to convert it to a checkbox. Double-click the checkbox with Alt held to convert it back to a rectangle. This lets you quickly add checkmarks to items.

### Cloud shape variation

The cloud shape generates its bumps procedurally based on the shape's ID. Each cloud has unique bump positions, giving visual variety while maintaining a consistent style. Larger clouds have more bumps; smaller clouds have fewer but at least six.

### Handle snap geometry

Arrows snap to geo shapes at meaningful positions:

- **Polygon-based shapes** (rectangle, triangle, pentagon, etc.): Arrows snap to each vertex and the center
- **Curved shapes** (ellipse, oval, cloud, heart): Arrows snap only to the center point

## Dynamic resize mode

When dynamic resize mode is enabled in user preferences, new geo shapes scale inversely with zoom level. Drawing while zoomed out creates shapes that appear the same size on screen as they would at 100% zoom.

```tsx
// Enable dynamic resize mode
editor.user.updateUserPreferences({ isDynamicResizeMode: true })
```

## Hyperlinks

Geo shapes can link to URLs. When a shape has a URL, a link button appears on the shape:

```tsx
editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	props: {
		geo: 'rectangle',
		w: 200,
		h: 100,
		url: 'https://tldraw.dev',
	},
})
```

Click the link button to open the URL in a new tab.

## Path rendering

Geo shapes use a path-based rendering system. Each geometric form has a corresponding path definition in `getGeoShapePath`, which generates the outline used for both fill rendering and stroke styles. The path system supports:

- **Fill rendering**: Solid, semi-transparent, or pattern fills
- **Stroke styles**: Solid lines, dashed patterns, dotted patterns, and hand-drawn "draw" style
- **Efficient caching**: Path calculations are cached per shape instance

When the `dash` property is set to `'draw'`, the shape renders with organic, hand-drawn strokes that vary slightly based on the shape's position and size.

## Geometry

The shape's geometry returns a [`Group2d`](/reference/editor/reference/editor/Group2d) containing:

1. The outline path geometry (polygon or curve depending on the form)
2. A label rectangle for hit testing text interactions

This compound geometry enables accurate point-in-shape detection for both the shape outline and its text label.

## Related articles

- [Default shapes](/sdk-features/default-shapes) — Overview of all built-in shapes
- [Rich text](/sdk-features/rich-text) — Working with formatted text content
- [Styles](/sdk-features/styles) — Working with shape styles like color and fill
- [Tools](/sdk-features/tools) — How tools handle user input

--------

# Geometry

Geometry in tldraw is a mathematical description of a shape's form. Each shape has a [`Geometry2d`](/reference/editor/reference/editor/Geometry2d) that defines its outline, bounds, and spatial properties. When you click to select a shape, the geometry determines whether the click hit. When you brush a selection box, the geometry calculates intersections. When you snap an arrow to a shape's edge, the geometry provides the nearest point. For the broader shape system, see [Shapes](/docs/shapes).

## How geometry works

Each [`ShapeUtil`](/reference/editor/reference/editor/ShapeUtil) implements a [`ShapeUtil.getGeometry`](/reference/editor/reference/editor/ShapeUtil#getGeometry) method that returns a [`Geometry2d`](/reference/editor/reference/editor/Geometry2d) instance. The editor calls this method to calculate bounds, test hits, find intersections, and measure distances.

```typescript
class MyShapeUtil extends ShapeUtil<MyShape> {
	getGeometry(shape: MyShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}
}
```

The `isFilled` property controls hit testing behavior. A filled geometry registers hits inside its area. An unfilled geometry only responds to hits on its outline—useful for shapes like frames where you want to click through the middle.

Geometry also powers [snapping](/docs/snapping). When you drag shapes, the snapping system uses geometry to find edges, centers, and corners to align to. Custom shapes can provide additional snap points by implementing [`ShapeUtil.getBoundsSnapGeometry`](/reference/editor/reference/editor/ShapeUtil#getBoundsSnapGeometry).

## Geometry primitives

The SDK includes geometry classes for common shapes.

### Rectangle2d

Axis-aligned rectangles. The most common geometry for box-shaped elements.

```typescript
new Rectangle2d({
	width: 200,
	height: 100,
	isFilled: true,
})
```

You can offset the rectangle from the origin:

```typescript
new Rectangle2d({
	x: 10,
	y: 10,
	width: 200,
	height: 100,
	isFilled: true,
})
```

### Ellipse2d

Circles and ellipses.

```typescript
new Ellipse2d({
	width: 100,
	height: 100, // circle
	isFilled: true,
})

new Ellipse2d({
	width: 200,
	height: 100, // ellipse
	isFilled: true,
})
```

### Circle2d

A specialized circle geometry that stores radius directly. The `x` and `y` parameters offset the circle's bounding box, not its center.

```typescript
new Circle2d({
	radius: 50,
	isFilled: true,
})

// Offset from origin
new Circle2d({
	x: 10,
	y: 10,
	radius: 50,
	isFilled: true,
})
```

### Polygon2d

Arbitrary closed polygons defined by vertices.

```typescript
new Polygon2d({
	points: [new Vec(0, 50), new Vec(100, 0), new Vec(100, 100), new Vec(0, 100)],
	isFilled: true,
})
```

Polygon2d requires at least three points and automatically closes the path.

### Polyline2d

Open paths defined by vertices. Use this for lines that don't form closed shapes. Requires at least two points.

```typescript
new Polyline2d({
	points: [new Vec(0, 0), new Vec(50, 100), new Vec(100, 0)],
})
```

Polylines are never filled since they don't enclose an area. Polygon2d extends Polyline2d but sets `isClosed` to true.

### Edge2d

A single line segment between two points.

```typescript
new Edge2d({
	start: new Vec(0, 0),
	end: new Vec(100, 100),
})
```

Arrows use Edge2d for straight arrow bodies.

### Arc2d

A circular arc defined by center, start, end, and arc flags. All parameters are required.

```typescript
new Arc2d({
	center: new Vec(50, 50),
	start: new Vec(0, 50),
	end: new Vec(100, 50),
	sweepFlag: 1,
	largeArcFlag: 0,
})
```

The `sweepFlag` and `largeArcFlag` follow SVG arc conventions: `sweepFlag` controls clockwise vs counterclockwise direction, and `largeArcFlag` chooses between the two possible arcs. Arrows use Arc2d for curved arrow bodies.

### Stadium2d

A pill or capsule shape (rectangle with semicircular ends). The shorter dimension determines the radius of the rounded ends.

```typescript
new Stadium2d({
	width: 200,
	height: 50,
	isFilled: true,
})
```

### CubicBezier2d

A single cubic bezier curve segment.

```typescript
new CubicBezier2d({
	start: new Vec(0, 0),
	cp1: new Vec(30, 100),
	cp2: new Vec(70, 100),
	end: new Vec(100, 0),
})
```

### CubicSpline2d

A smooth curve through multiple points, automatically generating smooth cubic bezier segments between them.

```typescript
new CubicSpline2d({
	points: [new Vec(0, 0), new Vec(50, 100), new Vec(100, 50), new Vec(150, 100)],
})
```

### Point2d

A single point. Requires both `point` and `margin` parameters—the margin determines how close a click must be to register as a hit.

```typescript
new Point2d({
	point: new Vec(50, 50),
	margin: 10, // clicks within 10 units count as hits
})
```

### Group2d

Combines multiple geometries into a single composite geometry. The children don't need to be the same type.

```typescript
new Group2d({
	children: [
		new Rectangle2d({ width: 100, height: 80, isFilled: true }),
		new Circle2d({ x: 50, y: -20, radius: 20, isFilled: true }),
	],
})
```

Group2d is essential for shapes with multiple parts. The geo shape uses it to combine its outline with its label bounds. The arrow shape uses it to combine the arrow body with its label.

## Geometry operations

All Geometry2d classes provide methods for spatial queries.

### Bounds and center

Get the axis-aligned bounding box:

```typescript
const geometry = editor.getShapeGeometry(shape)
const bounds = geometry.bounds // Box { x, y, w, h, ... }
const center = geometry.center // Vec at center of bounds
```

### Vertices

Get the points that define the geometry's outline:

```typescript
const vertices = geometry.vertices // Vec[]
```

For curves, this returns a discretized approximation with enough points to represent the curve accurately.

### Hit testing

Test if a point hits the geometry:

```typescript
geometry.hitTestPoint(point, margin, hitInside)
```

The `margin` expands the hit area. The `hitInside` parameter controls whether points inside unfilled shapes count as hits.

Test if a line segment intersects the geometry:

```typescript
geometry.hitTestLineSegment(A, B, distance)
```

### Distance and intersection

Find the nearest point on the geometry to a given point:

```typescript
const nearest = geometry.nearestPoint(point)
```

Get the distance from a point to the geometry:

```typescript
const distance = geometry.distanceToPoint(point)
```

Negative distances mean the point is inside a filled geometry.

Get intersection points with a line segment:

```typescript
const intersections = geometry.intersectLineSegment(A, B)
```

### Length, area, and interpolation

Get the perimeter length and area:

```typescript
const length = geometry.length // perimeter length
const area = geometry.area // enclosed area (0 for open paths)
```

Find a point at a fraction along the edge:

```typescript
const point = geometry.interpolateAlongEdge(0.5) // midpoint
```

Convert a point back to a fraction:

```typescript
const t = geometry.uninterpolateAlongEdge(point)
```

Generate an SVG path:

```typescript
const pathData = geometry.toSimpleSvgPath() // "M0,0 L100,0 L100,100 L0,100 Z"
```

## Implementing getGeometry

The `getGeometry` method receives the shape and returns geometry in shape-local coordinates (origin at top-left of shape).

### Simple shapes

For shapes with a single outline:

```typescript
getGeometry(shape: MyShape) {
	return new Rectangle2d({
		width: shape.props.w,
		height: shape.props.h,
		isFilled: shape.props.fill !== 'none',
	})
}
```

### Shapes with labels

Shapes that have text labels typically return a Group2d with the main geometry and a label rectangle:

```typescript
getGeometry(shape: MyShape) {
	const outline = new Rectangle2d({
		width: shape.props.w,
		height: shape.props.h,
		isFilled: shape.props.fill !== 'none',
	})

	const label = new Rectangle2d({
		x: labelX,
		y: labelY,
		width: labelWidth,
		height: labelHeight,
		isFilled: true,
		isLabel: true,
	})

	return new Group2d({
		children: [outline, label],
	})
}
```

The `isLabel` property marks geometry that represents text labels. This affects filtering in some operations.

### Custom polygons

For non-rectangular shapes, calculate vertices and use Polygon2d:

```typescript
getGeometry(shape: HouseShape) {
	const { w, h } = shape.props
	const roofPeak = h * 0.3

	return new Polygon2d({
		points: [
			new Vec(0, roofPeak),
			new Vec(w / 2, 0),
			new Vec(w, roofPeak),
			new Vec(w, h),
			new Vec(0, h),
		],
		isFilled: true,
	})
}
```

### Composite shapes

For shapes with multiple distinct parts:

```typescript
getGeometry(shape: HouseShape) {
	const house = new Polygon2d({
		points: getHouseVertices(shape),
		isFilled: true,
	})

	const door = new Rectangle2d({
		x: shape.props.w / 2 - 15,
		y: shape.props.h - 40,
		width: 30,
		height: 40,
		isFilled: true,
	})

	return new Group2d({
		children: [house, door],
	})
}
```

## Geometry caching

The editor caches geometry computations. Without caching, dragging a selection box over hundreds of shapes would recompute each shape's geometry on every frame.

Access cached geometry through the editor:

```typescript
const geometry = editor.getShapeGeometry(shape)
const pageBounds = editor.getShapePageBounds(shape)
```

The cache invalidates automatically when shape props change. You don't need to manage invalidation yourself.

## Geometry filtering

Group2d supports filtering to include or exclude certain geometry children during operations. This lets you mark parts of a shape's geometry for different purposes.

The `isLabel` flag marks geometry that represents text label bounds. Label geometry participates in click-to-edit detection but is typically excluded from outline calculations and snapping.

The `isInternal` flag marks geometry that exists for internal calculations but shouldn't be part of the shape's visible outline.

```typescript
// Mark geometry as a label
new Rectangle2d({
	// ...
	isLabel: true,
})

// Mark geometry as internal (not part of main outline)
new Rectangle2d({
	// ...
	isInternal: true,
})
```

The geometry system provides filter presets for common scenarios:

| Filter                 | Includes labels | Includes internal |
| ---------------------- | --------------- | ----------------- |
| `EXCLUDE_NON_STANDARD` | No              | No                |
| `INCLUDE_ALL`          | Yes             | Yes               |
| `EXCLUDE_LABELS`       | No              | Yes               |
| `EXCLUDE_INTERNAL`     | Yes             | No                |

Most operations use `EXCLUDE_NON_STANDARD` by default, which gives you the shape's main outline without labels or internal geometry.

## Advanced options

Geometry2d has additional options for special cases.

### excludeFromShapeBounds

When set, the geometry won't contribute to the shape's bounding box calculation. The geometry still participates in hit testing and other operations, but `getBoundsVertices()` returns an empty array for it.

```typescript
const label = new Rectangle2d({
	x: labelX,
	y: labelY,
	width: labelWidth,
	height: labelHeight,
	isFilled: true,
	isLabel: true,
	excludeFromShapeBounds: true, // label won't affect shape bounds
})
```

This is useful for labels and other auxiliary geometry that shouldn't change the shape's overall size.

### ignore

When set on geometry inside a Group2d, that geometry is placed in an `ignoredChildren` array and won't participate in the group's operations like hit testing, bounds calculation, or rendering.

```typescript
new Group2d({
	children: [
		mainGeometry,
		new Rectangle2d({
			// ...
			ignore: true, // won't participate in group operations
		}),
	],
})
```

### debugColor

A color string used when rendering geometry in the debug view. Defaults to red if not specified.

```typescript
new Rectangle2d({
	width: 100,
	height: 100,
	isFilled: true,
	debugColor: 'blue', // shows as blue in geometry debugging view
})
```

Enable the geometry debug view through the debug panel to visualize shape geometry during development.

## Transformed geometry

The [`TransformedGeometry2d`](/reference/editor/reference/editor/TransformedGeometry2d) class wraps a geometry with a transformation matrix. This is useful when you need geometry in a different coordinate space without creating new geometry objects.

```typescript
const transformed = geometry.transform(matrix)
```

All operations on the transformed geometry apply the transformation automatically. One limitation: transformed geometry doesn't support `getSvgPathData()`—you'll need to transform the path data yourself if you need it.

## Related examples

- **[Custom shape geometry](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-with-geometry)** - A house-shaped custom shape using Polygon2d and Group2d geometry.
- **[Cubic bezier curve shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/cubic-bezier-shape)** - Interactive bezier curve editing with CubicBezier2d geometry and custom handles.
- **[Custom bounds snapping](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/bounds-snapping-shape)** - Playing card shapes with custom snap geometry so they stack with visible icons.

--------

# Groups

Groups are logical containers that combine multiple shapes into a single selectable unit. Unlike frames, groups have no visual representation—they exist purely to organize shapes. Their geometry is the union of their children's geometries, their bounds update automatically as children change, and they clean themselves up when their contents are deleted. Groups support nesting, allowing hierarchical organization of shapes on the canvas.

## Creating groups

Use `editor.groupShapes()` to combine shapes into a group. Pass an array of shape IDs or shape objects, and the method creates a new group containing those shapes:

```typescript
// Group selected shapes
editor.groupShapes(editor.getSelectedShapeIds())

// Group specific shapes
editor.groupShapes([shapeId1, shapeId2, shapeId3])

// Group with options
editor.groupShapes([shapeId1, shapeId2], {
	groupId: createShapeId('my-group'), // Custom ID for the group
	select: false, // Don't select the group after creation
})
```

Grouping requires at least two shapes. The method does nothing if you pass fewer. Users can also group shapes with Ctrl+G (Cmd+G on Mac).

The new group is positioned at the top-left of the combined bounds of all grouped shapes. Its z-index matches the highest z-index among the grouped shapes, so it appears at the front of the layer stack.

## Ungrouping

Use `editor.ungroupShapes()` to dissolve groups and release their children:

```typescript
// Ungroup selected groups
editor.ungroupShapes(editor.getSelectedShapeIds())

// Ungroup specific groups
editor.ungroupShapes([groupId])

// Ungroup without selecting the released children
editor.ungroupShapes([groupId], { select: false })
```

Ungrouping moves children to the group's parent, preserving their exact page positions and rotations. The layer order is maintained—children appear where the group was in the z-stack. If you pass a mix of groups and non-groups, only the groups are ungrouped; the non-groups remain selected. Users can ungroup with Ctrl+Shift+G (Cmd+Shift+G on Mac).

Ungrouping is not recursive. If a group contains other groups, those inner groups remain intact. Ungroup them separately if needed.

## Focused groups

The editor tracks a **focused group** that defines the current editing scope. When you're focused inside a group, you can select and manipulate the shapes within it. Without focus, clicking a shape inside a group selects the group itself, not the individual shape.

```typescript
// Get the current focused group
const focusedGroup = editor.getFocusedGroup()

// Get the focused group ID (returns page ID if no group is focused)
const focusedId = editor.getFocusedGroupId()

// Focus a specific group
editor.setFocusedGroup(groupId)

// Exit the current focused group
editor.popFocusedGroupId()
```

The editor manages focus automatically based on selection:

- Selecting a shape inside a group focuses that group
- Selecting shapes across multiple groups focuses their common ancestor
- Pressing Escape pops focus one level up (or back to the page)
- Clearing selection keeps the current focus

### Layered selection

Clicking shapes inside groups follows a layered pattern:

1. First click selects the outermost group
2. Second click focuses the group and selects the parent of the target shape (or the shape if directly inside)
3. Further clicks drill down through nested groups

This lets you work at different levels of the hierarchy without keyboard modifiers.

## Nested groups

Groups can contain other groups, creating hierarchies:

```typescript
// Create a nested structure
editor.select(boxA, boxB)
editor.groupShapes(editor.getSelectedShapeIds())
const innerGroupId = editor.getOnlySelectedShapeId()

editor.select(innerGroupId, boxC, boxD)
editor.groupShapes(editor.getSelectedShapeIds())
const outerGroupId = editor.getOnlySelectedShapeId()

// Result:
// outerGroup
// ├── innerGroup
// │   ├── boxA
// │   └── boxB
// ├── boxC
// └── boxD
```

When grouping shapes that already have different parents, the editor finds their common ancestor and creates the group there. This prevents orphaning shapes from their natural hierarchy.

## Automatic cleanup

Groups maintain themselves automatically through the `onChildrenChange` lifecycle hook:

- **Empty groups delete themselves.** If you delete all children of a group, the group is removed.
- **Single-child groups ungroup themselves.** If a group ends up with only one child (after deleting others), it dissolves and reparents that child to the group's parent.

This cleanup happens immediately when children change, so you never end up with degenerate groups.

```typescript
// Start with a group containing boxA and boxB
editor.deleteShapes([boxA])
// Group now has only boxB, so it auto-ungroups
// boxB is now a direct child of the page (or the group's former parent)
```

## Bounds and transforms

Group bounds are computed from their children's geometries. The `Group2d` geometry class aggregates all child geometries for hit testing and bounds calculation:

```typescript
// Get a group's bounds
const bounds = editor.getShapePageBounds(groupId)

// Bounds update automatically when children move
editor.updateShape({ id: childId, x: newX, y: newY })
const updatedBounds = editor.getShapePageBounds(groupId)
```

When you transform a group (move, rotate, resize), all children transform with it. The group's position and rotation are applied to children through the standard parent-child transform composition.

Position preservation works both ways. When you group shapes, their page positions are preserved—only their `parentId` and local coordinates change. When you ungroup, shapes return to their original page positions even if the group was rotated.

## Creating shapes inside groups

When you create new shapes while focused inside a group, those shapes automatically become children of the focused group:

```typescript
// Focus a group by selecting a shape inside it
editor.select(shapeInsideGroup)
// Now getFocusedGroupId() returns the group's ID

// Create a new shape - it becomes a child of the focused group
editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	props: { w: 50, h: 50 },
})
// The new shape's parentId is the focused group
```

If no group is focused, new shapes are created on the current page.

## Limitations

Groups have a few constraints worth knowing about.

Arrows can't bind to groups. The `canBind()` method returns `false` for group shapes, so arrows must bind to individual shapes within the group.

Groups have no visual properties—they're purely structural containers. You can't style a group itself, only its children.

Both grouping and ungrouping require the select tool to be active and in its idle state. The operations won't run while you're in the middle of another interaction.

## Related examples

- **[Layer panel](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/layer-panel)** - Build a hierarchical layer panel that shows shape and group structure with visibility controls.

--------

# Highlighting

Shape highlighting shows visual indicators on shapes to provide feedback during user interactions. The editor tracks two types of highlighting: **hover** (the shape under the pointer) and **hints** (shapes you want to emphasize programmatically).

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					// Highlight specific shapes with a visual indicator
					const shapes = editor.getCurrentPageShapes()
					if (shapes.length > 0) {
						editor.setHintingShapes([shapes[0]])
					}
				}}
			/>
		</div>
	)
}
```

## Hover highlighting

The editor automatically tracks which shape is under the pointer and displays a selection-style indicator around it. This happens during idle states when the pointer moves over the canvas.

### Reading hover state

Use [`Editor.getHoveredShapeId`](/reference/editor/reference/editor/Editor#getHoveredShapeId) or [`Editor.getHoveredShape`](/reference/editor/reference/editor/Editor#getHoveredShape) to check which shape is currently hovered:

```typescript
// Get the hovered shape ID
const hoveredId = editor.getHoveredShapeId()

// Get the full shape object
const hoveredShape = editor.getHoveredShape()

if (hoveredShape) {
	console.log('Hovering over:', hoveredShape.type)
}
```

### Setting hover manually

Use [`Editor.setHoveredShape`](/reference/editor/reference/editor/Editor#setHoveredShape) to override the automatic hover detection:

```typescript
// Set hover by shape or ID
editor.setHoveredShape(myShape)
editor.setHoveredShape(myShape.id)

// Clear hover
editor.setHoveredShape(null)
```

Use this to highlight a shape that isn't directly under the pointer, such as when implementing custom interaction logic.

### Automatic hover detection

The editor's select tool automatically updates hover state as the pointer moves. The hover indicator appears when:

- The editor is idle or editing a shape
- The pointer is over the canvas (not UI elements)
- The input is not coarse (not touch input)
- The editor is not changing styles

Touch devices don't show hover indicators because touch has no hovering concept.

## Hint highlighting

Hints let you highlight multiple shapes programmatically. Unlike hover (single shape, automatic), hints are manually controlled and can include any number of shapes.

### Reading hints

Use [`Editor.getHintingShapeIds`](/reference/editor/reference/editor/Editor#getHintingShapeIds) or [`Editor.getHintingShape`](/reference/editor/reference/editor/Editor#getHintingShape) to get currently hinted shapes:

```typescript
// Get array of hinted shape IDs
const hintedIds = editor.getHintingShapeIds()

// Get array of hinted shape objects
const hintedShapes = editor.getHintingShape()
```

### Setting hints

Use [`Editor.setHintingShapes`](/reference/editor/reference/editor/Editor#setHintingShapes) to highlight shapes:

```typescript
// Highlight shapes by ID or shape object
editor.setHintingShapes([shape1, shape2])
editor.setHintingShapes([shape1.id, shape2.id])

// Clear all hints
editor.setHintingShapes([])
```

Hinted shapes render with a thicker stroke (2.5px) than selected or hovered shapes (1.5px). This makes them stand out when you need to draw attention to specific shapes.

### Common use cases

**Draw attention to shapes during a tutorial:**

```typescript
function highlightNextStep(editor: Editor, shapeId: TLShapeId) {
	editor.setHintingShapes([shapeId])
	// Clear after 3 seconds
	setTimeout(() => {
		editor.setHintingShapes([])
	}, 3000)
}
```

**Show related shapes when one is selected:**

```typescript
editor.sideEffects.registerAfterChangeHandler('instance_page_state', (prev, next) => {
	const selected = next.selectedShapeIds
	if (selected.length === 1) {
		// Find bindings connected to the selected shape
		const bindings = editor.getBindingsToShape(selected[0], 'arrow')
		const connectedShapeIds = bindings.map((b) => b.fromId)
		editor.setHintingShapes(connectedShapeIds)
	} else {
		editor.setHintingShapes([])
	}
})
```

## Visual rendering

Both hover and hint indicators use the same selection color (`--tl-color-selected` CSS variable). The editor renders them using either SVG or canvas depending on the shape's indicator implementation.

| State    | Stroke width | Condition                          |
| -------- | ------------ | ---------------------------------- |
| Selected | 1.5px        | Shape is in selection              |
| Hovered  | 1.5px        | Pointer is over shape (automatic)  |
| Hinted   | 2.5px        | Shape is in hinting array (manual) |

Collaborator selections render at 1.5px with their user color at reduced opacity.

## Page state storage

Hover and hint state are stored in [`TLInstancePageState`](/reference/tlschema/reference/tlschema/TLInstancePageState), which tracks per-page interaction state. Each page maintains its own hover and hint values.

```typescript
const pageState = editor.getCurrentPageState()

pageState.hoveredShapeId // TLShapeId | null
pageState.hintingShapeIds // TLShapeId[]
```

Both properties are ephemeral—they don't persist across sessions or sync between collaborators.

## Related articles

- [Instance state](/sdk-features/instance-state) — Session state including page state
- [Selection](/sdk-features/selection) — Working with selected shapes
- [Cursors](/sdk-features/cursors) — Cursor types and customization

## API reference

| Method                         | Description                            |
| ------------------------------ | -------------------------------------- |
| [`Editor.getHoveredShapeId`](/reference/editor/reference/editor/Editor#getHoveredShapeId)  | Get the ID of the shape under pointer  |
| [`Editor.getHoveredShape`](/reference/editor/reference/editor/Editor#getHoveredShape)    | Get the shape object under pointer     |
| [`Editor.setHoveredShape`](/reference/editor/reference/editor/Editor#setHoveredShape)    | Manually set or clear hover state      |
| [`Editor.getHintingShapeIds`](/reference/editor/reference/editor/Editor#getHintingShapeIds) | Get IDs of shapes with hint indicators |
| [`Editor.getHintingShape`](/reference/editor/reference/editor/Editor#getHintingShape)    | Get shapes with hint indicators        |
| [`Editor.setHintingShapes`](/reference/editor/reference/editor/Editor#setHintingShapes)   | Set shapes to show hint indicators     |

--------

# History (undo/redo)

The editor's history system tracks changes to the [store](/docs/store) and provides undo/redo functionality. Changes are organized into batches separated by marks, which act as stopping points. This lets complex interactions be undone as single atomic operations rather than individual edits.

The history manager captures all user-initiated changes automatically. Multiple rapid changes are compressed into cohesive undo steps, and you can control which changes are recorded using history options.

## How it works

The history manager maintains two stacks: one for undos and one for redos. Each stack contains entries that are either diffs (record changes) or marks (stopping points).

When you modify the store, the history manager captures the change as a diff. Changes accumulate until you create a mark, then the pending changes are flushed to the undo stack as a single entry. This batching prevents every keystroke or mouse movement from becoming a separate undo step.

```typescript
editor.updateShape({ id: myShapeId, type: 'geo', x: 100, y: 100 })
editor.updateShape({ id: myShapeId, type: 'geo', x: 110, y: 100 })
editor.updateShape({ id: myShapeId, type: 'geo', x: 120, y: 100 })
// All three updates are batched together until a mark is created
```

When you undo, the manager reverses all changes back to the previous mark, moves them to the redo stack, and applies the reversed diff atomically. Redo does the inverse.

## Marks and stopping points

Marks define where undo and redo operations stop. Create marks at the start of user interactions so that complex operations can be undone in one step.

```typescript
const markId = editor.markHistoryStoppingPoint('rotate shapes')
editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 4)
// Undoing will return to this mark
```

Each mark has a unique identifier that you can use with [bailToMark](#bailing) or [squashToMark](#squashing). Creating a mark flushes pending changes and clears the redo stack.

## Basic operations

### Undo and redo

Use [`Editor.undo`](/reference/editor/reference/editor/Editor#undo) and [`Editor.redo`](/reference/editor/reference/editor/Editor#redo) to move through history marks.

```typescript
editor.undo() // Reverse to previous mark
editor.redo() // Reapply changes
```

Both methods return the editor instance for chaining.

The [`Editor.canUndo`](/reference/editor/reference/editor/Editor#canUndo) and [`Editor.canRedo`](/reference/editor/reference/editor/Editor#canRedo) properties are reactive, so you can use them to update UI button states automatically:

```typescript
function UndoButton() {
	const editor = useEditor()
	const canUndo = useValue('canUndo', () => editor.canUndo, [editor])
	return (
		<button disabled={!canUndo} onClick={() => editor.undo()}>
			Undo
		</button>
	)
}
```

### Running operations with history options

The [`Editor.run`](/reference/editor/reference/editor/Editor#run) method executes a function while controlling how changes affect history. Use it to make changes that don't pollute the undo stack or that preserve the redo stack for special operations.

```typescript
// Ignore changes (don't add to undo stack)
editor.run(
	() => {
		editor.updateShape({ id: myShapeId, type: 'geo', x: 100 })
	},
	{ history: 'ignore' }
)

// Record but preserve redo stack
editor.run(
	() => {
		editor.updateShape({ id: myShapeId, type: 'geo', x: 100 })
	},
	{ history: 'record-preserveRedoStack' }
)
```

The three history modes are:

| Mode                       | Undo stack | Redo stack |
| -------------------------- | ---------- | ---------- |
| `record`                   | Add        | Clear      |
| `record-preserveRedoStack` | Add        | Keep       |
| `ignore`                   | Skip       | Keep       |

> We use `record-preserveRedoStack` when selecting shapes. This way you can undo, select some shapes, copy them, and then redo back to where you were. The selection goes on the undo stack, but existing redos aren't cleared.

> We use `ignore` for live cursor positions. Showing where collaborators' pointers are doesn't need to be undoable.

## Advanced features

### Bailing

Bailing reverses changes without adding them to the redo stack. The changes are discarded entirely. Use this when canceling an interaction.

```typescript
const markId = editor.markHistoryStoppingPoint('begin drag')
// User drags shapes around
// User presses escape to cancel
editor.bailToMark(markId) // Roll back and discard all changes since mark
```

[`Editor.bail`](/reference/editor/reference/editor/Editor#bail) reverts to the most recent mark. [`Editor.bailToMark`](/reference/editor/reference/editor/Editor#bailToMark) reverts to a specific mark by ID.

> We use bailing while cloning shapes. A user can switch between translating and cloning by pressing or releasing the control modifier key during a drag. When this changes, we bail on the changes since the interaction started, then apply the new mode's changes.

### Squashing

[`Editor.squashToMark`](/reference/editor/reference/editor/Editor#squashToMark) combines all changes since a mark into a single undo step. Intermediate marks are removed. This simplifies the undo experience for complex multi-step operations.

```typescript
const markId = editor.markHistoryStoppingPoint('bump shapes')
editor.nudgeShapes(shapes, { x: 10, y: 0 })
editor.nudgeShapes(shapes, { x: 0, y: 10 })
editor.nudgeShapes(shapes, { x: -5, y: -5 })
editor.squashToMark(markId) // All three nudges become one undo step
```

Squashing doesn't change the current state, only how history is organized.

> We use squashing during image cropping. As the user adjusts the crop, each change is recorded, allowing undo/redo of individual adjustments. When the user finishes cropping and exits this mode, we squash all the intermediate changes into one history entry. A single undo restores the image to its state before cropping began.

### Clearing history

[`Editor.clearHistory`](/reference/editor/reference/editor/Editor#clearHistory) removes all undo and redo entries. Use this when loading new documents or resetting the editor state.

```typescript
editor.loadSnapshot(snapshot)
editor.clearHistory() // Start with clean history
```

## Integration with the store

The history manager listens to [store](/docs/store) changes through a history interceptor. It only captures changes marked with source `'user'`, ignoring internal updates and external synchronization.

Internally, the manager has three states:

| State                        | Captures changes | Clears redo stack |
| ---------------------------- | ---------------- | ----------------- |
| `Recording`                  | Yes              | Yes               |
| `RecordingPreserveRedoStack` | Yes              | No                |
| `Paused`                     | No               | No                |

The `Paused` state is used during undo/redo operations, which prevents them from creating new history entries while they apply diffs.

## Related examples

- [Timeline scrubber](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/timeline-scrubber) - A visual timeline that lets users scrub through document history.
- [Store events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/store-events) - Listen to store changes, which is how the history manager tracks modifications.

--------

# Image export

The export system converts shapes to SVG and raster image formats for download, embedding, or integration with external tools. The editor handles the full pipeline from rendering shapes as SVG to converting those SVGs into PNG, JPEG, or WebP images. Exports are fully self-contained: the editor embeds fonts, inlines styles, and converts media elements to data URLs.

## How it works

Export has two stages: SVG generation and optional raster conversion. The SVG stage renders shapes into a self-contained SVG document, while the raster stage converts that SVG into a bitmap image.

### SVG generation

The editor gathers the shapes to export, calculates their bounding box, creates a React tree representing the SVG, renders it into a temporary DOM element, and processes it to be self-contained.

Each shape defines how it renders to SVG through its [`ShapeUtil`](/reference/editor/reference/editor/ShapeUtil):

- If the shape implements [`ShapeUtil.toSvg`](/reference/editor/reference/editor/ShapeUtil#toSvg) or [`ShapeUtil.toBackgroundSvg`](/reference/editor/reference/editor/ShapeUtil#toBackgroundSvg), those methods generate native SVG elements
- If the shape doesn't implement SVG methods, the editor renders its normal HTML representation inside an SVG `<foreignObject>` element

The temporary render step is necessary because CSS and layout aren't computed until elements are in the document. `<foreignObject>` elements in particular need their styles and content inlined to work when the SVG is extracted.

### Making SVG self-contained

SVG files must be self-contained to work outside the document. The editor processes the rendered SVG to embed all external resources:

**Font embedding**: The `FontEmbedder` traverses document stylesheets to find `@font-face` declarations, fetches font files, converts them to data URLs, and inlines them in the SVG. Text renders identically regardless of what fonts the viewer has installed.

**Style inlining**: The `StyleEmbedder` reads computed styles from every element in `<foreignObject>` sections and applies them as inline styles. This removes reliance on external stylesheets. Pseudo-elements like `::before` and `::after` can't be inlined, so the editor extracts their styles into a `<style>` tag within the SVG.

**Media conversion**: The `embedMedia` function converts images, videos, and canvas elements to embedded formats. Images become data URLs, videos become single-frame images, and canvas elements become images via `toDataURL()`.

### Raster conversion

Once the editor generates the SVG, it can convert it to a raster image. The `getSvgAsImage` function loads the SVG into an `Image` element, draws it to a canvas at the requested resolution, and exports the canvas as a blob.

The `pixelRatio` option controls output resolution. For high-DPI displays, use a pixel ratio of 2 or higher for sharp rendering. The editor automatically clamps dimensions to browser canvas limits to avoid out-of-memory errors.

## Export options

SVG export methods (`getSvgElement`, `getSvgString`) accept [`TLSvgExportOptions`](/reference/editor/reference/editor/TLSvgExportOptions). Raster export methods (`toImage`, `toImageDataUrl`) accept [`TLImageExportOptions`](/reference/editor/reference/editor/TLImageExportOptions), which extends `TLSvgExportOptions` with format-specific options.

**Shared options (all export methods):**

| Option                | Description                                                                                                                                                                                                                     |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `bounds`              | The bounding box in page coordinates to export. If omitted, the editor calculates bounds from the shapes.                                                                                                                       |
| `scale`               | Logical scale multiplier. A scale of 2 doubles the SVG size.                                                                                                                                                                    |
| `pixelRatio`          | For SVG exports, passed to the asset store so it can provide appropriately sized assets. For raster exports, multiplies output dimensions. Defaults to `undefined` for SVG and `2` for raster formats.                          |
| `background`          | Whether to include the background color. If `false`, the export is transparent (for formats that support it).                                                                                                                   |
| `padding`             | Space in pixels around the shape bounds. Defaults to 32. When exporting a single frame, padding is not applied (the frame itself serves as the boundary). When exporting shapes inside an image shape, padding is also skipped. |
| `darkMode`            | Whether to render in dark mode. Defaults to the current theme setting.                                                                                                                                                          |
| `preserveAspectRatio` | The SVG `preserveAspectRatio` attribute.                                                                                                                                                                                        |

**Raster-only options (toImage, toImageDataUrl):**

| Option    | Description                                                                     |
| --------- | ------------------------------------------------------------------------------- |
| `format`  | Output format: `'svg'`, `'png'`, `'jpeg'`, or `'webp'`. Defaults to `'png'`.    |
| `quality` | Compression quality for lossy formats (JPEG, WebP) as a number between 0 and 1. |

## Editor export methods

The [`Editor`](/reference/editor/reference/editor/Editor) class provides four methods for exporting shapes. All methods accept either shape IDs or shape objects, and an empty array exports all shapes on the current page.

### getSvgElement

[`Editor.getSvgElement`](/reference/editor/reference/editor/Editor#getSvgElement) returns the SVG as a DOM element along with its dimensions. Use this when you need to manipulate the SVG programmatically or insert it into the DOM.

```typescript
const result = await editor.getSvgElement(shapes, { scale: 2 })
if (result) {
	document.body.appendChild(result.svg)
}
```

### getSvgString

[`Editor.getSvgString`](/reference/editor/reference/editor/Editor#getSvgString) returns the SVG as a serialized string. Use this for saving to a file or sending to a server.

```typescript
const result = await editor.getSvgString(shapes, { background: true })
if (result) {
	console.log(result.svg) // SVG markup as string
}
```

### toImage

[`Editor.toImage`](/reference/editor/reference/editor/Editor#toImage) returns a blob of the exported image in the specified format. This is the primary method for raster images.

```typescript
const result = await editor.toImage(shapes, {
	format: 'png',
	pixelRatio: 2,
	background: true,
})

// Download the image
const link = document.createElement('a')
link.href = URL.createObjectURL(result.blob)
link.download = 'export.png'
link.click()
```

### toImageDataUrl

[`Editor.toImageDataUrl`](/reference/editor/reference/editor/Editor#toImageDataUrl) returns the exported image as a data URL string. Use this when you need the image as a base64-encoded string, for example to display in an `<img>` element or store in a database.

```typescript
const result = await editor.toImageDataUrl(shapes, { format: 'png' })
const img = document.createElement('img')
img.src = result.url
```

## Error handling

All export methods return `undefined` if the export fails (for example, if there are no shapes to export or if the browser canvas limits are exceeded). Always check the result:

```typescript
const result = await editor.toImage(shapes, { format: 'png' })
if (!result) {
	console.error('Export failed')
	return
}
// result.blob is available
```

The raster conversion automatically clamps dimensions to stay within browser canvas limits, which vary by platform but are typically around 16k x 16k pixels. Very large exports at high pixel ratios may fail if they exceed these limits.

## Related examples

- [Export canvas as image](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/export-canvas-as-image) - Export the entire canvas using [`Editor.toImage`](/reference/editor/reference/editor/Editor#toImage) and download it.
- [Export canvas as image (with settings)](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/export-canvas-settings) - Export with configurable format, scale, background, and other options.
- [Custom shape SVG export](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/toSvg-method-example) - Define how custom shapes render when exported using [`ShapeUtil.toSvg`](/reference/editor/reference/editor/ShapeUtil#toSvg) and [`ShapeUtil.toBackgroundSvg`](/reference/editor/reference/editor/ShapeUtil#toBackgroundSvg).

--------

# Indicators

Indicators are the colored outlines that appear around shapes when they're selected, hovered, or being interacted with. Every shape defines its own indicator through the [`ShapeUtil.indicator`](/reference/editor/reference/editor/ShapeUtil#indicator) method.

## How indicators work

When you hover over or select a shape, tldraw renders an SVG outline that matches the shape's geometry. The indicator is separate from the shape itself—it renders in an overlay layer above the canvas.

Indicators appear in three contexts:

| Context  | When it appears                               | Stroke weight |
| -------- | --------------------------------------------- | ------------- |
| Selected | Shape is in the current selection             | 1.5px         |
| Hovered  | Pointer is over an unselected shape           | 1.5px         |
| Hinting  | Shape is a drop target during drag operations | 2.5px         |

For collaborative editing, indicators also show which shapes other users have selected, using each collaborator's cursor color. Locked shapes never show indicators.

## Defining an indicator

Every [`ShapeUtil`](/reference/editor/reference/editor/ShapeUtil) must implement the `indicator` method. This method returns SVG elements that outline the shape:

```tsx
import { ShapeUtil, TLBaseShape, Rectangle2d, T, RecordProps } from 'tldraw'

type MyShape = TLBaseShape<'myshape', { w: number; h: number }>

class MyShapeUtil extends ShapeUtil<MyShape> {
	static override type = 'myshape' as const
	static override props: RecordProps<MyShape> = {
		w: T.number,
		h: T.number,
	}

	getDefaultProps() {
		return { w: 100, h: 100 }
	}

	getGeometry(shape: MyShape) {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(shape: MyShape) {
		return <div style={{ width: shape.props.w, height: shape.props.h }} />
	}

	indicator(shape: MyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

The indicator method receives the shape and returns SVG elements. You don't need to set stroke color or width—tldraw applies those automatically based on context.

### Common indicator patterns

For rectangular shapes, return a `<rect>`:

```tsx
indicator(shape: MyShape) {
	return <rect width={shape.props.w} height={shape.props.h} />
}
```

For circular shapes, use an ellipse or circle:

```tsx
indicator(shape: MyShape) {
	const { w, h } = shape.props
	return <ellipse cx={w / 2} cy={h / 2} rx={w / 2} ry={h / 2} />
}
```

For complex paths, use the shape's geometry:

```tsx
indicator(shape: MyShape) {
	const path = this.editor.getShapeGeometry(shape).toSvgPathString()
	return <path d={path} />
}
```

### Indicators with labels

Shapes with labels may need to clip the indicator where the label appears. Arrow shapes do this to prevent the indicator from overlapping label text. Return a more complex SVG structure to handle clipping.

## Canvas-based indicators

For performance-critical shapes, you can implement `getIndicatorPath()` to render indicators directly to a canvas instead of using SVG. Canvas rendering performs better with large selections.

```tsx
class MyShapeUtil extends ShapeUtil<MyShape> {
	// Return false to use canvas rendering
	override useLegacyIndicator() {
		return false
	}

	// Return a Path2D for canvas rendering
	override getIndicatorPath(shape: MyShape): Path2D {
		const path = new Path2D()
		path.rect(0, 0, shape.props.w, shape.props.h)
		return path
	}

	// Still required as fallback
	indicator(shape: MyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

When `useLegacyIndicator()` returns `false`, tldraw calls `getIndicatorPath()` instead of `indicator()`. Tldraw strokes the Path2D directly on an overlay canvas.

For shapes that need clipping (like arrows with labels), return an object with additional path information:

```tsx
override getIndicatorPath(shape: MyShape) {
	return {
		path: mainPath,
		clipPath: labelClipPath,
		additionalPaths: [extraPath],
	}
}
```

## Controlling indicator visibility

The [`DefaultShapeIndicators`](/reference/editor/reference/editor/DefaultShapeIndicators) component manages which indicators appear. By default, indicators show for:

- All shapes in the current selection
- The shape under the pointer (when hovering)
- Shapes marked as "hinting" (drop targets during drag operations)

### Show or hide all indicators

Override the `ShapeIndicators` component to control visibility globally:

```tsx
import { Tldraw, DefaultShapeIndicators, TLComponents } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	ShapeIndicators: () => {
		// Hide all indicators
		return <DefaultShapeIndicators hideAll />
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={components} />
		</div>
	)
}
```

Pass `showAll` to always show indicators for every visible shape. Pass `hideAll` to suppress them entirely.

### Custom indicator logic

For custom visibility logic, override `ShapeIndicators` completely:

```tsx
import { Tldraw, TLComponents, useEditor, useEditorComponents, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	ShapeIndicators: () => {
		const editor = useEditor()
		const { ShapeIndicator } = useEditorComponents()

		const shapesToShow = useValue(
			'shapes with indicators',
			() => {
				// Show indicators only for geo shapes
				return editor.getRenderingShapes().filter(({ id }) => {
					const shape = editor.getShape(id)
					return shape?.type === 'geo'
				})
			},
			[editor]
		)

		if (!ShapeIndicator) return null

		return shapesToShow.map(({ id }) => <ShapeIndicator key={id} shapeId={id} />)
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={components} />
		</div>
	)
}
```

## Hinting shapes

Hinting shapes are shapes that receive a highlighted indicator during drag operations. Use [`Editor.setHintingShapes`](/reference/editor/reference/editor/Editor#setHintingShapes) to mark shapes as drop targets:

```tsx
// Highlight a shape as a potential drop target
editor.setHintingShapes([targetShapeId])

// Clear hinting
editor.setHintingShapes([])
```

Hinting indicators render with a thicker stroke (2.5px vs 1.5px) to distinguish them from regular selection.

## Customizing the indicator component

Override `ShapeIndicator` to change how individual indicators render:

```tsx
import { Tldraw, TLComponents, TLShapeIndicatorProps, DefaultShapeIndicator } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	ShapeIndicator: (props: TLShapeIndicatorProps) => {
		// Use a custom color for all indicators
		return <DefaultShapeIndicator {...props} color="red" opacity={0.5} />
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={components} />
		</div>
	)
}
```

The [`TLShapeIndicatorProps`](/reference/editor/reference/editor/TLShapeIndicatorProps) interface includes:

| Prop        | Description                                    |
| ----------- | ---------------------------------------------- |
| `shapeId`   | The shape's ID                                 |
| `userId`    | User ID for collaborator indicators (optional) |
| `color`     | Stroke color (defaults to selection color)     |
| `opacity`   | Opacity from 0 to 1                            |
| `className` | Additional CSS class                           |
| `hidden`    | Whether to hide this indicator                 |

## Related articles

- [Shapes](/sdk-features/shapes) - Learn how to create custom shapes with their own indicators
- [Selection](/sdk-features/selection) - Understand how selection state controls indicator visibility
- [UI components](/sdk-features/ui-components) - Customize canvas components including indicators

## Related examples

- [Custom shape](/examples/shapes/tools/custom-shape) - Create a custom shape with an indicator
- [Custom indicators](/examples/ui/indicators-logic) - Control which shapes show indicators

--------

# Input handling

The `InputsManager` class tracks pointer and keyboard state for the editor. It stores pointer positions in both screen space and page space, tracks pressed keys and buttons, detects device types (mouse, touch, pen), and calculates pointer velocity.

All input state is reactive. The manager stores values as atoms from `@tldraw/state`, so components that read input state automatically update when those values change. The manager updates on every input event, converting coordinates between screen space and page space.

## Pointer position tracking

The manager tracks pointer positions in two coordinate spaces:

- **Screen space**: Pixels relative to the canvas container's origin
- **Page space**: Coordinates in the infinite canvas, adjusted for camera position and zoom

For each space, the manager maintains three position snapshots: current, previous, and origin.

### Current and previous positions

```typescript
editor.inputs.getCurrentScreenPoint() // Current position in screen space
editor.inputs.getCurrentPagePoint() // Current position in page space

editor.inputs.getPreviousScreenPoint() // Previous position in screen space
editor.inputs.getPreviousPagePoint() // Previous position in page space
```

The current position updates on every pointer event. The previous position stores where the pointer was before the most recent update. You can use these together to calculate deltas for dragging and panning:

```typescript
const delta = Vec.Sub(editor.inputs.getCurrentPagePoint(), editor.inputs.getPreviousPagePoint())
```

### Origin positions

The origin position captures where the most recent `pointer_down` event occurred:

```typescript
editor.inputs.getOriginScreenPoint() // Where pointer_down occurred in screen space
editor.inputs.getOriginPagePoint() // Where pointer_down occurred in page space
```

Tools use the origin to calculate drag distances and determine whether an interaction has moved far enough to trigger behaviors like dragging. The origin resets on every `pointer_down` event and when pinch gestures start.

### Coordinate space conversion

The manager converts screen coordinates to page coordinates using the camera's position and zoom:

```typescript
// Screen to page conversion
const pageX = screenX / camera.z - camera.x
const pageY = screenY / camera.z - camera.y
```

## Pointer velocity

The manager tracks pointer velocity for gesture detection:

```typescript
editor.inputs.getPointerVelocity() // Vec with x/y velocity in pixels per millisecond
```

Velocity is calculated on each animation frame tick (not on each pointer event). The `TickManager` calls `updatePointerVelocity()` every frame, calculating the distance traveled since the last tick. The velocity is smoothed by interpolating with the previous value, and very small values (below 0.01) are clamped to zero to prevent jitter.

Tools use velocity to distinguish between slow, precise interactions and fast flick gestures. Velocity resets to zero on `pointer_down` events and when pinch gestures start.

## Input device detection

The manager tracks whether the current input comes from a pen device:

```typescript
editor.inputs.getIsPen() // true for stylus input
```

This enables pen-specific behaviors like pen mode, which ignores non-pen input to prevent accidental touch interactions while using a stylus.

> Many stylus devices identify as 'mouse' rather than 'pen'. We use heuristics to detect these devices and correctly account for pressure.

## Modifier keys and button states

The manager tracks modifier key states:

```typescript
editor.inputs.getShiftKey()
editor.inputs.getAltKey()
editor.inputs.getCtrlKey()
editor.inputs.getMetaKey()
editor.inputs.getAccelKey() // Cmd on Mac, Ctrl elsewhere
```

The `getAccelKey()` method returns true for Command on macOS and Control on other platforms. Use this for cross-platform shortcuts.

### Button tracking

The manager tracks currently pressed pointer buttons in a reactive set:

```typescript
editor.inputs.buttons.has(0) // Primary button (left click)
editor.inputs.buttons.has(1) // Middle button
editor.inputs.buttons.has(2) // Secondary button (right click)
```

Buttons are added on `pointer_down` events and removed on `pointer_up` events.

### Keyboard key tracking

The manager tracks pressed keyboard keys in a reactive set:

```typescript
editor.inputs.keys.has('Space')
editor.inputs.keys.has('ShiftLeft')
```

Keys are added on `key_down` and removed on `key_up`. Tools can use this to detect held keys during pointer operations. For example, the select tool detects when Space is held to temporarily activate the hand tool.

## Interaction state flags

The manager tracks the current interaction state:

```typescript
editor.inputs.getIsPointing() // Pointer button is down
editor.inputs.getIsDragging() // Pointer moved beyond drag threshold while pointing
editor.inputs.getIsPinching() // Two-finger pinch gesture active
editor.inputs.getIsEditing() // Editing text or other content
editor.inputs.getIsPanning() // Panning the canvas
editor.inputs.getIsSpacebarPanning() // Panning via spacebar (vs. other panning modes)
```

The editor sets these flags during event processing. For example, `isPointing` becomes true on `pointer_down` and false on `pointer_up`. The `isDragging` flag becomes true when the pointer moves beyond the drag distance threshold while pointing.

## Event processing flow

When an input event occurs, the editor processes it through these stages:

1. The browser fires a native DOM event
2. The editor's UI layer captures the event and transforms it into a typed event info object
3. For pointer, pinch, and wheel events, the editor calls `updateFromEvent()` on the `InputsManager`
4. For pointer events, the editor dispatches to the `ClickManager` for multi-click detection (double-click, triple-click, etc.)
5. The editor sends the event to the state machine via `root.handleEvent()`
6. The state machine propagates the event through active tool states

The typed event info objects are:

| Event type                 | Info type             |
| -------------------------- | --------------------- |
| Pointer events             | `TLPointerEventInfo`  |
| Click events (multi-click) | `TLClickEventInfo`    |
| Keyboard events            | `TLKeyboardEventInfo` |
| Wheel events               | `TLWheelEventInfo`    |
| Pinch events               | `TLPinchEventInfo`    |

In collaborative sessions, `updateFromEvent()` also updates the user's pointer presence record in the store, broadcasting pointer position to other users.

## Input normalization

The editor normalizes input across different device types. Touch events convert to pointer events, and the manager tracks the device type through the `isPen` flag.

Pointer positions include a z coordinate representing pressure or hover distance, defaulting to 0.5 for devices that don't report pressure. The normalization layer accounts for the canvas container's position in the document, so the editor works correctly in nested layouts and scrolled containers.

## State serialization

The manager provides a `toJson()` method for debugging:

```typescript
const state = editor.inputs.toJson()
// Returns all position vectors, modifier key states, interaction flags,
// device type, and the contents of the keys and buttons sets
```

We use this serialized form when generating crash reports.

## Related examples

- [Reactive inputs](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/reactive-inputs) - Display pointer positions, velocity, and other input state reactively
- [Canvas events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/canvas-events) - Log pointer, keyboard, and wheel events to see the event flow

--------

# Instance state

Instance state is the per-tab state that tracks your current session. It includes which page you're viewing, whether the grid is visible, if debug mode is on, and transient interaction state like the current cursor position. Unlike document state (shapes, pages, assets), instance state belongs to a single browser tab and isn't synced between collaborators.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					// Enable grid mode and debug mode
					editor.updateInstanceState({
						isGridMode: true,
						isDebugMode: true,
					})
				}}
			/>
		</div>
	)
}
```

## Reading instance state

Use [`Editor.getInstanceState`](/reference/editor/reference/editor/Editor#getInstanceState) to access the current instance state. The returned object contains all session properties:

```typescript
const instance = editor.getInstanceState()

// Check modes
instance.isGridMode // true if grid is visible
instance.isDebugMode // true if debug overlays are shown
instance.isFocusMode // true if UI is minimized
instance.isPenMode // true if stylus input detected
instance.isToolLocked // true if tool stays active after creating shapes
instance.isReadonly // true if editing is disabled

// Current state
instance.currentPageId // which page is active
instance.cursor // cursor type and rotation
instance.isFocused // whether the editor has focus

// Screen information
instance.screenBounds // viewport dimensions
instance.devicePixelRatio // display scaling factor
instance.isCoarsePointer // true for touch input
```

The result is reactive. When you access it inside a `track` component or `react` callback, your code re-runs when the state changes:

```tsx
import { track, useEditor } from 'tldraw'

const DebugIndicator = track(function DebugIndicator() {
	const editor = useEditor()
	const { isDebugMode, isGridMode } = editor.getInstanceState()

	return (
		<div>
			Debug: {isDebugMode ? 'on' : 'off'}, Grid: {isGridMode ? 'on' : 'off'}
		</div>
	)
})
```

## Updating instance state

Use [`Editor.updateInstanceState`](/reference/editor/reference/editor/Editor#updateInstanceState) to modify instance properties:

```typescript
// Enable grid mode
editor.updateInstanceState({ isGridMode: true })

// Enable multiple options at once
editor.updateInstanceState({
	isDebugMode: true,
	isToolLocked: true,
})

// Toggle a mode
const { isGridMode } = editor.getInstanceState()
editor.updateInstanceState({ isGridMode: !isGridMode })
```

Changes take effect immediately and persist for the session. When using a `persistenceKey`, some properties persist across sessions (see [Session persistence](#session-persistence) below).

Note that `currentPageId` cannot be changed through `updateInstanceState`. Use [`Editor.setCurrentPage`](/reference/editor/reference/editor/Editor#setCurrentPage) instead.

## Available properties

### Mode flags

These boolean flags control major editor behaviors:

| Property       | Description                                     | Persists |
| -------------- | ----------------------------------------------- | -------- |
| `isGridMode`   | Show grid overlay on the canvas                 | Yes      |
| `isDebugMode`  | Show debug information overlays                 | Yes      |
| `isFocusMode`  | Minimize the UI to just the canvas              | Yes      |
| `isToolLocked` | Keep current tool active after creating a shape | Yes      |
| `isReadonly`   | Prevent all document modifications              | Yes      |
| `isPenMode`    | Track whether stylus input has been detected    | No       |
| `isFocused`    | Whether the editor currently has keyboard focus | Yes      |

### Display state

Properties that track the current display environment:

| Property           | Description                                                   | Persists |
| ------------------ | ------------------------------------------------------------- | -------- |
| `screenBounds`     | Viewport position and dimensions (x, y, w, h)                 | Yes      |
| `devicePixelRatio` | Display scaling factor (e.g., 2 for Retina)                   | Yes      |
| `isCoarsePointer`  | Indicates touch or low-precision input is active              | Yes      |
| `isHoveringCanvas` | Whether pointer is over the canvas (null if no hover support) | No       |
| `insets`           | Safe area insets as `[top, right, bottom, left]` booleans     | Yes      |

### Navigation state

| Property        | Description                      | Persists |
| --------------- | -------------------------------- | -------- |
| `currentPageId` | ID of the currently active page  | No       |
| `openMenus`     | Array of currently open menu IDs | No       |

### Interaction state

Temporary state used during user interactions:

| Property          | Description                                      | Persists |
| ----------------- | ------------------------------------------------ | -------- |
| `cursor`          | Current cursor type and rotation                 | No       |
| `brush`           | Selection brush bounds during drag selection     | No       |
| `zoomBrush`       | Zoom brush bounds during zoom-to-area            | No       |
| `scribbles`       | Active scribble animations (eraser trails, etc.) | No       |
| `isChangingStyle` | True while style picker is active                | No       |

### Shape creation

Settings that affect newly created shapes:

| Property              | Description                         | Persists |
| --------------------- | ----------------------------------- | -------- |
| `opacityForNextShape` | Opacity applied to new shapes (0-1) | No       |
| `stylesForNextShape`  | Style values applied to new shapes  | No       |
| `duplicateProps`      | State for smart duplicate offset    | No       |

### Collaboration

Properties for multiplayer features:

| Property             | Description                                | Persists |
| -------------------- | ------------------------------------------ | -------- |
| `followingUserId`    | ID of user being followed, or null         | No       |
| `highlightedUserIds` | IDs of users whose cursors are highlighted | No       |
| `chatMessage`        | Current chat message being composed        | No       |
| `isChatting`         | Whether chat input is active               | No       |

### Custom data

| Property           | Description                              | Persists |
| ------------------ | ---------------------------------------- | -------- |
| `meta`             | Arbitrary JSON data for your application | No       |
| `exportBackground` | Include background color when exporting  | Yes      |

## Common patterns

### Focus mode

Focus mode hides most of the UI for presentation or distraction-free editing:

```typescript
editor.updateInstanceState({ isFocusMode: true })
```

### Grid mode

Show a grid overlay to help with alignment:

```typescript
editor.updateInstanceState({ isGridMode: true })
```

The grid respects the camera zoom level. You can customize the grid appearance by overriding the `Grid` component.

### Debug mode

Debug mode shows useful overlays including shape bounds, geometry points, and performance information:

```typescript
editor.updateInstanceState({ isDebugMode: true })
```

### Tool lock

When tool lock is enabled, the current tool stays active after creating a shape instead of returning to the select tool:

```typescript
// Enable tool lock
editor.updateInstanceState({ isToolLocked: true })

// Check if locked
if (editor.getInstanceState().isToolLocked) {
	// Tool will stay active after creating shapes
}
```

Custom tools should check this property to decide whether to return to select after completing their action. See [Tools](/sdk-features/tools#tool-lock) for implementation details.

### Cursor customization

Set a custom cursor type and rotation:

```typescript
// Use the setCursor helper
editor.setCursor({ type: 'cross', rotation: 0 })

// Or update directly
editor.updateInstanceState({
	cursor: { type: 'grab', rotation: 0 },
})
```

See [Cursors](/sdk-features/cursors) for the full list of cursor types and rotation handling.

### Detecting touch input

Check `isCoarsePointer` to adapt your UI for touch:

```tsx
const { isCoarsePointer } = editor.getInstanceState()
const buttonSize = isCoarsePointer ? 48 : 32 // Larger touch targets
```

The value updates automatically when the user switches between mouse and touch.

## Session persistence

When you use a `persistenceKey` on the [`Tldraw`](/reference/tldraw/reference/tldraw/Tldraw) component, some instance properties persist across browser sessions. Properties marked "Persists: Yes" in the tables above are saved and restored.

Temporary state like cursor position, selection brushes, and open menus always reset when the page reloads. Navigation state like `currentPageId` doesn't persist because the referenced page might not exist in a fresh session.

## Instance state vs page state

Instance state ([`TLInstance`](/reference/tlschema/reference/tlschema/TLInstance)) is global to the editor—there's one instance record per browser tab. Page state ([`TLInstancePageState`](/reference/tlschema/reference/tlschema/TLInstancePageState)) is per-page and tracks page-specific information like selection:

```typescript
// Instance state: global to the editor
const instance = editor.getInstanceState()
instance.currentPageId // which page is active
instance.isGridMode // applies to all pages

// Page state: specific to the current page
const pageState = editor.getCurrentPageState()
pageState.selectedShapeIds // selection on this page
pageState.editingShapeId // shape being edited on this page
pageState.hoveredShapeId // shape under cursor on this page
```

When you switch pages, the instance's `currentPageId` changes, but each page retains its own selection and editing state.

## Related articles

- [Cursors](/sdk-features/cursors) — Cursor types and rotation handling
- [Readonly mode](/sdk-features/readonly) — Disable editing with `isReadonly`
- [Focus](/sdk-features/focus) — Editor focus state with `isFocused`
- [Tools](/sdk-features/tools#tool-lock) — Tool lock behavior with `isToolLocked`
- [User preferences](/sdk-features/user-preferences) — Global preferences that persist across editor instances

## Related examples

- **[Focus mode](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/focus-mode)** — Enable focus mode to minimize the UI.
- **[Custom grid](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-grid)** — Use `isGridMode` with a custom grid component.
- **[Read-only](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/readonly)** — Disable editing with `isReadonly`.

--------

# Internationalization

Tldraw's UI supports 50 languages out of the box, including right-to-left languages like Arabic, Hebrew, Farsi, and Urdu. The translation system loads language files on demand, detects the user's browser language, and lets you override any translation string or add custom ones.

## Setting the locale

The user's locale is stored in [user preferences](/sdk-features/user-preferences). By default, tldraw detects the browser's language and selects the closest match from supported languages.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					// Change the locale to French
					editor.user.updateUserPreferences({ locale: 'fr' })

					// Get the current locale
					const locale = editor.user.getLocale() // "fr"
				}}
			/>
		</div>
	)
}
```

The `locale` value uses standard language codes: `'en'`, `'fr'`, `'de'`, `'ja'`, `'zh-cn'`, `'ar'`, and so on.

### Automatic detection

When no locale is set, tldraw uses `getDefaultTranslationLocale()` to detect the user's preferred language from the browser:

```ts
import { getDefaultTranslationLocale } from '@tldraw/tlschema'

// Returns 'fr', 'en', 'zh-cn', etc. based on browser settings
const locale = getDefaultTranslationLocale()
```

The detection algorithm:

1. Reads the browser's `navigator.languages` array
2. Tries an exact match against supported languages
3. Falls back to language-only match (e.g., `'fr-CA'` → `'fr'`)
4. Applies region defaults for Chinese (`'zh'` → `'zh-cn'`), Portuguese (`'pt'` → `'pt-br'`), Korean (`'ko'` → `'ko-kr'`), and Hindi (`'hi'` → `'hi-in'`)
5. Defaults to `'en'` if no match is found

## Using translations in components

The `useTranslation` hook returns a function for looking up translation strings:

```tsx
import { useTranslation } from 'tldraw'

function CopyButton() {
	const msg = useTranslation()
	return <button>{msg('action.copy')}</button>
}
```

For access to the full translation object including locale and text direction:

```tsx
import { useCurrentTranslation } from 'tldraw'

function LocaleInfo() {
	const translation = useCurrentTranslation()
	return (
		<div dir={translation.dir}>
			<p>Locale: {translation.locale}</p>
			<p>Label: {translation.label}</p>
		</div>
	)
}
```

The [`TLUiTranslation`](/reference/tldraw/reference/tldraw/TLUiTranslation) object contains a `locale` code (e.g., `'fr'`), a `label` in the native script (e.g., `'Français'`), a `messages` record with all translation strings, and a `dir` indicating text direction (`'ltr'` or `'rtl'`).

## Overriding translations

Pass translation overrides through the `overrides` prop on `Tldraw`:

```tsx
import { Tldraw } from 'tldraw'

function App() {
	return (
		<Tldraw
			overrides={{
				translations: {
					en: {
						'action.copy': 'Copy to clipboard',
						'action.paste': 'Paste from clipboard',
					},
					fr: {
						'action.copy': 'Copier dans le presse-papiers',
					},
				},
			}}
		/>
	)
}
```

Overrides are merged with the base translations for each language. English serves as the fallback—any key missing from the target language uses the English string.

### Translation keys

Translation keys follow a hierarchical naming convention. Common prefixes include `action.*` for user actions like copy and paste, `tool.*` for tool names, `menu.*` for menu labels, `style-panel.*` for style panel UI, and `a11y.*` for accessibility announcements.

The [`TLUiTranslationKey`](/reference/tldraw/reference/tldraw/TLUiTranslationKey) type provides autocomplete for all available keys:

```ts
import type { TLUiTranslationKey } from 'tldraw'

const key: TLUiTranslationKey = 'action.copy'
```

## Supported languages

Import `LANGUAGES` from `@tldraw/tlschema` for the complete list of supported languages:

```tsx
import { LANGUAGES } from '@tldraw/tlschema'

function LanguageSelector() {
	return (
		<select>
			{LANGUAGES.map(({ locale, label }) => (
				<option key={locale} value={locale}>
					{label}
				</option>
			))}
		</select>
	)
}
```

Each entry in `LANGUAGES` has a `locale` code and a `label` in that language's native script.

The supported languages include: English, Spanish, French, German, Italian, Portuguese (Brazilian and European), Dutch, Russian, Polish, Czech, Danish, Finnish, Swedish, Hungarian, Norwegian, Romanian, Turkish, Ukrainian, Greek, Croatian, Slovenian, Arabic, Hebrew, Farsi, Urdu, Hindi, Tamil, Telugu, Malayalam, Kannada, Bengali, Gujarati, Nepali, Marathi, Punjabi, Thai, Khmer, Vietnamese, Indonesian, Malay, Filipino, Somali, Japanese, Korean, Simplified Chinese, Traditional Chinese (Taiwan), Catalan, and Galician.

## Right-to-left support

Languages like Arabic, Hebrew, Farsi, and Urdu automatically set `dir: 'rtl'` in the translation object. The tldraw UI respects this direction, mirroring layout and text alignment.

When building custom UI components, use the `dir` property from the translation context:

```tsx
import { useCurrentTranslation } from 'tldraw'

function CustomPanel() {
	const { dir } = useCurrentTranslation()
	return <aside dir={dir}>{/* Panel content */}</aside>
}
```

## Building a language picker

Here's a language picker that updates the user's locale preference:

```tsx
import { useEditor, useValue } from 'tldraw'
import { LANGUAGES } from '@tldraw/tlschema'

function LanguagePicker() {
	const editor = useEditor()
	const currentLocale = useValue('locale', () => editor.user.getLocale(), [editor])

	return (
		<select
			value={currentLocale}
			onChange={(e) => {
				editor.user.updateUserPreferences({ locale: e.target.value })
			}}
		>
			{LANGUAGES.map(({ locale, label }) => (
				<option key={locale} value={locale}>
					{label}
				</option>
			))}
		</select>
	)
}
```

The language change applies immediately without a page reload. The preference persists to localStorage and synchronizes across browser tabs.

## Translation loading

Translations load asynchronously when the locale changes. The system:

1. Fetches the translation JSON file for the selected locale
2. Merges it with English translations (ensuring all keys have values)
3. Applies any custom overrides
4. Updates the translation context

During loading, the UI uses the previous translations to avoid flicker. If loading fails, English remains as the fallback.

--------

# License key

The tldraw SDK requires a license key to work in production. Without a valid key, the SDK runs in development mode only. License keys unlock production deployment and, depending on your license type, may remove the "made with tldraw" watermark.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw licenseKey="your-license-key" />
		</div>
	)
}
```

## How license keys work

License keys are validated on the client. They can be public—you can safely include them in your frontend code. The SDK decodes and verifies the key locally without making network requests to a license server.

Each key encodes:

- **Allowed hosts**: The domains where the license is valid
- **License type**: Trial, commercial, or hobby
- **Expiration date**: When the license stops working

The SDK determines development vs production by checking the protocol and hostname. HTTPS on a non-localhost domain is considered production; HTTP or localhost is development.

## License types

| Type       | Watermark | Duration | Purpose                           |
| ---------- | --------- | -------- | --------------------------------- |
| Trial      | No        | 100 days | Evaluate before purchasing        |
| Commercial | No        | Annual   | Production use in commercial apps |
| Hobby      | Yes       | Varies   | Non-commercial projects           |

### Trial licenses

Get a free 100-day trial by completing the [trial license form](https://tldraw.dev/get-a-license/trial). You'll receive a license key immediately by email. One trial per company or project.

### Commercial licenses

Request a commercial license through the [plans form](https://tldraw.dev/get-a-license/plans). The sales team will discuss your requirements and pricing. Commercial licenses remove the watermark and are required for any commercial use in production.

### Hobby licenses

For non-commercial projects, request a [hobby license](https://tldraw.dev/get-a-license/hobby). Hobby licenses keep the "made with tldraw" watermark visible. They're discretionary. The team reviews each request.

## Development vs production

In development environments, the SDK works without a license key. It detects development by checking:

- **Protocol**: HTTP (not HTTPS) indicates development
- **Hostname**: `localhost` indicates development
- **Build mode**: `NODE_ENV !== 'production'` indicates development

If any of these conditions are true, you're in development mode and the SDK works normally without a key.

In production (HTTPS on a non-localhost domain with `NODE_ENV=production`), the SDK requires a valid license key. Without one, you'll see console errors about the missing or invalid license.

## Domain validation

License keys specify which domains they work on. The SDK validates the current hostname against the allowed hosts in the key.

Domain matching supports:

- **Exact matches**: `example.com` matches `example.com` and `www.example.com`
- **Wildcards**: `*.example.com` matches any subdomain
- **All domains**: Some enterprise licenses allow `*` for any domain

If you deploy to a domain not covered by your license, the SDK treats it as unlicensed.

## Grace period

Annual and perpetual licenses have a 30-day grace period after expiration. During this period, the SDK continues working but logs warnings to the console. This gives you time to renew without service interruption.

Evaluation (trial) licenses have no grace period—they stop working immediately on expiration.

## Perpetual licenses

Perpetual licenses don't have a time-based expiration. Instead, they're tied to a version: they work with any patch release indefinitely, but major or minor versions released after the license expiration date require renewal.

Early versions of tldraw were sold with a perpetual license. While we no longer sell these licenses (except in exceptional cases), we still support them for existing customers.

## Using the license key

### Automatic environment variable detection

The SDK automatically checks for license keys in common environment variables. If you set one of these, you don't need to pass the `licenseKey` prop:

- `TLDRAW_LICENSE_KEY`
- `NEXT_PUBLIC_TLDRAW_LICENSE_KEY` (Next.js)
- `REACT_APP_TLDRAW_LICENSE_KEY` (Create React App)
- `GATSBY_TLDRAW_LICENSE_KEY` (Gatsby)
- `VITE_TLDRAW_LICENSE_KEY` (Vite)
- `PUBLIC_TLDRAW_LICENSE_KEY` (SvelteKit, etc.)

The SDK checks both `process.env` and `import.meta.env` versions of each variable.

### Passing the key directly

Pass the key to the `licenseKey` prop on `<Tldraw>` or `<TldrawEditor>`:

```tsx
<Tldraw licenseKey="tldraw-abc123..." />
```

For `<TldrawImage>`, the same prop works:

```tsx
<TldrawImage snapshot={snapshot} licenseKey="tldraw-abc123..." />
```

You can also reference an environment variable explicitly:

```tsx
<Tldraw licenseKey={process.env.NEXT_PUBLIC_TLDRAW_LICENSE_KEY} />
```

Since keys are validated client-side and are domain-restricted, exposing them in your bundle is safe.

## Data collection

License behavior differs by type:

| License type | Data sent                                             |
| ------------ | ----------------------------------------------------- |
| Commercial   | None                                                  |
| Hobby        | None                                                  |
| Trial        | License hash and domain (for analytics, no user data) |
| Unlicensed   | Domain tracking for watermark display                 |

Trial licenses send a hashed version of the license key and deployment URL to tldraw's servers for analytics. No user data, canvas content, or personally identifiable information is collected.

## Troubleshooting

**Console shows "No tldraw license key provided" and "A license is required for production deployments"**: You're in production without a key. Add a valid `licenseKey` prop or set an environment variable.

**Console shows "License key is not valid for this domain"**: Your key doesn't include the current domain. Contact sales@tldraw.com to update your allowed domains.

**Console shows "Your tldraw evaluation license has expired"**: Trial licenses have no grace period. Contact sales@tldraw.com to purchase a full license.

**Console shows "Your tldraw license has been expired for more than 30 days"**: Your license is past the 30-day grace period. Contact sales@tldraw.com to renew.

**Key works locally but not in production**: Development mode doesn't require a key. Make sure you're passing the key correctly in your production build and that the domain matches your license.

## Learn more

See the [License](/community/license) page for full details on the tldraw license terms, including information about open source usage and trademark guidelines.

--------

# Locked shapes

Locked shapes can't be selected, moved, resized, edited, or deleted through normal interactions. Lock a shape when you want it to stay exactly where it is: background elements, reference images, or layout guides that shouldn't move while you work on other parts of the canvas.

## The isLocked property

Every [shape](/docs/shapes) has an `isLocked` boolean property. When `true`, the shape is protected from most modifications:

```typescript
// Create a locked shape
editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	isLocked: true,
	props: { w: 200, h: 150, geo: 'rectangle' },
})

// Check if a shape is locked
const shape = editor.getShape(shapeId)
if (shape.isLocked) {
	// Shape is locked
}
```

## Toggling lock state

Use [`Editor.toggleLock`](/reference/editor/reference/editor/Editor#toggleLock) to flip the lock state of shapes. If shapes have mixed lock states, they all become locked:

```typescript
// Lock selected shapes
editor.toggleLock(editor.getSelectedShapeIds())

// Lock specific shapes by ID
editor.toggleLock([shapeId1, shapeId2])
```

When you lock shapes that were all previously unlocked, they automatically deselect. This prevents accidentally manipulating them while they're protected.

## What locking prevents

Locked shapes resist most operations:

| Operation    | Behavior                                                                                                 |
| ------------ | -------------------------------------------------------------------------------------------------------- |
| Selection    | Clicking a locked shape doesn't select it. Brush selection and [`Editor.selectAll`](/reference/editor/reference/editor/Editor#selectAll) skip locked shapes. |
| Movement     | Pointer drags pass through locked shapes to the canvas.                                                  |
| Modification | [`Editor.updateShape`](/reference/editor/reference/editor/Editor#updateShape) calls on locked shapes are ignored.                                              |
| Deletion     | [`Editor.deleteShapes`](/reference/editor/reference/editor/Editor#deleteShapes) skips locked shapes.                                                            |
| Grouping     | Locked shapes can't be added to groups.                                                                  |
| Editing      | Double-clicking a locked shape doesn't enter edit mode.                                                  |

## Ancestor locking

Lock state inherits through the shape hierarchy. If a shape's ancestor is locked, the shape behaves as locked too. Check this with [`Editor.isShapeOrAncestorLocked`](/reference/editor/reference/editor/Editor#isShapeOrAncestorLocked):

```typescript
// True if the shape or any of its parents is locked
const isProtected = editor.isShapeOrAncestorLocked(shape)
```

Locking a frame or group protects all its children without needing to lock each shape individually.

## Bypassing locks programmatically

Sometimes you need to modify locked shapes from code: migrations, admin tools, or automated operations. Wrap your operations in [`Editor.run`](/reference/editor/reference/editor/Editor#run) with `ignoreShapeLock: true`:

```typescript
editor.run(
	() => {
		// These operations affect locked shapes
		editor.updateShape({ id: lockedShapeId, type: 'geo', x: 200 })
		editor.deleteShapes([lockedShapeId])
	},
	{ ignoreShapeLock: true }
)
```

This bypasses the lock check for all operations inside the callback. Use it carefully since the lock exists to protect shapes from unintended changes.

Even with `ignoreShapeLock: true`, some behaviors remain unchanged: locked shapes still can't be selected by clicking, pointer events still pass through to the canvas, and `selectAll()` still skips locked shapes. The flag affects store operations (create, update, delete), not the selection and interaction model.

## Shapes that can be edited while locked

Some shapes have interactive content that should remain usable even when locked. Embed shapes (YouTube videos, Figma files, interactive maps) are a good example: you might want the embed locked in place but still playable or navigable.

[ShapeUtils](/docs/shapes#shapeutils) can override [`ShapeUtil.canEditWhileLocked`](/reference/editor/reference/editor/ShapeUtil#canEditWhileLocked) to allow editing interactions on locked shapes:

```typescript
class MyInteractiveShapeUtil extends ShapeUtil<MyShape> {
	override canEditWhileLocked(shape: MyShape): boolean {
		return true
	}
}
```

When this returns `true`, double-clicking the locked shape enters edit mode, letting users interact with the shape's content without being able to move or resize it.

## Locking in the UI

In the default tldraw UI, users can lock shapes through the context menu or the keyboard shortcut (`Shift+L`). Locked shapes display a lock indicator when hovered, and the context menu shows an unlock option.

--------

# Note shape

The note shape is one of the default shapes in tldraw. It renders as a sticky note with a colored background and text content. Notes have special interaction behaviors that make them ideal for brainstorming and clustering ideas: you can quickly spawn new notes adjacent to existing ones using clone handles or keyboard shortcuts.

```tsx
import { toRichText } from 'tldraw'

editor.createShape({
	type: 'note',
	x: 100,
	y: 100,
	props: {
		color: 'yellow',
		labelColor: 'black',
		richText: toRichText('My note'),
		size: 'm',
		font: 'draw',
		align: 'middle',
		verticalAlign: 'middle',
	},
})
```

## Sizing behavior

Notes have a fixed base width of 200 pixels. Unlike most shapes, you can't manually resize a note by default. Instead, notes automatically grow vertically to fit their text content. The `growY` property tracks how much extra height the note needs beyond its base size.

When text is too wide, the note shrinks the font size (down to a minimum of 14px) before allowing text to wrap. This keeps notes compact without hiding content.

## Clone handles

Notes display clone handles on their edges—small plus buttons at the top, right, bottom, and left sides. These handles let you quickly create adjacent notes.

**Click a clone handle** to either:

- Create a new note in that direction, or
- If a note already exists there, select it and start editing

**Drag a clone handle** to create a new note and immediately begin moving it. When you release, the new note enters edit mode. Spawn notes and position them freely.

Clone handles only appear when the note is selected and the zoom level is high enough. At very low zoom levels (below 25%), handles are hidden entirely. Between 25-50% zoom, only the bottom handle appears to reduce visual clutter.

```tsx
// Clone handles are returned by getHandles on the note shape
const handles = editor.getShapeHandles(noteShape)
// Each handle has type: 'clone' and an id like 'top', 'right', 'bottom', 'left'
```

## Adjacent snapping

When you create a new note with the note tool, tldraw checks if you're clicking near an "adjacent position"—an empty slot next to an existing note. If you're within 10 pixels of one of these slots, the new note snaps into place with consistent spacing.

This snapping only works between notes with the same rotation and scale. The spacing between adjacent notes uses `editor.options.adjacentShapeMargin` (10 pixels by default).

## Keyboard navigation

When editing a note, you can use keyboard shortcuts to create adjacent notes:

| Shortcut            | Action                      |
| ------------------- | --------------------------- |
| **Tab**             | Create or select note right |
| **Shift+Tab**       | Create or select note left  |
| **Cmd/Ctrl+Enter**  | Create or select note below |
| **Shift+Cmd+Enter** | Create or select note above |

These shortcuts respect the current note's rotation. They also handle right-to-left text: in RTL content, Tab moves left instead of right.

When moving down, the keyboard shortcut accounts for the current note's `growY`. This keeps notes from overlapping when one note has grown taller than the base size.

## Visual appearance

Notes render with a subtle drop shadow that varies based on the shape's ID. Each note has slightly different lift and rotation. The shadow responds to the note's rotation on the canvas.

In dark mode, shadows are replaced with a simple bottom border since shadows don't render well against dark backgrounds. Shadows are also hidden when zoomed out below 25% to improve performance.

The note's text color is determined by its `labelColor` property. When set to `'black'` (the default), the note uses a color that contrasts well with the background. Other label colors override this automatic selection.

## Properties

| Property             | Type                            | Description                                                 |
| -------------------- | ------------------------------- | ----------------------------------------------------------- |
| `color`              | `TLDefaultColorStyle`           | Background color of the note                                |
| `labelColor`         | `TLDefaultColorStyle`           | Text color (independent of background)                      |
| `richText`           | `TLRichText`                    | Note content with formatting                                |
| `size`               | `TLDefaultSizeStyle`            | Size preset (`s`, `m`, `l`, `xl`) affecting base font       |
| `font`               | `TLDefaultFontStyle`            | Font family (`draw`, `sans`, `serif`, `mono`)               |
| `align`              | `TLDefaultHorizontalAlignStyle` | Horizontal text alignment                                   |
| `verticalAlign`      | `TLDefaultVerticalAlignStyle`   | Vertical text alignment                                     |
| `fontSizeAdjustment` | `number`                        | Runtime font size (set automatically based on content)      |
| `growY`              | `number`                        | Additional height beyond the base 200px (set automatically) |
| `url`                | `string`                        | Optional hyperlink URL                                      |
| `scale`              | `number`                        | Scale factor applied to the shape                           |

## Configuration

Notes support one configuration option:

| Option       | Type                  | Default  | Description                                                       |
| ------------ | --------------------- | -------- | ----------------------------------------------------------------- |
| `resizeMode` | `'none'` \| `'scale'` | `'none'` | How the note resizes. Set to `'scale'` for manual resize handles. |

By default, notes can't be manually resized—they only grow based on text content. To allow user resizing with locked aspect ratio:

```tsx
import { Tldraw, NoteShapeUtil } from 'tldraw'
import 'tldraw/tldraw.css'

const ConfiguredNoteUtil = NoteShapeUtil.configure({
	resizeMode: 'scale',
})

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw shapeUtils={[ConfiguredNoteUtil]} />
		</div>
	)
}
```

## Dynamic resize mode

When `editor.user.getIsDynamicResizeMode()` is true, new notes are created at a scale inversely proportional to the current zoom level. Notes stay visually consistent regardless of zoom level when created.

```tsx
// If dynamic resize mode is on and zoom is 2x, new notes get scale: 0.5
// If zoom is 0.5x, new notes get scale: 2
const scale = editor.user.getIsDynamicResizeMode() ? 1 / editor.getZoomLevel() : 1
```

--------

# Options

The tldraw editor accepts two kinds of configuration: **editor options** for core behavior (timing, limits, performance) and **component props** for features like persistence and custom shapes. Editor options are immutable after initialization; component props configure how the editor sets up.

## Editor options

The `options` prop accepts a `Partial<TldrawOptions>` object that configures core editor behavior: limits like maximum pages and shapes, timing for interactions and animations, sizing for handles and hit testing, and feature toggles.

Options are set once when the editor initializes and cannot change afterward. Pass a partial options object to override specific values; everything else uses sensible defaults.

```tsx
import { Tldraw, TldrawOptions } from 'tldraw'

const options: Partial<TldrawOptions> = {
	maxPages: 3,
	maxShapesPerPage: 1000,
}

function App() {
	return <Tldraw options={options} />
}
```

The `TldrawOptions` type defines all available options. Since you typically only need to customize a few values, pass `Partial<TldrawOptions>` to override specific options while accepting defaults for the rest.

## Reading options at runtime

After the editor initializes, access options through `editor.options`:

```typescript
const maxPages = editor.options.maxPages
const animationDuration = editor.options.animationMediumMs
```

The options object is readonly. Attempting to modify it has no effect and TypeScript will flag the error.

## Editor option categories

### Limits

Control maximum quantities to prevent performance issues or enforce business rules:

| Option             | Default | Description                         |
| ------------------ | ------- | ----------------------------------- |
| `maxShapesPerPage` | 4000    | Maximum shapes allowed on one page  |
| `maxPages`         | 40      | Maximum pages in a document         |
| `maxFilesAtOnce`   | 100     | Maximum files to handle in one drop |

Setting `maxPages` to 1 effectively disables multi-page functionality and removes the page menu from the UI.

### Interaction timing

Configure how the editor interprets user input timing:

| Option                  | Default | Description                                       |
| ----------------------- | ------- | ------------------------------------------------- |
| `doubleClickDurationMs` | 450     | Maximum interval for double-click detection       |
| `multiClickDurationMs`  | 200     | Maximum interval for triple/quadruple click       |
| `longPressDurationMs`   | 500     | Duration to trigger long press                    |
| `animationMediumMs`     | 320     | Duration for camera animations (zoom, pan to fit) |

### Drag detection

Control when pointer movement becomes a drag operation:

| Option                        | Default | Description                              |
| ----------------------------- | ------- | ---------------------------------------- |
| `dragDistanceSquared`         | 16      | Distance² threshold for mouse drag (4px) |
| `coarseDragDistanceSquared`   | 36      | Distance² threshold for touch drag (6px) |
| `uiDragDistanceSquared`       | 16      | Distance² for UI element drag (4px)      |
| `uiCoarseDragDistanceSquared` | 625     | Distance² for touch UI drag (25px)       |

Values are squared to avoid computing square roots during hit testing. The larger touch thresholds prevent accidental drags on mobile devices.

### Handle and hit testing

Configure selection handles and click target areas:

| Option               | Default | Description                                   |
| -------------------- | ------- | --------------------------------------------- |
| `handleRadius`       | 12      | Radius of selection handles                   |
| `coarseHandleRadius` | 20      | Handle radius for touch input                 |
| `coarsePointerWidth` | 12      | Expanded pointer size for touch               |
| `hitTestMargin`      | 8       | Additional margin around shapes for hit tests |

### Edge scrolling

Configure auto-scroll behavior when dragging near viewport edges:

| Option                   | Default | Description                              |
| ------------------------ | ------- | ---------------------------------------- |
| `edgeScrollDelay`        | 200     | Milliseconds before scroll starts        |
| `edgeScrollEaseDuration` | 200     | Milliseconds to accelerate to full speed |
| `edgeScrollSpeed`        | 25      | Base scroll speed in pixels per tick     |
| `edgeScrollDistance`     | 8       | Width of the edge scroll trigger zone    |

See [Edge scrolling](./edge-scrolling.mdx) for details on how these options affect behavior.

### Camera

Control camera movement and viewport behavior:

| Option                    | Default | Description                                       |
| ------------------------- | ------- | ------------------------------------------------- |
| `cameraSlideFriction`     | 0.09    | Friction applied to camera momentum               |
| `cameraMovingTimeoutMs`   | 64      | Time before camera is considered stopped          |
| `followChaseViewportSnap` | 2       | Snap threshold when following collaborators       |
| `spacebarPanning`         | true    | Enable spacebar to activate pan mode              |
| `zoomToFitPadding`        | 128     | Padding around content when zooming to fit bounds |

### Snapping

| Option          | Default | Description                                  |
| --------------- | ------- | -------------------------------------------- |
| `snapThreshold` | 8       | Distance in pixels at which snapping engages |

### Collaboration

Configure timing for collaborator presence:

| Option                          | Default | Description                               |
| ------------------------------- | ------- | ----------------------------------------- |
| `collaboratorInactiveTimeoutMs` | 60000   | Time before collaborator marked inactive  |
| `collaboratorIdleTimeoutMs`     | 3000    | Time before collaborator marked idle      |
| `collaboratorCheckIntervalMs`   | 1200    | Interval for checking collaborator status |

### Export

Configure image and SVG export behavior:

| Option                      | Default  | Description                              |
| --------------------------- | -------- | ---------------------------------------- |
| `defaultSvgPadding`         | 32       | Padding around exported SVG content      |
| `maxExportDelayMs`          | 5000     | Maximum wait time for export completion  |
| `flattenImageBoundsExpand`  | 64       | Expansion when flattening images         |
| `flattenImageBoundsPadding` | 16       | Padding when flattening images           |
| `exportProvider`            | Fragment | React provider wrapping exported content |

The `exportProvider` option wraps exported content in a React component. Use this when your custom shapes depend on context providers that must be present during rendering:

```tsx
const options: Partial<TldrawOptions> = {
	exportProvider: ({ children }) => <ThemeProvider theme={myTheme}>{children}</ThemeProvider>,
}
```

### Grid

Configure the alignment grid:

```typescript
gridSteps: [
	{ min: -1, mid: 0.15, step: 64 },
	{ min: 0.05, mid: 0.375, step: 16 },
	{ min: 0.15, mid: 1, step: 4 },
	{ min: 0.7, mid: 2.5, step: 1 },
]
```

Each entry defines a grid step size based on zoom level. The `min` and `mid` values define the zoom range where the `step` applies. At lower zoom levels, larger grid steps are used; at higher zoom levels, finer grid steps appear.

### Performance

Options that affect rendering performance:

| Option                       | Default  | Description                              |
| ---------------------------- | -------- | ---------------------------------------- |
| `debouncedZoom`              | true     | Use cached zoom while camera is moving   |
| `debouncedZoomThreshold`     | 500      | Shape count threshold for debounced zoom |
| `maxFontsToLoadBeforeRender` | Infinity | Fonts to load before showing canvas      |
| `textShadowLod`              | 0.35     | Zoom threshold for text shadow rendering |

When `debouncedZoom` is enabled and the page has more shapes than `debouncedZoomThreshold`, the editor returns a cached zoom level during camera movement. This reduces re-renders of complex documents.

### UI and features

| Option                           | Default   | Description                                    |
| -------------------------------- | --------- | ---------------------------------------------- |
| `createTextOnCanvasDoubleClick`  | true      | Create text shape on empty canvas double-click |
| `enableToolbarKeyboardShortcuts` | true      | Enable number keys (1-9) for toolbar items     |
| `actionShortcutsLocation`        | 'swap'    | Where to show keyboard shortcuts in menus      |
| `tooltipDelayMs`                 | 700       | Delay before showing tooltips                  |
| `laserDelayMs`                   | 1200      | Duration laser pointer remains visible         |
| `branding`                       | undefined | App name for accessibility labels              |
| `nonce`                          | undefined | CSP nonce for inline styles                    |

The `actionShortcutsLocation` option controls where keyboard shortcuts appear:

- `'menu'` - Show shortcuts in menu items only
- `'toolbar'` - Show shortcuts in toolbar tooltips only
- `'swap'` - Show in menus when toolbar is collapsed, toolbar when expanded

### Asset handling

| Option                            | Default | Description                                       |
| --------------------------------- | ------- | ------------------------------------------------- |
| `temporaryAssetPreviewLifetimeMs` | 180000  | How long temporary asset previews persist (3 min) |
| `adjacentShapeMargin`             | 10      | Margin between auto-positioned shapes             |

## Default values

The `defaultTldrawOptions` export provides all default values:

```typescript
import { defaultTldrawOptions } from 'tldraw'

console.log(defaultTldrawOptions.maxPages) // 40
```

Use this to check defaults or spread into your own options:

```typescript
const options: Partial<TldrawOptions> = {
	...defaultTldrawOptions,
	maxPages: 10,
}
```

## Tldraw component props

The `<Tldraw>` component accepts additional props beyond those available on `<TldrawEditor>`. These props configure the UI layer, external content handling, and other features that the full SDK provides.

### UI configuration

| Prop          | Type                    | Description                                        |
| ------------- | ----------------------- | -------------------------------------------------- |
| `hideUi`      | `boolean`               | Hide all UI elements, showing only the canvas      |
| `forceMobile` | `boolean`               | Force mobile breakpoints regardless of screen size |
| `overrides`   | `TLUiOverrides`         | Override actions, tools, and translations          |
| `onUiEvent`   | `TLUiEventHandler`      | Callback for UI interaction events                 |
| `components`  | `TLComponents`          | Override or disable UI and canvas components       |
| `assetUrls`   | `TLUiAssetUrlOverrides` | Custom URLs for fonts, icons, and other UI assets  |

The `hideUi` prop is useful when building custom interfaces around the canvas:

```tsx
function CustomEditor() {
	return (
		<Tldraw hideUi>
			<MyCustomToolbar />
		</Tldraw>
	)
}
```

### External content handling

These props control how the editor handles dropped or pasted files:

| Prop                     | Default                         | Description                                             |
| ------------------------ | ------------------------------- | ------------------------------------------------------- |
| `maxImageDimension`      | 5000                            | Maximum width/height for images (larger images resized) |
| `maxAssetSize`           | 10485760                        | Maximum file size in bytes (10 MB)                      |
| `acceptedImageMimeTypes` | `DEFAULT_SUPPORTED_IMAGE_TYPES` | Allowed image MIME types                                |
| `acceptedVideoMimeTypes` | `DEFAULT_SUPPORT_VIDEO_TYPES`   | Allowed video MIME types                                |

```tsx
function App() {
	return (
		<Tldraw
			maxImageDimension={2000}
			maxAssetSize={5 * 1024 * 1024} // 5 MB
			acceptedImageMimeTypes={['image/png', 'image/jpeg']}
		/>
	)
}
```

### Embeds

The `embeds` prop customizes which embed types the editor recognizes:

```tsx
import { Tldraw, TLEmbedDefinition } from 'tldraw'

const customEmbeds: TLEmbedDefinition[] = [
	{
		type: 'custom-video',
		title: 'Custom Video',
		hostnames: ['videos.example.com'],
		width: 560,
		height: 315,
		doesResize: true,
		toEmbedUrl: (url) => url.replace('/watch/', '/embed/'),
		fromEmbedUrl: (url) => url.replace('/embed/', '/watch/'),
	},
]

function App() {
	return <Tldraw embeds={customEmbeds} />
}
```

### Editor setup

These props configure how the editor initializes:

| Prop                 | Type                                                    | Description                                 |
| -------------------- | ------------------------------------------------------- | ------------------------------------------- |
| `autoFocus`          | `boolean`                                               | Automatically focus the editor on mount     |
| `initialState`       | `string`                                                | Initial tool state (defaults to `'select'`) |
| `shapeUtils`         | `TLShapeUtilConstructor[]`                              | Custom shape utilities                      |
| `bindingUtils`       | `TLBindingUtilConstructor[]`                            | Custom binding utilities                    |
| `tools`              | `TLStateNodeConstructor[]`                              | Custom tools                                |
| `onMount`            | `TLOnMountHandler`                                      | Callback when editor mounts                 |
| `cameraOptions`      | `Partial<TLCameraOptions>`                              | Camera constraints and behavior             |
| `textOptions`        | `TLTextOptions`                                         | Rich text editor configuration              |
| `deepLinks`          | `true \| TLDeepLinkOptions`                             | Sync camera state with URL                  |
| `getShapeVisibility` | `(shape, editor) => 'visible' \| 'hidden' \| 'inherit'` | Conditionally hide shapes                   |
| `user`               | `TLUser`                                                | Current user information                    |
| `inferDarkMode`      | `boolean`                                               | Infer dark mode from OS preference          |
| `licenseKey`         | `string`                                                | License key to remove watermark             |

The `getShapeVisibility` callback lets you conditionally hide shapes based on their properties:

```tsx
<Tldraw
	getShapeVisibility={(shape, editor) => {
		// Hide shapes marked as hidden in meta
		if (shape.meta.hidden) return 'hidden'
		// Force-show shapes regardless of parent visibility
		if (shape.meta.alwaysVisible) return 'visible'
		// Default: visible unless parent is hidden
		return 'inherit'
	}}
/>
```

### Store configuration

When not providing your own store, these props configure automatic store creation:

| Prop             | Type                  | Description                                           |
| ---------------- | --------------------- | ----------------------------------------------------- |
| `persistenceKey` | `string`              | Key for IndexedDB persistence (enables local storage) |
| `sessionId`      | `string`              | Session identifier for persistence                    |
| `snapshot`       | `TLEditorSnapshot`    | Initial document state                                |
| `migrations`     | `MigrationSequence[]` | Additional migrations for custom schemas              |

```tsx
function App() {
	return <Tldraw persistenceKey="my-document" snapshot={savedSnapshot} />
}
```

Alternatively, provide your own store with the `store` prop for full control over data management.

## Examples

- **[Editor options](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-options)** - Override default options like max pages and animation speed.
- **[Disable pages](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/disable-pages)** - Set `maxPages` to 1 to create a single-page editor.

--------

# Pages

The pages system provides multiple independent sub-documents within a single tldraw document. Each page acts as a separate scene graph root with its own shapes, camera position, and selection state.

When you switch pages, the editor preserves your camera position and selected shapes on the previous page and restores the state you left on the new page. The page system integrates with collaboration, letting users see which pages their collaborators are viewing and follow them across page boundaries.

## How it works

Each page is a record in the store with a unique ID, a name for display, and an index for ordering. Pages belong to the document scope, meaning they persist across sessions and sync in collaborative environments. When you create a page, the editor automatically creates associated records for the camera position and instance page state.

The camera record associated with a page tracks viewport position and zoom for that page only. The editor's current camera is based on the current page: when you navigate to a different page, the editor automatically switches to the camera for that page. This per-page camera state lets each user maintain their own view of each page, independent of other users and other pages.

The instance page state record tracks selection, editing state, focused groups, and other transient UI state unique to both a page and a browser session. This state belongs to the session scope, meaning it doesn't sync in collaborative environments. Each user maintains their own instance page state for each page they visit.

Pages are ordered. As with shapes, the page record's `index` property determines its order among other pages.

## Page methods

### Access

Get the current page or page ID:

```typescript
const currentPage = editor.getCurrentPage()
const currentPageId = editor.getCurrentPageId()
```

Access any page by ID:

```typescript
import { TLPageId } from 'tldraw'

const page = editor.getPage('page:page1' as TLPageId)
const allPages = editor.getPages()
```

### Navigation

Switch to a different page using `setCurrentPage()`:

```typescript
editor.setCurrentPage('page:page2' as TLPageId)
```

When switching pages, the editor completes any in-progress interactions and stops following other users. The camera constraints are reapplied to ensure the new page's camera respects its configured bounds.

### Creating and deleting pages

Create new pages with `createPage()`, which ensures unique page names and proper index ordering:

```typescript
editor.createPage({ name: 'Wireframes' })
```

The editor enforces a maximum page count through the `maxPages` option (default: 40). Attempts to create pages beyond this limit are ignored. Set `maxPages` to 1 to disable multi-page UI entirely.

Delete pages with `deletePage()`:

```typescript
editor.deletePage('page:page1' as TLPageId)
```

When deleting the current page, the editor switches to an adjacent page automatically. The last remaining page cannot be deleted. When a page is deleted, all shapes on that page are removed and the associated camera and instance page state records are cleaned up.

### Duplicating pages

Duplicate an entire page including all its shapes and camera position:

```typescript
editor.duplicatePage('page:main' as TLPageId)
```

The duplicated page receives a copy of all shapes from the source page, preserving their positions, properties, and bindings between copied shapes. The camera position is copied from the source page. The new page's name appends " Copy" to the original page name.

### Renaming and updating pages

Rename a page with `renamePage()`:

```typescript
editor.renamePage('page:page1' as TLPageId, 'New Name')
```

For more complex updates like changing metadata, use `updatePage()`:

```typescript
editor.updatePage({ id: 'page:page1' as TLPageId, name: 'Updated Name' })
```

## Working with shapes across pages

### Page-specific shape queries

Each page maintains its own shape hierarchy. Get shapes on the current page:

```typescript
const shapes = editor.getCurrentPageShapes()
const shapeIds = editor.getCurrentPageShapeIds()
```

Get shapes from any page:

```typescript
const pageShapeIds = editor.getPageShapeIds('page:page2' as TLPageId)
```

These queries return only the top-level and nested shapes that belong to the specified page. Shapes are parented to pages through their `parentId` field.

### Moving shapes between pages

Transfer shapes from one page to another using `moveShapesToPage()`:

```typescript
import { TLShapeId } from 'tldraw'

editor.moveShapesToPage(
	['shape:rect1' as TLShapeId, 'shape:circle2' as TLShapeId],
	'page:page2' as TLPageId
)
```

The operation copies the shapes to the destination page at the same position and then removes them from the source page. Bindings between moved shapes are preserved, but bindings to shapes not being moved are removed and receive isolation callbacks. The editor enforces per-page shape limits through the `maxShapesPerPage` option.

## Collaboration and pages

In collaborative sessions, each user's current page is tracked through the presence system. The editor provides methods to see which pages collaborators are viewing:

```typescript
const collaboratorsOnThisPage = editor.getCollaboratorsOnCurrentPage()
```

When following the viewport of a user who switches pages, your editor switches pages automatically to maintain the follow relationship. See [User following](/docs/user-following) for details on cross-page following behavior.

## Integration with other systems

The pages system interacts with several editor features.

In collaborative sessions, if a collaborator deletes a page you're viewing, the editor automatically moves you to the next available page.

Each page has its own camera record, preserving zoom and position independently. Camera constraints and options apply per-page.

Bindings can only connect shapes on the same page. When shapes move to different pages, their bindings are automatically removed.

Undo and redo operations are document-wide, not page-specific. Undoing a page creation removes the page and all its shapes.

URLs can encode specific page IDs with the deep links API, allowing direct navigation to a particular page when loading a document.

## Related examples

- [Disable pages](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/disable-pages) - Disable page-related UI for single-page use cases by setting the `maxPages` option to 1.
- [Deep links](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/deep-links) - Create URLs that navigate to specific pages using the deep links API.

--------

# Parenting and ancestors

Every shape in tldraw has a parent. A shape's parent is either the page it lives on or another shape that contains it. This parent-child relationship creates a hierarchy that affects how shapes move, transform, and render. Groups and frames use this hierarchy to contain other shapes; the editor tracks this hierarchy to manage transforms, selection, and rendering order.

## The parentId property

Every shape record has a `parentId` property that points to its parent. For shapes directly on the canvas, this is a page ID. For shapes inside groups or frames, it's the containing shape's ID:

```typescript
// A shape on the page
const shape = editor.getShape(myShapeId)
console.log(shape.parentId) // "page:somePage"

// A shape inside a group
const groupedShape = editor.getShape(childShapeId)
console.log(groupedShape.parentId) // "shape:someGroup"
```

You can check what type of parent a shape has using `isPageId` and `isShapeId` from `@tldraw/tlschema`:

```typescript
import { isPageId, isShapeId } from 'tldraw'

if (isPageId(shape.parentId)) {
	// Shape is directly on a page
}

if (isShapeId(shape.parentId)) {
	// Shape is inside another shape (group, frame, etc.)
}
```

## Getting a shape's parent

Use [`Editor.getShapeParent`](/reference/editor/reference/editor/Editor#getShapeParent) to get the parent shape. It returns `undefined` if the shape is directly on a page:

```typescript
const parent = editor.getShapeParent(myShape)

if (parent) {
	console.log('Parent shape:', parent.type)
} else {
	console.log('Shape is on the page')
}
```

## Getting ancestors

The ancestor chain is the path from a shape up to the page. Use [`Editor.getShapeAncestors`](/reference/editor/reference/editor/Editor#getShapeAncestors) to get all ancestors in order from the root to the immediate parent:

```typescript
// For a deeply nested shape:
// page > frameA > groupB > myShape
const ancestors = editor.getShapeAncestors(myShapeId)
// Returns: [frameA, groupB]
```

The array is ordered from root ancestor to immediate parent. The page itself is never included—ancestors only contain shapes.

### Finding a specific ancestor

Use [`Editor.findShapeAncestor`](/reference/editor/reference/editor/Editor#findShapeAncestor) to find the first ancestor matching a condition:

```typescript
// Find the containing frame
const frame = editor.findShapeAncestor(myShape, (ancestor) => ancestor.type === 'frame')

// Find the first locked ancestor
const lockedAncestor = editor.findShapeAncestor(myShape, (ancestor) => ancestor.isLocked)
```

### Checking for a specific ancestor

Use [`Editor.hasAncestor`](/reference/editor/reference/editor/Editor#hasAncestor) to check if a shape is inside a specific container:

```typescript
if (editor.hasAncestor(myShape, frameId)) {
	// myShape is somewhere inside this frame
}
```

### Finding the common ancestor

When working with multiple shapes, use [`Editor.findCommonAncestor`](/reference/editor/reference/editor/Editor#findCommonAncestor) to find their nearest shared parent:

```typescript
const shapeIds = [shapeA, shapeB, shapeC]
const commonAncestorId = editor.findCommonAncestor(shapeIds)

if (commonAncestorId) {
	// All shapes share this ancestor
} else {
	// Shapes are on the page with no common parent shape
}
```

You can also filter by a predicate:

```typescript
// Find the common frame ancestor
const commonFrame = editor.findCommonAncestor(shapeIds, (shape) => shape.type === 'frame')
```

## Getting children

Use [`Editor.getSortedChildIdsForParent`](/reference/editor/reference/editor/Editor#getSortedChildIdsForParent) to get a shape's children in z-index order:

```typescript
const childIds = editor.getSortedChildIdsForParent(groupId)
// Returns child IDs sorted from back to front
```

This works for pages too:

```typescript
const topLevelShapes = editor.getSortedChildIdsForParent(editor.getCurrentPageId())
```

### Visiting descendants

For recursive traversal, use [`Editor.visitDescendants`](/reference/editor/reference/editor/Editor#visitDescendants):

```typescript
editor.visitDescendants(frameId, (childId) => {
	const child = editor.getShape(childId)
	console.log('Found:', child.type)
	// Return false to skip this shape's children
})
```

To collect all descendants including the shape itself, use [`Editor.getShapeAndDescendantIds`](/reference/editor/reference/editor/Editor#getShapeAndDescendantIds):

```typescript
const allIds = editor.getShapeAndDescendantIds([frameId])
// Returns a Set containing frameId and all nested shape IDs
```

## Reparenting shapes

Use [`Editor.reparentShapes`](/reference/editor/reference/editor/Editor#reparentShapes) to move shapes into a new parent. This preserves the shapes' page positions—only their local coordinates change to match the new parent's coordinate space:

```typescript
// Move shapes into a frame
editor.reparentShapes([shapeA, shapeB], frameId)

// Move shapes to the page root
editor.reparentShapes([shapeA, shapeB], editor.getCurrentPageId())
```

The method handles coordinate transformation automatically. If the parent is rotated, children's positions and rotations are adjusted so they appear in the same place on the page.

You can optionally specify an insert index to control z-ordering:

```typescript
// Insert at a specific position in the parent's child stack
editor.reparentShapes([newChild], parentId, insertIndex)
```

## Transforms and coordinates

Parent-child relationships affect coordinate systems. A child shape's `x` and `y` are relative to its parent, not the page.

To convert between coordinate systems:

```typescript
// Convert a page point to a shape's local space ([`Editor.getPointInShapeSpace`](/reference/editor/reference/editor/Editor#getPointInShapeSpace))
const localPoint = editor.getPointInShapeSpace(parentShape, pagePoint)

// Get a shape's position in page coordinates ([`Editor.getShapePageTransform`](/reference/editor/reference/editor/Editor#getShapePageTransform))
const pageTransform = editor.getShapePageTransform(childShape)
const pagePoint = pageTransform.point()
```

When you move a parent, all children move with it. Their local coordinates stay the same, but their page coordinates change.

For more about coordinate systems and transforms, see [Coordinates](/docs/sdk-features/coordinates).

## Checking page membership

Use [`Editor.isShapeInPage`](/reference/editor/reference/editor/Editor#isShapeInPage) to check if a shape is on a specific page (even if nested):

```typescript
if (editor.isShapeInPage(myShape, pageId)) {
	// Shape is on this page (directly or nested)
}
```

To get the page a shape belongs to, use [`Editor.getAncestorPageId`](/reference/editor/reference/editor/Editor#getAncestorPageId):

```typescript
const pageId = editor.getAncestorPageId(myShape)
```

## Locked ancestors

A shape is effectively locked if any of its ancestors are locked. Use [`Editor.isShapeOrAncestorLocked`](/reference/editor/reference/editor/Editor#isShapeOrAncestorLocked) to check:

```typescript
if (editor.isShapeOrAncestorLocked(myShape)) {
	// Shape can't be interacted with
}
```

This is what the editor uses internally to determine if shapes should respond to interactions.

## Hidden shapes

The editor can track shape visibility through [`Editor.isShapeHidden`](/reference/editor/reference/editor/Editor#isShapeHidden). This only works if you provide a `getShapeVisibility` callback when creating the editor:

```typescript
const editor = new Editor({
	getShapeVisibility: (shape, editor) => {
		// Return 'hidden', 'visible', or 'inherit'
		return shape.meta.hidden ? 'hidden' : 'inherit'
	},
	// ... other options
})

// Now you can check visibility
if (editor.isShapeHidden(myShape)) {
	// Shape won't render (either it or an ancestor is hidden)
}
```

A shape is hidden if its visibility is `'hidden'` or if any ancestor is hidden (unless the shape explicitly overrides with `'visible'`). Without a `getShapeVisibility` callback, `isShapeHidden()` always returns `false`.

## The focused group

The editor tracks a "focused group" that determines which level of the hierarchy you're working in. When you're focused inside a group, new shapes are created as children of that group. See [Groups](/docs/sdk-features/groups) for details on focused groups.

## Related examples

- **[Layer panel](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/layer-panel)** - Build a hierarchical layer panel that shows parent-child relationships.
- **[Drag and drop](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/drag-and-drop)** - Handle reparenting when dropping shapes onto containers.

--------

# Persistence

In tldraw, persistence means storing the editor's state to a database and restoring it later. The SDK provides several approaches: automatic local persistence with a single prop, manual snapshots for custom storage backends, and a migration system for handling schema changes.

## The persistenceKey prop

The simplest way to persist an editor is with the `persistenceKey` prop:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw persistenceKey="my-document" />
		</div>
	)
}
```

With this prop, the editor saves to IndexedDB whenever it changes, loads from IndexedDB on mount, synchronizes across browser tabs with the same key, and stores assets alongside the document.

Each persistence key represents a separate document:

```tsx
<Tldraw persistenceKey="document-a" />
<Tldraw persistenceKey="document-b" />
```

Two editors with the same key share the same document and stay in sync. Each editor still maintains its own session state (camera position, selection, current page).

## Snapshots

For custom storage backends, use snapshots to save and load editor state. A snapshot is a JSON-serializable object containing the full document.

### Getting a snapshot

Call [`getSnapshot`](/reference/editor/reference/editor/getSnapshot) with the editor's store to get the current state:

```ts
import { getSnapshot } from 'tldraw'

const { document, session } = getSnapshot(editor.store)
```

The snapshot has two parts:

| Part       | Contents                                  | When to share                 |
| ---------- | ----------------------------------------- | ----------------------------- |
| `document` | Shapes, pages, bindings, assets           | Save to server in multiplayer |
| `session`  | Camera, current page, selection, UI state | Keep per-user locally         |

For single-user apps, save both together:

```ts
localStorage.setItem('my-drawing', JSON.stringify({ document, session }))
```

For multiplayer, save them separately:

```ts
await saveToServer(documentId, document)
localStorage.setItem(`session-${documentId}`, JSON.stringify(session))
```

### Loading a snapshot

Call [`loadSnapshot`](/reference/editor/reference/editor/loadSnapshot) to restore state into an existing editor:

```ts
import { loadSnapshot } from 'tldraw'

const saved = JSON.parse(localStorage.getItem('my-drawing'))
loadSnapshot(editor.store, saved)
```

You can load document and session separately:

```ts
// Load document from server
const document = await fetchFromServer(documentId)
loadSnapshot(editor.store, { document })

// Optionally load session from local storage
const session = JSON.parse(localStorage.getItem(`session-${documentId}`))
if (session) {
	loadSnapshot(editor.store, { session })
}
```

### Initial state

Pass a snapshot to the `Tldraw` component to initialize with saved data:

```tsx
import { useState, useEffect } from 'react'
import { Tldraw, TLEditorSnapshot } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	const [snapshot, setSnapshot] = useState<TLEditorSnapshot | null>(null)

	useEffect(() => {
		async function load() {
			const document = await fetchDocument(documentId)
			const session = getLocalSession(documentId)
			setSnapshot({ document, session })
		}
		load()
	}, [])

	if (!snapshot) return <div>Loading...</div>

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw snapshot={snapshot} />
		</div>
	)
}
```

## Custom persistence with store

For more control, create your own store and pass it to the editor. This lets you load data before mounting and implement custom sync logic.

### Creating a store

Use [`createTLStore`](/reference/editor/reference/editor/createTLStore) to create a standalone store:

```tsx
import { useState } from 'react'
import { createTLStore, loadSnapshot, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	const [store] = useState(() => {
		const store = createTLStore()

		const saved = localStorage.getItem('my-drawing')
		if (saved) {
			loadSnapshot(store, JSON.parse(saved))
		}

		return store
	})

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw store={store} />
		</div>
	)
}
```

### Async loading with TLStoreWithStatus

When loading data asynchronously, use [`TLStoreWithStatus`](/reference/editor/reference/editor/TLStoreWithStatus) to handle loading and error states:

```tsx
import { useState, useEffect } from 'react'
import { createTLStore, loadSnapshot, Tldraw, TLStoreWithStatus } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	const [storeWithStatus, setStoreWithStatus] = useState<TLStoreWithStatus>({
		status: 'loading',
	})

	useEffect(() => {
		let cancelled = false

		async function load() {
			try {
				const snapshot = await fetchSnapshot()
				if (cancelled) return

				const store = createTLStore()
				loadSnapshot(store, snapshot)

				setStoreWithStatus({ status: 'synced-local', store })
			} catch (error) {
				if (cancelled) return
				setStoreWithStatus({ status: 'error', error: error as Error })
			}
		}

		load()
		return () => {
			cancelled = true
		}
	}, [])

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw store={storeWithStatus} />
		</div>
	)
}
```

The editor shows appropriate UI for each status. The possible values are:

| Status          | Meaning                                                             |
| --------------- | ------------------------------------------------------------------- |
| `loading`       | Store is being loaded                                               |
| `error`         | Loading failed                                                      |
| `not-synced`    | Store created without persistence                                   |
| `synced-local`  | Store loaded from local storage                                     |
| `synced-remote` | Store synced with remote server (includes `connectionStatus` field) |

## Listening for changes

Subscribe to store changes to implement auto-save or sync:

```ts
const cleanup = editor.store.listen((entry) => {
	for (const record of Object.values(entry.changes.added)) {
		console.log('Added:', record.typeName, record.id)
	}

	for (const [prev, next] of Object.values(entry.changes.updated)) {
		console.log('Updated:', next.id)
	}

	for (const record of Object.values(entry.changes.removed)) {
		console.log('Removed:', record.id)
	}
})
```

The listener returns a cleanup function you should call when unmounting.

### Filtering changes

Filter by source and scope to listen for specific changes:

```ts
// Only user changes (not remote sync)
editor.store.listen(handleChanges, { source: 'user', scope: 'all' })

// Only document records (not session state)
editor.store.listen(handleChanges, { source: 'all', scope: 'document' })
```

| Filter   | Values                                           | Purpose                 |
| -------- | ------------------------------------------------ | ----------------------- |
| `source` | `'user'`, `'remote'`, `'all'`                    | Where changes came from |
| `scope`  | `'document'`, `'session'`, `'presence'`, `'all'` | Type of records         |

### Throttled auto-save

Here's a pattern for auto-saving with throttling:

```ts
import { throttle } from 'lodash'
import { getSnapshot } from 'tldraw'

const saveToStorage = throttle(() => {
	const snapshot = getSnapshot(editor.store)
	localStorage.setItem('my-drawing', JSON.stringify(snapshot))
}, 500)

const cleanup = editor.store.listen(saveToStorage)
```

## Remote changes

When synchronizing with a multiplayer backend, use [`Store.mergeRemoteChanges`](/reference/store/reference/store/Store#mergeRemoteChanges) to apply updates from other users:

```ts
myRemoteSource.on('change', (changes) => {
	editor.store.mergeRemoteChanges(() => {
		for (const change of changes) {
			if (change.type === 'add' || change.type === 'update') {
				editor.store.put([change.record])
			} else if (change.type === 'remove') {
				editor.store.remove([change.id])
			}
		}
	})
})
```

Changes inside `mergeRemoteChanges` are tagged with `source: 'remote'`. This lets you filter them out when listening, avoiding infinite sync loops:

```ts
// Only save user changes, not remote changes
editor.store.listen(saveToServer, { source: 'user', scope: 'document' })
```

For production multiplayer apps, consider using the [@tldraw/sync](/docs/sync) package instead of building your own sync layer.

## Migrations

Snapshots include schema version information. When you load a snapshot from an older version, the store migrates it automatically. You don't need to do anything for tldraw's built-in types.

### Shape props migrations

If you have custom shapes, define migrations to handle changes to their props over time:

```ts
import { createShapePropsMigrationIds, createShapePropsMigrationSequence, ShapeUtil } from 'tldraw'

// Version IDs must start at 1 and increment
const versions = createShapePropsMigrationIds('my-shape', {
	AddColor: 1,
	RenameSize: 2,
})

const migrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: versions.AddColor,
			up(props) {
				props.color = 'black'
			},
			down(props) {
				delete props.color
			},
		},
		{
			id: versions.RenameSize,
			up(props) {
				props.dimensions = props.size
				delete props.size
			},
			down(props) {
				props.size = props.dimensions
				delete props.dimensions
			},
		},
	],
})

// Attach migrations to your shape util
class MyShapeUtil extends ShapeUtil<MyShape> {
	static override type = 'my-shape' as const
	static override migrations = migrations
	// ...
}
```

The `down` migrations are used in multiplayer when a peer needs an older schema version.

### General migrations

For migrating other data like `meta` properties, use the general migration API:

```ts
import { createMigrationIds, createMigrationSequence } from 'tldraw'

const sequenceId = 'com.example.my-app'

const versions = createMigrationIds(sequenceId, {
	RemoveLegacyField: 1,
})

const migrations = createMigrationSequence({
	sequenceId,
	sequence: [
		{
			id: versions.RemoveLegacyField,
			scope: 'record',
			filter: (record) => record.typeName === 'page',
			up(page: any) {
				delete page.meta.legacyField
			},
		},
	],
})
```

Pass migrations to the `Tldraw` component or when creating a store:

```tsx
<Tldraw migrations={[migrations]} />
```

```ts
const store = createTLStore({ migrations: [migrations] })
```

### Migration scopes

Migrations support different scopes depending on what you need to change:

| Scope    | Use case                                                      |
| -------- | ------------------------------------------------------------- |
| `record` | Runs on individual records matching an optional filter        |
| `store`  | Receives the entire serialized store for cross-record changes |

Most migrations use `record` scope. Use `store` when you need to read or modify multiple records together.

## Examples

- [Persistence key](/examples/data/persistence-key) - Automatic local persistence with a single prop
- [Snapshots](/examples/data/snapshots) - Saving and loading editor state
- [Local storage](/examples/data/local-storage) - Custom persistence with throttled auto-save
- [Store events](/examples/data/store-events) - Listening to store changes
- [Shape with migrations](/examples/data/shape-with-migrations) - Migrations for custom shape props
- [Meta migrations](/examples/data/meta-migrations) - General migrations for meta properties

--------

# Readonly mode

Readonly mode turns the editor into a viewer. Users can pan, zoom, and select shapes to inspect them, but they can't create, modify, or delete anything. Use readonly mode when you want to display canvas content without allowing changes: embedding documents in a presentation, sharing a design for feedback, or showing a preview of saved work.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ReadOnlyViewer() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					editor.updateInstanceState({ isReadonly: true })
				}}
			/>
		</div>
	)
}
```

## Enabling readonly mode

Readonly state lives in the editor's instance state. Toggle it with `updateInstanceState`:

```typescript
// Enable readonly mode
editor.updateInstanceState({ isReadonly: true })

// Disable readonly mode
editor.updateInstanceState({ isReadonly: false })

// Check current state
const isReadonly = editor.getIsReadonly()
```

The state persists across sessions when using a `persistenceKey`. A document saved in readonly mode opens in readonly mode next time.

## What readonly mode blocks

When readonly is enabled, the editor prevents all document mutations.

| Category   | Blocked methods                                                                                |
| ---------- | ---------------------------------------------------------------------------------------------- |
| Shapes     | `createShape`, `deleteShapes`, `updateShape`, `groupShapes`, `ungroupShapes`                   |
| Pages      | `createPage`, `deletePage`, `renamePage`, `moveShapesToPage`                                   |
| Assets     | `createAssets`, `updateAssets`, `deleteAssets`                                                 |
| Transforms | `flipShapes`, `packShapes`, `alignShapes`, `distributeShapes`, `rotateShapesBy`, `resizeShape` |
| Styles     | `setStyleForSelectedShapes`, `setOpacityForSelectedShapes`, `setOpacityForNextShapes`          |
| Clipboard  | `cut`, `paste` (for external content)                                                          |

The toolbar automatically hides editing tools. Only the select tool, hand tool, and laser pointer remain visible. UI actions like undo and redo are also disabled in readonly mode.

## What readonly mode allows

Navigation and viewing operations work normally. You can pan, zoom, and use camera methods like `zoomIn`, `zoomOut`, `zoomToFit`, and `zoomToSelection`. Selection works too: clicking shapes, brush selection, `selectAll`, and `selectNone` all function as expected. You can hover over shapes to inspect them, switch between pages, and export the document using the `exportAs` or `copyAs` helper functions since exporting doesn't modify the document.

## Using the useReadonly hook

In React components, the `useReadonly` hook provides reactive access to the readonly state. Import it from `tldraw`:

```tsx
import { useReadonly } from 'tldraw'

function ReadonlyIndicator() {
	const isReadonly = useReadonly()

	if (!isReadonly) return null

	return <div className="readonly-badge">View only</div>
}
```

The component re-renders automatically when readonly state changes. Use this hook when building custom UI that needs to respond to the readonly state.

## Actions in readonly mode

Actions have a `readonlyOk` property that determines whether they work in readonly mode. When an action has `readonlyOk: false` (the default), triggering it in readonly mode does nothing.

Built-in actions that work in readonly mode include zoom controls (`zoom-in`, `zoom-out`, `zoom-to-fit`, `zoom-to-selection`), selection actions (`select-all`, `select-none`, `copy`), export actions (`export-as-svg`, `export-as-png`, `print`), navigation (`back-to-content`, `change-page-prev`, `change-page-next`), and preference toggles like `toggle-dark-mode`.

When defining custom actions, set `readonlyOk: true` if the action should work in readonly mode:

```typescript
const overrides: TLUiOverrides = {
	actions(editor, actions, helpers) {
		actions['share-link'] = {
			id: 'share-link',
			label: 'action.share-link',
			readonlyOk: true,
			onSelect() {
				// This works in readonly mode
				navigator.clipboard.writeText(window.location.href)
			},
		}
		return actions
	},
}
```

## Shapes that remain interactive

Some shapes have interactive content that works even when the document is readonly. Embed shapes (YouTube videos, Figma files, interactive maps) are a good example. The embed itself is locked in place, but users can still play videos or interact with the embedded content.

ShapeUtils can override `canEditInReadonly` to allow editing interactions on their shapes:

```typescript
class InteractiveWidgetUtil extends ShapeUtil<InteractiveWidget> {
	canEditInReadonly(shape: InteractiveWidget): boolean {
		return true
	}
}
```

When this returns `true`, double-clicking the shape enters edit mode even in readonly mode. The shape's interactive content becomes usable while the shape itself stays fixed.

## Forcing operations in readonly mode

For programmatic use cases like migrations or admin tools, you can bypass the readonly check by passing `force: true` to certain operations:

```typescript
// This works even in readonly mode
editor.putExternalContent({ type: 'files', files: myFiles, point: { x: 0, y: 0 } }, { force: true })
```

Only `putExternalContent` and `replaceExternalContent` support this option. Use it sparingly since readonly mode exists to prevent unintended changes.

## Collaboration and readonly mode

When using tldraw's sync packages for collaboration, readonly mode integrates with room permissions. A user with read-only access to a shared document sees the editor in readonly mode automatically. The sync layer communicates the mode through a reactive signal, and the editor updates `isReadonly` in response.

Changes from other collaborators still appear (the document updates in real time) but the readonly user can't contribute changes themselves.

## Related examples

- **[Read-only](/examples/configuration/readonly)** — Set up a readonly editor that disables all editing functionality.

--------

# Rich text

Rich text lets you add formatted text to tldraw shapes. You get inline formatting like bold, italic, code, and highlighting, plus structural features like lists and links. Text, note, geo, and arrow label shapes all support rich text editing.

Under the hood, tldraw uses TipTap (a React wrapper around ProseMirror) as the rich text engine. TipTap stores text as structured JSON rather than plain strings, which enables reliable formatting operations, custom extensions, and consistent serialization.

## How it works

Rich text content is represented as a JSON tree. The root document contains paragraphs, and paragraphs contain text nodes with optional formatting marks. This structure aligns with TipTap's document model and makes it easy to extend.

### Document structure

A rich text document has three main components: the document root, content blocks, and text nodes with marks.

```typescript
const richText: TLRichText = {
	type: 'doc',
	content: [
		{
			type: 'paragraph',
			content: [
				{ type: 'text', text: 'Hello ' },
				{
					type: 'text',
					text: 'world',
					marks: [{ type: 'bold' }],
				},
			],
		},
	],
}
```

The `type` field identifies the node kind. The `content` array holds child nodes. Text nodes include a `marks` array for formatting information. You can combine formatting marks in any way you need.

### Converting between formats

Use `toRichText` to convert plain text strings to rich text documents. Each line becomes a separate paragraph:

```typescript
import { toRichText } from 'tldraw'

const richText = toRichText('First line\nSecond line')
// Creates two paragraphs
```

Note that `toRichText` treats all input as plain text—it doesn't parse markdown or other formatting. To create formatted content programmatically, build the rich text JSON structure directly or use the TipTap editor API.

To extract plain text from a rich text document, use `renderPlaintextFromRichText`. It strips all formatting and preserves line breaks:

```typescript
import { renderPlaintextFromRichText } from 'tldraw'

const text = renderPlaintextFromRichText(editor, shape.props.richText)
// Returns: "First line\nSecond line"
```

For HTML output, use `renderHtmlFromRichText`. It preserves all styling and structure, which is useful for rendering rich text outside the editor or exporting content:

```typescript
import { renderHtmlFromRichText } from 'tldraw'

const html = renderHtmlFromRichText(editor, shape.props.richText)
// Returns: '<p dir="auto">First line</p><p dir="auto">Second line</p>'
```

## TipTap integration

TipTap handles the rich text editing experience. The editor appears when users double-click text shapes or press Enter while a text shape is selected. It manages focus, keyboard shortcuts, and formatting commands automatically.

### Default extensions

The `tipTapDefaultExtensions` array includes TipTap's StarterKit plus customizations for tldraw. The StarterKit provides basic formatting like bold, italic, and lists. Additional extensions add code highlighting and custom keyboard behavior.

```typescript
export const tipTapDefaultExtensions: Extensions = [
	StarterKit.configure({
		blockquote: false,
		codeBlock: false,
		horizontalRule: false,
		link: {
			openOnClick: false,
			autolink: true,
		},
	}),
	Highlight,
	KeyboardShiftEnterTweakExtension,
	extensions.TextDirection.configure({ direction: 'auto' }),
]
```

This configuration disables blockquotes, code blocks, and horizontal rules to keep the interface focused on inline formatting. Links don't open on click during editing, which prevents accidental navigation. Text direction is set to automatic for right-to-left language support.

### Custom extensions

You can add custom TipTap extensions through the `textOptions` prop on the Tldraw component. This lets you add new formatting options, custom keyboard shortcuts, or specialized behavior:

```tsx
import { Mark, mergeAttributes } from '@tiptap/core'
import { StarterKit } from '@tiptap/starter-kit'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const CustomMark = Mark.create({
	name: 'custom',
	parseHTML() {
		return [{ tag: 'span.custom' }]
	},
	renderHTML({ HTMLAttributes }) {
		return ['span', mergeAttributes({ class: 'custom' }, HTMLAttributes), 0]
	},
	addCommands() {
		return {
			toggleCustom:
				() =>
				({ commands }) =>
					commands.toggleMark(this.name),
		}
	},
})

const textOptions = {
	tipTapConfig: {
		extensions: [StarterKit, CustomMark],
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw textOptions={textOptions} />
		</div>
	)
}
```

Note that you must provide a complete list of extensions. If you include custom extensions, also include any default extensions you want to keep. The example above replaces the entire extension list, giving you full control over what features are available.

### Rich text toolbar

The rich text toolbar appears when editing text shapes. It gives you quick access to formatting commands like bold, italic, and lists. The toolbar updates dynamically to show which formats are active at the current cursor position.

You can customize the toolbar by overriding the `RichTextToolbar` component. Use `editor.getRichTextEditor()` to get the TipTap editor instance and execute formatting commands:

```tsx
import {
	DefaultRichTextToolbar,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	preventDefault,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])

		return (
			<DefaultRichTextToolbar>
				<TldrawUiButton
					type="icon"
					onClick={() => textEditor?.chain().focus().toggleBold().run()}
					onPointerDown={preventDefault}
				>
					B
				</TldrawUiButton>
			</DefaultRichTextToolbar>
		)
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={components} />
		</div>
	)
}
```

The `DefaultRichTextToolbar` component provides the default toolbar layout. Nest custom buttons inside it to extend the toolbar, or replace it entirely for complete control over the formatting interface.

## Shapes with rich text

Four shape types support rich text: text shapes, note shapes, geo shapes, and arrow labels. Each renders rich text through the `RichTextLabel` component, which handles both display and editing modes.

### Text shapes

Text shapes are standalone text blocks you can place anywhere on the canvas. They support auto-sizing (where the shape grows to fit content) or fixed-width mode with text wrapping.

```typescript
editor.createShape({
	type: 'text',
	x: 100,
	y: 100,
	props: {
		richText: toRichText('Sample text'),
		font: 'draw',
		size: 'm',
		textAlign: 'start',
		autoSize: true,
	},
})
```

The `autoSize` prop controls whether the shape expands automatically. When true, text never wraps and the shape width matches the content. When false, text wraps at the shape's width boundary.

### Note shapes

Note shapes display text on colored backgrounds. They always have fixed dimensions and wrap text to fit within those bounds.

```typescript
editor.createShape({
	type: 'note',
	x: 100,
	y: 100,
	props: {
		richText: toRichText('Note content'),
		font: 'draw',
		size: 'm',
		color: 'yellow',
	},
})
```

Notes work well for annotations, comments, or highlighting specific information on the canvas. The colored background provides visual distinction from regular text shapes.

### Geo shapes

Geo shapes include rectangles, ellipses, and other geometric forms that can contain text labels. Text appears centered within the shape bounds, with configurable alignment.

```typescript
editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	props: {
		geo: 'rectangle',
		w: 200,
		h: 100,
		richText: toRichText('Label'),
		font: 'draw',
		size: 'm',
		align: 'middle',
		verticalAlign: 'middle',
	},
})
```

The `align` and `verticalAlign` props control text positioning within the shape. Text wraps when it exceeds the available width minus padding.

### Arrow labels

Arrows can have a text label that appears along the arrow path. The label is editable like other rich text and moves with the arrow when repositioned.

```typescript
editor.createShape({
	type: 'arrow',
	x: 100,
	y: 100,
	props: {
		start: { x: 0, y: 0 },
		end: { x: 200, y: 0 },
		richText: toRichText('Arrow label'),
		font: 'draw',
		size: 'm',
	},
})
```

Arrow labels automatically position themselves based on the arrow's path and curvature. The label remains readable regardless of arrow orientation.

## Font management

Rich text can include multiple fonts and font styles within a single text block. The `FontManager` tracks which fonts are needed and ensures they load before rendering, preventing layout shifts.

Use `getFontsFromRichText` to collect all required font faces based on the text content and formatting marks:

```typescript
import { getFontsFromRichText } from 'tldraw'

const fonts = getFontsFromRichText(editor, richText, {
	family: 'tldraw_draw',
	weight: 'normal',
	style: 'normal',
})
```

The function accepts an initial font state representing the base font. It walks the document tree, examining marks on text nodes to determine when bold or italic variants are needed. When code marks are present, it switches to the monospace font family.

### Custom font resolution

You can override font resolution by providing a custom `addFontsFromNode` function through `textOptions`. This lets you use custom fonts or alternative font mapping strategies:

```typescript
const textOptions = {
	tipTapConfig: {
		extensions: [StarterKit],
	},
	addFontsFromNode: (node, state, addFont) => {
		// Custom font resolution logic
		if (node.marks.some((m) => m.type.name === 'bold')) {
			state = { ...state, weight: 'bold' }
		}
		// Call addFont() with required font faces
		return state
	},
}
```

The function receives the current node, font state, and a callback to register required fonts. It returns the updated state for child node processing, letting you walk the document tree while maintaining font context.

## Programmatic formatting

You can apply formatting to rich text programmatically by accessing the TipTap editor instance. This enables bulk operations like applying formatting to multiple shapes or implementing custom formatting commands:

```typescript
const textEditor = editor.getRichTextEditor()
if (textEditor) {
	// Make all selected text bold
	textEditor.chain().focus().selectAll().toggleBold().run()
}
```

The chain API lets you compose multiple operations. Each command returns a chainable object, and `run()` executes the composed command sequence.

For operations outside the editing context, you can manipulate the rich text JSON directly. This is useful when programmatically generating or transforming content:

```typescript
function makeAllTextBold(richText: TLRichText): TLRichText {
	const content = richText.content.map((paragraph) => {
		if (!paragraph.content) return paragraph

		return {
			...paragraph,
			content: paragraph.content.map((node) => {
				if (node.type !== 'text') return node

				const marks = node.marks || []
				if (marks.some((m) => m.type === 'bold')) return node

				return {
					...node,
					marks: [...marks, { type: 'bold' }],
				}
			}),
		}
	})

	return { ...richText, content }
}
```

This approach requires understanding the TipTap document structure but gives you precise control over content transformation.

## Measurement and rendering

Rich text measurement uses the same system as plain text, with HTML rendering replacing plain text content. The `TextManager` measures rich text by generating HTML, applying it to the measurement element, and reading the computed dimensions:

```typescript
import { renderHtmlFromRichTextForMeasurement } from 'tldraw'

const html = renderHtmlFromRichTextForMeasurement(editor, richText)
// Returns HTML wrapped in measurement container
```

The measurement system accounts for formatting that affects layout, like bold text or lists. Font loading completes before measurement to ensure accurate dimensions.

For SVG export, the `RichTextSVG` component renders rich text as a foreignObject element, preserving formatting and layout in exported images.

## Extension points

The rich text system offers several ways to customize behavior:

| Extension point              | Description                                                                    |
| ---------------------------- | ------------------------------------------------------------------------------ |
| **Custom TipTap extensions** | Add new marks, nodes, keyboard shortcuts, or commands                          |
| **Custom toolbar**           | Replace or extend the rich text toolbar with different formatting controls     |
| **Font resolution**          | Override font resolution to use custom fonts or alternative loading strategies |

The `textOptions` prop accepts a `tipTapConfig` object that passes through to TipTap's editor configuration, giving you access to all TipTap configuration options:

```typescript
const textOptions = {
	tipTapConfig: {
		extensions: [...],
		editorProps: {
			attributes: {
				class: 'custom-editor',
			},
		},
	},
	addFontsFromNode: customFontResolver,
}
```

## Related examples

- **[Rich text with custom extension](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/rich-text-custom-extension)** - Adding a custom TipTap extension and toolbar button.

- **[Rich text with font extensions](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/rich-text-font-extensions)** - Extending the editor with font-family and font-size controls.

- **[Format rich text on multiple shapes](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/rich-text-on-multiple-shapes)** - Applying formatting to multiple selected shapes programmatically.

--------

# Scribble

The scribble system draws temporary freehand paths for pointer-based interactions. Use scribbles to show visual feedback during tool operations like erasing, laser pointer drawing, or scribble-brush selection. Access the system through [`Editor.scribbles`](/reference/editor/reference/editor/Editor#scribbles).

Scribbles exist only in instance state and fade out automatically after the tool operation completes. They're never persisted to the document.

## How it works

### Scribble lifecycle

Every scribble moves through five states:

| State    | Description                                                                                                                    |
| -------- | ------------------------------------------------------------------------------------------------------------------------------ |
| Starting | The scribble collects points until it has more than 8. This prevents flickering for very short strokes.                        |
| Paused   | Drawing pauses temporarily.                                                                                                    |
| Active   | The scribble accumulates points as the pointer moves.                                                                          |
| Complete | Drawing finishes but fading hasn't started yet. This allows taper effects to apply when the user lifts the pointer.            |
| Stopping | The scribble fades out by progressively removing points from its tail. The manager deletes the scribble once all points clear. |

The [`ScribbleManager.tick`](/reference/editor/reference/editor/ScribbleManager#tick) method updates all scribbles on every animation frame, handling state transitions, point management, and fade-out timing.

### Fade-out behavior

During fade-out, the scribble shrinks from the tail by removing points at regular intervals. Set `shrink` above zero for a smooth disappearance effect. The stroke width decreases along with the point count.

The `delay` property controls how long a scribble stays at full length before shrinking. Self-consuming scribbles (the default) remove points from the start as you draw, maintaining a constant length.

## Using scribbles

The [`ScribbleManager`](/reference/editor/reference/editor/ScribbleManager) provides two APIs: a direct API for basic use cases and a session-based API for complex scenarios requiring grouped behavior or custom fade modes.

### Direct API

The direct API works well for tools like the eraser that use self-consuming scribbles:

```typescript
import { StateNode, TLPointerEventInfo } from '@tldraw/editor'

export class Erasing extends StateNode {
	static override id = 'erasing'

	private scribbleId = ''

	override onEnter(info: TLPointerEventInfo) {
		const scribble = this.editor.scribbles.addScribble({
			color: 'muted-1',
			size: 12,
		})
		this.scribbleId = scribble.id
		this.pushPointToScribble()
	}

	override onExit() {
		this.editor.scribbles.stop(this.scribbleId)
	}

	override onPointerMove() {
		this.pushPointToScribble()
	}

	private pushPointToScribble() {
		const { x, y } = this.editor.inputs.getCurrentPagePoint()
		this.editor.scribbles.addPoint(this.scribbleId, x, y)
	}
}
```

**Creating a scribble**: Call [`ScribbleManager.addScribble`](/reference/editor/reference/editor/ScribbleManager#addScribble) with optional configuration. The method returns a [`ScribbleItem`](/reference/editor/reference/editor/ScribbleItem) containing the scribble's ID:

```typescript
const scribble = this.editor.scribbles.addScribble({
	color: 'muted-1',
	size: 12,
})
```

**Adding points**: As the pointer moves, add points using the scribble ID. The [`ScribbleManager.addPoint`](/reference/editor/reference/editor/ScribbleManager#addPoint) method automatically deduplicates points that are too close together:

```typescript
const { x, y } = this.editor.inputs.getCurrentPagePoint()
this.editor.scribbles.addPoint(scribble.id, x, y)
```

Pass an optional third parameter `z` (defaults to `0.5`) to control point pressure for variable-width strokes.

**Stopping a scribble**: When the tool operation completes, stop the scribble to begin fade-out:

```typescript
this.editor.scribbles.stop(scribble.id)
```

The scribble transitions to stopping state and removes itself once all points clear.

### Session API

For more complex scenarios, use sessions to group multiple scribbles together and control their behavior. The laser pointer uses sessions to create a trailing effect where all scribbles fade together:

```typescript
import { StateNode, TLStateNodeConstructor } from '@tldraw/editor'

export class LaserTool extends StateNode {
	static override id = 'laser'
	static override initial = 'idle'

	private sessionId: string | null = null

	getSessionId(): string {
		// Reuse existing session if it's still active
		if (this.sessionId && this.editor.scribbles.isSessionActive(this.sessionId)) {
			return this.sessionId
		}

		// Create a new session
		this.sessionId = this.editor.scribbles.startSession({
			selfConsume: false,
			idleTimeoutMs: this.editor.options.laserDelayMs,
			fadeMode: 'grouped',
			fadeEasing: 'ease-in',
		})

		return this.sessionId
	}

	override onCancel() {
		if (this.sessionId && this.editor.scribbles.isSessionActive(this.sessionId)) {
			this.editor.scribbles.clearSession(this.sessionId)
			this.sessionId = null
		}
	}
}
```

Child states add scribbles to the session and add points:

```typescript
export class Lasering extends StateNode {
	static override id = 'lasering'

	private scribbleId = ''
	private sessionId = ''

	override onEnter(info: { sessionId: string; scribbleId: string }) {
		this.sessionId = info.sessionId
		this.scribbleId = info.scribbleId
		this.pushPointToScribble()
	}

	override onPointerMove() {
		this.pushPointToScribble()
	}

	private pushPointToScribble() {
		const { x, y } = this.editor.inputs.getCurrentPagePoint()
		this.editor.scribbles.addPointToSession(this.sessionId, this.scribbleId, x, y)
	}

	override onTick() {
		// Reset idle timeout on activity
		this.editor.scribbles.extendSession(this.sessionId)
	}

	override onPointerUp() {
		// Mark complete to apply taper, then let session handle fade
		this.editor.scribbles.complete(this.scribbleId)
		this.parent.transition('idle')
	}
}
```

## Scribble properties

Scribbles support these visual properties:

| Property  | Default        | Description                                                                                                         |
| --------- | -------------- | ------------------------------------------------------------------------------------------------------------------- |
| `id`      | auto-generated | Unique identifier for the scribble                                                                                  |
| `color`   | `'accent'`     | Canvas UI color: `'accent'`, `'white'`, `'black'`, `'selection-stroke'`, `'selection-fill'`, `'laser'`, `'muted-1'` |
| `size`    | `20`           | Stroke width in pixels                                                                                              |
| `opacity` | `0.8`          | Transparency from 0 to 1                                                                                            |
| `delay`   | `0`            | Milliseconds before shrinking starts (for self-consuming scribbles)                                                 |
| `shrink`  | `0.1`          | Rate at which stroke width decreases during fade-out (0 to 1)                                                       |
| `taper`   | `true`         | Whether the stroke tapers at the ends                                                                               |

All properties have defaults, so you only need to specify what you want to change.

## Session options

When using the session API, you can configure how scribbles behave:

| Property         | Default                   | Description                                                                         |
| ---------------- | ------------------------- | ----------------------------------------------------------------------------------- |
| `id`             | auto-generated            | Session identifier                                                                  |
| `selfConsume`    | `true`                    | Whether scribbles eat their own tail as you draw                                    |
| `idleTimeoutMs`  | `0`                       | Auto-stop session after this many milliseconds of inactivity (0 disables)           |
| `fadeMode`       | `'individual'`            | How scribbles fade: `'individual'` (each on its own) or `'grouped'` (fade together) |
| `fadeEasing`     | `'linear'` or `'ease-in'` | Easing for grouped fade. Defaults to `'ease-in'` when fadeMode is `'grouped'`       |
| `fadeDurationMs` | `laserFadeoutMs` (500ms)  | Duration of the fade in milliseconds                                                |

By default, points are removed from the start as you draw, maintaining a constant scribble length. This works well for tools like the eraser that need immediate visual feedback without a persistent trail.

When `selfConsume` is `false`, points accumulate while the session is active and only fade after the session stops. The laser pointer uses this with grouped fade mode. All strokes from a drawing session disappear together.

## Customizing scribble rendering

You can override the scribble component to customize how scribbles render. Pass a custom `Scribble` component through [`TLEditorComponents`](/reference/editor/reference/editor/TLEditorComponents). The component receives [`TLScribbleProps`](/reference/editor/reference/editor/TLScribbleProps) with `scribble`, `zoom`, `color`, `opacity`, and `className`. To customize how other users' scribbles appear in multiplayer, override the `CollaboratorScribble` component instead, which also receives `userId`.

```tsx
import { Tldraw, TLEditorComponents, getSvgPathFromPoints } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLEditorComponents = {
	Scribble: ({ scribble, zoom, opacity, color }) => {
		if (!scribble.points.length) return null

		return (
			<svg className="tl-overlays__item">
				<path
					d={getSvgPathFromPoints(scribble.points, false)}
					stroke={color ?? `var(--tl-color-${scribble.color})`}
					strokeWidth={8 / zoom}
					opacity={opacity ?? scribble.opacity}
					fill="none"
				/>
			</svg>
		)
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={components} />
		</div>
	)
}
```

The `@tldraw/editor` package provides [`DefaultScribble`](/reference/editor/reference/editor/DefaultScribble) which uses [`getSvgPathFromPoints`](/reference/editor/reference/editor/getSvgPathFromPoints) for simple stroked paths, as shown above. The `tldraw` package provides [`TldrawScribble`](/reference/tldraw/reference/tldraw/TldrawScribble) which uses [`getStroke`](/reference/tldraw/reference/tldraw/getStroke) to create smooth, pressure-sensitive filled paths.

## Related articles

- [Tools](/sdk-features/tools) - Learn how tools use state nodes and handle pointer events
- [UI components](/sdk-features/ui-components) - Customize canvas components including the scribble renderer

## Related examples

- [Custom components](/examples/ui/custom-components) - Override the Scribble component to customize scribble appearance

--------

# Selection

The editor tracks which shapes are selected and gives you methods to change the selection, get the selected shapes, and compute their collective bounds and rotation. It automatically enforces rules like "you can't select both a group and its children at the same time" and manages focus groups when you select shapes inside groups.

## Selected shape IDs

The editor tracks selection through the `selectedShapeIds` array in the current page's instance state. This array stores the IDs of all currently selected shapes and serves as the source of truth for selection state.

```typescript
// Get currently selected shape IDs
const selectedIds = editor.getSelectedShapeIds()

// Get the actual shape objects
const selectedShapes = editor.getSelectedShapes()
```

The `getSelectedShapes()` method resolves the IDs to actual shape records, filtering out any IDs that no longer exist in the store.

## Selection methods

### Basic selection

The editor provides several methods for changing the selection:

```typescript
// Select specific shapes (replaces current selection)
editor.select(shapeId1, shapeId2)
editor.setSelectedShapes([shapeId1, shapeId2])

// Deselect specific shapes (removes from current selection)
editor.deselect(shapeId1)

// Clear all selection
editor.selectNone()
```

Both `select()` and `setSelectedShapes()` replace the current selection entirely. Use `deselect()` to remove specific shapes while keeping others selected.

### Select all

The `selectAll()` method selects all unlocked shapes, with smart scoping based on the current selection:

```typescript
editor.selectAll()
```

The behavior adapts to context:

- If nothing is selected, it selects all page-level shapes
- If you select shapes that share a common parent (like shapes inside a group), it selects all shapes within that parent
- If the selected shapes have different parents, it does nothing

This allows users to progressively select "outward" by calling `selectAll()` multiple times.

### Adjacent selection

Select the next or previous shape in reading order, or navigate by cardinal direction:

```typescript
editor.selectAdjacentShape('next')
editor.selectAdjacentShape('prev')
editor.selectAdjacentShape('left')
editor.selectAdjacentShape('right')
```

When selecting by cardinal direction, the system uses geometric distance and directional scoring to find the most appropriate adjacent shape.

### Hierarchical selection

Navigate the shape hierarchy:

```typescript
// Select the parent of the currently selected shape
editor.selectParentShape()

// Select the first child of the currently selected shape
editor.selectFirstChildShape()
```

Both methods automatically zoom to the selected shape if it's offscreen.

## Single shape helpers

When you need to work with exactly one selected shape, use these convenience methods:

```typescript
// Get the ID if exactly one shape is selected, null otherwise
const id = editor.getOnlySelectedShapeId()

// Get the shape if exactly one shape is selected, null otherwise
const shape = editor.getOnlySelectedShape()
```

Both methods return `null` if zero shapes or multiple shapes are selected.

### Selected shape at point

To find which selected shape is at a specific point (useful for hit testing during interactions), use `getSelectedShapeAtPoint()`:

```typescript
const shape = editor.getSelectedShapeAtPoint({ x: 100, y: 200 })
```

This returns the top-most selected shape at the given point, ignoring groups. It returns `undefined` if no selected shape is at that point.

## Selection bounds

The editor computes bounds for the current selection in two ways: axis-aligned and rotated.

### Axis-aligned bounds

The `getSelectionPageBounds()` method returns the axis-aligned bounding box that contains all selected shapes:

```typescript
const bounds = editor.getSelectionPageBounds()
if (bounds) {
	console.log(bounds.x, bounds.y, bounds.width, bounds.height)
}
```

If the selection includes rotated shapes, these bounds represent the smallest axis-aligned box that contains the rotated shapes. The method returns `null` if nothing is selected.

### Rotated bounds

The `getSelectionRotatedPageBounds()` method returns bounds that respect the shared rotation of the selection:

```typescript
const rotatedBounds = editor.getSelectionRotatedPageBounds()
```

The selection box UI uses this for display. If all selected shapes share the same rotation, the bounds rotate with them. If shapes have different rotations, this falls back to axis-aligned bounds.

You can access the shared rotation angle via `getSelectionRotation()`, which returns `0` if shapes have different rotations.

### Screen space bounds

Both bound types have screen-space equivalents that account for the camera's zoom and pan:

```typescript
const screenBounds = editor.getSelectionScreenBounds()
const rotatedScreenBounds = editor.getSelectionRotatedScreenBounds()
```

## Selection rules

The editor automatically enforces selection consistency through store side effects.

### Ancestor-descendant filtering

When the selection changes, the editor filters out any shape whose ancestor is also selected:

```typescript
// If you try to select a shape and its parent, only the parent remains selected
editor.select(groupId, childOfGroupId)
// Result: only groupId is selected
```

This prevents ambiguous situations where both a container and its contents are selected. The filtering happens in the `instance_page_state` after-change side effect.

### Focused group management

When you select shapes that are children of a group, the editor automatically updates the focused group. A **focused group** is the group shape that defines the current editing scope—it determines which shapes are available for selection and manipulation. When you enter a group by selecting its children, that group becomes focused, restricting your editing context to shapes within that group.

```typescript
// Selecting shapes inside a group focuses that group
editor.select(shapeInsideGroup)
// The group becomes the focused group
```

If all selected shapes share a common group ancestor, that group becomes focused. If you clear the selection or select shapes without a common group ancestor, the editor clears the focused group.

## Locked shapes

The editor excludes locked shapes from bulk selection operations:

```typescript
// selectAll only selects unlocked shapes
editor.selectAll()

// Operations like delete and duplicate also respect locks
editor.deleteShapes(shapeIds) // Only deletes unlocked shapes
```

Locks do not restrict individual shape selection through `select()`, allowing users to explicitly select locked shapes when needed.

## Ancestor checking

To determine if a shape's ancestor is selected, use `isAncestorSelected()`:

```typescript
const hasSelectedAncestor = editor.isAncestorSelected(shape)
```

This walks up the shape's parent chain and returns `true` if any ancestor is in the current selection. This is useful for determining whether a shape is implicitly selected through its parent.

## Related examples

- **[Selection UI](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/selection-ui)** - Add custom UI elements that appear around the current selection using selection bounds.
- **[Prevent multi-shape selection](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/prevent-multi-shape-selection)** - Use side effects to restrict selection to a single shape at a time.
- **[Lasso select tool](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/lasso-select-tool)** - Create a custom freehand selection tool.

--------

# Shape clipping

Shape clipping lets parent shapes mask their children so content outside the parent's boundary is hidden. Frames are the primary example—drop shapes into a frame and they're cropped to the frame's edges. Custom shapes can define their own clip boundaries using any polygon.

## How clipping works

The clipping system uses two ShapeUtil methods that work together: `getClipPath` defines the clipping boundary as an array of points, and `shouldClipChild` controls which children get clipped.

When a shape is a child of a clipping parent, the editor:

1. Gets the parent's clip path from `getClipPath`
2. Checks if this child should be clipped via `shouldClipChild`
3. Transforms the clip path to page coordinates
4. Applies it as a CSS clip-path during rendering

If a shape has multiple clipping ancestors, their clip paths are intersected. A shape nested inside two clipping parents is clipped by both—only the overlapping region shows.

## Implementing clipping

To make a custom shape clip its children, implement `getClipPath` in your ShapeUtil:

```tsx
import { Rectangle2d, ShapeUtil, TLBaseShape, Vec } from 'tldraw'

type MyClipShape = TLBaseShape<'my-clip', { w: number; h: number }>

class MyClipShapeUtil extends ShapeUtil<MyClipShape> {
	static override type = 'my-clip' as const

	override getDefaultProps() {
		return { w: 200, h: 200 }
	}

	override getGeometry(shape: MyClipShape) {
		return new Rectangle2d({ width: shape.props.w, height: shape.props.h, isFilled: true })
	}

	override component(shape: MyClipShape) {
		return <rect width={shape.props.w} height={shape.props.h} fill="transparent" stroke="black" />
	}

	override indicator(shape: MyClipShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	override getClipPath(shape: MyClipShape): Vec[] | undefined {
		// Return polygon vertices in local coordinates
		return [
			new Vec(0, 0),
			new Vec(shape.props.w, 0),
			new Vec(shape.props.w, shape.props.h),
			new Vec(0, shape.props.h),
		]
	}

	override canReceiveNewChildrenOfType() {
		return true
	}
}
```

The returned points define a polygon in the shape's local coordinate space. The editor transforms these points to page space before applying the clip. Return `undefined` to disable clipping entirely.

> **Note for stroked shapes:** If your clipping shape has a stroke, consider insetting the clip path by half the stroke width so children are clipped to the inner boundary rather than the outer edge of the stroke. This prevents children from overlapping with the stroke itself.

### Selective clipping

By default, all children of a clipping parent are clipped. Override `shouldClipChild` to change this:

```typescript
override shouldClipChild(child: TLShape): boolean {
	// Don't clip text shapes
	if (child.type === 'text') return false
	return true
}
```

This lets you create clipping shapes where some content types break out of the boundary. You might clip geometric shapes but let labels extend beyond the edge.

## Frame clipping

Frames are the primary built-in example of clipping. The FrameShapeUtil implements clipping by returning its geometry vertices:

```typescript
override getClipPath(shape: TLFrameShape) {
	return this.editor.getShapeGeometry(shape.id).vertices
}
```

This clips to the frame's rectangular boundary. Content that extends beyond the frame's edges is hidden during rendering but still exists in the document—you can ungroup or move shapes out of the frame to see the clipped portions.

## Reading shape masks

The editor computes masks for any clipped shape. Use these methods to access mask data:

| Method                     | Returns                  | Description                      |
| -------------------------- | ------------------------ | -------------------------------- |
| `getShapeMask`             | `VecLike[] \| undefined` | Mask polygon in page coordinates |
| `getShapeClipPath`         | `string \| undefined`    | CSS `polygon(...)` string        |
| `getShapeMaskedPageBounds` | `Box \| undefined`       | Bounds clipped by the mask       |

```typescript
const mask = editor.getShapeMask(shapeId)
// Returns array of points in page space, or undefined if not clipped

const clipPath = editor.getShapeClipPath(shapeId)
// Returns a "polygon(...)" CSS string, or undefined

const clippedBounds = editor.getShapeMaskedPageBounds(shapeId)
// Returns the shape's page bounds intersected with its mask
```

These methods are useful for custom rendering, SVG export, or building UI that needs to understand clipping relationships.

## Non-rectangular clip paths

Clip paths can be any polygon. For a circular clip, approximate the circle with polygon segments:

```typescript
override getClipPath(shape: CircleShape): Vec[] | undefined {
	const centerX = shape.props.w / 2
	const centerY = shape.props.h / 2
	const radius = Math.min(shape.props.w, shape.props.h) / 2
	const segments = 48

	const points: Vec[] = []
	for (let i = 0; i < segments; i++) {
		const angle = (i / segments) * Math.PI * 2
		points.push(
			new Vec(
				centerX + Math.cos(angle) * radius,
				centerY + Math.sin(angle) * radius
			)
		)
	}
	return points
}
```

More segments create smoother curves. The performance cost is minimal since clip paths are cached and only recomputed when the shape changes.

## Backgrounds and clipping

Shapes that clip typically also provide backgrounds for their children. Override `providesBackgroundForChildren` to enable this:

```typescript
override providesBackgroundForChildren(): boolean {
	return true
}
```

When this returns true, child shapes with `backgroundComponent` methods have their backgrounds rendered above this shape rather than above the canvas background. This creates proper visual layering within clipping containers.

## Clipping and hit testing

Clipping affects both rendering and hit testing. The [`Editor.getShapeAtPoint`](/reference/editor/reference/editor/Editor#getShapeAtPoint) method filters out shapes when the click point falls outside the shape's mask—you can't select a clipped shape by clicking its hidden portions.

Snapping and bounds calculations use the shape's full geometry, so a clipped shape's bounds may extend beyond what's visible. Only rendering and hit testing are masked.

For an example of custom clipping shapes, see the [custom clipping shape example](/examples/editor-api/custom-clipping-shape).

--------

# Shape indexing

Every shape in tldraw has an `index` property that determines its visual stacking order (z-order) on the canvas. Shapes with higher index values appear in front of shapes with lower values. The index system uses string-based fractional indexing, which allows efficient reordering and supports real-time collaboration.

## Why fractional indexing?

Integer-based indexing has problems. If you have shapes at indices `[0, 1, 2]` and want to insert between 0 and 1, you'd need to renumber subsequent shapes or use floats that eventually lose precision.

Fractional indexing uses lexicographically sortable strings. You can always generate a new index between any two existing indices. Standard JavaScript string comparison sorts them correctly, and reordering only updates the moved shapes - not every shape on the canvas.

## Index structure

Indices are strings like `'a1'`, `'a2'`, or `'a1V'`. The first letter is the integer part (base-62 encoded), and optional following characters are the fractional part for inserting between existing indices. The `@tldraw/utils` package uses the [jittered fractional indexing](https://www.npmjs.com/package/jittered-fractional-indexing) algorithm to generate these strings.

## Generating indices

The `@tldraw/utils` package exports functions for generating indices:

```ts
import {
	getIndexBetween,
	getIndexAbove,
	getIndexBelow,
	getIndicesAbove,
	getIndicesBelow,
	getIndicesBetween,
	sortByIndex,
	IndexKey,
} from '@tldraw/utils'

// Generate a single index between two existing indices
const between = getIndexBetween('a1' as IndexKey, 'a3' as IndexKey) // e.g. 'a2'

// Generate indices above or below an existing index
const above = getIndexAbove('a1' as IndexKey) // e.g. 'a2'
const below = getIndexBelow('a2' as IndexKey) // e.g. 'a1'

// Generate multiple indices at once (exact values vary due to jittering)
const multipleAbove = getIndicesAbove('a0' as IndexKey, 3)
const multipleBelow = getIndicesBelow('a2' as IndexKey, 2)
const multipleBetween = getIndicesBetween('a0' as IndexKey, 'a2' as IndexKey, 2)

// Sort objects by their index property
const shapes = [{ index: 'a2' as IndexKey }, { index: 'a1' as IndexKey }]
shapes.sort(sortByIndex) // [{ index: 'a1' }, { index: 'a2' }]
```

The algorithm includes jittering (randomization) to reduce conflicts in collaborative environments. When two users insert shapes at the same position simultaneously, jittering makes them generate different indices instead of identical ones.

## Reordering shapes

The [`Editor`](/reference/editor/reference/editor/Editor) provides four methods for changing shape z-order. You can pass either shape IDs or shape objects to any of these methods.

### Send to back and bring to front

```ts
// Move shapes to the very back or front
editor.sendToBack(['shape:abc123' as TLShapeId, 'shape:def456' as TLShapeId])
editor.bringToFront(['shape:abc123' as TLShapeId])
```

These move shapes to the bottom or top of the z-order within their parent.

### Send backward and bring forward

```ts
// Move shapes one step back or forward
editor.sendBackward(['shape:abc123' as TLShapeId])
editor.bringForward(['shape:abc123' as TLShapeId])
```

By default, these methods only move shapes past other shapes they visually overlap. This makes keyboard shortcuts feel intuitive - pressing "send backward" moves a shape behind the shape it's actually covering, not behind some distant shape.

To move past any shape regardless of overlap:

```ts
editor.sendBackward(['shape:abc123' as TLShapeId], { considerAllShapes: true })
```

### Order preservation

All reordering methods preserve relative order. If you select shapes A, B, and C (stacked A-B-C from back to front) and bring them forward, they stay in A-B-C order at their new position.

## How reordering works internally

Shape indices are always relative to siblings within the same parent. When you reorder shapes, tldraw:

1. Groups shapes by parent
2. Finds the insertion point (front, back, or adjacent to an overlapping shape)
3. Generates new indices using `getIndicesBetween`
4. Updates only the shapes that actually need new indices

If shapes are already at the target position, no updates occur.

## Collaboration

Fractional indexing works well for real-time collaboration. When two users simultaneously reorder shapes, they generate different indices in the same region of index space. Both operations succeed and merge cleanly.

The jittering mentioned earlier is important here. Without it, two users inserting at the same position would generate identical indices, causing conflicts. With jittering, they get different indices that sort near each other but remain distinct.

Since reordering only updates the moved shapes' indices, it doesn't interfere with other concurrent edits to different shapes.

## Index validation

`IndexKey` is a branded type - you can't accidentally pass an arbitrary string as an index. Use `validateIndexKey` to check if a string is valid:

```ts
import { validateIndexKey } from '@tldraw/utils'

validateIndexKey('a1') // passes, 'a1' is a valid index
validateIndexKey('invalid!') // throws an error
```

The store validates indices when you create or update shapes, so the editor won't enter an invalid state.

## Related

- [Layer panel example](/examples/ui/layer-panel) - Shows shape hierarchy and z-order in a custom panel

--------

# Shape transforms

The shape transform system provides operations for manipulating multiple shapes together as a unified group. These operations include grouping and ungrouping shapes into hierarchical containers, aligning shapes to common edges or centers, distributing shapes with even spacing, stacking shapes with consistent gaps, packing shapes into compact grid arrangements, flipping shapes along horizontal or vertical axes, and rotating shapes around a common pivot point.

All transform operations respect the editor's parent-child coordinate system and work seamlessly with shapes that have different parents or rotations. Shapes connected by arrow bindings automatically move together as clusters, preserving diagram relationships during transforms.

## Transform operations

The editor provides seven primary transform operations, each accessible through a dedicated method on the Editor class. These methods accept either shape IDs or shape objects and typically operate on the current selection. The operations fall into two categories: structural transforms (grouping) that change the shape hierarchy, and spatial transforms (alignment, distribution, stacking, packing, flipping, rotation) that reposition shapes without changing their parent relationships.

### Grouping and ungrouping

Grouping creates a new group shape that serves as a parent container for the selected shapes. The editor calculates a common ancestor for all shapes being grouped and creates the group at the appropriate position in the hierarchy. When shapes are grouped, they are reparented to the new group container, maintaining their visual positions on the page while changing their coordinate space to be relative to the group.

```typescript
editor.groupShapes([shape1, shape2, shape3])
editor.ungroupShapes([groupShape])
```

Ungrouping reverses this process by moving the group's children back to the group's parent and removing the group shape itself. The shapes maintain their page positions but return to using their original parent's coordinate space.

### Alignment

Alignment moves shapes so they share a common edge or center line. The editor supports six alignment operations: left, right, top, bottom, center-horizontal, and center-vertical. When aligning shapes, the editor first calculates the common bounding box of all selected shapes, then moves each shape to align with the appropriate edge or center of that common box.

```typescript
editor.alignShapes(editor.getSelectedShapeIds(), 'left')
editor.alignShapes([box1, box2], 'center-vertical')
```

Shapes connected by arrow bindings move together as a cluster during alignment. This ensures that if shape A is bound to shape B by an arrow, and you align shape A with shape C, then shape B will move along with shape A to maintain the arrow relationship.

### Distribution

Distribution spaces shapes evenly between the outermost shapes in a selection. The editor identifies the first and last shapes based on their positions, then calculates the gap needed to distribute the remaining shapes evenly in the space between them. This can create negative gaps if shapes overlap.

```typescript
editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
editor.distributeShapes([box1, box2, box3], 'vertical')
```

Distribution requires at least three shape clusters. Like alignment, shapes connected by arrows form clusters that move together, so the actual number of moveable units may be less than the number of selected shapes.

### Stacking

Stacking arranges shapes in a sequence with consistent gaps between them. Unlike distribution, which spaces shapes within a fixed range, stacking positions each shape relative to the previous one with a specified gap. The gap can be explicitly provided or calculated automatically by detecting existing patterns in the current spacing.

```typescript
editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal', 16)
editor.stackShapes([box1, box2, box3], 'vertical')
```

When no gap is specified and automatic gap detection is used, the editor analyzes the current spacing between shapes to find the most common gap or calculates an average if no pattern exists.

### Packing

Packing arranges shapes into a compact grid layout using a bin-packing algorithm based on potpack. The editor groups shapes by their parent containers, then arranges each group into an efficient rectangular grid. The packed arrangement is centered on the shapes' original center point, minimizing the distance shapes need to move.

```typescript
editor.packShapes(editor.getSelectedShapeIds(), 8)
editor.packShapes([box1, box2, box3, box4])
```

Packing is particularly useful for cleaning up scattered shapes or creating organized layouts from randomly positioned elements. The gap parameter controls the padding between packed shapes.

### Flipping

Flipping mirrors shapes along either the horizontal or vertical axis. The operation uses the center point of all selected shapes' common bounding box as the flip origin. Shapes are scaled by -1 on the appropriate axis, which inverts their position and visual appearance while maintaining their size.

```typescript
editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal')
editor.flipShapes([box1, box2], 'vertical')
```

When flipping groups, the editor automatically includes all children of the group to ensure the entire hierarchy is flipped together. Some shapes may opt out of flipping by returning false from their ShapeUtil's canBeLaidOut method.

### Rotation

Rotation spins shapes around a common center point. The editor calculates the collective center of all selected shapes, then rotates each shape both around that center point and around its own center. This produces the expected result where shapes orbit the selection center while also rotating individually.

```typescript
editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 4)
```

The rotation system maintains a snapshot of the initial shape positions and rotations, allowing for smooth incremental updates during drag operations. Shape utilities can respond to rotation events through the onRotateStart, onRotate, and onRotateEnd methods.

## Parent coordinate transforms

All transform operations handle parent coordinate spaces correctly. When a shape has a rotated parent, the editor converts page-space movement deltas back into the parent's local coordinate space before updating the shape's position. This ensures that moving a child shape always produces the correct visual result regardless of parent rotation or nesting depth.

The conversion process uses the parent's page transform matrix to inverse-rotate the delta vector. For example, if a parent is rotated 45 degrees and you want to move a child 10 pixels to the right in page space, the editor calculates what movement in the parent's coordinate space would produce that page-space result.

```typescript
const parent = editor.getShapeParent(shape) // [1]
if (parent) {
	const parentTransform = editor.getShapePageTransform(parent) // [2]
	if (parentTransform) shapeDelta.rot(-parentTransform.rotation()) // [3]
}
```

1. Get the shape's parent to check if coordinate conversion is needed
2. Retrieve the parent's full page transform matrix (position, rotation, scale)
3. Rotate the movement delta by the negative of the parent's rotation to convert from page space to parent space

This parent transform handling is critical for operations like align, distribute, and stack, which calculate movement in page space but must apply it in each shape's local space.

## Shape clustering via arrow bindings

Several transform operations group shapes into clusters based on arrow bindings. When shapes are connected by arrows, they form a logical unit that should move together during transforms. The editor uses a recursive algorithm to collect all shapes connected through arrow bindings, starting from each selected shape and traversing the binding graph.

The clustering algorithm maintains a visited set to avoid processing shapes multiple times and only includes shapes that were part of the initial selection. This means that if A connects to B via an arrow, but only A is selected, then B will not be included in the transform unless B is also explicitly selected.

Each cluster is treated as a single unit with a common bounding box. When the transform calculates movement for the cluster, it applies that movement to all shapes in the cluster, maintaining their relative positions and arrow relationships.

## Shape utility integration

Shape utilities can control whether their shapes participate in transforms through the canBeLaidOut method. This method receives information about the transform type and the full list of shapes being transformed, allowing the utility to make context-aware decisions.

```typescript
canBeLaidOut(shape: MyShape, info: TLShapeUtilCanBeLaidOutOpts): boolean {
  // type is one of: 'align' | 'distribute' | 'pack' | 'stack' | 'flip' | 'stretch'
  return true
}
```

For rotation operations, shape utilities can respond to rotation lifecycle events. The onRotateStart method is called when rotation begins, onRotate is called for each update, and onRotateEnd is called when rotation completes. These methods can return shape partials to modify the shape during rotation.

## Related examples

- **[Keyboard shortcuts](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/keyboard-shortcuts)** - Customize shortcuts for align, distribute, and other transform operations.
- **[Selection UI](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/selection-ui)** - Build custom controls that can trigger transform operations on selected shapes.

--------

# Shapes

Shapes are the fundamental content elements on the tldraw canvas. Every rectangle, arrow, text box, and freehand stroke is a shape. The shape system separates data from behavior: shape records store immutable data in the store, while ShapeUtil classes define how each shape type renders, responds to interaction, and computes its geometry. This separation keeps the data layer simple and portable while allowing complex per-shape behavior. Shapes support parent-child hierarchies for grouping and frames, participate in a reactive rendering pipeline, and integrate with the binding system to form relationships with other shapes.

## Shape records

A shape record is a plain object stored in the editor's reactive store. All shape types extend `TLBaseShape`, which defines the common properties every shape has: a unique identifier, position and rotation, z-ordering index, parent reference, lock state, opacity, and a `props` field for shape-specific properties. The `props` field contains data unique to each shape type. A geo shape stores its width, height, and geometry type. A text shape stores its text content and font size. Each shape type defines its own props structure.

### Shape types in tldraw

The default tldraw installation includes these shape types:

| Category   | Types                                 |
| ---------- | ------------------------------------- |
| Basic      | `geo`, `text`, `note`                 |
| Drawing    | `draw`, `line`, `highlight`           |
| Media      | `image`, `video`, `bookmark`, `embed` |
| Structural | `frame`, `group`                      |
| Connectors | `arrow`                               |

Each type has a corresponding ShapeUtil that implements its behavior.

### Creating and accessing shapes

The editor provides methods for working with shape records. Create shapes with `createShape`, passing the shape type, position, and props. Get shapes by ID with `getShape`, or get all shapes on the current page with `getCurrentPageShapes`. Update shapes with `updateShape`, passing the shape ID and properties to change. Delete shapes with `deleteShape`.

```typescript
// Create a geo shape
editor.createShape({
	type: 'geo',
	x: 100,
	y: 100,
	props: { w: 200, h: 150, geo: 'rectangle' },
})

// Get a shape by ID
const shape = editor.getShape(shapeId)

// Update a shape's position
editor.updateShape({ id: shape.id, x: 200 })
```

Shapes are immutable records. When you update a shape, the editor creates a new record with the changes and stores it, replacing the old one. This immutability enables efficient change detection and undo/redo.

## ShapeUtil

A ShapeUtil class defines how a shape type behaves. The editor maintains one ShapeUtil instance per shape type, and uses it for all shapes of that type. ShapeUtil is an abstract class with required and optional methods that control rendering, geometry, and interaction.

### Required methods

Every ShapeUtil must implement four methods: `getDefaultProps` returns default property values for new shapes, `getGeometry` returns a mathematical representation for hit testing and bounds calculation, `component` returns a React component that renders the shape, and `indicator` returns an SVG element for the selection outline.

```typescript
class MyShapeUtil extends ShapeUtil<MyShape> {
	static override type = 'my-shape' as const

	getDefaultProps(): MyShape['props'] {
		return { w: 100, h: 100 }
	}

	getGeometry(shape: MyShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(shape: MyShape): JSX.Element {
		return <div style={{ width: shape.props.w, height: shape.props.h }} />
	}

	indicator(shape: MyShape): JSX.Element {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

### Capability methods

ShapeUtils can override capability methods to declare what interactions the shape supports. These methods return booleans indicating whether the shape can be edited, resized, cropped, scrolled, or bound to other shapes. The `canReceiveNewChildrenOfType` method controls whether the shape can contain other shapes as children.

### Lifecycle hooks

ShapeUtils can respond to shape changes through lifecycle hooks. The `onBeforeCreate` and `onBeforeUpdate` hooks intercept shape creation and updates before they reach the store, allowing modification or validation. The `onResize`, `onRotate`, and `onTranslate` hooks respond to transformation operations. The `onChildrenChange` hook responds to changes in a shape's children. Interaction hooks like `onDoubleClick`, `onDragShapesOver`, and `onDropShapesOver` enable custom behavior for user interactions.

The `onResize` hook requires careful implementation. When a shape resizes, the hook receives resize information including the scale factors and the handle being dragged. It returns a partial update containing just the props you want to change (without the `id` or `type`):

```typescript
onResize(shape: MyShape, info: TLResizeInfo<MyShape>) {
	return {
		props: {
			w: shape.props.w * info.scaleX,
			h: shape.props.h * info.scaleY,
		},
	}
}
```

### Static properties

ShapeUtil classes use static properties for type registration and schema configuration:

```typescript
class MyShapeUtil extends ShapeUtil<MyShape> {
	static override type = 'my-shape' as const

	// Define props validators (including style props)
	static override props = {
		w: T.number,
		h: T.number,
		color: DefaultColorStyle, // StyleProp instances are recognized automatically
	}

	// Define migrations for schema evolution
	static override migrations = defineMigrations({
		currentVersion: 1,
		migrators: {
			1: {
				up: (shape) => ({ ...shape, props: { ...shape.props, newProp: 'default' } }),
				down: (shape) => {
					const { newProp, ...rest } = shape.props
					return { ...shape, props: rest }
				},
			},
		},
	})
}
```

### Configuring built-in shapes

Use [`ShapeUtil.configure`](/reference/editor/reference/editor/ShapeUtil#configure) to customize options on built-in shape utilities without subclassing them:

```typescript
import { GeoShapeUtil, Tldraw } from 'tldraw'

// Create a configured version with custom options
const ConfiguredGeoShapeUtil = GeoShapeUtil.configure({
	canCrop: false,
	hideSelectionBoundsFg: true,
})

function App() {
	return <Tldraw shapeUtils={[ConfiguredGeoShapeUtil]} />
}
```

This is useful for changing behavior like `canCrop`, `canResize`, or `canEdit` without creating a full custom ShapeUtil.

### Registering ShapeUtils

Register custom ShapeUtils when initializing tldraw by passing them to the `shapeUtils` prop. The editor creates one instance of each ShapeUtil and uses it for all shapes of that type.

## Geometry system

The geometry system provides mathematical representations of shapes for hit testing, bounds calculation, snapping, and collision detection. Every ShapeUtil returns a [`Geometry2d`](/reference/editor/reference/editor/Geometry2d) instance from its `getGeometry` method. The system includes geometry classes for common shapes: [`Rectangle2d`](/reference/editor/reference/editor/Rectangle2d) for axis-aligned rectangles, [`Circle2d`](/reference/editor/reference/editor/Circle2d) for true circles (with center and radius), [`Ellipse2d`](/reference/editor/reference/editor/Ellipse2d) for ellipses with different width/height, [`Polygon2d`](/reference/editor/reference/editor/Polygon2d) for arbitrary closed polygons, [`Polyline2d`](/reference/editor/reference/editor/Polyline2d) for open paths, [`Arc2d`](/reference/editor/reference/editor/Arc2d) for circular arcs, [`Stadium2d`](/reference/editor/reference/editor/Stadium2d) for rounded rectangles, and [`Group2d`](/reference/editor/reference/editor/Group2d) for composite geometry.

### Key geometry operations

Geometry2d provides methods for spatial queries. Get the axis-aligned bounding box with the `bounds` property. Get boundary vertices with `getVertices`. Find the nearest point on the shape boundary with `nearestPoint`. Test if a point hits the shape with `hitTestPoint`, which accepts a `margin` parameter that expands the hit area and a `hitInside` parameter that controls whether points inside the shape count as hits for unfilled shapes. Test line segment intersection with `hitTestLineSegment` or get intersection points with `intersectLineSegment`.

### Geometry caching

The editor caches geometry computations to avoid recalculating bounds and hit test data on every frame. Without caching, dragging a selection box over hundreds of shapes would recompute each shape's geometry repeatedly, causing noticeable lag. The cache invalidates automatically when a shape's props change. Access cached geometry with `getShapeGeometry` or cached page bounds (geometry combined with transforms) with `getShapePageBounds`.

## Shape rendering

The editor renders shapes through a React component hierarchy. Each shape is wrapped in a container that handles positioning, transforms, and culling. When a shape renders, the editor computes the shape's page transform by combining its local position and rotation with all ancestor transforms, extracts bounds from the shape's geometry, skips rendering if the shape is outside the viewport and supports culling, renders the shape's visual content through the ShapeUtil's `component` method, and if selected, renders the selection outline through the `indicator` method.

### Transform composition

Shapes position relative to their parent's coordinate space. For a shape nested inside a rotated frame, the editor composes transforms. Get the transform from shape space to page space with `getShapePageTransform`. Get just the local transform with `getShapeLocalTransform`. Convert a page point to shape-local coordinates with `getPointInShapeSpace`.

### Opacity

Shape opacity multiplies with parent opacity. A shape at 50% opacity inside a frame at 50% opacity renders at 25% opacity. Access a shape's opacity directly from the shape record via `shape.opacity`. The editor computes the final rendered opacity by combining the shape's opacity with all ancestor opacities.

## Shape lifecycle

Shapes go through creation, updates, and deletion. The editor provides hooks and events at each stage.

### Creation flow

When `createShape` is called, the editor assigns an ID if none provided, determines the parent either explicitly, inferred from position, or defaults to the current page, calculates the fractional index for z-ordering, calls `ShapeUtil.onBeforeCreate` for any modifications, validates the shape against the schema, and stores the shape in the store.

### Update flow

When `updateShape` is called, the editor checks if the shape or an ancestor is locked, merges the partial update with the existing shape, calls `ShapeUtil.onBeforeUpdate` for any modifications, validates and stores the updated shape, and emits update events.

### Deletion flow

When `deleteShape` is called, the editor collects all descendant shapes, removes bindings involving the shapes, calls deletion side effects, and removes all shapes from the store. Deleting a frame or group deletes all its children. Bindings are automatically cleaned up, and connected shapes receive isolation callbacks to update their state.

## Parent-child relationships

Shapes can be parented to pages or other shapes. This creates a hierarchy used for grouping, frames, and coordinate transforms.

### Frames

Frames are container shapes that clip their children and provide a visual boundary. Shapes inside a frame position relative to the frame's origin. Moving the frame moves all its children. The frame clips content at its boundaries during rendering. See [Shape clipping](/sdk-features/shape-clipping) for details on implementing custom clipping shapes.

### Groups

Groups are logical containers without visual representation. Group selected shapes with `groupShapes`. Ungroup with `ungroupShapes`. Groups exist only to organize shapes. Their geometry is the union of their children's geometry. When you delete the last child of a group, the group deletes itself.

### Focused groups

The editor tracks a **focused group** that defines the current editing scope. When you double-click a group, it becomes focused, and you can select and edit shapes inside it. Get the current focused group with `getFocusedGroup`. Focus a specific group with `setFocusedGroup`. Exit the focused group with `popFocusedGroupId`.

## Coordinate spaces

The editor works with multiple coordinate spaces. Screen space uses the browser viewport top-left as the origin for mouse events and UI positioning. Page space uses the canvas origin at (0,0) for shape positions and bounds. Parent space uses the parent shape's top-left for nested shape positions. Local space uses the shape's own top-left for shape-internal coordinates.

The editor provides methods to convert between spaces. Convert screen points to page points with `screenToPage`. Convert page points to screen points with `pageToScreen`. Convert page points to shape-local coordinates with `getPointInShapeSpace`. Get a shape's page-space transform matrix with `getShapePageTransform`.

## Shape derivations

The editor maintains computed derivations that update automatically as shapes change.

### Parents to children index

Maps parent IDs to sorted arrays of child shape IDs. Updated incrementally as shapes are added, removed, or reparented. Get children of a shape or page, sorted by z-index, with `getSortedChildIdsForParent`.

### Culled shapes

Tracks which shapes are outside the viewport. Shapes whose ShapeUtil returns `true` from `canCull()` are candidates for culling. Culled shapes are still in the DOM but have their `display` set to `none` for performance. Check if a shape is currently culled with `getCulledShapes().has(shapeId)`.

### Shape geometry cache

Caches geometry computations per shape. Invalidates when shape props change. Access through `getShapeGeometry`, which returns cached geometry and only recomputes when needed.

## Related examples

- **[Custom shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-shape)** - A simple custom shape demonstrating basic ShapeUtil implementation.
- **[Editable custom shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/editable-shape)** - A custom shape that can be edited by double-clicking it, showing how to use the editing state.
- **[Clickable custom shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/interactive-shape)** - A custom shape with onClick interactions demonstrating pointer event handling.
- **[Custom shape geometry](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-with-geometry)** - A house-shaped custom shape demonstrating custom geometry implementation.
- **[Custom shape with custom styles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-with-custom-styles)** - Shows how to create your own styles and use them in custom shapes.
- **[Custom shape with tldraw styles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-with-tldraw-styles)** - Use tldraw's default styles in your custom shapes.
- **[Custom shape migrations](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-with-migrations)** - Migrate shapes and their data between versions using the migrations system.
- **[Custom shape with handles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/speech-bubble)** - A speech bubble shape with custom handles for interaction.
- **[Shape options](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/configure-shape-util)** - Change the behavior of built-in shapes by setting their options via ShapeUtil.configure.
- **[Custom snapping](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/bounds-snapping-shape)** - Custom shapes with special bounds snapping behavior, demonstrated with playing cards.
- **[Cubic bezier curve shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/cubic-bezier-shape)** - A custom shape with interactive bezier curve editing using draggable control handles.
- **[Data grid shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/ag-grid-shape)** - A custom shape that renders AG Grid, showing complex component integration.
- **[Popup shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/popup-shape)** - Create a 3D illusion of depth with dynamic shadows and CSS transforms.
- **[Custom clipping shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-clipping-shape)** - Custom shapes that can clip their children with any polygon geometry.
- **[DOM-based shape size](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/size-from-dom)** - A custom shape whose size is derived from its rendered DOM.

--------

# Side effects

Side effects are lifecycle hooks that run when records are created, updated, or deleted. You can use them to intercept and modify records, validate changes, or react to completed operations by updating related data.

The editor uses side effects internally to keep data consistent. When you delete a shape, the editor automatically removes its bindings. When a binding changes, the connected shapes get notified to update. These hooks let independent parts of the system stay in sync without being directly coupled.

## How it works

### Before and after handlers

Side effects provide six handler types organized around three operations: create, change, and delete. Each operation has a "before" and "after" phase.

**Before handlers** run during the operation and can modify or block changes:

- `beforeCreate` transforms records before creation. Return a modified record to change what gets stored.
- `beforeChange` intercepts updates. Return the previous record to block the change, or return a modified record.
- `beforeDelete` can return `false` to prevent deletion.

**After handlers** run once the operation completes. They can't modify the record that triggered them, but they can update other records:

- `afterCreate` reacts to new records by updating related data.
- `afterChange` responds to updates by maintaining relationships.
- `afterDelete` cleans up orphaned references or cascades deletions.

The key distinction: use before handlers to modify the record being operated on, and after handlers to update other records in response.

### Source tracking

Every handler receives a `source` parameter indicating whether the change came from user interaction (`'user'`) or remote synchronization (`'remote'`). This lets you handle local and synced changes differently:

```typescript
editor.sideEffects.registerAfterCreateHandler('shape', (shape, source) => {
	if (source === 'user') {
		logUserAction('created shape', shape.type)
	}
})
```

You might auto-save only after user operations, or skip validation for trusted remote data.

### Registration and cleanup

Register side effects using the type-specific methods on `editor.sideEffects`. Each method returns a cleanup function you can call to remove the handler:

```typescript
const cleanup = editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
	// Clean up bindings involving the deleted shape
	const bindings = editor.getBindingsInvolvingShape(shape.id)
	if (bindings.length) {
		editor.deleteBindings(bindings)
	}
})

// Later, when no longer needed
cleanup()
```

### Execution order

Handlers execute in registration order. If you register three `afterCreate` handlers for shapes, they run in the sequence they were registered. This matters when handlers depend on each other's effects.

Side effects run within store transactions. All before handlers complete before any after handlers run. The `operationComplete` handler runs last, after all individual record handlers finish.

## Use cases

### Constraining shape positions

Before handlers can enforce constraints on records. This example keeps shapes within a certain area by returning a modified record:

```typescript
editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
	if (next.x < 0 || next.y < 0) {
		return prev // Block the change by returning the previous record
	}
	return next
})
```

### Cascading deletions

You can delete related shapes when a parent is removed. This example deletes empty frames:

```typescript
editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
	const parent = editor.getShape(shape.parentId)
	if (parent && parent.type === 'frame') {
		const siblings = editor.getSortedChildIdsForParent(parent.id)
		if (siblings.length === 0) {
			editor.deleteShape(parent.id)
		}
	}
})
```

### Batch processing with operationComplete

The `operationComplete` handler runs once after all changes in a transaction finish. Use it for expensive operations that should happen once per batch rather than on every record change:

```typescript
editor.sideEffects.registerOperationCompleteHandler((source) => {
	if (source === 'user') {
		scheduleAutosave()
	}
})
```

## Related examples

- [Before create/update shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/before-create-update-shape) - Constrain shapes to a circular area
- [Before delete shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/before-delete-shape) - Prevent deletion of certain shapes
- [After create/update shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/after-create-update-shape) - Ensure only one red shape exists at a time
- [After delete shape](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/after-delete-shape) - Delete empty frames automatically
- [Shape meta (on create)](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/meta-on-create) - Add creation timestamps to shapes
- [Shape meta (on change)](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/meta-on-change) - Track modification history

--------

# Signals

The tldraw SDK uses signals for state management. Signals automatically track dependencies and update efficiently: when state changes, only the parts of your application that depend on that state will update.

The editor exposes many of its internal values as signals. Methods like `editor.getSelectedShapeIds()` and `editor.getCurrentPageShapes()` return reactive values that update automatically when the underlying state changes. The React bindings connect these signals to components, so your UI stays in sync without manual subscription management.

## Core concepts

### Atoms

An atom holds a mutable value. When you change the value, any computeds or effects that depend on the atom will update.

```ts
import { atom } from '@tldraw/state'

const count = atom('count', 0)

count.get() // 0
count.set(5)
count.get() // 5

// Update based on current value
count.update((n) => n + 1)
count.get() // 6
```

The first argument is a name for debugging. The second is the initial value. Atoms support a few options:

- `isEqual` — Custom equality function to determine if a value has changed
- `historyLength` — Number of diffs to retain for incremental updates
- `computeDiff` — Function to compute diffs between values

### Computed values

A computed derives its value from other signals. It recomputes only when its dependencies change.

```ts
import { atom, computed } from '@tldraw/state'

const firstName = atom('firstName', 'Jane')
const lastName = atom('lastName', 'Doe')

const fullName = computed('fullName', () => {
	return `${firstName.get()} ${lastName.get()}`
})

fullName.get() // 'Jane Doe'

firstName.set('John')
fullName.get() // 'John Doe' — recomputed automatically
```

Computed values are lazy: they don't calculate until you call `.get()`. They also cache their result. If you call `.get()` multiple times without any dependencies changing, the derivation function runs only once.

The `@computed` decorator provides the same functionality for class methods:

```ts
import { atom, computed } from '@tldraw/state'

class Counter {
	count = atom('count', 0)

	@computed getDoubled() {
		return this.count.get() * 2
	}
}
```

### Effects and reactors

Effects run side effects in response to signal changes. There are two ways to create them:

```ts
import { atom, react, reactor } from '@tldraw/state'

const count = atom('count', 0)

// react() starts immediately and returns a cleanup function
const stop = react('log count', () => {
	console.log('Count is:', count.get())
})

count.set(1) // logs: Count is: 1
count.set(2) // logs: Count is: 2

stop() // Stop listening

// reactor() gives you control over when to start
const r = reactor('log count', () => {
	console.log('Count is:', count.get())
})

r.start() // Begin listening
r.stop() // Stop listening
```

Effects track which signals they read and re-run when those signals change. The `scheduleEffect` option lets you batch updates, for example using `requestAnimationFrame`:

```ts
react(
	'update-dom',
	() => {
		// DOM updates based on signal state
	},
	{
		scheduleEffect: (execute) => requestAnimationFrame(execute),
	}
)
```

### Transactions

Transactions batch multiple changes into a single update. Effects only run once after all changes complete:

```ts
import { atom, react, transact } from '@tldraw/state'

const a = atom('a', 1)
const b = atom('b', 2)

react('sum', () => {
	console.log('Sum:', a.get() + b.get())
})

// Without transaction: effect runs twice
a.set(10) // logs: Sum: 12
b.set(20) // logs: Sum: 30

// With transaction: effect runs once
transact(() => {
	a.set(100)
	b.set(200)
})
// logs: Sum: 300
```

The `transaction` function supports rollback:

```ts
import { transaction } from '@tldraw/state'

transaction((rollback) => {
	a.set(999)
	if (somethingWentWrong) {
		rollback() // Restores original values
	}
})
```

## React integration

The `@tldraw/state-react` package connects signals to React components.

### useValue

The most common hook. It reads a signal value and subscribes the component to changes:

```tsx
import { atom } from '@tldraw/state'
import { useValue } from '@tldraw/state-react'

const count = atom('count', 0)

function Counter() {
	const value = useValue(count)
	return <div>Count: {value}</div>
}
```

You can also compute a value inline with a dependency array:

```tsx
function ShapeInfo({ editor }) {
	const selectedCount = useValue('selected count', () => editor.getSelectedShapeIds().length, [
		editor,
	])
	return <div>{selectedCount} shapes selected</div>
}
```

### track

The `track` higher-order component automatically tracks signal access during render:

```tsx
import { track } from '@tldraw/state-react'

const Counter = track(function Counter() {
	return <div>Count: {count.get()}</div>
})
```

Tracked components re-render when any signal accessed during render changes. This is the pattern used throughout tldraw's internal components. The component is also wrapped in `React.memo`, so it only re-renders when props change or tracked signals update.

### useAtom and useComputed

Create component-local signals that persist across renders:

```tsx
import { useAtom, useComputed } from '@tldraw/state-react'

function Counter() {
	const count = useAtom('count', 0)
	const doubled = useComputed('doubled', () => count.get() * 2, [count])

	return (
		<div>
			<button onClick={() => count.update((n) => n + 1)}>Increment</button>
			<div>Count: {count.get()}</div>
			<div>Doubled: {doubled.get()}</div>
		</div>
	)
}
```

### useReactor and useQuickReactor

Run effects tied to component lifecycle. The effect automatically tracks which signals it reads:

```tsx
import { useReactor, useQuickReactor } from '@tldraw/state-react'

function SelectionLogger({ editor }) {
	// Throttled to next animation frame — good for DOM updates
	useReactor(
		'update title',
		() => {
			const count = editor.getSelectedShapeIds().length
			document.title = `${count} shapes selected`
		},
		[editor]
	)

	// Runs immediately — for critical state synchronization
	useQuickReactor(
		'sync data',
		() => {
			syncToServer(editor.getDocumentState())
		},
		[editor]
	)

	return null
}
```

### useStateTracking

Lower-level hook for manual tracking. This is what `track` uses internally:

```tsx
import { useStateTracking } from '@tldraw/state-react'

function CustomComponent() {
	return useStateTracking('CustomComponent', () => {
		return <div>{someSignal.get()}</div>
	})
}
```

## Signals in the editor

The editor uses signals extensively. Most getter methods return reactive values:

```tsx
function SelectionInfo({ editor }) {
	const selectedShapes = useValue('shapes', () => editor.getSelectedShapes(), [editor])
	const currentPage = useValue('page', () => editor.getCurrentPage(), [editor])
	const zoomLevel = useValue('zoom', () => editor.getZoomLevel(), [editor])

	return (
		<div>
			<div>Page: {currentPage.name}</div>
			<div>Zoom: {Math.round(zoomLevel * 100)}%</div>
			<div>{selectedShapes.length} shapes selected</div>
		</div>
	)
}
```

You can use `track` for cleaner syntax when accessing many signals:

```tsx
const SelectionInfo = track(function SelectionInfo({ editor }) {
	const shapes = editor.getSelectedShapes()
	const page = editor.getCurrentPage()
	const zoom = editor.getZoomLevel()

	return (
		<div>
			<div>Page: {page.name}</div>
			<div>Zoom: {Math.round(zoom * 100)}%</div>
			<div>{shapes.length} shapes selected</div>
		</div>
	)
})
```

## Debugging

The `whyAmIRunning` function helps trace what triggered an update. Call it inside an effect or computed to see which signals changed:

```ts
import { atom, react, whyAmIRunning } from '@tldraw/state'

const name = atom('name', 'Bob')

react('greeting', () => {
	whyAmIRunning()
	console.log('Hello', name.get())
})

name.set('Alice')
// Console output:
// Effect(greeting) is executing because:
//  ↳ Atom(name) changed
```

For nested dependencies, the output shows the full chain:

```ts
const firstName = atom('firstName', 'Jane')
const lastName = atom('lastName', 'Doe')
const fullName = computed('fullName', () => `${firstName.get()} ${lastName.get()}`)

react('log name', () => {
	whyAmIRunning()
	console.log(fullName.get())
})

firstName.set('John')
// Console output:
// Effect(log name) is executing because:
//  ↳ Computed(fullName) changed
//    ↳ Atom(firstName) changed
```

All signals have a `name` property (the first argument when creating them) that appears in debug output.

## Reading without tracking

Sometimes you want to read a signal's value without creating a dependency. Use `unsafe__withoutCapture` to read signals without triggering re-runs:

```ts
import { atom, react, unsafe__withoutCapture } from '@tldraw/state'

const name = atom('name', 'Sam')
const time = atom('time', Date.now())

// Update time every second
setInterval(() => time.set(Date.now()), 1000)

react('log name changes', () => {
	// Only re-run when name changes, not when time changes
	const currentTime = unsafe__withoutCapture(() => time.get())
	console.log(name.get(), 'was changed at', currentTime)
})
```

## API reference

### @tldraw/state

| Export                       | Description                                                     |
| ---------------------------- | --------------------------------------------------------------- |
| `atom(name, value, options)` | Create a mutable signal                                         |
| `computed(name, fn)`         | Create a derived signal                                         |
| `@computed`                  | Decorator for computed class methods                            |
| `react(name, fn, options)`   | Run an effect immediately, returns cleanup function             |
| `reactor(name, fn, options)` | Create a controllable effect with `start()` and `stop()`        |
| `transact(fn)`               | Batch changes into a single update                              |
| `transaction(fn)`            | Batch changes with rollback support                             |
| `isAtom(value)`              | Type guard for atoms                                            |
| `isSignal(value)`            | Type guard for any signal                                       |
| `getComputedInstance(o, p)`  | Get the underlying computed for a `@computed` decorated method  |
| `whyAmIRunning()`            | Debug helper to trace update triggers                           |
| `unsafe__withoutCapture(fn)` | Read signals without creating dependencies                      |
| `RESET_VALUE`                | Symbol returned by `getDiffSince` when history is insufficient  |
| `isUninitialized(value)`     | Check if a computed is running its first derivation             |
| `withDiff(value, diff)`      | Manually provide a diff when returning from a computed          |
| `localStorageAtom(name, v)`  | Returns `[atom, cleanup]` tuple; atom persists to localStorage  |
| `deferAsyncEffects(fn)`      | Queue effects for async operations (used internally for stores) |

### @tldraw/state-react

| Export                             | Description                                 |
| ---------------------------------- | ------------------------------------------- |
| `useValue(signal)`                 | Subscribe to a signal, returns its value    |
| `useValue(name, fn, deps)`         | Compute and subscribe to a derived value    |
| `useAtom(name, initialValue)`      | Create a component-local atom               |
| `useComputed(name, fn, deps)`      | Create a component-local computed           |
| `useReactor(name, fn, deps)`       | Effect throttled to animation frames        |
| `useQuickReactor(name, fn, deps)`  | Effect that runs immediately                |
| `useStateTracking(name, renderFn)` | Manual signal tracking for render functions |
| `track(Component)`                 | HOC that tracks signal access during render |

## Related examples

- **[Reactive inputs](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/reactive-inputs)** — Using `useValue` with editor input state.

--------

# Snapping

When you move or resize shapes, tldraw snaps them to key geometry on nearby shapes. This helps users achieve precise alignment without manual measurement.

The editor provides three types of snapping. Bounds snapping aligns edges, centers, and corners during movement and resizing. Handle snapping connects endpoints to outlines and key points, like arrow tips to shape edges. Gap snapping maintains consistent spacing between shapes.

Snap lines appear when shapes come within the snap threshold, giving real-time visual feedback.

## SnapManager

The [`SnapManager`](/reference/editor/reference/editor/SnapManager) coordinates all snapping behavior. Access it at `editor.snaps`:

```typescript
// The two snap systems
editor.snaps.shapeBounds // BoundsSnaps - edge and center alignment
editor.snaps.handles // HandleSnaps - precise point connections

// Shared utilities
editor.snaps.getSnapThreshold() // Distance threshold (8px / zoom)
editor.snaps.getSnappableShapes() // Which shapes can be snapped to
editor.snaps.setIndicators(indicators) // Update visual snap lines
editor.snaps.clearIndicators() // Remove all snap indicators
```

The snap threshold is 8 screen pixels, scaled by the current zoom level. At 100% zoom, shapes snap when within 8 pixels. At 200% zoom, the threshold becomes 4 canvas units (still 8 screen pixels).

### Snappable shape filtering

The `getSnappableShapes()` method determines which shapes can be snapped to. It excludes currently selected shapes (you don't snap to what you're dragging), includes only shapes visible in the viewport for performance, and respects the shape utility's `canSnap()` method for opt-out behavior. Frame shapes are included as snap targets. For groups, the method recurses into children and snaps to them, but not to the group itself.

The method returns a computed set that updates reactively as shapes move, selection changes, or the viewport pans.

## Bounds snapping

Bounds snapping aligns bounding box edges and centers. When you move or resize shapes, the [`BoundsSnaps`](/reference/editor/reference/editor/BoundsSnaps) system compares snap points on the selection against snap points on nearby shapes.

### Snap points

Each shape defines snap points through [`ShapeUtil.getBoundsSnapGeometry`](/reference/editor/reference/editor/ShapeUtil#getBoundsSnapGeometry). By default, shapes snap to their bounding box corners and center. Override this to provide custom snap points:

```typescript
class MyShapeUtil extends ShapeUtil<MyShape> {
	getBoundsSnapGeometry(shape: MyShape): BoundsSnapGeometry {
		return {
			points: [
				{ x: 0, y: 0 },
				{ x: shape.props.w, y: 0 },
				{ x: shape.props.w / 2, y: shape.props.h / 2 },
			],
		}
	}
}
```

To disable snapping to a shape entirely, return `{ points: [] }`.

### Translation snapping

When moving shapes, `snapTranslateShapes()` finds the nearest snap alignment in each axis:

```typescript
const snapData = editor.snaps.shapeBounds.snapTranslateShapes({
	lockedAxis: null, // or 'x' | 'y' to constrain to one axis
	initialSelectionPageBounds: selectionBounds,
	initialSelectionSnapPoints: selectionSnapPoints,
	dragDelta: delta,
})

// Apply the nudge to achieve snapping
const snappedDelta = Vec.Add(delta, snapData.nudge)
```

The returned `nudge` vector indicates how much to adjust the drag delta to achieve alignment. When multiple shapes align at the same distance, the system displays all of them.

### Resize snapping

When resizing, `snapResizeShapes()` snaps the corners and edges being moved. Which snap points are used depends on the resize handle:

- Corner handles snap both x and y axes using that corner
- Edge handles snap only the perpendicular axis using both corners on that edge
- When aspect ratio is locked, the dominant snap axis determines both

```typescript
const snapData = editor.snaps.shapeBounds.snapResizeShapes({
	initialSelectionPageBounds: selectionBounds,
	dragDelta: delta,
	handle: 'bottom_right',
	isAspectRatioLocked: false,
	isResizingFromCenter: false,
})
```

### Gap snapping

Gap snapping maintains consistent spacing between shapes. The system detects gaps between adjacent shapes and provides three types of snapping.

Gap center snapping centers the selection within a gap larger than itself, creating equal spacing on both sides. Gap duplication snapping duplicates an existing gap on the opposite side of a shape. For example, if two shapes have a 100px gap between them, dragging a third shape snaps to create another 100px gap. Adjacent gap detection finds all gaps with matching lengths and displays them together, helping maintain consistent spacing across many shapes.

Gaps are calculated separately for horizontal and vertical directions. A gap exists when two shapes don't overlap in one axis but have overlapping ranges in the perpendicular axis.

## Handle snapping

Handle snapping enables precise connections between shapes. When dragging a handle (like an arrow endpoint), the [`HandleSnaps`](/reference/editor/reference/editor/HandleSnaps) system snaps to nearby geometry.

### Handle snap geometry

Shapes define what handles can snap to through [`ShapeUtil.getHandleSnapGeometry`](/reference/editor/reference/editor/ShapeUtil#getHandleSnapGeometry). The method returns an object with these properties:

| Property               | Description                                                                                                                 |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| `outline`              | A `Geometry2d` describing the shape's outline. Defaults to the shape's geometry. Set to `null` to disable outline snapping. |
| `points`               | Key points on the shape to snap to. These have higher priority than outlines.                                               |
| `getSelfSnapOutline()` | Returns a stable outline for snapping to the shape's own geometry.                                                          |
| `getSelfSnapPoints()`  | Returns stable points for self-snapping.                                                                                    |

```typescript
class MyShapeUtil extends ShapeUtil<MyShape> {
	getHandleSnapGeometry(shape: MyShape): HandleSnapGeometry {
		return {
			outline: this.getGeometry(shape),
			points: [
				{ x: 0, y: 0 },
				{ x: shape.props.w, y: shape.props.h },
			],
		}
	}
}
```

By default, handles cannot snap to their own shape. Moving the handle would change the snap target, creating feedback loops. The `getSelfSnapOutline()` and `getSelfSnapPoints()` methods enable opt-in self-snapping when the snap geometry remains stable regardless of handle position.

### Snap types

Handles support two snap types controlled by the `snapType` property on [`TLHandle`](/reference/tlschema/reference/tlschema/TLHandle).

Point snapping (`snapType: 'point'`) snaps to the single nearest location. The system checks snap points first, then falls back to the nearest point on any outline. This magnetizes to a single best target.

Align snapping (`snapType: 'align'`) snaps to align with nearby points on both x and y axes independently, showing perpendicular snap lines in each direction.

Each handle uses one snap type based on its `snapType` property. Snap points always have higher priority than outlines.

> **Note:** The older `canSnap` property on handles is deprecated. Use `snapType: 'point'` or `snapType: 'align'` instead.

### Snapping handles

Tools call `snapHandle()` to snap a handle position:

```typescript
// Get the handle from the shape (TLHandle type)
const handle = editor.getShapeHandles(shape)?.find((h) => h.id === handleId)

if (handle) {
	const snapData = editor.snaps.handles.snapHandle({
		currentShapeId: shape.id,
		handle, // TLHandle with x, y, snapType, etc.
	})

	if (snapData) {
		// Apply nudge to achieve snapping
		const snappedPosition = Vec.Add(handle, snapData.nudge)
	}
}
```

The method returns `null` if no snap is found within the threshold, or a `SnapData` object with the `nudge` vector to achieve snapping. Snap indicators are automatically set on the manager for visual feedback.

## Snap indicators

Snap indicators provide visual feedback when snapping occurs. The `SnapManager` maintains a reactive atom of current indicators that the UI renders as SVG overlays.

Two types of indicators exist. Points indicators (`type: 'points'`) display as lines connecting aligned points. When multiple snap points align on the same axis, they appear as a single continuous line spanning all aligned points. Gaps indicators (`type: 'gaps'`) display spacing between shapes with measurement lines at each gap. When multiple equal-sized gaps exist, all matching gaps are shown to highlight the consistent spacing pattern.

The manager automatically deduplicates gap indicators to reduce visual noise. When gap breadths overlap and one is larger than another, only the smaller gap displays because it provides more specific information.

Indicators are cleared automatically when dragging stops or when you call `clearIndicators()`.

## Related examples

For working examples of custom snapping, see:

- [Custom bounds snapping](/examples/bounds-snapping-shape): Create shapes with custom snap geometry so they snap to specific points, like playing cards that stack with visible icons.
- [Custom relative snapping](/examples/custom-relative-snapping): Customize snapping behavior between shapes using getBoundsSnapGeometry.

--------

# Store

The store is tldraw's reactive database. It holds all shapes, pages, bindings, assets, and other records that make up your document. The store is reactive: when data changes, the UI updates automatically. It validates all records against a schema and tracks every change for undo/redo, persistence, and synchronization.

In most cases you won't interact with the store directly—the editor wraps it with higher-level methods like [`Editor.createShapes`](/reference/editor/reference/editor/Editor#createShapes) and [`Editor.getCurrentPageShapes`](/reference/editor/reference/editor/Editor#getCurrentPageShapes). But understanding the store helps when you need snapshots for persistence, want to listen for changes, or need direct access to records.

## Records

Everything in the store is a record. A record is a JSON object with an `id` and a `typeName`. Here's what a shape record looks like:

```ts
{
  id: 'shape:abc123',
  typeName: 'shape',
  type: 'geo',
  x: 100,
  y: 200,
  props: {
    geo: 'rectangle',
    w: 300,
    h: 150,
    color: 'blue',
  },
  // ... other fields
}
```

The `id` is a branded string that includes the type prefix (`shape:`, `page:`, `binding:`). This prevents accidentally mixing up IDs from different record types.

### Record scopes

Records have a scope that determines how they're persisted and synchronized:

| Scope      | Persisted | Synced to other users | Example                          |
| ---------- | --------- | --------------------- | -------------------------------- |
| `document` | Yes       | Yes                   | Shapes, pages, bindings          |
| `session`  | Optional  | No                    | Current page, camera position    |
| `presence` | No        | Yes                   | Cursor positions, user selection |

Document records are your actual drawing data—saved to storage and synced across instances. Session records are local to one editor instance, like which page you're viewing. Presence records sync to other users in real-time but aren't saved—they're for showing cursors and selections in multiplayer.

## Basic operations

### Reading records

The store provides reactive and non-reactive access to records:

```ts
// Reactive — creates a dependency, component will re-render when record changes
const shape = editor.store.get(shapeId)

// Non-reactive — for hot paths where you don't want re-renders
const shape = editor.store.unsafeGetWithoutCapture(shapeId)

// Check if a record exists
const exists = editor.store.has(shapeId)

// Get all records
const allRecords = editor.store.allRecords()
```

The reactive [`Store.get`](/reference/store/reference/store/Store#get) integrates with tldraw's signals system. When you call it inside a tracked component or computed, the component re-renders when that record changes.

### Creating and updating records

The [`Store.put`](/reference/store/reference/store/Store#put) method handles both creation and updates:

```ts
// Create a new record
editor.store.put([
	{
		id: 'shape:my-shape' as TLShapeId,
		typeName: 'shape',
		type: 'geo',
		x: 0,
		y: 0,
		// ... all required fields
	},
])

// Update an existing record (put with same id)
const shape = editor.store.get(shapeId)
editor.store.put([{ ...shape, x: 100 }])
```

The [`Store.update`](/reference/store/reference/store/Store#update) helper is more convenient for single-record updates:

```ts
editor.store.update(shapeId, (shape) => ({
	...shape,
	x: shape.x + 50,
}))
```

### Deleting records

```ts
// Remove specific records
editor.store.remove([shapeId])

// Clear everything
editor.store.clear()
```

## Listening to changes

Subscribe to store changes with [`Store.listen`](/reference/store/reference/store/Store#listen). The callback receives a diff describing what changed:

```ts
const cleanup = editor.store.listen((entry) => {
	// Records that were created
	for (const record of Object.values(entry.changes.added)) {
		console.log('Added:', record.typeName, record.id)
	}

	// Records that were updated [before, after]
	for (const [prev, next] of Object.values(entry.changes.updated)) {
		console.log('Updated:', next.id)
	}

	// Records that were deleted
	for (const record of Object.values(entry.changes.removed)) {
		console.log('Removed:', record.id)
	}
})

// Stop listening
cleanup()
```

### Filtering listeners

You can filter by source and scope:

```ts
// Only listen to user changes (not remote sync)
editor.store.listen(handleChanges, { source: 'user', scope: 'all' })

// Only document records
editor.store.listen(handleChanges, { source: 'all', scope: 'document' })
```

The `source` indicates where the change came from: `'user'` for local edits, `'remote'` for synchronized changes from other users.

For maintaining internal consistency—like cleaning up bindings when a shape is deleted—use [side effects](/docs/side-effects) instead. Side effects are lifecycle hooks that can intercept and modify records during operations.

## Snapshots

Snapshots serialize the store for persistence or transfer.

### Saving state

```ts
import { getSnapshot } from 'tldraw'

// Get a snapshot of document and session state
const { document, session } = getSnapshot(editor.store)

// Save to storage
localStorage.setItem('my-drawing', JSON.stringify({ document, session }))
```

The `document` snapshot contains shapes, pages, bindings, and assets—everything that makes up the drawing itself. The `session` snapshot contains per-instance state like the current page and camera position.

For multiplayer apps, you typically save document state to your server and session state per-user locally.

### Loading state

```ts
import { loadSnapshot } from 'tldraw'

const saved = JSON.parse(localStorage.getItem('my-drawing'))
loadSnapshot(editor.store, saved)
```

See [`getSnapshot`](/reference/editor/reference/editor/getSnapshot) and [`loadSnapshot`](/reference/editor/reference/editor/loadSnapshot) for more details.

You can load document and session separately:

```ts
// Load just the document
loadSnapshot(editor.store, { document: saved.document })

// Later, restore session state
loadSnapshot(editor.store, { session: saved.session })
```

### Initial state

Pass a snapshot to the `Tldraw` component to initialize with saved data:

```tsx
function App() {
	return <Tldraw snapshot={savedSnapshot} />
}
```

### Migrations

Snapshots include schema version information. When you load a snapshot from an older schema version, the store migrates it automatically:

```ts
// Migrate a snapshot without loading it
const migrated = editor.store.migrateSnapshot(oldSnapshot)
```

The migration system handles schema changes between tldraw versions. You can also define custom migrations for your own record types—see [persistence](/docs/persistence) for details.

## Queries

The store provides indexed queries for efficient lookups through [`Store.query`](/reference/store/reference/store/Store#query):

```ts
// Create an index by property value
const shapesByParent = editor.store.query.index('shape', 'parentId')

// Get all shapes with a specific parent
const childShapes = shapesByParent.get().get(frameId) ?? new Set()
```

Indexes are reactive computed values. They update automatically when records change and track dependencies like any other signal.

```ts
// Filter by type and query expression
const textShapes = editor.store.query.records('shape', () => ({
	type: { eq: 'text' },
}))

// Get all records of a type
const allShapes = editor.store.query.records('shape')
```

Query expressions support `eq` for exact matches. The `records()` method returns a computed array that updates when matching records change, while `index()` returns a map from property values to record IDs.

## Transactions

Batch multiple changes into a single update with `Store.atomic`:

```ts
editor.store.atomic(() => {
	editor.store.put([shape1, shape2])
	editor.store.update(shape3Id, (s) => ({ ...s, x: 100 }))
	editor.store.remove([shape4Id])
})
// All changes applied together, listeners notified once
```

Without batching, each operation triggers listeners separately. Transactions ensure observers see a consistent state and reduce re-renders.

## Computed caches

For expensive derived data, use [`Store.createComputedCache`](/reference/store/reference/store/Store#createComputedCache):

```ts
const boundsCache = editor.store.createComputedCache('shape-bounds', (shape: TLShape) => {
	return calculateBounds(shape)
})

// Get cached value (recalculates only when shape changes)
const bounds = boundsCache.get(shapeId)
```

The cache lazily computes values when accessed and invalidates them when the underlying record changes. This is how the editor efficiently maintains shape bounds, geometry, and other derived data.

## Creating a standalone store

Most of the time you use the store through the editor. But you can create a standalone store for testing or headless scenarios using [`createTLStore`](/reference/editor/reference/editor/createTLStore):

```ts
import { createTLStore, loadSnapshot } from 'tldraw'

// Create a store and load saved data
const store = createTLStore()
loadSnapshot(store, savedSnapshot)

// Pass the pre-loaded store to Tldraw
function App() {
	return <Tldraw store={store} />
}
```

Creating your own store is useful when you need to load data before mounting the editor, share a store between multiple components, or work with tldraw data without rendering the editor at all.

## Related examples

- **[Store events](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/store-events)** — Listening to store changes and displaying them in real-time.
- **[Snapshots](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/snapshots)** — Saving and loading editor state with `getSnapshot` and `loadSnapshot`.
- **[Local storage](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/local-storage)** — Persisting to localStorage with throttled saves.

--------

# Styles

The styles system manages visual properties like color, size, font, fill, and dash patterns across shapes. Style properties differ from regular shape properties in two key ways: they apply consistently across multiple shapes at once, and the editor remembers the last-used value to automatically apply it to newly created shapes. This creates a coherent visual experience where users can set a color once and have it persist across their work.

Styles are defined using [`StyleProp`](/reference/tlschema/reference/tlschema/StyleProp) instances that specify valid values and defaults. The editor tracks "shared styles" across the current selection—computing whether all selected shapes share the same value or have different values—to drive the UI and enable batch updates.

## How it works

### StyleProp

A [`StyleProp`](/reference/tlschema/reference/tlschema/StyleProp) represents a reusable style property that can be applied across different shape types. Each `StyleProp` has a unique identifier, a default value, and optional validation. The editor treats `StyleProp` instances specially, automatically saving their values and applying them to new shapes.

You define a `StyleProp` using one of two static methods:

```typescript
import { StyleProp, T } from 'tldraw'

// Define a numeric style property
const LineWidthStyle = StyleProp.define('myApp:lineWidth', {
	defaultValue: 2,
	type: T.number,
})

// Define an enumerated style property
const CapStyle = StyleProp.defineEnum('myApp:cap', {
	defaultValue: 'round',
	values: ['round', 'square', 'butt'],
})
```

The unique identifier should be namespaced to avoid conflicts with other style properties. Use your app or library name as a prefix.

### Shape integration

To use a style property in your shape, include the `StyleProp` instance in your shape's props definition. The editor recognizes `StyleProp` instances and handles them specially: it saves their values, applies them to new shapes, and tracks them across selections.

```typescript
import { DefaultColorStyle, DefaultSizeStyle, RecordProps, T, TLBaseShape } from 'tldraw'

// Define your shape type with the value types for styles
type TLMyShape = TLBaseShape<
	'my-shape',
	{
		w: number
		h: number
		color: string // Will be one of the default color names
		size: string // Will be one of the default size values
	}
>

// Pass StyleProp instances in the props object for validation
const myShapeProps: RecordProps<TLMyShape> = {
	w: T.number,
	h: T.number,
	color: DefaultColorStyle,
	size: DefaultSizeStyle,
}
```

When you create a shape, provide the actual style values. If you omit a style prop, the editor uses its saved value from previous shapes:

```typescript
editor.createShape({
	type: 'my-shape',
	props: {
		w: 100,
		h: 100,
		color: 'red',
		size: 'm',
	},
})
```

### Shared styles

The editor computes shared styles across the current selection. Use [`Editor.getSharedStyles`](/reference/editor/reference/editor/Editor#getSharedStyles) to get a map of each style property to its status: either "shared" (all shapes have the same value) or "mixed" (shapes have different values).

```typescript
const sharedStyles = editor.getSharedStyles()
const colorStyle = sharedStyles.get(DefaultColorStyle)

if (colorStyle && colorStyle.type === 'shared') {
	console.log('All shapes are', colorStyle.value)
} else if (colorStyle && colorStyle.type === 'mixed') {
	console.log('Shapes have different colors')
}
```

For convenience, use `getAsKnownValue` when you only care about the shared case:

```typescript
const sharedStyles = editor.getSharedStyles()
const color = sharedStyles.getAsKnownValue(DefaultColorStyle)
// Returns the color if all shapes share it, undefined otherwise
```

The `getSharedStyles` method examines each selected shape, extracts its style values, and compares them. For groups, it recursively examines the group's children rather than the group itself, since groups don't have visual styles.

When no shapes are selected, `getSharedStyles` returns the styles for the current tool if that tool creates shapes. This lets the UI show and modify the styles that will be applied to the next shape.

### Style persistence

When you set a style on selected shapes, the editor saves that value as the "style for next shapes." The next shape you create will automatically have the same style value.

```typescript
// Set color for selected shapes - also saves it for next shapes ([`Editor.setStyleForSelectedShapes`](/reference/editor/reference/editor/Editor#setStyleForSelectedShapes))
editor.setStyleForSelectedShapes(DefaultColorStyle, 'blue')

// Create a new shape - it will be blue because 'blue' was saved
editor.createShape({ type: 'geo', props: { w: 100, h: 100 } })
```

You can set the style for next shapes without affecting the current selection using [`Editor.setStyleForNextShapes`](/reference/editor/reference/editor/Editor#setStyleForNextShapes):

```typescript
editor.setStyleForNextShapes(DefaultColorStyle, 'green')
```

## Default styles

The `@tldraw/tlschema` package provides a set of default style properties that the built-in shapes use. These styles cover the most common visual properties and integrate with tldraw's theme system for consistent appearance.

**Color styles** control the visual color of shapes and their labels. Colors reference theme values rather than raw hex codes, allowing shapes to adapt to light and dark modes.

- [`DefaultColorStyle`](/reference/tlschema/reference/tlschema/DefaultColorStyle) - Primary shape color (black, red, blue, green, etc.)
- [`DefaultLabelColorStyle`](/reference/tlschema/reference/tlschema/DefaultLabelColorStyle) - Label text color for shapes

**Appearance styles** affect how shapes are drawn and filled. These work together to create the hand-drawn aesthetic that defines tldraw's visual style.

- [`DefaultFillStyle`](/reference/tlschema/reference/tlschema/DefaultFillStyle) - Fill pattern (none, semi, solid, pattern, fill, lined-fill)
- [`DefaultDashStyle`](/reference/tlschema/reference/tlschema/DefaultDashStyle) - Stroke style (draw, solid, dashed, dotted)
- [`DefaultSizeStyle`](/reference/tlschema/reference/tlschema/DefaultSizeStyle) - Relative size scale (s, m, l, xl)

**Text styles** control typography for text shapes and labels. The alignment styles handle both the text itself and how content positions within shape bounds.

- [`DefaultFontStyle`](/reference/tlschema/reference/tlschema/DefaultFontStyle) - Font family (draw, sans, serif, mono)
- [`DefaultTextAlignStyle`](/reference/tlschema/reference/tlschema/DefaultTextAlignStyle) - Horizontal text alignment (start, middle, end)
- [`DefaultHorizontalAlignStyle`](/reference/tlschema/reference/tlschema/DefaultHorizontalAlignStyle) - Horizontal content alignment within bounds
- [`DefaultVerticalAlignStyle`](/reference/tlschema/reference/tlschema/DefaultVerticalAlignStyle) - Vertical content alignment within bounds

**Shape-specific styles** apply to particular shape types rather than being universal. These are defined alongside their respective shape utilities.

- [`GeoShapeGeoStyle`](/reference/tlschema/reference/tlschema/GeoShapeGeoStyle) - Geometric shape type (rectangle, ellipse, triangle, etc.)
- [`ArrowShapeArrowheadStartStyle`](/reference/tlschema/reference/tlschema/ArrowShapeArrowheadStartStyle) - Start arrowhead type
- [`ArrowShapeArrowheadEndStyle`](/reference/tlschema/reference/tlschema/ArrowShapeArrowheadEndStyle) - End arrowhead type

Note that opacity is not a style property. It's a regular property on the base shape ([`TLBaseShape`](/reference/tlschema/reference/tlschema/TLBaseShape)) that all shapes inherit, and it doesn't persist to new shapes or sync across selections like style properties do.

## Using styles

### Getting styles

Use `getSharedStyles` to examine the current selection's styles:

```typescript
const styles = editor.getSharedStyles()

// Check if all shapes share a color
const color = styles.get(DefaultColorStyle)
if (color?.type === 'shared') {
	console.log('Shared color:', color.value)
}
```

To get the style value for the next shape to be created, use [`Editor.getStyleForNextShape`](/reference/editor/reference/editor/Editor#getStyleForNextShape):

```typescript
const nextColor = editor.getStyleForNextShape(DefaultColorStyle)
```

### Setting styles

Use [`Editor.setStyleForSelectedShapes`](/reference/editor/reference/editor/Editor#setStyleForSelectedShapes) to change styles on the current selection:

```typescript
// Change color for all selected shapes
editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')

// Change size
editor.setStyleForSelectedShapes(DefaultSizeStyle, 'l')
```

This method recursively applies the style to all shapes in the selection, including shapes nested inside groups. It only updates shapes that support the given style property.

Use [`Editor.setStyleForNextShapes`](/reference/editor/reference/editor/Editor#setStyleForNextShapes) to change the style for subsequently created shapes:

```typescript
// Next shapes will be blue
editor.setStyleForNextShapes(DefaultColorStyle, 'blue')
```

## Custom styles

You can create custom style properties for your shapes using [`StyleProp.define`](/reference/tlschema/reference/tlschema/StyleProp#define) or [`StyleProp.defineEnum`](/reference/tlschema/reference/tlschema/StyleProp#defineEnum).

### Defining a custom style

For numeric or complex types, use `StyleProp.define`:

```typescript
import { StyleProp, T } from 'tldraw'

export const MyLineWidthStyle = StyleProp.define('myApp:lineWidth', {
	defaultValue: 2,
	type: T.number,
})
```

For enumerated values, use `StyleProp.defineEnum`:

```typescript
export const MyPatternStyle = StyleProp.defineEnum('myApp:pattern', {
	defaultValue: 'solid',
	values: ['solid', 'striped', 'dotted', 'checkered'],
})
```

### Using custom styles in shapes

Include your custom style in your shape's props definition:

```typescript
import { RecordProps, T, TLBaseShape } from 'tldraw'

type TLMyShape = TLBaseShape<
	'my-shape',
	{
		w: number
		h: number
		lineWidth: number
		pattern: string
	}
>

const myShapeProps: RecordProps<TLMyShape> = {
	w: T.number,
	h: T.number,
	lineWidth: MyLineWidthStyle,
	pattern: MyPatternStyle,
}
```

The editor automatically recognizes `StyleProp` instances in your props and handles them during shape creation, selection, and updates.

## Related examples

- **[Custom shape with custom styles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-with-custom-styles)** - Create your own custom styles and use them in custom shapes.
- **[Custom shape with tldraw styles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/shape-with-tldraw-styles)** - Use tldraw's default styles in your custom shapes and integrate with the style panel.
- **[Change default styles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/changing-default-style)** - Change the default value for a style property (e.g., setting size to small by default).
- **[Change default colors](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/changing-default-colors)** - Customize the color values in the tldraw theme.
- **[Custom stroke and font sizes](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-stroke-and-font-sizes)** - Override the default stroke and font size values.
- **[Easter egg styles](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/easter-egg-styles)** - Access hidden styles like white color, special fill variants, and label colors programmatically.

--------

# Text measurement

The editor measures text to calculate shape bounds, handle text wrapping, and enable precise hit testing. Two managers handle this: `TextManager` measures text dimensions using a hidden DOM element, and `FontManager` loads custom fonts before measurement so dimensions are accurate.

## How text measurement works

The `TextManager` creates a hidden measurement element on initialization and appends it to the editor container. This element stays in the DOM throughout the editor's lifecycle, allowing fast repeated measurements without repeated DOM manipulation.

```typescript
// Simplified for clarity - see TextManager.ts for full implementation
const elm = document.createElement('div')
elm.classList.add('tl-text-measure')
elm.setAttribute('dir', 'auto')
this.editor.getContainer().appendChild(elm)
```

The element is hidden from users but remains part of the document flow so the browser's layout engine computes accurate dimensions.

### Measuring text

The `measureText` method calculates text dimensions. Pass in text content and styling options, and it returns a box model with width and height.

```typescript
const dimensions = editor.textMeasure.measureText('Hello world', {
	fontFamily: 'Inter',
	fontSize: 16,
	fontWeight: 'normal',
	fontStyle: 'normal',
	lineHeight: 1.35,
	maxWidth: null, // No wrapping
	padding: '4px',
})
// Returns: { x: 0, y: 0, w: 85, h: 22, scrollWidth: 0 }
```

The method applies styles to the measurement element, reads the computed dimensions, then restores the previous styles. This means rapid successive measurements don't interfere with each other.

You can also use `measureHtml` to measure HTML content directly instead of plain text.

### Text wrapping

Set `maxWidth` to a number and the browser wraps text to fit within that width. The `TextManager` uses the browser's native text layout algorithm rather than implementing its own wrapping logic.

```typescript
const wrapped = editor.textMeasure.measureText('This is a long line of text', {
	fontFamily: 'Inter',
	fontSize: 16,
	fontWeight: 'normal',
	fontStyle: 'normal',
	lineHeight: 1.35,
	maxWidth: 100, // Wrap at 100px
	padding: '4px',
})
// Returns dimensions accounting for multiple lines
```

Set `maxWidth: null` to preserve explicit line breaks and spaces without wrapping. This is useful for measuring single-line text or when wrapping is handled elsewhere.

## Measuring text spans

For SVG export or precise text selection, `measureTextSpans` breaks text into individual spans based on line breaks and word boundaries.

```typescript
const spans = editor.textMeasure.measureTextSpans('Hello world\nSecond line', {
	width: 200,
	height: 100,
	padding: 8,
	fontSize: 16,
	fontWeight: 'normal',
	fontFamily: 'Inter',
	fontStyle: 'normal',
	lineHeight: 1.35,
	textAlign: 'start',
	overflow: 'wrap',
})
```

Each span includes the text content and its bounding box:

```typescript
;[
	{ text: 'Hello ', box: { x: 0, y: 0, w: 45, h: 22 } },
	{ text: 'world', box: { x: 45, y: 0, w: 40, h: 22 } },
	{ text: 'Second ', box: { x: 0, y: 22, w: 52, h: 22 } },
	{ text: 'line', box: { x: 52, y: 22, w: 32, h: 22 } },
]
```

The algorithm creates a `Range` object for each character, measures its position using `getClientRects()`, then groups characters into spans based on line position and word boundaries.

### Truncation handling

The `overflow` option controls how text exceeding the available space is handled:

| Value               | Behavior                                              |
| ------------------- | ----------------------------------------------------- |
| `wrap`              | Text wraps to multiple lines (default)                |
| `truncate-clip`     | Text truncates to the first line, no visual indicator |
| `truncate-ellipsis` | Text truncates with an ellipsis character             |

When using `truncate-ellipsis`, the algorithm first measures the ellipsis width, then subtracts it from the available width and remeasures to find the cut point.

## Font loading

The `FontManager` loads custom fonts before text measurement. If you measure text before its font loads, you get incorrect dimensions and layout shifts when the font finally becomes available.

### Declaring font requirements

Shapes declare which fonts they need through the `getFontFaces` method on their `ShapeUtil`:

```typescript
class MyTextShapeUtil extends ShapeUtil<MyTextShape> {
	getFontFaces(shape: MyTextShape): TLFontFace[] {
		return [
			{
				family: 'MyCustomFont',
				src: { url: '/fonts/my-custom-font.woff2', format: 'woff2' },
				weight: 'normal',
				style: 'normal',
			},
		]
	}
}
```

The `FontManager` tracks these font requirements and loads them before the shape renders.

### Loading fonts

Use `ensureFontIsLoaded` to load a specific font, or `requestFonts` to batch multiple font loading requests:

```typescript
// Load a single font
await editor.fonts.ensureFontIsLoaded(fontFace)

// Batch load multiple fonts (batched into a single microtask)
editor.fonts.requestFonts([fontFace1, fontFace2])
```

The manager caches font loading state to avoid redundant loading. Multiple concurrent requests for the same font share a single loading promise.

### Tracking fonts reactively

For shapes that need reactive font tracking (so they re-render when fonts load), use `trackFontsForShape`:

```typescript
// In your ShapeUtil's getGeometry or component method
editor.fonts.trackFontsForShape(shape)
```

This sets up reactive tracking so the shape re-renders once its fonts are ready.

### Loading fonts for the current page

Use `loadRequiredFontsForCurrentPage` to load all fonts needed by shapes on the current page. This is useful before exporting or taking screenshots:

```typescript
await editor.fonts.loadRequiredFontsForCurrentPage()
// All fonts for visible shapes are now loaded
```

Pass a `limit` parameter to avoid loading too many fonts at once on pages with many different fonts.

## Performance considerations

The `TextManager` doesn't cache measurements itself. Shape utilities typically cache their own results using reactive computed values, so text is only remeasured when font properties or content actually change.

The `FontManager` optimizes font loading in several ways: font faces are computed per-shape and cached (only recalculating when shape props or meta change), multiple requests for the same font share a single loading promise, and `requestFonts` batches requests into a single microtask to reduce overhead.

The measurement element uses specific CSS properties for consistent measurements: `overflow-wrap: break-word` allows long words to break when needed, `width` and `max-width` control wrapping, unitless `line-height` ensures consistent spacing, and `dir="auto"` handles mixed LTR/RTL content.

## Related examples

- **[Rich text with font options](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/rich-text-font-extensions)** - Extend the TipTap text editor with font-family and font-size options.
- **[Rich text custom extension](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/rich-text-custom-extension)** - Create custom TipTap extensions for rich text shapes.

--------

# Text shape

The text shape displays formatted text content on the canvas. Text shapes support rich text formatting, automatic sizing, and two distinct modes: auto-sized (where the shape expands to fit content) and fixed-width (where text wraps at a specified boundary). The text tool creates text shapes and manages text entry interactions.

## Auto-size vs fixed-width

Text shapes operate in two modes controlled by the `autoSize` property:

| Mode        | Behavior                                                         | Use case                                  |
| ----------- | ---------------------------------------------------------------- | ----------------------------------------- |
| Auto-size   | Shape width expands to fit content; text never wraps             | Labels, titles, short annotations         |
| Fixed-width | Text wraps at the shape's width boundary; height grows as needed | Paragraphs, longer descriptions, callouts |

### Auto-size mode

When `autoSize` is true (the default), the text shape automatically adjusts its width to accommodate the text content. The shape grows horizontally as you type, and text never wraps to a new line unless you press Enter.

```tsx
import { toRichText } from 'tldraw'

editor.createShape({
	type: 'text',
	x: 100,
	y: 100,
	props: {
		richText: toRichText('This text will never wrap'),
		autoSize: true,
	},
})
```

Auto-sized text shapes maintain their position based on the `textAlign` property. When text expands:

- **Start** alignment: Shape grows to the right; left edge stays fixed
- **Middle** alignment: Shape grows equally in both directions; center stays fixed
- **End** alignment: Shape grows to the left; right edge stays fixed

### Fixed-width mode

When `autoSize` is false, the shape uses a fixed width specified by the `w` property. Text wraps when it reaches this boundary, and the shape grows vertically to accommodate additional lines.

```tsx
editor.createShape({
	type: 'text',
	x: 100,
	y: 100,
	props: {
		richText: toRichText('This text will wrap when it reaches the specified width'),
		autoSize: false,
		w: 200, // Width in pixels
	},
})
```

To convert an auto-sized shape to fixed-width, resize it by dragging the left or right edge handles. The shape switches to fixed-width mode and maintains that width as you continue typing.

## Text alignment

The `textAlign` property controls horizontal text alignment:

| Value    | Description                                    |
| -------- | ---------------------------------------------- |
| `start`  | Left-aligned (or right-aligned in RTL locales) |
| `middle` | Center-aligned                                 |
| `end`    | Right-aligned (or left-aligned in RTL locales) |

```tsx
editor.createShape({
	type: 'text',
	x: 100,
	y: 100,
	props: {
		richText: toRichText('Centered text'),
		textAlign: 'middle',
		autoSize: false,
		w: 300,
	},
})
```

Text shapes always align vertically to the middle of the shape's geometry.

## Creating text with the text tool

The text tool (`T` key) provides two ways to create text shapes:

### Click to create auto-sized text

Click anywhere on the canvas to create an auto-sized text shape. The shape appears centered at your click position and immediately enters edit mode. Start typing to add content.

### Drag to create fixed-width text

Click and drag horizontally to create a fixed-width text shape. The drag distance determines the initial width. After dragging far enough (approximately 6× the base drag distance), the tool switches to resize mode—continue dragging to adjust the width, then release to start editing.

The drag must exceed a minimum threshold (based on pointer type and timing) to trigger fixed-width creation. Quick, short drags create auto-sized shapes instead.

### Tool shortcuts

| Action                     | Result                                      |
| -------------------------- | ------------------------------------------- |
| **Click**                  | Create auto-sized text at click position    |
| **Drag horizontally**      | Create fixed-width text with dragged width  |
| **Enter** (shape selected) | Enter edit mode for the selected text shape |
| **Escape**                 | Exit text tool, return to select tool       |
| **Cmd/Ctrl+Enter**         | Confirm text and exit edit mode             |

## Editing text

Double-click a text shape or press Enter while it's selected to enter edit mode. The shape displays a cursor and you can type, select, and format text using the rich text editor.

Text shapes use the same rich text system as notes, geo shapes, and arrow labels. You get formatting options like bold, italic, code, and highlighting through keyboard shortcuts or the rich text toolbar.

### Empty text deletion

When you exit edit mode (by clicking outside or pressing Escape), the shape checks if it contains only whitespace. Empty text shapes delete themselves automatically—you don't end up with invisible shapes cluttering the canvas.

## Scaling and resize

Text shapes support two resize behaviors:

### Aspect-ratio locked scaling

Dragging corner handles scales the entire shape proportionally. The `scale` property tracks this multiplier. Scaling preserves the text's appearance while making it larger or smaller.

```tsx
// A text shape at 2x scale
editor.createShape({
	type: 'text',
	props: {
		richText: toRichText('Scaled up'),
		scale: 2,
	},
})
```

### Width adjustment

Dragging the left or right edge handles adjusts only the width. For auto-sized shapes, this converts them to fixed-width mode. For already fixed-width shapes, this changes where text wraps.

## Dynamic resize mode

When `editor.user.getIsDynamicResizeMode()` is true, new text shapes are created with a scale inversely proportional to the current zoom level. At 200% zoom, new shapes get `scale: 0.5`; at 50% zoom, they get `scale: 2`. This keeps text visually consistent regardless of your zoom level when creating it.

```tsx
const scale = editor.user.getIsDynamicResizeMode() ? 1 / editor.getZoomLevel() : 1
```

## Arrow bindings

Arrows can bind to text shapes just like other shapes. The text shape's geometry includes extra horizontal padding (configurable via `extraArrowHorizontalPadding`) to prevent arrowheads from overlapping the text content.

```tsx
const ConfiguredTextUtil = TextShapeUtil.configure({
	extraArrowHorizontalPadding: 20, // More space for arrows (default: 10)
})
```

## Text outline

Text shapes can display an outline effect using the canvas background color. This improves readability when text overlaps other shapes or complex backgrounds.

The outline is implemented using CSS text-shadow and is enabled by default. On Safari, the outline is skipped because text-shadow is not performant on that browser.

```tsx
const ConfiguredTextUtil = TextShapeUtil.configure({
	showTextOutline: false, // Disable the outline effect
})
```

## Properties

| Property    | Type                      | Description                                     |
| ----------- | ------------------------- | ----------------------------------------------- |
| `richText`  | `TLRichText`              | Text content with formatting                    |
| `color`     | `TLDefaultColorStyle`     | Text color                                      |
| `size`      | `TLDefaultSizeStyle`      | Font size preset (`s`, `m`, `l`, `xl`)          |
| `font`      | `TLDefaultFontStyle`      | Font family (`draw`, `sans`, `serif`, `mono`)   |
| `textAlign` | `TLDefaultTextAlignStyle` | Horizontal alignment (`start`, `middle`, `end`) |
| `autoSize`  | `boolean`                 | When true, shape resizes to fit content         |
| `w`         | `number`                  | Width when autoSize is false                    |
| `scale`     | `number`                  | Scale factor applied to the shape               |

## Configuration

| Option                        | Type      | Default | Description                                                              |
| ----------------------------- | --------- | ------- | ------------------------------------------------------------------------ |
| `extraArrowHorizontalPadding` | `number`  | `10`    | Additional horizontal padding for arrow binding geometry                 |
| `showTextOutline`             | `boolean` | `true`  | Display text outline for readability (skipped on Safari for performance) |

```tsx
import { Tldraw, TextShapeUtil } from 'tldraw'
import 'tldraw/tldraw.css'

const ConfiguredTextUtil = TextShapeUtil.configure({
	extraArrowHorizontalPadding: 20,
	showTextOutline: false,
})

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw shapeUtils={[ConfiguredTextUtil]} />
		</div>
	)
}
```

## Grid snapping

When grid mode is enabled (`editor.getInstanceState().isGridMode`), new text shapes snap to grid positions. The tool calculates the snapped position after creating the shape and adjusts for the shape's alignment-based offset.

## Programmatic text formatting

To create text with formatting, construct the rich text JSON structure directly:

```tsx
editor.createShape({
	type: 'text',
	x: 100,
	y: 100,
	props: {
		richText: {
			type: 'doc',
			content: [
				{
					type: 'paragraph',
					content: [
						{ type: 'text', text: 'Regular and ' },
						{ type: 'text', text: 'bold', marks: [{ type: 'bold' }] },
						{ type: 'text', text: ' text' },
					],
				},
			],
		},
		autoSize: true,
	},
})
```

Available marks include `bold`, `italic`, `code`, `link`, and `highlight`. See [Rich text](/sdk-features/rich-text) for complete documentation on the formatting system.

## Related articles

- [Rich text](/sdk-features/rich-text) — Text formatting system and TipTap integration
- [Default shapes](/sdk-features/default-shapes) — Overview of all built-in shapes
- [Tools](/sdk-features/tools) — How tools handle user input
- [Styles](/sdk-features/styles) — Working with shape styles like color and size

## Related examples

- [Programmatic text shape creation](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/text-shape-configuration) — Creating text shapes with various configurations
- [Outlined text with TipTap mark](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/outlined-text) — Adding text outline styling via a custom TipTap mark extension

--------

# Ticks

The tick system provides a frame-synchronized update loop for the editor. The editor emits `tick` and `frame` events on every animation frame using `requestAnimationFrame`, passing the elapsed time since the last frame. This enables smooth animations, edge scrolling during drag operations, and time-based state updates. The `frame` event fires before `tick` and is used internally for input processing, while `tick` is intended for application code.

While pointer and keyboard events fire in response to user input, tick events fire continuously. Use them when you need updates that run every frame regardless of user interaction.

## Subscribing to tick events

The most common way to use ticks is by subscribing to the `tick` event on the editor. The callback receives the elapsed time in milliseconds since the last frame:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function TickExample() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				onMount={(editor) => {
					const handleTick = (elapsed: number) => {
						// elapsed is typically ~16ms at 60fps
						updateAnimation(elapsed)
					}

					editor.on('tick', handleTick)

					// Clean up when done
					return () => editor.off('tick', handleTick)
				}}
			/>
		</div>
	)
}
```

Remember to unsubscribe when your component unmounts or when you no longer need tick updates. The elapsed time lets you create frame-rate-independent animations by scaling movement based on actual time passed rather than assuming a fixed framerate.

## Tick events in tools

When building custom tools using the state machine pattern, you can handle tick events by implementing the `onTick` method on your `StateNode`. The editor dispatches tick events through the state tree, so your active tool states receive them automatically:

```typescript
import { StateNode, TLTickEventInfo } from '@tldraw/editor'

export class MyDraggingState extends StateNode {
	static override id = 'dragging'

	override onTick({ elapsed }: TLTickEventInfo) {
		// Update something every frame while this state is active
		this.updateDragPosition(elapsed)
	}

	private updateDragPosition(elapsed: number) {
		// Your frame-based logic here
	}
}
```

The `TLTickEventInfo` contains the elapsed time in milliseconds. Use this for time-based calculations rather than assuming a fixed frame duration.

## Edge scrolling example

The most common use of `onTick` in tools is edge scrolling during drag operations. When you drag near the edge of the viewport, the canvas scrolls automatically. Here's how tldraw's built-in `Translating` state handles it:

```typescript
import { StateNode, TLTickEventInfo } from '@tldraw/editor'

export class Translating extends StateNode {
	static override id = 'translating'

	override onTick({ elapsed }: TLTickEventInfo) {
		this.editor.edgeScrollManager.updateEdgeScrolling(elapsed)
	}
}
```

The `EdgeScrollManager` accumulates elapsed time to create a smooth acceleration effect. After a short delay, scrolling begins slowly and speeds up the longer you hold near the edge. This creates a natural feel where small adjustments are easy but you can also scroll quickly when needed.

For more details on edge scrolling, see the [edge scrolling](/docs/edge-scrolling) documentation.

## How the editor uses ticks internally

The editor uses tick events for several internal features:

**Scribble animations**: The `ScribbleManager` animates the visual trails you see during brush selection and laser pointer usage. On each tick, it adds new points to active scribbles and shrinks them from the tail, creating a fading trail effect.

**Pointer velocity**: The editor tracks pointer velocity by measuring movement between ticks. This data is available via `editor.inputs.getPointerVelocity()` and is used for features like gesture detection.

**Camera animations**: Methods like `editor.zoomIn()` and `editor.resetZoom()` animate smoothly by subscribing to tick events for the duration of the animation, then unsubscribing when complete.

## When to use tick events

Tick events are appropriate when you need continuous updates that run every frame:

- Animations that should run smoothly regardless of user input
- Edge scrolling during drag operations
- Physics simulations or particle systems
- Smooth interpolation between values over time
- Debouncing based on frame counts rather than timeouts

Don't use tick events for responding to user input. Pointer, keyboard, and wheel events are better for that since they fire immediately when the user acts. Tick events add a frame of latency.

## Related

- [Events](/docs/events) - Overview of all editor events including tick
- [Edge scrolling](/docs/edge-scrolling) - Detailed documentation on edge scrolling behavior
- [Snowstorm example](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/snowstorm) - Uses tick events to animate falling snowflakes

--------

# Tools

Tools in tldraw define how the editor responds to user input. Each tool handles a specific interaction mode—selecting shapes, drawing, or panning the canvas. You implement tools as state machines using the `StateNode` class, which gives you a structured way to manage complex interactions through a hierarchy of states. The editor maintains a single active tool at any time and routes all input events through it. When you click the hand icon in the toolbar, the editor transitions from the select tool to the hand tool, changing how the canvas responds to your mouse movements and clicks.

The state machine architecture lets you handle multi-step interactions cleanly. For example, when you use the select tool to resize a shape, the tool transitions through multiple states: idle, pointing the resize handle, and actively resizing. Each state handles different events and can transition to other states based on user input. This pattern keeps your tool logic organized and makes complex interactions manageable.

## How it works

Tools are organized in a hierarchical state machine where each node can handle events and contain child states. The editor creates a root state that contains all tools as children. When an input event occurs, it flows down from the root through the currently active tool and its active child state.

The [`StateNode`](/reference/editor/reference/editor/StateNode) class provides the foundation for this system. Each state node has an id, optional children, and methods for handling events. State nodes come in three types: root nodes that contain tools, branch nodes that have child states, and leaf nodes that perform actual work. Tools themselves are typically branch nodes with child states representing different phases of an interaction.

When a state becomes active, its `onEnter` method runs. When it becomes inactive, its `onExit` method runs. Between these lifecycle events, the state handles input through event methods like `onPointerDown`, `onPointerMove`, and `onKeyDown`. If a state doesn't handle an event, it passes through without effect. Child states receive events after their parent, allowing both to respond.

You trigger transitions between states explicitly through the `transition` method. When the select tool's idle state detects a pointer down on a shape, it calls `this.parent.transition('pointing_shape', info)` to move to the pointing state. The transition triggers the appropriate exit and enter handlers, maintaining clean state boundaries.

## Key concepts

### State hierarchy

Tools exist in a tree structure starting from a root node. The root contains all available tools like select, hand, eraser, and draw. Each tool can contain child states for different phases of its interaction. For example, the select tool has children including idle, pointing, translating, resizing, and rotating. When the select tool is active and the user starts dragging a shape, the active path becomes `select.translating`.

The hierarchy allows tools to share common behavior at higher levels while specializing at lower levels. The select tool handles keyboard shortcuts at its top level, while child states handle specific mouse interactions. This organization prevents duplicate logic across related states.

### Event handling

State nodes implement event handler methods that match input event types. The handlers receive an info object containing event details like pointer position, keyboard modifiers, and the event target. Common handlers include `onPointerDown`, `onPointerMove`, `onPointerUp`, `onKeyDown`, and `onTick` for animation frame updates.

Events flow through the state hierarchy. When a pointer move occurs, the root receives it first, then the current tool, then the tool's active child state. Each node can handle the event by implementing the corresponding method. The hand tool's dragging state implements `onPointerMove` to update the camera position as the user drags.

### State transitions

The `transition` method moves between states by id. You can transition to a direct child using just its id, or to deeper descendants using dot notation like `'crop.pointing_crop_handle'`. Transitions are atomic - the old state's `onExit` runs, the new state's `onEnter` runs, and the state is updated.

Transitions carry information through their second parameter. When transitioning from idle to pointing, the pointer event info passes along so the pointing state knows where the interaction started. This data is available in both the exit handler of the old state and the enter handler of the new state.

### Tool registration

Tools are registered with the editor through the root state. The `@tldraw/editor` package provides only the root state with no tools. The `@tldraw/tldraw` package extends this with a full suite of tools. Custom tools are added by creating a custom root state that includes them as children.

The editor's `setCurrentTool` method transitions the root state to a different tool by id. The `getCurrentTool` method returns the currently active tool state node. These methods provide the public API for tool management while the state machine handles the internal transitions.

### Event target detection

Event info objects include a target property indicating what the user interacted with. Possible targets include canvas, shape, handle, and selection. The select tool's idle state uses this to determine which child state to transition to. A pointer down on a shape transitions to pointing_shape, while a pointer down on the canvas transitions to pointing_canvas.

Target detection happens before events reach tools, using the editor's geometry system to determine what's under the pointer. This separation means tools can focus on interaction logic without implementing hit testing.

### Tool lock

Tool lock keeps the current tool active after completing an action. Normally, tools like draw or geo return to the select tool after creating a shape. With tool lock enabled, the tool stays active so you can create multiple shapes without reselecting the tool each time.

Tool lock is stored in instance state:

```ts
// Check if tool lock is enabled
editor.getInstanceState().isToolLocked

// Enable tool lock
editor.updateInstanceState({ isToolLocked: true })

// Toggle tool lock
const current = editor.getInstanceState().isToolLocked
editor.updateInstanceState({ isToolLocked: !current })
```

Custom tools should check `isToolLocked` when deciding whether to return to the select tool after completing their action.

## Creating custom tools

To create a custom tool, extend the `StateNode` class and implement the required static properties and event handlers.

```typescript
import { StateNode, TLPointerEventInfo } from '@tldraw/editor'

export class StampTool extends StateNode {
	static override id = 'stamp'
	static override initial = 'idle'
	static override children() {
		return [StampIdle, StampPointing]
	}

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}
}
```

The `StateNode` class has these static properties:

| Property             | Description                                                             |
| -------------------- | ----------------------------------------------------------------------- |
| `id`                 | Required. The unique identifier for this state                          |
| `initial`            | The id of the initial child state (required if the tool has children)   |
| `children()`         | A function returning an array of child state constructors               |
| `isLockable`         | Whether tool lock applies to this tool (default: `true`)                |
| `useCoalescedEvents` | Whether to batch pointer move events for performance (default: `false`) |

For a simple tool without child states, implement event handlers directly on the tool class:

```typescript
export class MeasureTool extends StateNode {
	static override id = 'measure'

	override onPointerDown(info: TLPointerEventInfo) {
		const { currentPagePoint } = this.editor.inputs
		// Start measuring from this point
	}

	override onPointerMove(info: TLPointerEventInfo) {
		// Update measurement as pointer moves
	}

	override onPointerUp(info: TLPointerEventInfo) {
		// Finalize measurement and return to select tool
		this.editor.setCurrentTool('select')
	}
}
```

Child states follow the same pattern but focus on specific phases of the interaction. A drawing tool might have idle, pointing, and drawing states. The pointing state waits to see if the user is clicking or starting a drag, then transitions accordingly:

```typescript
export class DrawingPointing extends StateNode {
	static override id = 'pointing'

	override onPointerMove(info: TLPointerEventInfo) {
		if (this.editor.inputs.isDragging) {
			this.parent.transition('drawing', info)
		}
	}

	override onPointerUp(info: TLPointerEventInfo) {
		this.parent.transition('idle', info)
	}
}
```

Access the editor through `this.editor` to read input state, manipulate shapes, or transition tools. Access the parent state through `this.parent` to transition between sibling states. The editor instance provides the full API for querying and modifying the document.

To register a custom tool, pass it to the Tldraw component via the `tools` prop:

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const customTools = [StampTool, MeasureTool]

export default function App() {
	return <Tldraw tools={customTools} />
}
```

The tools array should be defined outside the component to avoid recreation on each render.

## Overriding default tools

The tldraw component provides several ways to customize which tools are available. You can remove tools from the toolbar, add new tools, or dynamically register and unregister tools at runtime.

### Removing tools from the toolbar

Use the `overrides` prop to modify which tools appear in the UI. The `tools` function receives the current tools object and returns a modified version:

```typescript
import { Tldraw, TLUiOverrides } from 'tldraw'

const overrides: TLUiOverrides = {
	tools(editor, tools, helpers) {
		// Remove the text tool from the toolbar
		delete tools.text
		return tools
	},
}

function App() {
	return <Tldraw overrides={overrides} />
}
```

This removes the tool from the UI but doesn't remove it from the editor's state machine. Users can still activate the tool programmatically or via keyboard shortcuts. To fully disable a tool, you'd also need to remove its keyboard shortcut binding.

### Adding custom tools to the toolbar

When you create a custom tool, you need to add it both to the editor's state machine and to the UI. The `tools` prop registers the tool with the state machine, while `overrides.tools` adds it to the UI context:

```typescript
import { Tldraw, TLUiOverrides, StateNode } from 'tldraw'

class MyTool extends StateNode {
	static override id = 'my-tool'
	// ... implementation
}

const overrides: TLUiOverrides = {
	tools(editor, tools, helpers) {
		tools['my-tool'] = {
			id: 'my-tool',
			icon: 'my-icon',
			label: 'My Tool',
			kbd: 'm',
			onSelect: () => editor.setCurrentTool('my-tool'),
		}
		return tools
	},
}

function App() {
	return <Tldraw tools={[MyTool]} overrides={overrides} />
}
```

To make the tool appear in the toolbar, override the `Toolbar` component and include your tool item. See the "Add a tool to the toolbar" example for the complete implementation.

### Dynamic tool registration

Tools can be added or removed at runtime using the `setTool` and `removeTool` methods on the editor. This is useful when tool availability depends on user permissions, feature flags, or application state.

```tsx
import { useState } from 'react'
import { Editor, StateNode, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

class HeartTool extends StateNode {
	static override id = 'heart'
	override onPointerDown() {
		// Create a heart shape at click position
	}
}

function App() {
	const [editor, setEditor] = useState<Editor | null>(null)
	const [isEnabled, setIsEnabled] = useState(false)

	const toggleTool = () => {
		if (!editor) return
		if (isEnabled) {
			// Switch away first if currently using the tool
			if (editor.getCurrentToolId() === 'heart') {
				editor.setCurrentTool('select')
			}
			editor.removeTool(HeartTool)
		} else {
			editor.setTool(HeartTool)
		}
		setIsEnabled(!isEnabled)
	}

	return <Tldraw onMount={setEditor} />
}
```

When removing a tool, check whether the user is currently using it. If so, transition to a different tool like select to avoid leaving the editor in an invalid state. The `setTool` method adds a tool constructor to the state chart, while `removeTool` removes it.

## Related examples

- **[Custom tool (sticker)](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/custom-tool)** - A simple custom tool that adds a heart emoji sticker to the canvas when you click, demonstrating the basics of extending StateNode.
- **[Custom tool with child states](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/tool-with-child-states)** - Expands on the sticker tool to show how to create a tool with complex interactions using child states in the state machine.
- **[Screenshot tool](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/screenshot-tool)** - A custom tool that takes a screenshot of a specific area of the canvas, demonstrating how to handle multi-step interactions.
- **[Lasso select tool](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/lasso-select-tool)** - A custom selection tool that uses freehand drawing to select shapes, showing how to build alternative selection tools with reactive atoms and overlays.
- **[Add a tool to the toolbar](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/add-tool-to-toolbar)** - Shows how to make your custom tool icon appear on tldraw's toolbar by overriding the toolbar component and providing custom assets.
- **[Remove a tool from the toolbar](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/remove-tool)** - Shows how to remove a default tool from the toolbar using UI overrides.
- **[Dynamic tools with setTool and removeTool](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/dynamic-tools)** - Demonstrates how to dynamically add and remove tools from the editor's state chart after initialization, useful for conditional tool availability.

--------

# UI components

The `@tldraw/tldraw` package includes a complete React-based UI. It provides the menus, toolbars, panels, and dialogs that users interact with when creating and editing content. The UI is composed of named component slots that you can selectively override or hide, so you can customize the interface while still benefiting from the editor's reactive state management.

The UI connects to the editor through React hooks and context providers. Components automatically update when editor state changes. You can replace individual parts of the interface without reimplementing the logic that connects UI actions to editor operations.

## How it works

### Component slot architecture

The UI divides the screen into distinct layout zones:

```
┌─────────────────────────────────────────────────────────┐
│                    Top Panel                             │
├────────────┬──────────────────────────┬─────────────────┤
│   Left     │         Canvas           │     Right       │
│   Panel    │                          │     Panel       │
├────────────┴──────────────────────────┴─────────────────┤
│                   Bottom Panel                           │
└─────────────────────────────────────────────────────────┘
```

The top zone contains the main menu, helper buttons (like "Back to content"), the top panel for collaboration features, and the share and style panels. The bottom zone houses navigation controls, the main toolbar with drawing tools, and the help menu. On desktop, the style panel appears in the top-right zone; on mobile it moves to a modal overlay.

Each zone can host multiple components. The toolbar includes the tool selector, tool-specific options, and the tool lock button. These components share context and coordinate through the editor's state.

### Context providers and state management

The UI establishes a hierarchy of React context providers that manage different aspects of the interface. At the root, `TldrawUiContextProvider` coordinates all other providers and merges your overrides. Specialized providers handle translations, tooltips, dialogs, toasts, breakpoints for responsive behavior, and the component registry.

The actions and tools providers transform raw editor methods into UI-friendly actions with labels, icons, and keyboard shortcuts. When you click a toolbar button, the component calls an action from context, which invokes the appropriate editor method. This indirection means the same action can be triggered from multiple places (toolbar, menu, keyboard shortcut) with consistent behavior.

### Reactive UI updates

UI components read editor state through hooks like `useEditor`, `useValue`, and `useReactor`. These hooks use the editor's reactive signal system to automatically re-render when relevant state changes. The style panel uses `useRelevantStyles` to determine which style controls to show based on the current selection—when you select a different shape, the hook detects the change and the panel updates.

This reactive approach means you don't need to manually manage subscriptions or worry about stale state. Components declare their dependencies, and the reactivity system handles the rest.

## Key components

### Component slots

The UI defines several component slots you can override or hide.

The **Toolbar** contains the primary tool selector with buttons for each available tool (select, draw, shapes, etc.). On mobile, it hides automatically when editing text to make room for the virtual keyboard.

The **TopPanel** displays the page name and collaboration indicators when multiplayer features are enabled. It's hidden in single-player mode.

The **StylePanel** shows style controls for selected shapes: color, fill, stroke, size, opacity. It appears in the top-right on desktop and as a modal on mobile.

The **MenuPanel** houses the main application menu with actions like export, print, and preferences. It's typically in the top-left corner.

The **NavigationPanel** provides page navigation, zoom controls, and the minimap toggle. It sits in the bottom-left area.

**HelperButtons** are context-sensitive buttons that appear based on editor state—"Back to content" when the camera is far from shapes, "Exit pen mode" on touch devices.

**ActionsMenu**, **ContextMenu**, and **HelpMenu** provide access to actions and information through different interaction patterns.

Each slot is optional. Pass `null` as an override to hide a component entirely, or provide your own React component to replace the default implementation.

### UI hooks

Components access editor functionality through specialized hooks.

`useEditor` returns the editor instance, providing direct access to all editor methods and state.

`useActions` returns a collection of UI actions (copy, paste, delete) with their labels, icons, and keyboard shortcuts. Each action is a function you can call from your custom UI.

`useTools` returns the available tools with their metadata. The toolbar uses this to render tool buttons.

`useRelevantStyles` determines which styles are relevant to the current selection and returns their values. It powers the style panel.

`useBreakpoint` returns a numeric breakpoint index (0-7) that maps to the `PORTRAIT_BREAKPOINT` enum. Compare against values like `PORTRAIT_BREAKPOINT.MOBILE` or `PORTRAIT_BREAKPOINT.TABLET_SM` to adapt layout for different screen sizes.

These hooks encapsulate common UI patterns and keep your custom components in sync with editor state.

## Hiding the UI

You can hide the default tldraw user interface entirely using the `hideUi` prop. This turns off both the visuals and the keyboard shortcuts.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw hideUi />
		</div>
	)
}
```

When the UI is hidden, you can't select tools using keyboard shortcuts. You can still control the editor programmatically through `Editor` methods. Open the console and try:

```ts
editor.setCurrentTool('draw')
```

All of tldraw's user interface works by controlling the editor via its methods. If you hide the user interface, you can still use these same methods to control the editor. See the [custom user interface example](/examples/custom-ui) for this in action.

## Extension points

### Overriding components

Override individual components by passing them to the `components` prop:

```tsx
import { Tldraw, useEditor, useTools } from 'tldraw'
import 'tldraw/tldraw.css'

function CustomToolbar() {
	const editor = useEditor()
	const tools = useTools()

	return (
		<div className="my-toolbar">
			{Object.values(tools).map((tool) => (
				<button key={tool.id} onClick={() => editor.setCurrentTool(tool.id)}>
					{tool.label}
				</button>
			))}
		</div>
	)
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				components={{
					Toolbar: CustomToolbar,
				}}
			/>
		</div>
	)
}
```

The `useTools` hook returns an object mapping tool IDs to [TLUiToolItem](/reference/tldraw/TLUiToolItem) objects. Each tool item contains metadata like `id`, `label`, `icon`, and `kbd` (keyboard shortcut).

### Hiding components

Pass `null` to hide a component entirely. This is useful for focused experiences that don't need the full default UI:

```tsx
<Tldraw
	components={{
		HelpMenu: null,
		DebugMenu: null,
		SharePanel: null,
	}}
/>
```

See the [UI components hidden example](/examples/ui-components-hidden) for a complete list of hideable components.

## Overrides

Control tldraw's menu content with the `overrides` prop. This prop accepts a [TLUiOverrides](/reference/tldraw/TLUiOverrides) object, which has methods for `actions` and `tools`, and a `translations` property.

### Actions

The user interface has a set of shared actions used in the menus and keyboard shortcuts. Override these by providing an `actions` method that receives the editor, the [default actions](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/context/actions.tsx), and a helpers object, then returns a mutated actions object.

```tsx
import { Tldraw, TLUiOverrides } from 'tldraw'
import 'tldraw/tldraw.css'

const myOverrides: TLUiOverrides = {
	actions(editor, actions, helpers) {
		// Delete an action (remember to also delete any menu items that reference it)
		delete actions['insert-embed']

		// Create a new action or replace an existing one
		actions['my-new-action'] = {
			id: 'my-new-action',
			label: 'My new action',
			readonlyOk: true,
			kbd: 'cmd+shift+u,ctrl+shift+u',
			onSelect(source) {
				window.alert('My new action just happened!')
			},
		}
		return actions
	},
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw overrides={myOverrides} />
		</div>
	)
}
```

The `actions` object is a map of [TLUiActionItem](/reference/tldraw/TLUiActionItem)s, keyed by their `id`. See the [action overrides example](/examples/action-overrides) for more.

### Tools

Override tools the same way you override actions. Provide a `tools` method that accepts the editor, the [default tools object](https://github.com/tldraw/tldraw/blob/main/packages/tldraw/src/lib/ui/hooks/useTools.tsx), and a helpers object, then returns a mutated version.

```tsx
const myOverrides: TLUiOverrides = {
	tools(editor, tools, helpers) {
		// Create a tool item in the UI's context
		tools.card = {
			id: 'card',
			icon: 'color',
			label: 'tools.card',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('card')
			},
		}
		return tools
	},
}
```

The `tools` object is a map of [TLUiToolItem](/reference/tldraw/TLUiToolItem)s, keyed by their `id`. See the [add tool to toolbar example](/examples/add-tool-to-toolbar) for a complete implementation.

### Translations

The `translations` property accepts a table of new translations. If you add a tool with `label: 'tools.card'`, you need to provide an English translation for that key:

```tsx
const myOverrides: TLUiOverrides = {
	translations: {
		en: {
			'tools.card': 'Card',
		},
	},
}
```

See [internationalization](/sdk-features/internationalization) for more about tldraw's translation system.

## UI events

The [`Tldraw`](/reference/tldraw/reference/tldraw/Tldraw) component has an `onUiEvent` prop that fires when users interact with the UI:

```tsx
import { Tldraw, TLUiEventHandler } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	const handleUiEvent: TLUiEventHandler = (name, data) => {
		console.log('UI event:', name, data)
	}

	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw onUiEvent={handleUiEvent} />
		</div>
	)
}
```

The callback receives the event name as a string and an object with information about the event's source (e.g. `menu` or `context-menu`) and other data specific to each event, such as the direction in an `align-shapes` event.

Note that `onUiEvent` only fires for UI interactions. Calling [`Editor.alignShapes`](/reference/editor/reference/editor/Editor#alignShapes) directly won't trigger this callback. See the [UI events example](/examples/ui-events) for more.

## Related articles

- [UI primitives](/sdk-features/ui-primitives) - Use tldraw's button, menu, dialog, and other UI components in your custom interfaces
- [Internationalization](/sdk-features/internationalization) - Customize translations and add new languages
- [Tools](/sdk-features/tools) - Learn how tools work and create your own

## Related examples

- [Replace the entire UI](/examples/custom-ui) - Build a completely custom toolbar UI while using the editor's functionality
- [Custom canvas components](/examples/custom-components) - Override individual canvas components like the brush selection box and scribble
- [Hide the entire UI](/examples/hide-ui) - Use hideUi to hide the entire default interface
- [Hide UI components](/examples/ui-components-hidden) - Selectively hide specific UI components
- [Changing menus](/examples/custom-menus) - Create custom menus using tldraw's menu system
- [Vertical toolbar](/examples/vertical-toolbar) - Switch to a vertical toolbar layout
- [Add tool to toolbar](/examples/add-tool-to-toolbar) - Add a custom tool to the toolbar
- [UI events](/examples/ui-events) - Listen to UI events like tool selection and menu interactions

--------

# UI primitives

The `@tldraw/tldraw` package exports a set of UI primitive components that you can use when building custom interfaces. These components match the look and feel of tldraw's default UI and integrate with the editor's theming, translations, and accessibility features.

Use these primitives when you want your custom UI to feel like a natural part of tldraw rather than something bolted on.

## Buttons

The button system consists of `TldrawUiButton` and its companion components for icons, labels, and state indicators.

### TldrawUiButton

The base button component with several visual variants:

```tsx
import { TldrawUiButton, TldrawUiButtonLabel } from 'tldraw'

function MyButtons() {
	return (
		<>
			<TldrawUiButton type="normal" onClick={() => console.log('clicked')}>
				<TldrawUiButtonLabel>Normal</TldrawUiButtonLabel>
			</TldrawUiButton>

			<TldrawUiButton type="primary" onClick={() => console.log('clicked')}>
				<TldrawUiButtonLabel>Primary</TldrawUiButtonLabel>
			</TldrawUiButton>

			<TldrawUiButton type="danger" onClick={() => console.log('clicked')}>
				<TldrawUiButtonLabel>Danger</TldrawUiButtonLabel>
			</TldrawUiButton>

			<TldrawUiButton type="icon" onClick={() => console.log('clicked')}>
				<TldrawUiButtonIcon icon="plus" />
			</TldrawUiButton>
		</>
	)
}
```

The `type` prop controls the button's appearance:

| Type      | Description                              |
| --------- | ---------------------------------------- |
| `normal`  | Standard button for general actions      |
| `primary` | Emphasized button for primary actions    |
| `danger`  | Red button for destructive actions       |
| `low`     | Subtle button with minimal visual weight |
| `icon`    | Square button sized for a single icon    |
| `tool`    | Tool button style used in the toolbar    |
| `menu`    | Button style used inside menus           |
| `help`    | Style used for help/info buttons         |

Use `isActive` to indicate a selected or active state:

```tsx
<TldrawUiButton type="tool" isActive={true}>
	<TldrawUiButtonIcon icon="draw" />
</TldrawUiButton>
```

### Button sub-components

Build up button contents using these components:

```tsx
import {
	TldrawUiButton,
	TldrawUiButtonIcon,
	TldrawUiButtonLabel,
	TldrawUiButtonCheck,
	TldrawUiButtonSpinner,
} from 'tldraw'

// Icon button
<TldrawUiButton type="icon">
	<TldrawUiButtonIcon icon="trash" />
</TldrawUiButton>

// Button with icon and label
<TldrawUiButton type="menu">
	<TldrawUiButtonIcon icon="plus" />
	<TldrawUiButtonLabel>Add item</TldrawUiButtonLabel>
</TldrawUiButton>

// Button with checkmark (for toggles in menus)
<TldrawUiButton type="menu">
	<TldrawUiButtonCheck checked={true} />
	<TldrawUiButtonLabel>Show grid</TldrawUiButtonLabel>
</TldrawUiButton>

// Button with loading spinner
<TldrawUiButton type="normal" disabled>
	<TldrawUiButtonSpinner />
	<TldrawUiButtonLabel>Loading...</TldrawUiButtonLabel>
</TldrawUiButton>
```

## Icons

`TldrawUiIcon` renders icons from tldraw's icon set. Icons are SVG-based and inherit the current text color.

```tsx
import { TldrawUiIcon } from 'tldraw'

<TldrawUiIcon icon="draw" label="Draw tool" />
<TldrawUiIcon icon="arrow-left" label="Go back" small />
<TldrawUiIcon icon="check" label="Complete" color="green" />
```

The `label` prop is required for accessibility—it becomes the icon's `aria-label`. Use `small` for a smaller icon size.

You can also pass a custom React element instead of an icon name:

```tsx
<TldrawUiIcon icon={<div className="my-custom-icon">★</div>} label="Favorite" />
```

## Menu primitives

When adding items to tldraw's menus, use these components to match the default menu styling and behavior.

### TldrawUiMenuItem

The main component for menu items. It automatically adapts its rendering based on which menu it's in (dropdown, context menu, toolbar, etc.):

```tsx
import { TldrawUiMenuItem, TldrawUiMenuGroup } from 'tldraw'
;<TldrawUiMenuGroup id="my-actions">
	<TldrawUiMenuItem
		id="my-action"
		label="Do something"
		icon="plus"
		kbd="cmd+shift+d"
		onSelect={() => {
			console.log('action triggered')
		}}
	/>
</TldrawUiMenuGroup>
```

Props:

| Prop         | Description                                            |
| ------------ | ------------------------------------------------------ |
| `id`         | Unique identifier for the menu item                    |
| `label`      | Display text (supports translation keys)               |
| `icon`       | Icon to display (on right in menus)                    |
| `iconLeft`   | Icon to display on the left side                       |
| `kbd`        | Keyboard shortcut to display                           |
| `onSelect`   | Called when the item is clicked                        |
| `disabled`   | Whether the item is disabled                           |
| `readonlyOk` | If true, item is shown even in readonly mode           |
| `isSelected` | Whether the item shows as selected (for toolbar items) |
| `spinner`    | Show a loading spinner                                 |
| `noClose`    | Prevent the menu from closing when clicked             |

### TldrawUiMenuGroup

Groups related menu items together. In dropdown menus, groups are separated by dividers:

```tsx
<TldrawUiMenuGroup id="clipboard">
	<TldrawUiMenuItem id="cut" label="Cut" kbd="cmd+x" onSelect={handleCut} />
	<TldrawUiMenuItem id="copy" label="Copy" kbd="cmd+c" onSelect={handleCopy} />
	<TldrawUiMenuItem id="paste" label="Paste" kbd="cmd+v" onSelect={handlePaste} />
</TldrawUiMenuGroup>
```

### TldrawUiMenuSubmenu

Creates a nested submenu:

```tsx
import { TldrawUiMenuSubmenu } from 'tldraw'
;<TldrawUiMenuSubmenu id="export" label="Export as...">
	<TldrawUiMenuGroup id="formats">
		<TldrawUiMenuItem id="png" label="PNG" onSelect={exportPng} />
		<TldrawUiMenuItem id="svg" label="SVG" onSelect={exportSvg} />
		<TldrawUiMenuItem id="json" label="JSON" onSelect={exportJson} />
	</TldrawUiMenuGroup>
</TldrawUiMenuSubmenu>
```

### TldrawUiMenuCheckboxItem

A menu item with a checkbox:

```tsx
import { TldrawUiMenuCheckboxItem } from 'tldraw'
;<TldrawUiMenuCheckboxItem
	id="snap-to-grid"
	label="Snap to grid"
	checked={snapEnabled}
	onSelect={() => {
		setSnapEnabled(!snapEnabled)
	}}
/>
```

The `onSelect` callback receives a `source` parameter indicating where the action was triggered from (e.g., 'context-menu', 'menu'). You can ignore it if you don't need to differentiate between sources.

## Dialogs

Build modal dialogs using tldraw's dialog primitives. These components handle accessibility, focus management, and styling.

```tsx
import {
	TldrawUiDialogHeader,
	TldrawUiDialogTitle,
	TldrawUiDialogCloseButton,
	TldrawUiDialogBody,
	TldrawUiDialogFooter,
	TldrawUiButton,
	TldrawUiButtonLabel,
	useDialogs,
} from 'tldraw'

function MyDialog({ onClose }: { onClose(): void }) {
	return (
		<>
			<TldrawUiDialogHeader>
				<TldrawUiDialogTitle>Confirm deletion</TldrawUiDialogTitle>
				<TldrawUiDialogCloseButton />
			</TldrawUiDialogHeader>
			<TldrawUiDialogBody style={{ maxWidth: 350 }}>
				Are you sure you want to delete this item? This action cannot be undone.
			</TldrawUiDialogBody>
			<TldrawUiDialogFooter className="tlui-dialog__footer__actions">
				<TldrawUiButton type="normal" onClick={onClose}>
					<TldrawUiButtonLabel>Cancel</TldrawUiButtonLabel>
				</TldrawUiButton>
				<TldrawUiButton
					type="danger"
					onClick={() => {
						deleteItem()
						onClose()
					}}
				>
					<TldrawUiButtonLabel>Delete</TldrawUiButtonLabel>
				</TldrawUiButton>
			</TldrawUiDialogFooter>
		</>
	)
}

// Show the dialog using the useDialogs hook
function MyComponent() {
	const { addDialog } = useDialogs()

	return <button onClick={() => addDialog({ component: MyDialog })}>Delete item</button>
}
```

The `onClose` function is passed to your dialog component automatically. Call it to dismiss the dialog.

## Input

`TldrawUiInput` is a styled text input with built-in handling for Enter (confirm) and Escape (cancel):

```tsx
import { TldrawUiInput } from 'tldraw'
;<TldrawUiInput
	label="Name"
	defaultValue="Untitled"
	onComplete={(value) => {
		// Called when user presses Enter
		saveName(value)
	}}
	onCancel={(value) => {
		// Called when user presses Escape
		// Value is reset to initial value
	}}
	onValueChange={(value) => {
		// Called on every keystroke
	}}
	autoSelect // Select all text on focus
	autoFocus
/>
```

Add icons to the input using `iconLeft` (left side) or `icon` (right side):

```tsx
<TldrawUiInput iconLeft="search" placeholder="Search shapes..." onValueChange={setSearchQuery} />
<TldrawUiInput icon="check" placeholder="Confirmed value" />
```

## Layout

Layout primitives help organize UI controls with proper spacing and orientation-aware tooltips.

```tsx
import { TldrawUiRow, TldrawUiColumn, TldrawUiGrid } from 'tldraw'

// Horizontal row of buttons
<TldrawUiRow>
	<TldrawUiButton type="icon"><TldrawUiButtonIcon icon="align-left" /></TldrawUiButton>
	<TldrawUiButton type="icon"><TldrawUiButtonIcon icon="align-center" /></TldrawUiButton>
	<TldrawUiButton type="icon"><TldrawUiButtonIcon icon="align-right" /></TldrawUiButton>
</TldrawUiRow>

// Vertical column
<TldrawUiColumn>
	<TldrawUiButton type="menu"><TldrawUiButtonLabel>Option 1</TldrawUiButtonLabel></TldrawUiButton>
	<TldrawUiButton type="menu"><TldrawUiButtonLabel>Option 2</TldrawUiButtonLabel></TldrawUiButton>
</TldrawUiColumn>

// 4-column grid (useful for color pickers, shape selectors, etc.)
<TldrawUiGrid>
	{colors.map(color => (
		<TldrawUiButton key={color} type="icon" onClick={() => setColor(color)}>
			<div style={{ background: color, width: 16, height: 16 }} />
		</TldrawUiButton>
	))}
</TldrawUiGrid>
```

These components automatically set up a `tooltipSide` context—tooltips appear below items in rows and to the right of items in columns, and nested components inherit this positioning.

## Other primitives

### TldrawUiKbd

Displays a keyboard shortcut:

```tsx
import { TldrawUiKbd } from 'tldraw'
;<TldrawUiKbd>cmd+shift+d</TldrawUiKbd>
```

### TldrawUiSlider

A slider control. The slider uses discrete steps rather than a continuous range:

```tsx
import { TldrawUiSlider } from 'tldraw'
;<TldrawUiSlider
	title="Opacity"
	label="style-panel.opacity"
	value={5}
	steps={10}
	onValueChange={(value) => console.log(value)}
/>
```

Props:

| Prop            | Description                                     |
| --------------- | ----------------------------------------------- |
| `title`         | Tooltip title text                              |
| `label`         | Translation key for the label                   |
| `value`         | Current value (0 to steps), or null             |
| `steps`         | Maximum value (the slider goes from 0 to steps) |
| `min`           | Optional minimum value (defaults to 0)          |
| `onValueChange` | Called with the new value when it changes       |

### TldrawUiPopover

A popover that appears next to a trigger element:

```tsx
import { TldrawUiPopover, TldrawUiPopoverTrigger, TldrawUiPopoverContent } from 'tldraw'
;<TldrawUiPopover id="my-popover">
	<TldrawUiPopoverTrigger>
		<TldrawUiButton type="icon">
			<TldrawUiButtonIcon icon="dots-vertical" />
		</TldrawUiButton>
	</TldrawUiPopoverTrigger>
	<TldrawUiPopoverContent side="bottom">
		<div style={{ padding: 8 }}>Popover content here</div>
	</TldrawUiPopoverContent>
</TldrawUiPopover>
```

The `id` prop is required and used to track the popover's open state. The `side` prop on `TldrawUiPopoverContent` controls which side of the trigger the popover appears on.

### TldrawUiDropdownMenu

A dropdown menu built on Radix UI:

```tsx
import {
	TldrawUiDropdownMenuRoot,
	TldrawUiDropdownMenuTrigger,
	TldrawUiDropdownMenuContent,
	TldrawUiDropdownMenuItem,
	TldrawUiDropdownMenuGroup,
	TldrawUiButton,
	TldrawUiButtonLabel,
} from 'tldraw'
;<TldrawUiDropdownMenuRoot id="my-dropdown">
	<TldrawUiDropdownMenuTrigger>
		<TldrawUiButton type="normal">
			<TldrawUiButtonLabel>Options</TldrawUiButtonLabel>
		</TldrawUiButton>
	</TldrawUiDropdownMenuTrigger>
	<TldrawUiDropdownMenuContent>
		<TldrawUiDropdownMenuGroup>
			<TldrawUiDropdownMenuItem>
				<TldrawUiButton type="menu" onClick={handleEdit}>
					<TldrawUiButtonLabel>Edit</TldrawUiButtonLabel>
				</TldrawUiButton>
			</TldrawUiDropdownMenuItem>
			<TldrawUiDropdownMenuItem>
				<TldrawUiButton type="menu" onClick={handleDuplicate}>
					<TldrawUiButtonLabel>Duplicate</TldrawUiButtonLabel>
				</TldrawUiButton>
			</TldrawUiDropdownMenuItem>
			<TldrawUiDropdownMenuItem>
				<TldrawUiButton type="menu" onClick={handleDelete}>
					<TldrawUiButtonLabel>Delete</TldrawUiButtonLabel>
				</TldrawUiButton>
			</TldrawUiDropdownMenuItem>
		</TldrawUiDropdownMenuGroup>
	</TldrawUiDropdownMenuContent>
</TldrawUiDropdownMenuRoot>
```

The `id` prop is required on `TldrawUiDropdownMenuRoot`. Each `TldrawUiDropdownMenuItem` wraps a child element (typically a button) and handles the dropdown behavior.

## Related examples

- **[Custom menus](/examples/custom-menus)** — Add items to tldraw's menus using menu primitives
- **[Toasts and dialogs](/examples/toasts-and-dialogs)** — Show toasts and custom dialogs
- **[Custom UI](/examples/custom-ui)** — Build a completely custom interface

--------

# User following

User following lets you track a collaborator's viewport in real-time. When you follow someone, your [camera](/docs/camera) automatically moves to match their view, including page changes and zoom level. The editor handles follow chains (A follows B who follows C) and smoothly interpolates your viewport toward the target on each frame.

Following works with the [collaboration](/docs/collaboration) presence system to track collaborators. It stops automatically when you interact with the canvas or when the followed user disconnects.

## How it works

### Follow mechanism

When you call [`Editor.startFollowingUser`](/reference/editor/reference/editor/Editor#startFollowingUser), the editor stores the target user ID in `followingUserId` on the instance state and sets up two reactive processes: one watches for page changes and switches pages when the followed user navigates, and another runs on every frame to interpolate your camera toward their viewport.

The frame handler calculates the difference between your current viewport and the target, then applies smooth interpolation using your animation speed preference. This creates an ease-out effect where the camera moves quickly at first and slows as it approaches. Once the viewport difference drops below the `followChaseViewportSnap` threshold (default 2 pixels), the editor locks onto the target and stops interpolating until they move again.

### Viewport calculation

The editor reads the followed user's camera state and screen bounds from their presence record, constructs their viewport in page space, then resizes your viewport to contain theirs while maintaining your screen's aspect ratio. This ensures you can see everything the followed user sees, regardless of different screen sizes.

The interpolation uses `lerp` on viewport bounds rather than camera values directly, which produces more natural movement when zoom levels differ. The interpolation factor clamps between 0.1 and 0.8 based on the animation speed preference, preventing both sluggish and aggressive following.

### Page synchronization

Page changes happen separately from camera movement. A reactive effect watches the followed user's `currentPageId` and immediately switches [pages](/docs/pages) when it changes. The page switch uses a direct store update rather than `setCurrentPage()` to avoid triggering the automatic follow-stopping behavior that occurs on manual page changes.

When switching pages to follow a user, the editor sets an internal `_isLockedOnFollowingUser` flag to prevent camera interpolation from running until the page switch completes. This avoids jarring camera movements during page transitions.

## API methods

### startFollowingUser

Start following a user's viewport. Pass a user ID to set up frame handlers that track their camera and page.

```ts
editor.startFollowingUser('user-abc-123')
```

The editor automatically stops following any previously followed user before starting the new follow. If it can't find the target user's presence, the method returns early without starting follow mode.

### stopFollowingUser

Stop following and return control to the local user. This commits the current camera position to the store and clears `followingUserId` from instance state.

```ts
editor.stopFollowingUser()
```

Following stops automatically when you interact with the canvas through panning, zooming, or selecting shapes. Manual page changes also stop following unless the follow system itself initiated the page change.

### zoomToUser

Move the camera instantly to a user's cursor position without entering follow mode. Use this for one-time navigation to a collaborator's location.

```ts
editor.zoomToUser('user-abc-123')
editor.zoomToUser('user-abc-123', { animation: { duration: 200 } })
```

If you're already following someone, `zoomToUser()` stops following first. The method switches pages if necessary, centers the camera on the user's cursor, and briefly highlights their cursor for visual feedback. The highlight clears after `collaboratorIdleTimeoutMs`.

## Follow chains

When user A follows user B who is following user C, user A follows user C directly rather than B's view of C. The editor traverses the follow chain until it finds a user who isn't following anyone else.

The traversal maintains a visited set to prevent infinite loops if users create a circular follow chain. If a cycle is detected, it returns the last valid presence before the cycle. This keeps the system stable even with invalid follow configurations.

```ts
// A follows B follows C
// A's camera tracks C's viewport, not B's viewport
editor.startFollowingUser('user-b')
// Internally resolves to user-c's presence if user-b is following user-c
```

The follow chain resolution runs on every frame, so changes in the chain (like B stopping following C) immediately affect A's target viewport without requiring A to restart following.

## UI integration

### FollowingIndicator

The [`DefaultFollowingIndicator`](/reference/tldraw/reference/tldraw/DefaultFollowingIndicator) component displays a colored border around the canvas when you're following someone. It reads `followingUserId` from instance state and fetches the corresponding presence record to get the user's color.

```tsx
import { useEditor, usePresence, useValue } from '@tldraw/editor'

export function DefaultFollowingIndicator() {
	const editor = useEditor()
	const followingUserId = useValue('follow', () => editor.getInstanceState().followingUserId, [
		editor,
	])
	if (!followingUserId) return null
	return <FollowingIndicatorInner userId={followingUserId} />
}

function FollowingIndicatorInner({ userId }: { userId: string }) {
	const presence = usePresence(userId)
	if (!presence) return null
	return <div className="tlui-following-indicator" style={{ borderColor: presence.color }} />
}
```

You can override this component through the [UI customization](/docs/ui-components) system to change its appearance or add the followed user's name.

### Follow state detection

Check `editor.getInstanceState().followingUserId` to detect when a user is following someone. Use this to show UI elements like a "Stop following" button or status indicators.

```ts
const followingUserId = editor.getInstanceState().followingUserId
if (followingUserId) {
	// Show stop following button
}
```

The presence records from [`Editor.getCollaborators`](/reference/editor/reference/editor/Editor#getCollaborators) include each user's `followingUserId`, so you can visualize the entire follow graph and show which users are following whom.

## Related

- [Camera](/docs/camera) - Learn about viewport and camera control
- [Collaboration](/docs/collaboration) - Set up multiplayer presence and sync
- [Pages](/docs/pages) - Understand page management
- [UI components](/docs/ui-components) - Customize UI elements like the following indicator

--------

# User preferences

User preferences store per-user settings that persist across sessions and synchronize across browser tabs. Access them through `editor.user`:

```tsx
import { Tldraw, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

function PreferencesPanel() {
	const editor = useEditor()

	// Read preferences
	const isDark = editor.user.getIsDarkMode()
	const animationSpeed = editor.user.getAnimationSpeed()
	const locale = editor.user.getLocale()

	// Update preferences
	const toggleDarkMode = () => {
		editor.user.updateUserPreferences({
			colorScheme: isDark ? 'light' : 'dark',
		})
	}

	return <button onClick={toggleDarkMode}>Toggle theme</button>
}

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw components={{ TopPanel: PreferencesPanel }} />
		</div>
	)
}
```

Preferences fall into three categories: visual settings (color scheme, animation speed), interaction settings (snap mode, edge scroll speed), and identity properties (user name, color, locale). The system stores data in localStorage and uses the BroadcastChannel API to sync changes across tabs in real time.

## Reading preferences

The `UserPreferencesManager` exposes each preference as a computed value. These are reactive: when you read them, your component automatically re-renders when the value changes.

```tsx
// Individual preferences
const isDark = editor.user.getIsDarkMode()
const speed = editor.user.getAnimationSpeed()
const locale = editor.user.getLocale()
const userName = editor.user.getName()
const userColor = editor.user.getColor()
const isSnapMode = editor.user.getIsSnapMode()

// All preferences as an object
const allPrefs = editor.user.getUserPreferences()
```

## Updating preferences

Use `updateUserPreferences()` to change one or more preferences at once:

```tsx
editor.user.updateUserPreferences({
	colorScheme: 'dark',
	animationSpeed: 0.5,
	isSnapMode: true,
})
```

Changes apply immediately, save to localStorage, and broadcast to other tabs.

## Available preferences

### Visual preferences

| Preference         | Type                            | Default                        | Description                          |
| ------------------ | ------------------------------- | ------------------------------ | ------------------------------------ |
| `colorScheme`      | `'light' \| 'dark' \| 'system'` | `'light'`                      | Theme mode                           |
| `animationSpeed`   | `number`                        | `1` (or `0` if reduced motion) | Multiplier for animation durations   |
| `enhancedA11yMode` | `boolean`                       | `false`                        | Additional UI labels and visual aids |

When `colorScheme` is `'system'`, the editor tracks the operating system's dark mode preference through a media query listener.

### Interaction preferences

| Preference                    | Type                            | Default | Description                                     |
| ----------------------------- | ------------------------------- | ------- | ----------------------------------------------- |
| `isSnapMode`                  | `boolean`                       | `false` | Snap shapes to other shapes and guides          |
| `isWrapMode`                  | `boolean`                       | `false` | Enable text wrapping in text shapes             |
| `isDynamicSizeMode`           | `boolean`                       | `false` | Live shape updates during resize                |
| `isPasteAtCursorMode`         | `boolean`                       | `false` | Paste at cursor instead of original location    |
| `edgeScrollSpeed`             | `number`                        | `1`     | Speed multiplier for edge scrolling during drag |
| `areKeyboardShortcutsEnabled` | `boolean`                       | `true`  | Enable or disable keyboard shortcuts            |
| `inputMode`                   | `'trackpad' \| 'mouse' \| null` | `null`  | Optimize behavior for input device              |

### Identity properties

| Preference | Type     | Default             | Description                          |
| ---------- | -------- | ------------------- | ------------------------------------ |
| `id`       | `string` | Auto-generated      | Unique user identifier               |
| `name`     | `string` | `''`                | Display name shown to collaborators  |
| `color`    | `string` | Random from palette | User color for cursor and selections |
| `locale`   | `string` | Browser locale      | Language code (e.g., `'en'`, `'fr'`) |

The user color is randomly chosen from 12 visually distinct colors designed for collaboration.

## Dark mode

The `getIsDarkMode()` method resolves the color scheme to a boolean. When `colorScheme` is `'system'`, it tracks the operating system's preference through a media query listener:

```tsx
const isDark = editor.user.getIsDarkMode()
// true if colorScheme is 'dark', or 'system' with OS in dark mode
```

You can also use the `inferDarkMode` prop on the Tldraw component to automatically infer the initial theme from the user's system preference:

```tsx
<Tldraw inferDarkMode />
```

## Persistence and synchronization

Preferences persist to localStorage under the key `TLDRAW_USER_DATA_v3`. Each save includes a version number, and the system runs migrations when loading older data to keep preferences compatible across tldraw releases.

The system uses the BroadcastChannel API to sync preference changes across browser tabs. When you change a preference in one tab, all other tabs update automatically. Each tab has a unique origin ID to avoid processing its own broadcasts.

## Accessibility defaults

The `animationSpeed` default respects the `prefers-reduced-motion` media query. Users with reduced motion enabled get `animationSpeed: 0` by default, disabling animations without manual configuration.

## Validation

Preferences are validated using `userTypeValidator` from `@tldraw/editor`. Invalid data falls back to fresh preferences rather than causing errors.

## Related examples

- [Toggle dark mode](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/dark-mode-toggle) - Toggle between light and dark mode by changing `colorScheme`.
- [Infer dark mode](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/infer-dark-mode) - Automatically infer the initial theme from the user's system preference.

--------

# Validation

Validation in tldraw is handled by `@tldraw/validate` and applied across schemas, record types, and shape props. Validators enforce runtime type safety and provide structured errors when data is malformed.

## Where validation runs

- Shape and binding props via `RecordProps`
- Record types in the Store via `createRecordType` and `StoreSchema`
- Worker request parsing via `parseRequestBody` and `parseRequestQuery`

## Core validators

Use `T` validators to describe data shapes and validate unknown input:

```typescript
import { T } from '@tldraw/validate'

const userValidator = T.object({
	id: T.string,
	name: T.string.optional(),
	age: T.number.optional(),
})

const user = userValidator.validate(input)
```

Every validator has three key methods:

- `validate(value)` - validates unknown input and returns a typed result
- `isValid(value)` - returns true if valid, false otherwise (useful as a type guard)
- `validateUsingKnownGoodVersion(knownGood, newValue)` - performance-optimized validation that reuses previously validated data

## Validator catalog

### Primitives

- `T.unknown`, `T.any`
- `T.string`, `T.number`, `T.boolean`, `T.bigint`

### Numbers

- `T.positiveNumber`, `T.nonZeroNumber`, `T.nonZeroFiniteNumber`
- `T.unitInterval`, `T.integer`, `T.positiveInteger`, `T.nonZeroInteger`

### Collections and objects

- `T.array`, `T.arrayOf`, `T.object`, `T.unknownObject`
- `T.dict`, `T.jsonDict`, `T.jsonValue`

### Unions and enums

- `T.literal`, `T.literalEnum`, `T.setEnum`
- `T.union`, `T.or`

### URLs and identifiers

- `T.linkUrl`, `T.srcUrl`, `T.httpUrl`, `T.indexKey`

### Modifiers and helpers

- `validator.optional()`, `validator.nullable()`
- `T.optional(...)`, `T.nullable(...)`
- `validator.refine(...)`, `validator.check(...)`
- `T.model(...)`

## Common validator patterns

```typescript
import { T, ValidationError } from '@tldraw/validate'

const configValidator = T.object({
	id: T.string,
	mode: T.literalEnum('view', 'edit'),
	tags: T.arrayOf(T.string).optional(),
	meta: T.object({ note: T.string }).nullable(),
})

const evenNumber = T.number.check('even', (value) => {
	if (value % 2 !== 0) throw new ValidationError('Expected even number')
})
```

## Record props validation

Shapes and bindings use `RecordProps` to validate their `props` at runtime. This keeps stored data consistent with the schema.

```typescript
import { ShapeUtil, type RecordProps, T, DefaultColorStyle } from 'tldraw'

class MyShapeUtil extends ShapeUtil<MyShape> {
	static override props: RecordProps<MyShape> = {
		color: DefaultColorStyle,
		text: T.string,
	}
}
```

## Store validation and recovery

The Store validates records on write. You can provide `onValidationFailure` to recover or sanitize data:

```typescript
import { StoreSchema, createRecordType } from '@tldraw/store'

const Book = createRecordType<Book>('book', { scope: 'document' })

const schema = StoreSchema.create(
	{ book: Book },
	{
		onValidationFailure: (failure) => failure.record,
	}
)
```

The `failure` object contains:

| Property       | Description                                                                              |
| -------------- | ---------------------------------------------------------------------------------------- |
| `error`        | The validation error that occurred                                                       |
| `store`        | The store instance where validation failed                                               |
| `record`       | The invalid record                                                                       |
| `phase`        | When validation failed: `'initialize'`, `'createRecord'`, `'updateRecord'`, or `'tests'` |
| `recordBefore` | The previous record state (null for new records)                                         |

## Validation lifecycle

1. A record is created or updated.
2. The record type validator runs.
3. If validation fails, `onValidationFailure` receives the failure object.
4. The handler can return a corrected record or throw to abort the write.

## Error handling

The `ValidationError` class provides structured information about what went wrong:

```typescript
import { T, ValidationError } from '@tldraw/validate'

const userValidator = T.object({
	name: T.string,
	settings: T.object({ theme: T.literalEnum('light', 'dark') }),
})

try {
	userValidator.validate({ name: 'Alice', settings: { theme: 'invalid' } })
} catch (error) {
	if (error instanceof ValidationError) {
		console.log(error.message) // "At settings.theme: Expected "light" or "dark", got "invalid""
		console.log(error.rawMessage) // 'Expected "light" or "dark", got "invalid"'
		console.log(error.path) // ['settings', 'theme']
	}
}
```

The error has two useful properties:

- `rawMessage` - the error message without path information
- `path` - an array showing where in the data structure validation failed (e.g., `['settings', 'theme']` or `['items', 0, 'name']`)

The full `message` property combines these: `"At settings.theme: Expected..."`.

## Gotchas

- Validators must be pure and must not mutate input values.
- If you use `onValidationFailure`, return a valid record or rethrow to abort the write.

## Related examples

- **[Custom shape](/examples/shapes/tools/custom-shape)** - Define shape props with validators using RecordProps.
- **[Shape meta (on create)](/examples/events/meta-on-create)** - Add custom metadata to shapes when they're created.

--------

# Handles

In tldraw, handles are interactive control points on shapes that let users manipulate shape geometry. Arrows have handles at their endpoints, lines have handles at each vertex, and notes have clone handles for quick duplication.

## Handle basics

Handles appear when a shape is selected. Each handle has a position, type, and optional snapping behavior. You define handles by implementing `getHandles` on your [`ShapeUtil`](/reference/editor/reference/editor/ShapeUtil):

```tsx
import { ShapeUtil, TLHandle, ZERO_INDEX_KEY } from 'tldraw'

class MyShapeUtil extends ShapeUtil<MyShape> {
	// ...

	override getHandles(shape: MyShape): TLHandle[] {
		return [
			{
				id: 'point',
				type: 'vertex',
				index: ZERO_INDEX_KEY,
				x: shape.props.pointX,
				y: shape.props.pointY,
			},
		]
	}
}
```

Handle coordinates are in the shape's local coordinate system, where `(0, 0)` is the shape's top-left corner.

## Handle types

There are four handle types:

| Type      | Description                                                                    |
| --------- | ------------------------------------------------------------------------------ |
| `vertex`  | A primary control point that defines part of the shape's geometry              |
| `virtual` | A secondary handle between vertices. Use it to add new points to a path.       |
| `create`  | A handle for extending geometry. Line shapes use these to add endpoints.       |
| `clone`   | A handle for duplicating the shape. Note shapes use these for adjacent copies. |

Most custom shapes use `vertex` handles. The `virtual` and `create` types are used by the line shape to let users add points to a path.

## Responding to handle drags

When a user drags a handle, tldraw calls `onHandleDrag` with the updated handle position. Return the new shape props:

```tsx
import { ShapeUtil, TLHandleDragInfo } from 'tldraw'

class SpeechBubbleUtil extends ShapeUtil<SpeechBubbleShape> {
	// ...

	override onHandleDrag(shape: SpeechBubbleShape, { handle }: TLHandleDragInfo<SpeechBubbleShape>) {
		return {
			...shape,
			props: {
				...shape.props,
				tailX: handle.x,
				tailY: handle.y,
			},
		}
	}
}
```

The `handle` object in `TLHandleDragInfo` contains the updated `x` and `y` coordinates. Use these to update your shape's props.

### Lifecycle callbacks

For more control over handle interactions, implement these additional methods:

| Method               | When it's called                    |
| -------------------- | ----------------------------------- |
| `onHandleDragStart`  | When the user starts dragging       |
| `onHandleDragEnd`    | When the user releases the handle   |
| `onHandleDragCancel` | When the drag is cancelled (escape) |

## Handle snapping

Handles can snap to other shapes' geometry. Set `snapType` on the handle:

```tsx
{
	id: 'end',
	type: 'vertex',
	index: ZERO_INDEX_KEY,
	x: shape.props.endX,
	y: shape.props.endY,
	snapType: 'point', // Snap to points on other shapes
}
```

The `snapType` options are:

| Value     | Behavior                                               |
| --------- | ------------------------------------------------------ |
| `'point'` | Snaps to key points on other shapes (corners, centers) |
| `'align'` | Snaps to alignment guides from other shapes            |

### Angle snapping

When the user holds Shift while dragging, handles snap to 15-degree angles. By default, this is relative to the shape's position. You can snap relative to another handle by setting `snapReferenceHandleId`:

```tsx
{
	id: 'controlPoint',
	type: 'vertex',
	index: indices[1],
	x: shape.props.cpX,
	y: shape.props.cpY,
	snapType: 'align',
	snapReferenceHandleId: 'start', // Angle snaps relative to 'start' handle
}
```

Bezier curves use this so control points snap to angles relative to their associated endpoint.

### Custom snap geometry

By default, handles snap to a shape's outline and key points. Override `getHandleSnapGeometry` to customize what handles snap to:

```tsx
import { HandleSnapGeometry, ShapeUtil } from 'tldraw'

class BezierCurveUtil extends ShapeUtil<BezierCurveShape> {
	// ...

	override getHandleSnapGeometry(shape: BezierCurveShape): HandleSnapGeometry {
		return {
			// Points other shapes' handles can snap to
			points: [shape.props.start, shape.props.end],

			// Points this shape's own handles can snap to (for self-snapping)
			getSelfSnapPoints: (handle) => {
				if (handle.id === 'controlPoint') {
					return [shape.props.start, shape.props.end]
				}
				return []
			},
		}
	}
}
```

The `HandleSnapGeometry` object has these properties:

| Property             | Description                                                    |
| -------------------- | -------------------------------------------------------------- |
| `outline`            | Custom outline geometry for snapping (default: shape geometry) |
| `points`             | Key points to snap to (corners, centers, etc.)                 |
| `getSelfSnapOutline` | Returns outline for self-snapping given a handle               |
| `getSelfSnapPoints`  | Returns points for self-snapping given a handle                |

## Complete example

Here's a speech bubble shape with a draggable tail handle:

```tsx
import { Polygon2d, ShapeUtil, TLHandle, TLHandleDragInfo, TLShape, ZERO_INDEX_KEY } from 'tldraw'

const SPEECH_BUBBLE_TYPE = 'speech-bubble'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[SPEECH_BUBBLE_TYPE]: { w: number; h: number; tailX: number; tailY: number }
	}
}

type SpeechBubbleShape = TLShape<typeof SPEECH_BUBBLE_TYPE>

class SpeechBubbleUtil extends ShapeUtil<SpeechBubbleShape> {
	static override type = SPEECH_BUBBLE_TYPE

	getDefaultProps(): SpeechBubbleShape['props'] {
		return { w: 200, h: 100, tailX: 100, tailY: 150 }
	}

	getGeometry(shape: SpeechBubbleShape) {
		const { w, h, tailX, tailY } = shape.props
		return new Polygon2d({
			points: [
				{ x: 0, y: 0 },
				{ x: w, y: 0 },
				{ x: w, y: h },
				{ x: w * 0.7, y: h },
				{ x: tailX, y: tailY },
				{ x: w * 0.3, y: h },
				{ x: 0, y: h },
			],
			isFilled: true,
		})
	}

	override getHandles(shape: SpeechBubbleShape): TLHandle[] {
		return [
			{
				id: 'tail',
				type: 'vertex',
				label: 'Move tail',
				index: ZERO_INDEX_KEY,
				x: shape.props.tailX,
				y: shape.props.tailY,
			},
		]
	}

	override onHandleDrag(shape: SpeechBubbleShape, { handle }: TLHandleDragInfo<SpeechBubbleShape>) {
		return {
			...shape,
			props: {
				...shape.props,
				tailX: handle.x,
				tailY: handle.y,
			},
		}
	}

	component(shape: SpeechBubbleShape) {
		const geometry = this.getGeometry(shape)
		return (
			<svg className="tl-svg-container">
				<path d={geometry.getSvgPathData()} fill="white" stroke="black" />
			</svg>
		)
	}

	indicator(shape: SpeechBubbleShape) {
		const geometry = this.getGeometry(shape)
		return <path d={geometry.getSvgPathData()} />
	}
}
```

## Reading handles

Use [`Editor.getShapeHandles`](/reference/editor/reference/editor/Editor#getShapeHandles) to get the handles for any shape:

```ts
const handles = editor.getShapeHandles(shape)
if (handles) {
	for (const handle of handles) {
		console.log(handle.id, handle.x, handle.y)
	}
}
```

Returns `undefined` if the shape doesn't have handles.

## Examples

- [Custom shape with handles](/examples/shapes/tools/speech-bubble) — A speech bubble shape with a draggable tail handle
- [Cubic bezier curve shape](/examples/shapes/tools/cubic-bezier-shape) — Multiple handles with custom snapping and control point behavior

--------

# Visibility

The editor's visibility system determines which shapes are rendered on screen. It handles two separate concerns: **culling** (hiding off-screen shapes for performance) and **hidden shapes** (shapes your application explicitly hides).

## Culling

Culling is a performance optimization. Shapes outside the viewport are removed from the render output by setting `display: none` on their DOM elements. The shapes remain in the store and can still be selected, updated, or queried—they just don't render.

You can get the set of culled shape IDs with [`Editor.getCulledShapes`](/reference/editor/reference/editor/Editor#getCulledShapes):

```ts
const culledIds = editor.getCulledShapes()
```

Two kinds of shapes are never culled, even when off-screen:

1. **Selected shapes** — the user might be dragging them back into view
2. **The editing shape** — the user is actively working on it

### How culling works

The editor uses a spatial index (an R-tree) to quickly find which shapes are inside the viewport. Shapes outside the viewport are candidates for culling, but the final decision depends on [`ShapeUtil.canCull`](/reference/editor/reference/editor/ShapeUtil#canCull):

```ts
class MyShapeUtil extends ShapeUtil<MyShape> {
	override canCull(shape: MyShape): boolean {
		return true // default behavior
	}
}
```

Return `false` from `canCull` to prevent a shape from being culled. You'd do this for shapes that need to keep running while off-screen—for example, shapes that measure their DOM content to determine their size:

```ts
class DynamicSizeShapeUtil extends ShapeUtil<DynamicSizeShape> {
	override canCull() {
		return false // keep rendering so we can measure DOM
	}
}
```

### Culling methods

| Method                                          | Description                                                                   |
| ----------------------------------------------- | ----------------------------------------------------------------------------- |
| [`Editor.getCulledShapes`](/reference/editor/reference/editor/Editor#getCulledShapes)                     | Returns the set of shape IDs that are currently culled.                       |
| [`Editor.getNotVisibleShapes`](/reference/editor/reference/editor/Editor#getNotVisibleShapes)                 | Returns shape IDs outside the viewport (before selection filtering).          |
| [`Editor.getCurrentPageRenderingShapesSorted`](/reference/editor/reference/editor/Editor#getCurrentPageRenderingShapesSorted) | Returns shapes that will actually render (excludes culled and hidden shapes). |

## Hidden shapes

Hidden shapes are shapes your application explicitly hides using the `getShapeVisibility` option. Unlike culled shapes, hidden shapes are excluded from hit tests, exports, and rendering.

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				getShapeVisibility={(shape) => {
					if (shape.meta.hidden) return 'hidden'
					return 'inherit'
				}}
			/>
		</div>
	)
}
```

The function can return:

| Return value               | Behavior                                                |
| -------------------------- | ------------------------------------------------------- |
| `'inherit'` or `undefined` | Shape is visible unless its parent is hidden (default). |
| `'hidden'`                 | Shape is always hidden.                                 |
| `'visible'`                | Shape is always visible, even if parent is hidden.      |

Hidden shapes are still in the store. They're just excluded from:

- Canvas rendering
- Hit tests ([`Editor.getShapeAtPoint`](/reference/editor/reference/editor/Editor#getShapeAtPoint), [`Editor.getShapesAtPoint`](/reference/editor/reference/editor/Editor#getShapesAtPoint))
- [`Editor.getRenderingShapes`](/reference/editor/reference/editor/Editor#getRenderingShapes) and [`Editor.getCurrentPageRenderingShapesSorted`](/reference/editor/reference/editor/Editor#getCurrentPageRenderingShapesSorted)
- Image exports and printing

You can check if a shape is hidden with [`Editor.isShapeHidden`](/reference/editor/reference/editor/Editor#isShapeHidden):

```ts
if (editor.isShapeHidden(shapeId)) {
	// shape won't render
}
```

### Preventing hidden shapes from being selected

Hidden shapes can still be selected via keyboard shortcuts like select-all. If you want to prevent this, filter the selection when it changes:

```tsx
import { react, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function App() {
	return (
		<div style={{ position: 'fixed', inset: 0 }}>
			<Tldraw
				getShapeVisibility={(shape) => (shape.meta.hidden ? 'hidden' : 'inherit')}
				onMount={(editor) => {
					return react('filter hidden from selection', () => {
						const selectedIds = editor.getSelectedShapeIds()
						const visibleIds = selectedIds.filter((id) => !editor.isShapeHidden(id))
						if (selectedIds.length !== visibleIds.length) {
							editor.setSelectedShapes(visibleIds)
						}
					})
				}}
			/>
		</div>
	)
}
```

For examples using hidden shapes, see the [collaboration private content example](/examples/collaboration/sync-private-content) and the [layer panel example](/examples/ui/layer-panel).

## Opacity

Each shape has an `opacity` property (0 to 1) that controls its transparency. When shapes are nested, opacity multiplies down the hierarchy—a shape at 0.5 opacity inside a parent at 0.5 opacity renders at 0.25 opacity.

The editor calculates the cumulative opacity for each shape and passes it to the rendering layer. You can access the computed opacity through [`Editor.getRenderingShapes`](/reference/editor/reference/editor/Editor#getRenderingShapes):

```ts
const renderingShapes = editor.getRenderingShapes()
for (const { shape, opacity } of renderingShapes) {
	console.log(shape.id, opacity) // cumulative opacity
}
```

### Erasing feedback

When shapes are being erased (the user is mid-gesture with the eraser tool), they render at 32% of their normal opacity. This gives visual feedback that the shapes will be deleted when the gesture completes. The editor handles this automatically—you don't need to implement anything for erasing feedback to work.

## Rendering shapes

[`Editor.getRenderingShapes`](/reference/editor/reference/editor/Editor#getRenderingShapes) returns the shapes that should be rendered, along with their computed properties:

```ts
interface TLRenderingShape {
	id: TLShapeId
	shape: TLShape
	util: ShapeUtil
	index: number // z-index for the shape layer
	backgroundIndex: number // z-index for the background layer
	opacity: number // cumulative opacity
}
```

The `index` and `backgroundIndex` values control z-ordering. The editor uses CSS z-index rather than DOM ordering to position shapes visually. This keeps the DOM stable (shapes stay in ID order) and avoids expensive reflows when z-order changes.

For most use cases, you won't need to work with rendering shapes directly—the editor's canvas handles this. But if you're building custom rendering or need to understand which shapes are visible at what opacity, this is the API to use.

--------

# Performance

The tldraw SDK uses several techniques to maintain smooth performance even with thousands of shapes on the canvas. Understanding these systems helps you build custom shapes that perform well and avoid common pitfalls.

## How tldraw optimizes rendering

### Viewport culling

Shapes outside the viewport don't need to render. The editor maintains a spatial index that tracks which shapes are visible, and hides off-screen shapes by setting `display: none` on their DOM elements. This means a canvas with 10,000 shapes might only render 50 if the rest are out of view.

Culling happens automatically for all shapes. The shapes remain in the store and can still be selected or updated—they just don't incur rendering cost. See [Culling](/docs/culling) for details on how to control this behavior for custom shapes.

### Reactive signals

The SDK uses reactive [signals](/docs/signals) instead of React's built-in state management. Signals automatically track dependencies and update only the parts of your application that actually depend on changed data.

When a shape's props change, only that shape's component re-renders—not the entire canvas. The system tracks dependencies at a granular level, so changing a shape's color won't trigger updates for shapes that don't care about color.

This is why methods like `editor.getSelectedShapeIds()` return reactive values. If you access them inside a `track()` component or `useValue()` hook, your code automatically re-runs when the underlying data changes.

### Batched store updates

The [store](/docs/store) batches multiple changes into single updates. When you call methods like `editor.createShapes()` or `editor.updateShapes()` with multiple shapes, observers receive one notification with all changes rather than one per shape:

```ts
// These changes are batched automatically
editor.updateShapes([
	{ id: shape1.id, type: 'geo', x: 100 },
	{ id: shape2.id, type: 'geo', x: 200 },
	{ id: shape3.id, type: 'geo', x: 300 },
])
```

For complex operations spanning multiple calls, wrap them in `editor.run()`:

```ts
editor.run(() => {
	editor.createShapes([...])
	editor.updateShapes([...])
	editor.deleteShapes([...])
})
// All changes applied together, listeners notified once
```

### Debounced zoom

When the camera moves, shape components receive the new zoom level to scale stroke widths and other visual properties. On documents with many shapes, recalculating everything mid-zoom causes jank.

The editor provides `editor.getEfficientZoomLevel()` which returns a stable value during camera movement when the document has more than 500 shapes (configurable via the `debouncedZoomThreshold` option). Once the camera stops, the value updates to the true zoom level.

Shape components should use this value rather than `editor.getZoomLevel()` for properties that affect rendering:

```tsx
function MyShapeComponent({ shape }) {
	const editor = useEditor()
	const zoom = useValue('zoom', () => editor.getEfficientZoomLevel(), [editor])

	// Stroke width stays stable during camera movement
	const strokeWidth = 2 / zoom

	return <path strokeWidth={strokeWidth} ... />
}
```

### Geometry caching

Computing a shape's geometry—bounds, hit test regions, outline—can be expensive. The editor caches these computations and invalidates them only when a shape's props change.

Access cached geometry through `editor.getShapeGeometry(shapeId)` rather than calling `shapeUtil.getGeometry()` directly. The editor handles caching, transforms, and bounds calculation.

## Tips for custom shapes

### Simplify at small sizes

When shapes are very small on screen, fine details become invisible. Rendering simpler geometry at low zoom levels improves performance without visible quality loss.

Use `editor.getEfficientZoomLevel()` to detect when shapes are small enough to simplify:

```tsx
function MyShapeComponent({ shape }) {
	const editor = useEditor()
	const isSmall = useValue(
		'is small',
		() => {
			const zoom = editor.getEfficientZoomLevel()
			// Shape is small if its screen size is under 50px
			return shape.props.w * zoom < 50
		},
		[editor, shape.props.w]
	)

	if (isSmall) {
		// Render simplified version
		return <rect width={shape.props.w} height={shape.props.h} fill="currentColor" />
	}

	// Render full detail version
	return <ComplexShapeContent shape={shape} />
}
```

The built-in shapes use this pattern. Pattern fills switch to solid colors when zoomed out far enough, and text shadows disable at low zoom levels (controlled by the `textShadowLod` option).

### Avoid shape animations

Animating shape properties causes continuous re-renders. A spinning shape triggers updates every frame. If you have many shapes or complex rendering, this adds up quickly.

If you need animation, consider:

- **CSS animations** for purely visual effects that don't change shape data
- **Canvas rendering** for particle systems or complex animations
- **Limiting concurrent animations** to a small number of shapes

The [Animation](/docs/animation) article covers the editor's animation system. The animation system handles camera movement and occasional shape transitions. It's not designed for continuous per-shape animation.

### Use stable values for zoom-dependent calculations

When calculating values that depend on zoom (stroke widths, font sizes, handle positions), use `getEfficientZoomLevel()` rather than `getZoomLevel()`. This prevents recalculations during camera movement:

```tsx
// Avoid: causes re-renders during zoom
const strokeWidth = 2 / editor.getZoomLevel()

// Better: stable during camera movement
const strokeWidth = 2 / editor.getEfficientZoomLevel()
```

### Keep component functions cheap

Shape components render frequently. Avoid expensive operations inside them:

```tsx
// Avoid: expensive calculation every render
function MyShapeComponent({ shape }) {
	const complexData = computeExpensiveData(shape) // runs every render
	return <div>{complexData}</div>
}

// Better: use memoization or move to getGeometry
function MyShapeComponent({ shape }) {
	const complexData = useMemo(() => computeExpensiveData(shape), [shape.props.relevantProp])
	return <div>{complexData}</div>
}
```

For calculations that affect hit testing or bounds, put them in `getGeometry()` instead. The editor caches geometry automatically.

### Disable culling only when necessary

By default, all shapes participate in culling. Override `canCull()` to return `false` only for shapes that genuinely need to stay rendered off-screen:

```ts
class MyShapeUtil extends ShapeUtil<MyShape> {
	override canCull(shape: MyShape): boolean {
		// Only disable culling for shapes that measure their DOM
		return !shape.props.dynamicSize
	}
}
```

Common reasons to disable culling:

- Shapes that measure their DOM content to determine size
- Shapes with visual effects (shadows, glows) that extend beyond bounds
- Shapes running animations that should continue off-screen

For most shapes, leave culling enabled.

## Editor options for performance

Several [editor options](/docs/options) affect performance:

| Option                   | Default | Description                                      |
| ------------------------ | ------- | ------------------------------------------------ |
| `debouncedZoom`          | `true`  | Use stable zoom during camera movement           |
| `debouncedZoomThreshold` | 500     | Shape count above which debounced zoom activates |
| `maxShapesPerPage`       | 4000    | Maximum shapes allowed per page                  |
| `textShadowLod`          | 0.35    | Zoom threshold below which text shadows disable  |

```tsx
import { Tldraw } from 'tldraw'

function App() {
	return (
		<Tldraw
			options={{
				debouncedZoomThreshold: 1000, // Higher threshold for simpler documents
				maxShapesPerPage: 10000, // Allow more shapes if needed
			}}
		/>
	)
}
```

## Measuring performance

When investigating performance issues:

1. **Check shape count** — `editor.getCurrentPageShapeIds().size` tells you how many shapes are on the current page
2. **Check culled shapes** — `editor.getCulledShapes().size` shows how many are hidden by culling
3. **Use browser profiler** — React DevTools and Chrome's Performance tab help identify slow components
4. **Test with production builds** — Development mode has overhead that production builds don't

If performance degrades with many shapes, look for:

- Shapes that disable culling unnecessarily
- Components that use `getZoomLevel()` instead of `getEfficientZoomLevel()`
- Expensive calculations inside component render functions
- Continuous animations on many shapes

## Related

- [Culling](/docs/culling) — How viewport culling works and how to control it
- [Signals](/docs/signals) — The reactive state system
- [Store](/docs/store) — How the reactive database batches changes
- [Options](/docs/options) — All available editor options
- [Animation](/docs/animation) — The shape and camera animation systems

--------------------------------

# tldraw SDK releases

--------

# v4.3.0

[View on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.3.0)

This release introduces several significant changes: a new pattern for defining custom shape/binding typings, pluggable storage for `TLSocketRoom` with a new SQLite option, reactive `editor.inputs`, and optimized draw shape encoding. It also adds various other API improvements, performance optimizations, and bug fixes, including better support for React 19.

---

### New pattern for defining custom shape/binding types (breaking change) ([#7091](https://github.com/tldraw/tldraw/pull/7091))

We've improved the developer experience of working with custom shape and binding types. There's now less boilerplate and fewer gotchas when using tldraw APIs in a type-safe manner.

This is a minor breaking change at the type level—your code will still run, but you'll get TypeScript errors until you migrate.

<details>
<summary>Migration guide</summary>

When _declaring_ types for custom shapes, you can now use TypeScript's module augmentation feature to provide more specific types for the custom shape.

Before:

```ts
import { TLBaseShape } from 'tldraw'

// Shapes were defined by using the helper TLBaseShape type
type MyShape = TLBaseShape`<'my-shape', { w: number; h: number; text: string }>`
```

After:

```ts
import { TLShape } from 'tldraw'

const MY_SHAPE = 'my-shape'

// We now use TypeScript's module augmentation feature to allow
// extending the builtin TLShape type.
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_SHAPE]: { w: number; h: number; text: string }
	}
}

type MyShape = TLShape`<typeof MY_SHAPE>`
```

The benefit of this new system is that Editor APIs such as `createShape` now know about your custom shapes automatically:

```ts
// Just works - TypeScript validates props and provides autocomplete
editor.createShape({ type: 'my-shape', props: { w: 100, h: 100, text: 'Hello' } })

// Will cause a TypeScript error for `text`
editor.createShape({ type: 'my-shape', props: { w: 100, h: 100, text: 123 } })
```

The same pattern applies to custom bindings. See the [Custom Shapes Guide](https://tldraw.dev/docs/shapes#Custom-shapes-1) and the [Pin Bindings example](https://github.com/tldraw/tldraw/tree/main/apps/examples/src/examples/pin-bindings) for details.

</details>

(contributed by [@Andarist](https://github.com/Andarist))

---

### Pluggable storage for TLSocketRoom + SQLite support ([#7320](https://github.com/tldraw/tldraw/pull/7320), [#7123](https://github.com/tldraw/tldraw/pull/7123))

We've refactored the `TLSocketRoom` API to support a pluggable storage layer. We're providing two implementations:

- **`SQLiteSyncStorage`** – Automatically persists room state to SQLite. Recommended for production.
- **`InMemorySyncStorage`** – Keeps state in memory with manual persistence via callbacks (previous built-in behavior).

**We recommend switching to `SQLiteSyncStorage` if your environment supports SQLite** (Cloudflare Durable Objects, Node.js, Bun, Deno). It provides automatic persistence, lower memory usage, and faster startup times.

<details>
<summary>Why SQLite?</summary>

- **Automatic persistence**: Data survives process restarts without manual snapshot handling
- **Lower memory usage**: No need to keep entire documents in memory
- **Faster startup**: No need to load the document into memory before accepting socket connections
- **Simpler code**: No more `onChange` callbacks and manual persistence logic

</details>

<details>
<summary>Platform support</summary>

| Platform                   | Wrapper                          | SQLite Library                    |
| -------------------------- | -------------------------------- | --------------------------------- |
| Cloudflare Durable Objects | `DurableObjectSqliteSyncWrapper` | Built-in `ctx.storage`            |
| Node.js/Deno               | `NodeSqliteWrapper`              | `better-sqlite3` or `node:sqlite` |

See the [Cloudflare template](https://github.com/tldraw/tldraw-sync-cloudflare) and the [Node server example](https://github.com/tldraw/tldraw/tree/main/templates/simple-server-example) respectively. Bun support should be straightforward to add.

</details>

<details>
<summary>Migration guide</summary>

Existing code continues to work, however we have deprecated the following `TLSocketRoom` options:

- `initialSnapshot`
- `onDataChange`

These are replaced by the new `storage` option. We've also deprecated the `TLSocketRoom.updateStore` method, which has been supplanted by `storage.transaction`.

Before:

```ts
const existingSnapshot = loadExistingSnapshot()

const room = new TLSocketRoom({
	initialSnapshot: existingSnapshot,
	onDataChange: () => {
		persistSnapshot(room.getCurrentSnapshot())
	},
})
```

If you want to keep the same behavior with in-memory document storage and manual persistence:

```ts
import { InMemorySyncStorage, TLSocketRoom } from '@tldraw/sync-core'

const room = new TLSocketRoom({
	storage: new InMemorySyncStorage({
		snapshot: existingSnapshot,
		onChange() {
			saveToDatabase(storage.getSnapshot())
		},
	}),
})
```

However, we recommend switching to SQLite. Users of our Cloudflare template should follow the migration guide on the [sync docs page](https://tldraw.dev/docs/sync).

If you're using `TLSocketRoom` on Node, creating the room should end up looking something like this:

```ts
import Database from 'better-sqlite3'
import { SQLiteSyncStorage, NodeSqliteWrapper, TLSocketRoom, RoomSnapshot } from '@tldraw/sync-core'

async function createRoom(roomId: string) {
	const db = new Database(`path/to/${roomId}.db`)
	const sql = new NodeSqliteWrapper(db)
	let snapshot: RoomSnapshot | undefined = undefined
	if (!SQLiteSyncStorage.hasBeenInitialized(sql)) {
		// This db hasn't been used before, so if it's a pre-existing
		// document, load the legacy room snapshot
		snapshot = await loadExistingSnapshot()
	}

	const storage = new SQLiteSyncStorage({ sql, snapshot })
	return new TLSocketRoom({
		storage,
		onSessionRemoved(room, args) {
			if (args.numSessionsRemaining === 0) {
				room.close()
				db.close()
			}
		},
	})
}
```

</details>

---

### Optimized draw shape encoding ([#7364](https://github.com/tldraw/tldraw/pull/7364), [#7710](https://github.com/tldraw/tldraw/pull/7710))

Draw and highlight shape point data is now stored using a compact delta-encoded binary format instead of JSON arrays. This reduces storage size by approximately 80% while preserving stroke fidelity.

<details>
<summary>Breaking change details</summary>

If you were reading or writing draw shape data programatically you might need to update your code to use the new format.

- `TLDrawShapeSegment.points` renamed to `.path` and changed from `VecModel[]` to `string` (base64-encoded)
- Added `scaleX` and `scaleY` properties to draw and highlight shapes
- New exports: `b64Vecs` encoding utilities, e.g. `getPointsFromDrawSegment` helper. Use this if you need to manually read/write point data.

Existing documents are automatically migrated.

</details>

---

### Reactive inputs ([#7312](https://github.com/tldraw/tldraw/pull/7312))

Refactored `editor.inputs` to use reactive atoms via the new `InputsManager` class. All input state is now accessed via getter methods (e.g., `editor.inputs.getCurrentPagePoint()`, `editor.inputs.getShiftKey()`). Direct property access is deprecated but still supported for backwards compatibility.

## API changes

- 💥 **`DefaultTopPanel`** export removed from `tldraw`. The top panel component for displaying the offline indicator is now handled internally by `PeopleMenu`. ([#7568](https://github.com/tldraw/tldraw/pull/7568))
- 💥 **`TextDirection`** export removed from `tldraw`. Use TipTap's native `TextDirection` extension instead. The `richTextValidator` now includes an optional `attrs` property - a migration may be necessary for older clients/custom shapes. ([#7304](https://github.com/tldraw/tldraw/pull/7304))
- Add `tlenvReactive` atom to `@tldraw/editor` for reactive environment state tracking, including coarse pointer detection that updates when users switch between mouse and touch input. ([#7296](https://github.com/tldraw/tldraw/pull/7296))
- Add `hideAllTooltips()` helper function for programmatically dismissing tooltips. ([#7288](https://github.com/tldraw/tldraw/pull/7288))
- Add `zoomToFitPadding` option to `TldrawOptions` to customize the default padding used by zoom-to-fit operations. ([#7602](https://github.com/tldraw/tldraw/pull/7602))
- Add `snapThreshold` option to `TldrawOptions` for configuring the snap distance, defaulting to 8 screen pixels. ([#7543](https://github.com/tldraw/tldraw/pull/7543))
- Add `resizeChildren` configuration option to `FrameShapeUtil` to allow frame children to be resized proportionally when the frame is resized. ([#7526](https://github.com/tldraw/tldraw/pull/7526))
- Add `Editor.canEditShape()` and `Editor.canCropShape()` methods to centralize shape permission checks. Add `ShapeUtil.canEditWhileLocked()` for shapes that remain editable when locked. ([#7361](https://github.com/tldraw/tldraw/pull/7361))
- Add `editor.getDebouncedZoomLevel()` and `editor.getEfficientZoomLevel()` methods for improved zoom performance on dense canvases. Add `debouncedZoom` and `debouncedZoomThreshold` options. ([#7235](https://github.com/tldraw/tldraw/pull/7235))
- Add configurable `showTextOutline` option to `TextShapeUtil`, `ArrowShapeUtil`, and `GeoShapeUtil` via `.configure()` pattern. ([#7314](https://github.com/tldraw/tldraw/pull/7314))
- Export freehand stroke utilities: `getStroke`, `getStrokeOutlinePoints`, and `setStrokePointRadii`. ([#7400](https://github.com/tldraw/tldraw/pull/7400)) (contributed by [@VimHax](https://github.com/VimHax))
- Add `Box.isValid()` method to check for finite coordinates. ([#7532](https://github.com/tldraw/tldraw/pull/7532))
- Add `spacebarPanning` option to control whether spacebar activates pan mode. ([#7312](https://github.com/tldraw/tldraw/pull/7312))
- Introduce pluggable `TLSyncStorage` API for `TLSocketRoom`. The `initialSnapshot` and `onDataChange` options are now deprecated in favor of the new `storage` option. ([#7123](https://github.com/tldraw/tldraw/pull/7123))
- Export `DefaultLabelColorStyle` which is necessary for rich text in custom shapes. ([#7114](https://github.com/tldraw/tldraw/pull/7114))

### Improvements

- Improve coarse pointer detection by replacing CSS media queries with a reactive `data-coarse` attribute that updates when users switch between mouse and touch input. ([#7404](https://github.com/tldraw/tldraw/pull/7404))
- Add CSS containment to main toolbar and text measurement element for improved rendering performance. ([#7406](https://github.com/tldraw/tldraw/pull/7406)) ([#7407](https://github.com/tldraw/tldraw/pull/7407))
- Improve cross-realm support by scoping canvas event listeners to the editor container's ownerDocument. ([#7113](https://github.com/tldraw/tldraw/pull/7113))
- Simplify ImmutableMap implementation for better code clarity. ([#7431](https://github.com/tldraw/tldraw/pull/7431))
- Improve code readability in number validator by using `Number.isFinite()` instead of arithmetic trick. ([#7374](https://github.com/tldraw/tldraw/pull/7374))
- Upgrade to React 19 with all necessary type and configuration changes for compatibility. ([#7317](https://github.com/tldraw/tldraw/pull/7317))
- Improve signal graph traversal performance by eliminating per-recursion closure allocations. ([#7430](https://github.com/tldraw/tldraw/pull/7430))
- Optimize object utility functions. ([#7432](https://github.com/tldraw/tldraw/pull/7432))
- Use in-place sorting in parentsToChildren derivation. ([#7433](https://github.com/tldraw/tldraw/pull/7433))
- Optimize notVisibleShapes derivation with inlined bounds checks. ([#7429](https://github.com/tldraw/tldraw/pull/7429))
- Cache label size measurements with WeakCache for improved geo shape performance. ([#7412](https://github.com/tldraw/tldraw/pull/7412))
- Optimize validators with fast paths and production inlining. ([#7373](https://github.com/tldraw/tldraw/pull/7373))

### Bug fixes

- Fix migrations for draw and highlight shapes to be idempotent, preventing errors when migrations run multiple times. ([#7389](https://github.com/tldraw/tldraw/pull/7389))
- Fix dot detection in draw and highlight shapes after the point compression change. ([#7365](https://github.com/tldraw/tldraw/pull/7365))
- Fix clicking a shape's text label while editing to re-focus the input and select all text. ([#7342](https://github.com/tldraw/tldraw/pull/7342))
- Fix pasting at cursor to correctly account for frames and parent containers. ([#7277](https://github.com/tldraw/tldraw/pull/7277))
- Fix editing mode to exit when dragging causes the text input to blur. ([#7291](https://github.com/tldraw/tldraw/pull/7291))
- Fix CommonJS build issues with TipTap imports in rich text module. ([#7282](https://github.com/tldraw/tldraw/pull/7282))
- Fix iOS automatically zooming in on input fields by ensuring 16px minimum font size. ([#7118](https://github.com/tldraw/tldraw/pull/7118))
- Fix `distanceToLineSegment` returning squared distance instead of actual distance, causing hit testing (eraser, scribble select) to be too strict. ([#7610](https://github.com/tldraw/tldraw/pull/7610)) (contributed by [@arpit-goblins](https://github.com/arpit-goblins))
- Fix `zoomToSelection` to toggle between 100% zoom and zoom-to-fit behavior. ([#7536](https://github.com/tldraw/tldraw/pull/7536))
- Fix export of SVG markers by handling fragment-only URLs correctly. ([#7506](https://github.com/tldraw/tldraw/pull/7506)) (contributed by [@PidgeyBE](https://github.com/PidgeyBE))
- Restore wheel and pinch canvas event emission. ([#6834](https://github.com/tldraw/tldraw/pull/6834)) (contributed by [@swdev33](https://github.com/swdev33))
- Fix context menu submenu flickering when hovered. ([#6837](https://github.com/tldraw/tldraw/pull/6837)) (contributed by [@swdev33](https://github.com/swdev33))
- Fix rotated shape positions not being restored after flipping twice. ([#7359](https://github.com/tldraw/tldraw/pull/7359))
- Fix keyboard shortcuts and clipboard events not working when `hideUi` is true. ([#7367](https://github.com/tldraw/tldraw/pull/7367))
- Fix elbow arrows routing incorrectly when using dynamic sizing at high zoom levels. ([#7424](https://github.com/tldraw/tldraw/pull/7424))
- Allow fullscreen for embed shapes. ([#7417](https://github.com/tldraw/tldraw/pull/7417))
- Move mobile rotate handle to bottom for image and video shapes to accommodate the contextual toolbar. ([#6727](https://github.com/tldraw/tldraw/pull/6727))
- Fix dropdown menu items incorrectly displaying an icon on the right side. ([#7533](https://github.com/tldraw/tldraw/pull/7533))
- Fix zoom menu showing debounced zoom level for canvases with many shapes. ([#7626](https://github.com/tldraw/tldraw/pull/7626))
- Fix extra line appearing after bullet and ordered lists in text shapes. ([#7643](https://github.com/tldraw/tldraw/pull/7643)) (contributed by [@sahiee-dev](https://github.com/sahiee-dev))
- Fix "Back to content" button not appearing when selected shapes are off-screen. ([#7649](https://github.com/tldraw/tldraw/pull/7649))
- Fix dotted freehand lines becoming invisible at minimum zoom on Chrome. ([#7650](https://github.com/tldraw/tldraw/pull/7650))
- Fix menu bar stretching to full width on mobile viewports instead of fitting content. ([#7568](https://github.com/tldraw/tldraw/pull/7568))

--------

# v4.2.0

This month's release includes many bug fixes and small API additions, along with a major version bump of our TipTap rich text editor.

## What's new

### TipTap v3 ([#5717](https://github.com/tldraw/tldraw/pull/5717))

We've upgraded TipTap from v2 to v3. If you've done any customization to our standard TipTap kit, please refer to TipTap's guide [How to upgrade Tiptap v2 to v3](https://tiptap.dev/docs/guides/upgrade-tiptap-v2) for breaking changes you might experience.

## API changes

- Add `Editor.setTool`/`Editor.removeTool` for dynamically altering the editor's tool state chart. ([#6909](https://github.com/tldraw/tldraw/pull/6909)) ([#7134](https://github.com/tldraw/tldraw/pull/7134))
- Allow using custom socket implementations with `useSync` via a new `connect` option. ([#6859](https://github.com/tldraw/tldraw/pull/6859)) (contributed by [@Digital39999](https://github.com/Digital39999))
- Add support for nested property queries in the store. ([#6981](https://github.com/tldraw/tldraw/pull/6981))
- Add `createBookmarkFromUrl` helper for easier bookmark shape creation. ([#6894](https://github.com/tldraw/tldraw/pull/6894))
- Add custom reference points for handle angle snapping. ([#6987](https://github.com/tldraw/tldraw/pull/6987)) (contributed by [@naaa760](https://github.com/naaa760))
- Add new "lined-fill" style, accessible via Option+Shift+F. ([#7034](https://github.com/tldraw/tldraw/pull/7034))
- Add `onInteractionEnd` callback option. ([#6919](https://github.com/tldraw/tldraw/pull/6919))
- Add `allowReferrer` option for window opening functions. ([#7004](https://github.com/tldraw/tldraw/pull/7004))
- Remove defunct Excalidraw embed definition. ([#6897](https://github.com/tldraw/tldraw/pull/6897))

## Improvements

- Use window.prompt for renaming frames on mobile. ([#6838](https://github.com/tldraw/tldraw/pull/6838))
- Optimize string append operations in sync protocol. ([#7007](https://github.com/tldraw/tldraw/pull/7007)) (contributed by [@quasor](https://github.com/quasor))

## Bug fixes

- Fix Replit embed URL handling. ([#6892](https://github.com/tldraw/tldraw/pull/6892))
- Fix accessibility issue that caused a misleading warning in the console. ([#6904](https://github.com/tldraw/tldraw/pull/6904))
- Fix convert-to-bookmark action. ([#6894](https://github.com/tldraw/tldraw/pull/6894))
- Fix dropdown menu pointer handling. ([#7021](https://github.com/tldraw/tldraw/pull/7021))
- Fix iOS Safari image uploads. ([#7037](https://github.com/tldraw/tldraw/pull/7037))
- Fix Alt+Tab conflict on Windows. ([#7005](https://github.com/tldraw/tldraw/pull/7005))
- Fix text focus issues. ([#7043](https://github.com/tldraw/tldraw/pull/7043))
- Fix `TldrawEditor` usability without `TldrawUiContextProvider`. ([#7053](https://github.com/tldraw/tldraw/pull/7053))
- Fix cross-realm clipboard functionality. ([#7026](https://github.com/tldraw/tldraw/pull/7026))
- Fix iOS ink rendering via coalesced events. ([#6917](https://github.com/tldraw/tldraw/pull/6917))
- Fix menu-open dragging behavior. ([#6918](https://github.com/tldraw/tldraw/pull/6918))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.2.0)

---

## Patch releases

### v4.2.1

- Fix CommonJS/cjs builds that were broken in v4.2.0. ([#7282](https://github.com/tldraw/tldraw/pull/7282))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.2.1)

--------

# v4.1.0

This month's release introduces a new shader starter kit for WebGL integration, along with API additions for embed control, minimap filtering, and localStorage-backed atoms.

## What's new

### Shader starter kit ([#6847](https://github.com/tldraw/tldraw/pull/6847))

A new template demonstrating WebGL shader integration with tldraw for dynamic, interactive backgrounds that respond to canvas interactions. Includes four complete examples:

- **Fluid simulation** - Navier-Stokes dynamics
- **Rainbow** - Animated gradients
- **Shadows** - Raymarching and signed distance fields
- **Minimal** - Bare-bones template for custom shaders

Features configurable parameters, localStorage persistence, and full TypeScript support.

## API changes

- Add `embedOnPaste` option to `EmbedDefinition` for opting out of automatic embed-on-paste behavior. ([#6874](https://github.com/tldraw/tldraw/pull/6874))
- Add `hideInMinimap` option to `ShapeUtil` for excluding shapes from the minimap. ([#6327](https://github.com/tldraw/tldraw/pull/6327))
- Add `snapType?: 'point' | 'align'` to `TLHandle` for finer control over handle snapping. The `canSnap` property is now deprecated. ([#6883](https://github.com/tldraw/tldraw/pull/6883))
- Expose `Editor#getShapePageBounds` and `isRecordsDiffEmpty` as public methods. ([#6871](https://github.com/tldraw/tldraw/pull/6871))
- Add `localStorageAtom` to `@tldraw/state` for atoms backed by localStorage with cross-tab syncing. ([#6876](https://github.com/tldraw/tldraw/pull/6876))
- Add inline style picker component variants. ([#6920](https://github.com/tldraw/tldraw/pull/6920))

## Improvements

- Make bookmark titles clickable. ([#6326](https://github.com/tldraw/tldraw/pull/6326))
- Optimize mobile top bar rendering. ([#6895](https://github.com/tldraw/tldraw/pull/6895))
- Add numpad Enter support for entering edit mode. ([#6830](https://github.com/tldraw/tldraw/pull/6830))
- Consolidate preferences menu items. ([#6802](https://github.com/tldraw/tldraw/pull/6802))

## Bug fixes

- Fix accessibility shortcut typo. ([#6811](https://github.com/tldraw/tldraw/pull/6811))
- Fix focus mode action missing. ([#6812](https://github.com/tldraw/tldraw/pull/6812))
- Fix arrow rendering edge case. ([#6799](https://github.com/tldraw/tldraw/pull/6799))
- Fix empty window opening on anchor click. ([#6817](https://github.com/tldraw/tldraw/pull/6817))
- Fix missing translation key. ([#6826](https://github.com/tldraw/tldraw/pull/6826))
- Fix shape index race condition. ([#6884](https://github.com/tldraw/tldraw/pull/6884))
- Fix zero geometry vertices edge case. ([#6885](https://github.com/tldraw/tldraw/pull/6885))
- Fix style panel button overflow. ([#6920](https://github.com/tldraw/tldraw/pull/6920))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.1.0)

---

## Patch releases

### v4.1.1

- Update the formatting of the `npm create tldraw` command in the CLI output.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.1.1)

### v4.1.2

- Move `InFrontOfTheCanvas` component back out of the `.tl-canvas` element. ([#7021](https://github.com/tldraw/tldraw/pull/7021))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.1.2)

--------

# v4.0.0

This major release introduces new starter kits, a CLI tool, WCAG 2.2 Level AA accessibility compliance, and significant API enhancements for building custom canvas applications.

## What's new

### npm create tldraw ([#6753](https://github.com/tldraw/tldraw/pull/6753))

A new CLI tool for quickly scaffolding tldraw projects. Run `npm create tldraw` to initialize projects using templates and starter kits.

### Starter kits

Five new MIT-licensed starter kits demonstrate different applications of tldraw's canvas:

- **[agent](https://tldraw.dev/starter-kits/agent)** - Cursor-style chatbot interface where conversations occur on the canvas with AI assistance
- **[workflow](https://tldraw.dev/starter-kits/workflow)** - Node-and-wire visual programming interface for automation workflows and state machines
- **[branching-chat](https://tldraw.dev/starter-kits/branching-chat)** - Multi-path conversation explorer for managing conversation branches
- **[chat](https://tldraw.dev/starter-kits/chat)** - Canvas-based image annotation with integrated chatbot
- **[multiplayer](https://tldraw.dev/starter-kits/multiplayer)** - Collaborative whiteboard foundation built on tldraw sync

### Licensing ([#6707](https://github.com/tldraw/tldraw/pull/6707))

Production deployments now require a license key. Development and localhost environments remain exempt. Available licenses include:

- Free 100-day trial license
- Commercial license for commercial projects
- Hobby license for non-commercial use

### Accessibility ([#6695](https://github.com/tldraw/tldraw/pull/6695))

Achieves WCAG 2.2 Level AA compliance with an accessibility mode, improved keyboard shortcuts, comprehensive aria-labels, and scrollable menus.

### Drag from toolbar ([#6681](https://github.com/tldraw/tldraw/pull/6681))

Create shapes by dragging directly from the toolbar, eliminating the click-then-draw workflow.

### Custom shape clipping ([#6649](https://github.com/tldraw/tldraw/pull/6649))

Shapes can now clip their children, enabling complex visual hierarchies and container-style shapes.

### Vertical toolbar support ([#6623](https://github.com/tldraw/tldraw/pull/6623))

The toolbar supports vertical orientation for alternative layout configurations.

### Rich text arrows ([#6594](https://github.com/tldraw/tldraw/pull/6594))

Arrow labels support rich text formatting including bold, italic, and text styling.

## API changes

- 💥 **CSS variables** now start with `--tl-` prefix. Update custom CSS: `--color-background` → `--tl-color-background`, `--space-4` → `--tl-space-4`. ([#6712](https://github.com/tldraw/tldraw/pull/6712))
- 💥 **`Geometry2D.isLabel`** replaced with `excludeFromShapeBounds` flag. ([#6668](https://github.com/tldraw/tldraw/pull/6668))
- 💥 **`open-url` event** now uses `destinationUrl` instead of `url`. ([#6641](https://github.com/tldraw/tldraw/pull/6641))
- 💥 **Arrow shapes** now use `richText` instead of `text` property. Data migrates automatically, but direct access to `arrow.props.text` must update to `arrow.props.richText`. ([#6594](https://github.com/tldraw/tldraw/pull/6594))
- 💥 **`@tldraw/ai` module** removed. Use the [agent starter kit](https://tldraw.dev/starter-kits/agent) instead.
- 💥 **Event propagation behavior** changed. Use `editor.markEventAsHandled()` for custom event handling. ([#6592](https://github.com/tldraw/tldraw/pull/6592))
- 💥 **Style panel** redesigned with legacy picker components removed. ([#6573](https://github.com/tldraw/tldraw/pull/6573))
- 💥 **Toolbar CSS class names** updated for consistency. ([#6551](https://github.com/tldraw/tldraw/pull/6551))
- Add custom messages in `TLSocketRoom` via `sendCustomMessage()` and `onCustomMessageReceived`. ([#6614](https://github.com/tldraw/tldraw/pull/6614)) (contributed by [@mootari](https://github.com/mootari))
- Add `Editor.getShapesAtPoint()` with flexible margin options for precise hit testing. ([#6724](https://github.com/tldraw/tldraw/pull/6724))
- Add `editor.toImageDataUrl()` for generating image data URLs directly from shapes. ([#6658](https://github.com/tldraw/tldraw/pull/6658))
- Add `ShapeUtil.isExportBoundsContainer` and `canCull` methods for controlling export behavior and rendering optimization. ([#6649](https://github.com/tldraw/tldraw/pull/6649))
- Add `EditorAtom` for managing UI state outside React components. ([#6687](https://github.com/tldraw/tldraw/pull/6687))
- Add enhanced handle drag callbacks with timing events for custom drag interactions. ([#6702](https://github.com/tldraw/tldraw/pull/6702))

## Bug fixes

- Fix arrow labels being cut off in exports. ([#6783](https://github.com/tldraw/tldraw/pull/6783))
- Fix PNG physical pixel dimensions parsing. ([#6771](https://github.com/tldraw/tldraw/pull/6771))
- Fix pointer events on mobile firing inconsistently. ([#6738](https://github.com/tldraw/tldraw/pull/6738))
- Fix Chrome embed positioning at non-100% zoom levels. ([#6724](https://github.com/tldraw/tldraw/pull/6724))
- Fix hollow shapes not being properly bound-to by arrows. ([#6705](https://github.com/tldraw/tldraw/pull/6705))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.0.0)

---

## Patch releases

### v4.0.1

- Fix template exports. ([#6804](https://github.com/tldraw/tldraw/pull/6804))
- Fix documentation. ([#6805](https://github.com/tldraw/tldraw/pull/6805))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.0.1)

### v4.0.2

- Fix focus mode SDK issue that caused problems when using focus mode in the SDK. ([#6815](https://github.com/tldraw/tldraw/pull/6815))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.0.2)

### v4.0.3

- Add Claude 4.5 Sonnet to agent starter kit. ([#6852](https://github.com/tldraw/tldraw/pull/6852))
- Ensure templates don't use internal functions. ([#6871](https://github.com/tldraw/tldraw/pull/6871))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.0.3)

### v4.0.4

- Fix shape index jitter for the first shape created, preventing potential index collisions. ([#6884](https://github.com/tldraw/tldraw/pull/6884))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v4.0.4)

--------

# v3.9.0

This release focuses on bug fixes and performance enhancements, laying groundwork for v3.10 features.

## API changes

- 💥 **`store.createSelectedComputedCache`** removed; use `store.createCache` with custom selector `computed` instead.
- 💥 **`createComputerCache` API** modified: third argument now accepts options object with `areRecordsEqual` and `areResultsEqual` properties instead of single equality function.

## Improvements

- Improve layout operations including align, distribute, flip, and stack with better compatibility for arrows and overlapping shapes.
- Add new `AtomMap` class to accelerate shape, binding, and record creation/deletion, available as a utility for building custom reactive maps.
- Add horizontal padding to text-bound arrows for improved visual appearance.

## Bug fixes

- Fix pasted image size calculations.
- Remove `canvas-size` dependency resolving bundler compatibility issues.
- Fix SVG copy mimetype.
- Fix text shape cloning crash.
- Fix temporary image preview display during uploads.
- Recognize `https://localhost` as development environment for licensing.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.9.0)

--------

# v3.8.0

This release delivers performance enhancements, UI improvements, and developer experience upgrades alongside bug fixes.

## API changes

- 💥 **`maxDrawShapePoints`** moved to `DrawShapeUtil.configure({ maxPoints })`.
- 💥 **Asset upload** now returns `{ src, meta? }` object instead of string.
- 💥 **JSON export option** removed; `useImageOrVideoAssetUrl` requires width parameter.
- 💥 **`TldrawUiToasts` and `TldrawUiDialogs`** renamed to `DefaultToasts` and `DefaultDialogs`.
- Add new `Editor.toImage` method for refined export functionality.
- Add custom content handlers for pasted tldraw and excalidraw content.
- Add "before-event" listener for custom input event handling.
- Add `onCrop` method for shape-specific cropping customization.

## Improvements

- Add `ShapeUtil.configure` utility for passing options to shape utilities.
- Allow note shapes to resize by scale.
- Add geometric tool shortcut (`g` key) for quick selection.
- Add URL drag-and-drop to create bookmark shapes on canvas.
- Expand support to 40+ languages via i18n enhancements.
- Add React 19 compatibility.
- Improve frame performance through computation relocation.

## Bug fixes

- Fix dialog and edit menu glitches.
- Fix mousewheel scrolling on elements.
- Fix image export width.
- Fix text paste behavior via keyboard shortcuts.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.8.0)

---

## Patch releases

### v3.8.1

- Fix `TldrawImage` not functioning properly with `format=png`. ([#5429](https://github.com/tldraw/tldraw/pull/5429))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.8.1)

--------

# v3.7.0

This release delivers bug fixes and performance enhancements, including customization options for presence data synchronization.

## What's new

### Presence sync customization ([#5149](https://github.com/tldraw/tldraw/pull/5149))

Developers can now customize what presence data is synced between clients, or disable presence syncing entirely. This enables optimization for high-latency connections and privacy-focused applications.

## API changes

- Allow `expandSelectionOutlinePx` to return a `Box` object to enable asymmetric expansion across different sides.
- Modify behavior when using `editor.updateShape` to properly handle undefined values.

## Bug fixes

- Fix React Strict Mode listener bug affecting `store.listen`.
- Fix image rotation and cropping functionality issues.
- Fix CSS import failures during export/print operations.
- Fix text measurement div leakage during development hot reloads.
- Fix popover menu viewport overflow problems.
- Fix GitHub Gist URL validation.
- Fix image dimension limits for pasted content.
- Fix pages menu and quick actions rendering.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.7.0)

---

## Patch releases

### v3.7.1

- Pass custom migrations to `useLocalStore`. ([#5204](https://github.com/tldraw/tldraw/pull/5204))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.7.1)

### v3.7.2

- Fix pasting files copied from the local filesystem with cmd-v. ([#5225](https://github.com/tldraw/tldraw/pull/5225))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.7.2)

--------

# v3.6.0

This release focuses on developer experience improvements with expanded helper functions and various bug fixes across the editor, embed system, and export functionality.

## What's new

### Expanded helper functions ([#5041](https://github.com/tldraw/tldraw/pull/5041))

Actions and toasts overrides now have access to a wider range of helper functions, including clipboard interactions, toast notifications, export utilities, printing, and more. This makes it easier to create custom actions and tools that integrate deeply with tldraw's functionality.

## API changes

- 💥 **`setEmbedDefinitions`** changed from an instance method to a static method on the `EmbedShapeUtil` class. Update your embed definitions to use `EmbedShapeUtil.setEmbedDefinitions()` instead of calling it on an instance. ([#5027](https://github.com/tldraw/tldraw/pull/5027))
- 💥 **`ExtractOptionalKeys` and `ExtractRequiredKeys`** utility types removed. Use the new utility type for creating optional properties instead. ([#5055](https://github.com/tldraw/tldraw/pull/5055))

## Improvements

- Add utility type for making undefined properties optional, simplifying type definitions for shape props and other optional configurations. ([#5055](https://github.com/tldraw/tldraw/pull/5055))
- Make notes properly snap to the grid after their position is updated, improving alignment consistency. ([#5010](https://github.com/tldraw/tldraw/pull/5010))
- Add incremental derivation example demonstrating advanced computed value patterns. ([#5038](https://github.com/tldraw/tldraw/pull/5038))

## Bug fixes

- Fix asset resolution when copying and pasting multiple items, including proper handling of video assets. ([#5061](https://github.com/tldraw/tldraw/pull/5061))
- Fix text clipping in scaled frames during export, ensuring all text content is visible in exported images. ([#5022](https://github.com/tldraw/tldraw/pull/5022))
- Fix concurrent export operations interfering with each other's font loading. ([#5022](https://github.com/tldraw/tldraw/pull/5022))
- Fix long-press point accuracy to ensure touch interactions register at the correct coordinates. ([#5032](https://github.com/tldraw/tldraw/pull/5032))
- Fix export naming for single unnamed frames, which now receive appropriate default names. ([#4918](https://github.com/tldraw/tldraw/pull/4918))
- Fix custom embeds not rendering correctly on initial mount. ([#5027](https://github.com/tldraw/tldraw/pull/5027))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.6.0)

---

## Patch releases

### v3.6.1

- Fix bugs in the editor, state-react, and tldraw packages. ([#5132](https://github.com/tldraw/tldraw/pull/5132))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.6.1)

--------

# v3.5.0

This release introduces enhancements to grid snapping during shape creation, improves layering mechanics, and provides better control over export functionality.

## What's new

### Grid snapping for shape creation ([#4894](https://github.com/tldraw/tldraw/pull/4894))

Shapes now automatically align to the grid when drawn in grid mode. The new `maybeSnapToGrid` function enables snapping for both click-created and drag-created shapes.

### Improved layering actions ([#4898](https://github.com/tldraw/tldraw/pull/4898))

The "bring forward" and "send backward" actions now only consider nearby overlapping shapes, making layer management more intuitive when working with complex canvases.

## API changes

- Add `scale` and `pixelRatio` parameters to export utilities for more precise control over export dimensions and quality.
- Expose font size and stroke size APIs.
- Add socket close reason for rate limiting.
- Add option to toggle double-click text creation.

## Improvements

- Improve panning performance for note-heavy canvases and zoomed-out views.
- Improve page menu hover interaction.
- Add custom React provider support in SVG exports.
- Switch default theme to light mode.
- Improve frame heading right-click behavior.

## Bug fixes

- Fix off-screen shape zoom-to-edit.
- Fix erasing state stickiness.
- Fix frame heading drag interactions.
- Fix Safari sleep-related crashes.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.5.0)

---

## Patch releases

### v3.5.1

- Fix long press on inset canvases. ([#5037](https://github.com/tldraw/tldraw/pull/5037))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.5.1)

--------

# v3.4.0

This release addresses UI bugs, enhances image/video performance, and improves Excalidraw content compatibility.

## API changes

- 💥 **`id` DOM attribute** on shapes removed in favor of a `data-shape-id` attribute on shape wrappers.
- Add `labelColor` property to note shapes.
- Add `useUniqueSafeId` and `useSharedSafeId` utilities for managing DOM IDs in tldraw components.

## Improvements

- Improve tooltip wording in the style panel.
- Prevent arrow label indicators from displaying behind labels.
- Limit page name length in the move-to-page menu.
- Improve image and video rendering performance.

## Bug fixes

- Fix re-render loops caused by inline `options` in the Tldraw component.
- Fix toolbar button outline border-radius alignment.
- Fix color preservation when pasting Excalidraw content.
- Fix unhighlighted menu triggers.
- Fix drag event type handling.
- Fix duplicate image creation on canvas drops.
- Fix link indicator visibility on sticky notes.
- Fix URL parsing in embed dialogs.
- Fix cross-instance rendering conflicts.
- Fix menu options in read-only mode.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.4.0)

---

## Patch releases

### v3.4.1

- Fix arrows being clipped incorrectly when multiple tldraw instances or exports are present in the DOM. ([#4819](https://github.com/tldraw/tldraw/pull/4819))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.4.1)

--------

# v3.3.0

This release introduces sync improvements, readonly mode support, and various performance enhancements.

## What's new

### Readonly mode

Servers can now restrict client editing while preserving presence updates using the new "readonly" mode. This enables use cases like view-only sharing and presentation modes where users can see each other's cursors but cannot modify the document.

### Sync server enhancements

New `TLSocketRoom` methods (`closeSession`, `getRecord`, and `getSessions`) provide finer control over sync connections and room state management.

## API changes

- Add editor option for quick action shortcut placement.
- Add `editor.getIsReadonly()` helper method.

## Improvements

- Pass wheel events through toolbar elements for improved scrolling/zooming.
- Allow Command/Control modifier keys to enable multi-select (previously shift-only).
- Allow text tool to be locked.
- Improve draw shape rendering performance during zoom interactions.

## Bug fixes

- Fix Safari arrow rendering.
- Fix image drop navigation errors.
- Fix watermark layering.
- Fix geometry calculations.
- Fix readonly mode label editing prevention.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.3.0)

---

## Patch releases

### v3.3.1

- Fix meta key incorrectly triggering the shift key. ([#4703](https://github.com/tldraw/tldraw/pull/4703))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.3.1)

### v3.3.2

- Fix dropped images being created twice. ([#4727](https://github.com/tldraw/tldraw/pull/4727))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.3.2)

### v3.3.3

- Fix image duplication when dropping onto the canvas. ([#4789](https://github.com/tldraw/tldraw/pull/4789))
- Fix additional keyboard modifier issues. ([#4789](https://github.com/tldraw/tldraw/pull/4789))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.3.3)

--------

# v3.2.0

This release contains no code changes. It was published to align version numbers across packages. See the [v3.1.0 release notes](/releases/v3.1.0) for information about changes since v3.0.x.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.2.0)

--------

# v3.15.0

This release introduces `npm create tldraw` for bootstrapping new projects, along with API additions, accessibility improvements, and performance optimizations.

## What's new

### npm create tldraw

Developers can now initialize new tldraw projects by running `npm create tldraw` in their terminal, selecting from available starter templates.

## API changes

- Add handle interaction callbacks: `onHandleDragStart`, `onHandleDragEnd`, and cancellation callbacks (`onTranslateCancel`, `onResizeCancel`, `onRotateCancel`, `onHandleDragCancel`).
- Add JSX icon support for custom icons in tool overrides, action overrides, buttons, and menu items.
- Add `StateNode.addChild` method enabling dynamic tool functionality additions.
- Convert `DefaultSpinner` component to SVG format, now accepts standard SVG properties.
- Export `HeartToolbarItem` component.

## Improvements

- Enhance "Select All" functionality to intelligently select within a shape's common parent context (e.g., selecting shapes within a frame without selecting the frame itself).
- Add user preference option to disable keyboard shortcuts.
- Prevent frame drops.
- Optimize the `useValue` and `useReactor` hooks.
- Enhance frame rendering efficiency.
- Expand `aria-hidden` application.
- Improve keyboard navigation.
- Add proper `role="radiogroup"` assignment for toggle groups.
- Correct aria slider values.

## Bug fixes

- Fix HTML entity escaping in pasted content.
- Fix text measurement accuracy.
- Fix arrow rendering between circles.
- Fix SVG text outline rendering.
- Fix image toolbar camera movement interactions.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.15.0)

---

## Patch releases

### v3.15.1

- Fix room change event handling in the sync core library. ([#6543](https://github.com/tldraw/tldraw/pull/6543))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.15.1)

### v3.15.2

- Fix editor remounting in a loop when given custom assetUrls. ([#6605](https://github.com/tldraw/tldraw/pull/6605))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.15.2)

### v3.15.3

- Enhance callback functionality for shape utilities. ([#6634](https://github.com/tldraw/tldraw/pull/6634))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.15.3)

### v3.15.4

- Fix potential bug in TLSyncClient. ([#6660](https://github.com/tldraw/tldraw/pull/6660))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.15.4)

### v3.15.5

- Show license flags message as a warning. ([#6843](https://github.com/tldraw/tldraw/pull/6843))
- Fix expired internal license verification. ([#6843](https://github.com/tldraw/tldraw/pull/6843))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.15.5)

--------

# v3.14.0

This release introduces contextual toolbars for image and video shapes, enhanced cropping options, and a new PathBuilder API.

## API changes

- 💥 **`Editor#getShapePageGeometry`** removed.
- 💥 **`Editor#getShapesAtPoint`** now returns shapes in descending index order.
- 💥 **Locked shapes** cannot be duplicated; pasting locked shapes unlocks them.
- 💥 **`ShapeUtil.canDropShapes`** removed—drag-and-drop participation now requires implementing handlers.
- Add `TldrawUiContextualToolbar` component enabling developers to create floating toolbars.
- Add `PathBuilder` API for constructing tldraw-style inky and dashed SVGs.
- Add arrow binding configuration for controlling when arrows should be exact and/or bind.
- Add `measureScrollWidth` option for text measurement.
- Add `defaultAutoplay` boolean property for `VideoShapeUtil`.

## Improvements

- Add image and video contextual toolbar with floating controls for enhanced interaction.
- Add download functionality for image and video shapes to download original files.
- Add advanced image cropping options.
- Improve context menu keyboard support.
- Improve style panel keyboard navigation.
- Improve focus management.
- Optimize copy operations.
- Optimize arrow rendering with labels.
- Optimize shape resizing.
- Optimize keyboard interactions.
- Optimize arrow dragging.
- Improve text measurement caching.

## Bug fixes

- Fix page menu scrolling behavior.
- Fix undo functionality for sticky creation.
- Fix bookmark hyperlink handling.
- Fix SVG output and vector calculations.
- Fix frame resizing with multiple selections.
- Fix HTML copy-paste positioning.
- Fix keyboard shortcuts and text overflow issues.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.14.0)

---

## Patch releases

### v3.14.1

- Fix text measurement bug where styles could leak from one measurement to the next. ([#6388](https://github.com/tldraw/tldraw/pull/6388))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.14.1)

### v3.14.2

- Fix HTML entities being escaped in clipboard operations. ([#6396](https://github.com/tldraw/tldraw/pull/6396))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.14.2)

--------

# v3.13.0

This release introduces elbow arrows for technical diagramming and continues accessibility improvements toward WCAG compliance.

## What's new

### Elbow arrows

The arrow shape now supports a new elbow connector style. These arrows travel between points using straight lines joined at right angles rather than curved paths, making them ideal for technical diagrams. Access this option through the arrow tool's line style settings.

## API changes

- 💥 **`ShapeUtil.canEditInReadOnly`** renamed to `ShapeUtil.canEditInReadonly` (note capitalization change).
- 💥 **Arrow target highlights** migrated from `setHintingShapes` to a custom `TldrawOverlays` component; users of `<TldrawEditor />` must pass this component to the `Overlays` slot.
- Add text measurement API that accepts arbitrary style parameters.
- Add new `Overlays` component for camera-following canvas overlays.
- Add `hasCustomTabBehavior` prop to `RichTextLabel` for custom tab logic.

## Improvements

- Auto-select link text when editing shape links.
- Snap pasted text and embeds to grid when enabled.
- Allow Figma embeds to work with selection links.
- Show visual block indicating label placement when editing arrow labels.
- Include background color in single frame exports.
- Allow frames to be double-click resized to fit contents.
- Allow style panel to focus with keyboard shortcut.
- Add proper labels to more UI icons and handles.
- Add container navigation shortcuts for moving selections in/out of frames and groups.
- Make embed shapes keyboard-tabbable.
- Add keyboard navigation to toolbars throughout the application.
- Show rich text editing shortcuts in the help menu.
- Improve performance of programmatic rotation of selected shapes.
- Improve performance of multi-shape dragging operations.
- Optimize selection evaluation to prevent unnecessary re-evaluations.

## Bug fixes

- Fix flattened shape backgrounds.
- Fix screenreader behavior.
- Fix tool consistency.
- Fix text rendering.
- Fix selection accuracy.
- Fix arrow flickering during rotation.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.13.0)

---

## Patch releases

### v3.13.1

- Show elbow arrow outline indicator on hover when creating elbow arrows. ([#6099](https://github.com/tldraw/tldraw/pull/6099))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.13.1)

### v3.13.2

- Fix LoadingScreen context bug where custom asset URL configuration was ignored. ([#6283](https://github.com/tldraw/tldraw/pull/6283))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.13.2)

### v3.13.3

- Fix overriding builtin tools not working. ([#6330](https://github.com/tldraw/tldraw/pull/6330))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.13.3)

### v3.13.4

- Fix cross-realm functionality issues. ([#6338](https://github.com/tldraw/tldraw/pull/6338))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.13.4)

--------

# v3.12.0

This release focuses on accessibility improvements and API enhancements, with no breaking changes.

## API changes

- Add new `getShapeVisibility` prop replacing the deprecated `isShapeHidden`, allowing hidden children to override parent visibility states.
- Allow frames to display colorful borders and labels by configuring `FrameShapeUtil` with `showColors: true`.
- Add `Geometry2d` helper methods including `intersectLineSegment`, `intersectCircle`, `transform`, and filtering options.
- Export two Tiptap extensions individually for rich text customization.

## Improvements

- Add keyboard-based selection movement between shapes using Tab and Cmd/Ctrl+Arrow keys.
- Add screen reader announcements for tool and shape selection changes.
- Add keyboard resizing capability via Cmd/Ctrl+Alt+Shift with +/- keys.
- Improve semantic HTML5 tags and proper ARIA roles throughout the UI.
- Simplify keyboard shortcut syntax (e.g., `'?!l'` becomes `'alt+shift+l'`).
- Add atomic `Store.mergeRemoteChanges` with correct scope-triggered side effects.
- Add smoother drawing on slower CPUs via `getCoalescedEvents`.
- Add YouTube embed support for time/loop parameters.
- Add optional asset URL overrides for unused Embed shape icons.

## Bug fixes

- Fix Firefox SVG pasting.
- Fix TailwindCSS text export styling.
- Fix image pasting efficiency.
- Fix Miro shape compatibility.
- Fix Safari trackpad zoom.
- Fix performance regressions in rich text and iPad drawing.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.12.0)

---

## Patch releases

### v3.12.1

- Fix group bounds containing text shapes. ([#5911](https://github.com/tldraw/tldraw/pull/5911))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.12.1)

### v3.12.2

- Restore DPR constrained shape dimensions. ([#6034](https://github.com/tldraw/tldraw/pull/6034))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.12.2)

--------

# v3.11.0

This release addresses rich text issues following v3.10, adds zoom improvements, and introduces accessibility enhancements.

## API changes

- 💥 **`editor.user.getName()`** no longer returns "New user" when unnamed; returns empty string instead.
- 💥 **`defaultUserPreferences.name`** changed from "New user" to empty string.
- Export `RichTextSVG` from the package.

## Improvements

- Add a new minimum zoom step at 5%.
- Add keyboard shortcuts (Shift +/Shift -) for zooming toward your cursor.
- Add option to hit Enter to continue editing after selection in the style panel.
- Improve rich text rendering performance with many shapes.
- Improve hiding/showing shape indicators on large projects.
- Add page navigation shortcuts (option + arrows).
- Add support for satellite mode in Google Map embeds.
- Add focus rings for accessibility.
- Add nonce support for the editor security.

## Bug fixes

- Fix rich text numbered list geometry bounds.
- Fix React 19 StrictMode compatibility.
- Fix export styling issues.
- Fix missing internationalization strings for rich text elements.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.11.0)

---

## Patch releases

### v3.11.1

- Fix application of zoomSpeed setting to pinch gestures. ([#5696](https://github.com/tldraw/tldraw/pull/5696))
- Fix unexpected borders in exports from Tailwind CSS pages. ([#5696](https://github.com/tldraw/tldraw/pull/5696))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.11.1)

### v3.11.2

- Fix sync core bug. ([#6667](https://github.com/tldraw/tldraw/pull/6667))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.11.2)

--------

# v3.10.0

This release introduces rich text as a first-class primitive within the Editor, alongside various performance improvements and bug fixes.

## What's new

### Rich text support

The SDK now offers rich text as a first-class primitive. The implementation utilizes TipTap with its StarterKit extension plus additional customizations. Developers can configure this functionality through a `textOptions` property to customize TipTap and modify extensions.

## API changes

- 💥 **`text` property** on most shapes replaced with `richText`. When setting values, use `richText: toRichText('some string')` instead of `text: 'some string'`. When retrieving values, use `renderPlaintextFromRichText(props.text)` rather than `props.text`.
- Add asset rehydration for .tldr files containing embedded base64 data.
- Add `BrokenAssetIcon` display on file upload failures.
- Add public collaboration hooks (`usePeerIds`, `usePresence`).
- Add `userId` parameter to collaboration components.

## Bug fixes

- Fix performance regression affecting document loading.
- Fix Firefox export/style embedding for foreignObjects.
- Fix shape reparenting order preservation.
- Fix resize functionality.
- Fix Safari file pasting issues.
- Fix SSR environment compatibility (core-js import removal).
- Fix IME text duplication in Chrome.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.10.0)

---

## Patch releases

### v3.10.1

- Fix API reference links in state packages. ([#5610](https://github.com/tldraw/tldraw/pull/5610))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.10.1)

### v3.10.2

- Add `textOptions` to `<TldrawImage />` component. ([#5650](https://github.com/tldraw/tldraw/pull/5650))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.10.2)

### v3.10.3

- Fix Inter font being embedded in exports. ([#5676](https://github.com/tldraw/tldraw/pull/5676))
- Reduce excessive styling in exported content. ([#5676](https://github.com/tldraw/tldraw/pull/5676))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.10.3)

--------

# v3.1.0

This release introduces shape visibility control and server-side data manipulation capabilities, alongside API enhancements and bug fixes.

## What's new

### Shape visibility control ([#4570](https://github.com/tldraw/tldraw/pull/4570))

The new `isShapeHidden` predicate option prevents shapes from being rendered or reacting to pointer events. This is useful for implementing permission systems in collaborative applications where certain shapes should be invisible to specific users.

### Server-side document manipulation ([#4581](https://github.com/tldraw/tldraw/pull/4581))

The tldraw sync server now supports server-side document manipulation through the `updateShapes` method, enabling integration with third-party services and automated document updates.

## API changes

- Add option to `Editor.rotateShapesBy` specifying rotation center point.
- Add `useAsset` hook for resolving responsive asset versions.

## Bug fixes

- Fix arrow label text measurement calculations.
- Fix arrow collaborator indicators overlapping labels.
- Fix binding processing error handling.
- Fix watermark opacity and animation behavior.

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.1.0)

--------

# v3.0.0

This release introduces a revised licensing model alongside deep links, enhanced image export, custom embeds, and a new text search API.

## What's new

### Licensing

The most significant change involves updated licenses permitting use in both commercial and non-commercial projects when displaying a "Made with tldraw" watermark. Users can now purchase Business Licenses to remove the watermark, with details available at [tldraw.dev](https://tldraw.dev). ([#4449](https://github.com/tldraw/tldraw/pull/4449), [#4517](https://github.com/tldraw/tldraw/pull/4517), [#4561](https://github.com/tldraw/tldraw/pull/4561))

### Deep links

New APIs enable creation of shareable URLs pointing to specific canvas locations, such as particular shapes or pages, with automatic URL updates as users navigate.

```typescript
// Create a deep link to a specific shape
const url = editor.createDeepLink({
	shapeId: 'shape-id',
	viewport: 'fit',
})

// The URL updates automatically as you navigate
editor.on('change', () => {
	const currentUrl = editor.getCurrentDeepLink()
})
```

See the [deep links guide](https://tldraw.dev/docs/editor#Deep-links) for more information. ([#4498](https://github.com/tldraw/tldraw/pull/4498))

### Enhanced image export

Custom shapes now export as images by default through HTML/CSS embedding within SVG files, eliminating the need for developers to implement custom SVG rendering methods.

```typescript
// Custom shapes automatically export as images
class MyShapeUtil extends ShapeUtil<MyShape> {
  // No need to implement toSvg() anymore
  component(shape: MyShape) {
    return <div className="my-shape">{/* ... */}</div>
  }
}
```

### Custom embeds API

Developers can now customize which external websites (YouTube, Google Maps, CodeSandbox, etc.) appear as embeddable content, or add entirely new embed types.

```typescript
// Add a custom embed type
const customEmbedDef = {
  type: 'custom',
  title: 'My Custom Embed',
  hostnames: ['mysite.com'],
  toEmbedUrl: (url: string) => `https://mysite.com/embed/${url}`,
  fromEmbedUrl: (url: string) => url.replace('/embed/', '/')
}

<Tldraw embedDefs={[customEmbedDef, ...defaultEmbedDefs]} />
```

### Text search via getText API

A new `getText` API provides reliable access to human-readable shape content, facilitating text search implementation within applications.

```typescript
// Search through all shapes for text content
const searchResults = editor.getCurrentPageShapes().filter((shape) => {
	const text = editor.getText(shape.id)
	return text?.toLowerCase().includes(searchTerm.toLowerCase())
})
```

## API changes

- 💥 **`TLRotationSnapshot`** type removed from the public API. Use `editor.getShapePageTransform(shape).rotation()` instead.
- 💥 **`onEditorMount`** callback in `createTLStore` renamed to `onMount` for consistency.
- 💥 **`Editor.mark()`** deprecated in favor of `Editor.markHistoryStoppingPoint()` for clearer intent.
- 💥 **`TLSvgOptions`** type renamed to `TLImageExportOptions` to better reflect its broader use in image export.
- 💥 **Focus event behavior**: Calling `updateInstanceState({isFocused: true})` now triggers standard focus events consistently. Use `editor.focus()` for reliable focus behavior.
- Add `editor.getText(shapeId)` method for accessing shape text content.
- Add `editor.createDeepLink(options)` for generating shareable URLs.
- Add `embedDefs` prop to Tldraw component for customizing embed types.
- Expose additional shape export utilities for custom image generation.

## Improvements

- Improve bookmark rendering for URLs without preview images. ([#4460](https://github.com/tldraw/tldraw/pull/4460))
- Improve handling of asset storage and persistence. ([#4542](https://github.com/tldraw/tldraw/pull/4542))
- Improve documentation search functionality. ([#4485](https://github.com/tldraw/tldraw/pull/4485))
- Refine watermark appearance and behavior. ([#4589](https://github.com/tldraw/tldraw/pull/4589), [#4622](https://github.com/tldraw/tldraw/pull/4622))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.0.0)

---

## Patch releases

### v3.0.1

- Fix documentation search functionality and article issues. ([#4515](https://github.com/tldraw/tldraw/pull/4515))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.0.1)

### v3.0.2

- Fix build caching issue causing "You have multiple versions of tldraw libraries installed" errors. ([#4525](https://github.com/tldraw/tldraw/pull/4525))
- Fix container null error. ([#4524](https://github.com/tldraw/tldraw/pull/4524))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.0.2)

### v3.0.3

- Fix bugs in the editor and tldraw packages. ([#4541](https://github.com/tldraw/tldraw/pull/4541))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v3.0.3)

--------

# v2.4.0

This release introduces our sync engine as a general-use library, new animation options for shapes, support for image flipping, and many bug fixes and developer experience enhancements.

## What's new

### Sync ([#4031](https://github.com/tldraw/tldraw/pull/4031))

For the first time, we're releasing our real-time collaboration engine—the one we developed for tldraw.com—as a general library. The SDK still supports any backend for collaboration, but we hope this will be the easiest option for developers. See the new `sync` package in the repository and the multiplayer-demo example.

### Interpolation ([#4162](https://github.com/tldraw/tldraw/pull/4162))

You can use `Editor.animateShapes` to animate shapes on the canvas. Previously only position and rotation would animate. Now you can implement `ShapeUtil.getInterpolatedProps` to describe how your custom shape's other properties should animate.

```ts
override getInterpolatedProps(
  startShape: Shape,
  endShape: Shape,
  t: number
): Shape['props'] {
  return {
    ...endShape.props,
    w: lerp(startShape.props.w, endShape.props.w, t),
    h: lerp(startShape.props.h, endShape.props.h, t),
  }
}
```

### Editor.run ([#4042](https://github.com/tldraw/tldraw/pull/4042))

The new `Editor.run` method runs a function within additional context. By default, the function runs inside a transaction, meaning all changes settle at once—improving performance and avoiding unnecessary renders. You can also use options to ignore history or ignore locked shapes.

```ts
editor.run(
	() => {
		editor.createShapes(myShapes)
		editor.sendToBack(myShapes)
		editor.selectNone()
	},
	{ history: 'ignore' }
)
```

### Assets

As part of our work on sync, we have a new system for handling large assets like images and videos. Provide a [`TLAssetStore`](https://tldraw.dev/reference/tlschema/TLAssetStore) to control how assets are uploaded and retrieved. Use [`Editor.uploadAsset`](https://tldraw.dev/reference/editor/Editor#uploadAsset) and [`Editor.resolveAssetURL`](https://tldraw.dev/reference/editor/Editor#resolveAssetUrl) in your shapes and tools.

## API changes

- 💥 **`editor.history.ignore(cb)`** replaced with `editor.run(cb, {history: 'ignore'})`.
- 💥 **`editor.batch`** deprecated, replaced with `editor.run`.
- 💥 **`@tldraw/state` imports**: If you're importing from `@tldraw/state` directly, the `track` function and all hooks (e.g. `useValue`) have moved to `@tldraw/state-react`. ([#4170](https://github.com/tldraw/tldraw/pull/4170))
- Add `DefaultMenuPanel` export. ([#4193](https://github.com/tldraw/tldraw/pull/4193))
- Make `fileSize` property of `TLImageAsset` and `TLVideoAsset` optional. ([#4206](https://github.com/tldraw/tldraw/pull/4206))
- Allow passing partial `TLEditorSnapshot` to `TldrawImage` and `useTLStore`. ([#4190](https://github.com/tldraw/tldraw/pull/4190))
- Make `EffectScheduler` and `useStateTracking` public. ([#4155](https://github.com/tldraw/tldraw/pull/4155))
- Add `setDefaultValue` to `StyleProp`. ([#4044](https://github.com/tldraw/tldraw/pull/4044))
- Add `ShapeUtil.getInterpolatedProps`. ([#4162](https://github.com/tldraw/tldraw/pull/4162))
- Add `Editor.run`, replacing `Editor.batch`. ([#4042](https://github.com/tldraw/tldraw/pull/4042))

## Improvements

- Add horizontal and vertical flipping for images. ([#4113](https://github.com/tldraw/tldraw/pull/4113))
- Allow custom tools to decide whether they are affected by shape lock. ([#4208](https://github.com/tldraw/tldraw/pull/4208))
- Serve icons as a single SVG instead of many individual requests. ([#4150](https://github.com/tldraw/tldraw/pull/4150))
- Make paste-at-point behavior based on a user preference. ([#4104](https://github.com/tldraw/tldraw/pull/4104))
- Show toast when uploading an unsupported file type or file that's too large. ([#4114](https://github.com/tldraw/tldraw/pull/4114))
- Show toast when pasting fails due to missing clipboard permissions. ([#4117](https://github.com/tldraw/tldraw/pull/4117))
- Add `ShapeIndicators` component for custom logic about when to display indicators. ([#4083](https://github.com/tldraw/tldraw/pull/4083))
- Animate shape opacity changes. ([#4242](https://github.com/tldraw/tldraw/pull/4242))

## Bug fixes

- Fix font style export to SVG. ([#4195](https://github.com/tldraw/tldraw/pull/4195))
- Fix `force` flag for camera methods. ([#4214](https://github.com/tldraw/tldraw/pull/4214))
- Show user's color scheme in menu by default. ([#4184](https://github.com/tldraw/tldraw/pull/4184))
- Fix padding for dynamically scaled text shapes. ([#4140](https://github.com/tldraw/tldraw/pull/4140))
- Fix `cameraOptions` via React causing editor to re-mount. ([#4089](https://github.com/tldraw/tldraw/pull/4089))
- Allow high-res images to be uploaded. ([#4198](https://github.com/tldraw/tldraw/pull/4198))
- Prevent locked shapes from being updated, grouped, or ungrouped programmatically. ([#4042](https://github.com/tldraw/tldraw/pull/4042))
- Fix `snapshots` prop in `createTLStore`. ([#4233](https://github.com/tldraw/tldraw/pull/4233))
- Fix grid backgrounds with multiple tldraw instances. ([#4132](https://github.com/tldraw/tldraw/pull/4132))
- Fix inputs staying in place while viewport-following. ([#4108](https://github.com/tldraw/tldraw/pull/4108))
- Fix bookmarks rendering across devices. ([#4118](https://github.com/tldraw/tldraw/pull/4118))
- Fix `InFrontOfTheCanvas` component stack order. ([#4024](https://github.com/tldraw/tldraw/pull/4024))
- Fix frame headers not stopping edit on focus loss. ([#4092](https://github.com/tldraw/tldraw/pull/4092))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.4.0)

---

## Patch releases

### v2.4.1

- Fix `assets` prop on `<Tldraw />` and `<TldrawEditor />` components not being respected. ([#4285](https://github.com/tldraw/tldraw/pull/4285))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.4.1)

### v2.4.2

- Fix bugs and improve the sync engine and related packages. ([#4309](https://github.com/tldraw/tldraw/pull/4309))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.4.2)

### v2.4.3

- Fix bugs in the tldraw package. ([#4328](https://github.com/tldraw/tldraw/pull/4328))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.4.3)

### v2.4.4

- Fix bugs in the editor, sync, tldraw, and tlschema packages. ([#4352](https://github.com/tldraw/tldraw/pull/4352))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.4.4)

### v2.4.5

- Fix unhandled promise rejection during strict mode in the editor. ([#4407](https://github.com/tldraw/tldraw/pull/4407))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.4.5)

### v2.4.6

- Improve rendering performance in the store and tldraw packages. ([#4434](https://github.com/tldraw/tldraw/pull/4434))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.4.6)

--------

# v2.3.0

This release focuses on image and video storage improvements, a new fonts/icons CDN, image performance optimizations, and a new flatten feature.

## What's new

### Image and video storage improvements ([#3836](https://github.com/tldraw/tldraw/pull/3836))

When using local-only storage, images and videos are now stored in a separate IndexedDB table instead of as base64-encoded blobs in the room's JSON. This significantly improves performance and reduces the size of room data.

### Fonts and icons CDN ([#3923](https://github.com/tldraw/tldraw/pull/3923))

Improved our CDN for assets (fonts and icons). We were using unpkg before, but now we're using Cloudflare directly for more fine-grained control and better performance. ([#3927](https://github.com/tldraw/tldraw/pull/3927))

### Image level-of-detail ([#3827](https://github.com/tldraw/tldraw/pull/3827))

For higher-resolution images (over a couple megabytes), the image gets transformed to an appropriate size depending on your viewport, zoom level, and network speed. This helps with bandwidth and browser memory usage when you have multiple high-res images on the board.

### Flatten ([#3933](https://github.com/tldraw/tldraw/pull/3933))

You can now select multiple shapes and flatten them into a single image. For those moments when you need to press things together.

### Security improvements ([#3884](https://github.com/tldraw/tldraw/pull/3884))

Locked down referrer network requests to make sure we weren't leaking tldraw rooms to external media/iframe requests. ([#3881](https://github.com/tldraw/tldraw/pull/3881))

## API changes

- Add fill-fill style, accessible via `Alt`+`F`. ([#3966](https://github.com/tldraw/tldraw/pull/3966))
- Make `ArrowBindingUtil` public. ([#3913](https://github.com/tldraw/tldraw/pull/3913))
- Add `getSnapshot` and `loadSnapshot` methods to `Editor` class. ([#3912](https://github.com/tldraw/tldraw/pull/3912))

## Improvements

- Allow users to use system appearance (dark/light) mode. ([#3703](https://github.com/tldraw/tldraw/pull/3703))
- Remove ability to rename document while in readonly mode. ([#3911](https://github.com/tldraw/tldraw/pull/3911))
- Add delay and easing to edge scrolling. ([#3950](https://github.com/tldraw/tldraw/pull/3950))

## Bug fixes

- Fix copy/paste for older versions of Firefox. ([#4008](https://github.com/tldraw/tldraw/pull/4008))
- Fix copy/paste in Firefox 127+. ([#4003](https://github.com/tldraw/tldraw/pull/4003))
- Fix not allowing editing locked shapes when switching edit modes. ([#4007](https://github.com/tldraw/tldraw/pull/4007))
- Fix text shape measurement in React strict mode. ([#4001](https://github.com/tldraw/tldraw/pull/4001))
- Fix border color for following user. ([#3975](https://github.com/tldraw/tldraw/pull/3975))
- Fix scale issue with new draw lines. ([#3971](https://github.com/tldraw/tldraw/pull/3971))
- Fix edge scrolling at odd browser zoom levels. ([#3973](https://github.com/tldraw/tldraw/pull/3973))
- Fix appearance of solid-style heart shapes. ([#3963](https://github.com/tldraw/tldraw/pull/3963))
- Fix position of multiple assets when pasted/dropped onto canvas. ([#3965](https://github.com/tldraw/tldraw/pull/3965))
- Fix indicator for stylus-drawn draw shapes. ([#3962](https://github.com/tldraw/tldraw/pull/3962))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.3.0)

--------

# v2.2.0

This release introduces the bindings system, camera constraints, and configurable options—major features that unlock new types of applications you can build with tldraw.

## What's new

### Bindings ([#3326](https://github.com/tldraw/tldraw/pull/3326))

Bindings allow you to create relationships between shapes. Our default arrow shapes are a great example: each end of the arrow can bind to another shape. When that shape moves, so does the arrow.

Before this change, arrows were hard-coded into the library. Now, with the bindings system, you can create arrows, constraint systems, visual programming environments, and much more.

Check out the [bindings guide](https://tldraw.dev/docs/editor#Bindings) for more information. ([#3780](https://github.com/tldraw/tldraw/pull/3780)) ([#3797](https://github.com/tldraw/tldraw/pull/3797)) ([#3800](https://github.com/tldraw/tldraw/pull/3800)) ([#3871](https://github.com/tldraw/tldraw/pull/3871))

### Camera constraints ([#3282](https://github.com/tldraw/tldraw/pull/3282))

You can now limit the camera to a fixed area of the canvas. This is useful for creating experiences that don't quite fit the "infinite canvas" paradigm: document annotators, image editors, slideshow creators, and more.

See the [camera constraints guide](https://tldraw.dev/docs/editor#Camera-options) for more information. ([#3747](https://github.com/tldraw/tldraw/pull/3747)) ([#3814](https://github.com/tldraw/tldraw/pull/3814))

### Configurable options ([#3799](https://github.com/tldraw/tldraw/pull/3799))

You can now override many options which were previously hard-coded constants. Pass an `options` prop into the tldraw component to change the maximum number of pages, grid steps, or other previously hard-coded values.

See [`TldrawOptions`](https://tldraw.dev/reference/editor/TldrawOptions) for details. ([#3900](https://github.com/tldraw/tldraw/pull/3900))

### 💥 Undo/redo changes

The history system has been significantly reworked:

1. **History options simplified**: `squashing`, `ephemeral`, and `preserveRedoStack` flags have been consolidated. Use `editor.history.ignore(fn)` or `editor.history.batch(fn, {history: 'record-preserveRedoStack'})` instead.

2. **Automatic recording**: Everything that touches the store is now recorded in undo/redo (unless part of `mergeRemoteChanges`). Use `editor.history.ignore(fn)` for changes you don't want recorded.

3. **Side effects captured**: Changes in side-effects are now captured by undo/redo. Wrap in `editor.history.ignore` for the old behavior.

## API changes

- 💥 **`canBind`** now accepts an options object instead of just the shape. See [`TLShapeUtilCanBindOpts`](https://tldraw.dev/reference/editor/TLShapeUtilCanBindOpts).
- 💥 **`editor.sideEffects.registerBatchCompleteHandler`** replaced with `editor.sideEffects.registerOperationCompleteHandler`. ([#3748](https://github.com/tldraw/tldraw/pull/3748))
- 💥 **`editor.getArrowInfo(shape)`** replaced with `getArrowInfo(editor, shape)`.
- 💥 **`editor.getArrowsBoundTo(shape)`** removed—use `editor.getBindingsToShape(shape, 'arrow')` instead.
- 💥 **Arrow shape `start` and `end` properties** are now always points. Use `getArrowBindings(editor, shape)` to check for bindings.
- 💥 **Types renamed**: `ShapeProps` → `RecordProps`, `ShapePropsType` → `RecordPropsType`, `TLShapePropsMigrations` → `TLPropsMigrations`, `SchemaShapeInfo` → `SchemaPropsInfo`.
- Add `editor.blur` method. ([#3875](https://github.com/tldraw/tldraw/pull/3875))
- Add better defaults for `createTLStore`. ([#3886](https://github.com/tldraw/tldraw/pull/3886))
- Add `getSnapshot` and `loadSnapshot` for easier document persistence. See [State Snapshots](https://tldraw.dev/docs/persistence#State-Snapshots). ([#3811](https://github.com/tldraw/tldraw/pull/3811))
- Add `select` option to `Editor.groupShapes` and `Editor.ungroupShapes`. ([#3690](https://github.com/tldraw/tldraw/pull/3690))
- `InFrontOfTheCanvas` now has access to the editor's UI context. ([#3782](https://github.com/tldraw/tldraw/pull/3782))
- `useEditor` and other context-based hooks now throw an error when used out-of-context. ([#3750](https://github.com/tldraw/tldraw/pull/3750))
- Add `defaultShapeSchemas` for custom multiplayer implementations. ([#3613](https://github.com/tldraw/tldraw/pull/3613))

## Improvements

- Add a heart shape to the geo shape set. ([#3787](https://github.com/tldraw/tldraw/pull/3787))
- Improve rendering for bookmarks without preview images. ([#3856](https://github.com/tldraw/tldraw/pull/3856))
- Improve undo/redo UX around image cropping. ([#3891](https://github.com/tldraw/tldraw/pull/3891))
- Increase default limit of shapes per page from 2000 to 4000. ([#3716](https://github.com/tldraw/tldraw/pull/3716))
- Expand accepted image types to include webp, webm, apng, and avif. ([#3730](https://github.com/tldraw/tldraw/pull/3730))
- Prune unused assets when loading `.tldr` files. ([#3689](https://github.com/tldraw/tldraw/pull/3689))
- Improve handling of mouse-type devices that support pressure (e.g., Wacom tablets). ([#3639](https://github.com/tldraw/tldraw/pull/3639))
- Change text shapes to be left-aligned by default. ([#3627](https://github.com/tldraw/tldraw/pull/3627))
- Add Desmos graph embed type. ([#3608](https://github.com/tldraw/tldraw/pull/3608))

## Bug fixes

- Fix 'insert media' undo removing other changes. ([#3910](https://github.com/tldraw/tldraw/pull/3910))
- Fix referrer being sent for bookmarks and images. ([#3881](https://github.com/tldraw/tldraw/pull/3881))
- Fix minimum drag distance being wrong when zoomed. ([#3873](https://github.com/tldraw/tldraw/pull/3873))
- Fix cropped images not exporting properly. ([#3837](https://github.com/tldraw/tldraw/pull/3837))
- Fix spacebar and middle mouse button panning. ([#3791](https://github.com/tldraw/tldraw/pull/3791)) ([#3792](https://github.com/tldraw/tldraw/pull/3792))
- Fix cursor and shapes wiggling when following someone's viewport. ([#3695](https://github.com/tldraw/tldraw/pull/3695))
- Fix cross-browser focus management issues. ([#3718](https://github.com/tldraw/tldraw/pull/3718))
- Fix imports in Astro. ([#3742](https://github.com/tldraw/tldraw/pull/3742))
- Fix copy/paste for patterned shapes as SVG/PNG. ([#3708](https://github.com/tldraw/tldraw/pull/3708))
- Fix RTL text layout for SVG exports. ([#3680](https://github.com/tldraw/tldraw/pull/3680))
- Fix clicking on minimap sometimes not changing viewport. ([#3617](https://github.com/tldraw/tldraw/pull/3617))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.2.0)

---

## Patch releases

### v2.2.1

- Improve documentation and make `ArrowBindingUtil` public. ([#3958](https://github.com/tldraw/tldraw/pull/3958))
- Add `editor.getSnapshot()` and `editor.loadSnapshot()` methods. ([#3958](https://github.com/tldraw/tldraw/pull/3958))
- Fix CSS styling for bookmark elements. ([#3958](https://github.com/tldraw/tldraw/pull/3958))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.2.1)

### v2.2.2

- Fix text measurement breaking when `Tldraw` was used with React strict mode. ([#4004](https://github.com/tldraw/tldraw/pull/4004))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.2.2)

### v2.2.3

- Fix copy/paste functionality in Firefox 127+. ([#4006](https://github.com/tldraw/tldraw/pull/4006))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.2.3)

### v2.2.4

- Fix copy/paste functionality for older versions of Firefox. ([#4011](https://github.com/tldraw/tldraw/pull/4011))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.2.4)

--------

# v2.1.0

This release includes completely redesigned sticky notes, an overhaul to our migration system, and significant performance improvements.

## What's new

### New stickies ([#3249](https://github.com/tldraw/tldraw/pull/3249))

Sticky notes have been completely redesigned with a fresh look and improved functionality.

### 💥 New migrations ([#3220](https://github.com/tldraw/tldraw/pull/3220))

The migrations system has been overhauled for better reliability and developer experience.

- The `Migrations` type is now called `LegacyMigrations`
- The serialized schema format (returned by `StoreSchema.serialize()` and `Store.getSnapshot()`) has changed
- `compareRecordVersions` and `RecordVersion` have been removed
- `compareSchemas` is gone—use `schema.getMigrationsSince(prevSchema)` instead
- `defineMigrations` has been deprecated. See [updating legacy shape migrations](https://tldraw.dev/docs/persistence#Updating-legacy-shape-migrations-defineMigrations) for upgrade instructions
- `migrate` has been removed

### 💥 Input buffering ([#3223](https://github.com/tldraw/tldraw/pull/3223))

Events are now buffered and sent to state nodes every tick, instead of immediately. This unlocks big performance improvements but could introduce subtle issues with custom tools—make sure to test any custom tools thoroughly.

### 💥 React-powered SVG exports ([#3117](https://github.com/tldraw/tldraw/pull/3117))

If any of your shapes implement `toSvg` for exports, you'll need to replace your implementation with a new version that returns JSX instead of manually constructing SVG DOM nodes.

`editor.getSvg` is deprecated. Use `editor.getSvgElement` or `editor.getSvgString` instead.

### 💥 Component-based toolbar customization ([#3067](https://github.com/tldraw/tldraw/pull/3067))

If you're using the `toolbar` callback to override toolbar items, switch to using the new `Toolbar` component override. See the [custom toolbar example](https://tldraw.dev/examples/ui/custom-toolbar) for details.

## API changes

- 💥 **`getRenderingShapes`** no longer returns `isCulled`—use `getCulledShapes` instead.
- Add `Editor.getStyleForNextShape`. ([#3039](https://github.com/tldraw/tldraw/pull/3039))
- Add `usePreloadAssets` export. ([#3545](https://github.com/tldraw/tldraw/pull/3545))

## Improvements

- Improve color contrast. ([#3486](https://github.com/tldraw/tldraw/pull/3486))
- Add long press event. ([#3275](https://github.com/tldraw/tldraw/pull/3275))
- Add severity colors and icons to toasts. ([#2988](https://github.com/tldraw/tldraw/pull/2988))
- Improve handling of broken images/videos. ([#2990](https://github.com/tldraw/tldraw/pull/2990))
- Improve performance of draw shapes. ([#3464](https://github.com/tldraw/tldraw/pull/3464))
- Use WebGL to draw the minimap. ([#3510](https://github.com/tldraw/tldraw/pull/3510))
- Improve reactivity bookkeeping performance. ([#3471](https://github.com/tldraw/tldraw/pull/3471)) ([#3487](https://github.com/tldraw/tldraw/pull/3487))
- Improve selection/erasing performance. ([#3454](https://github.com/tldraw/tldraw/pull/3454))
- Improve performance of text shapes on iOS/Safari. ([#3429](https://github.com/tldraw/tldraw/pull/3429))
- Reduce rendered DOM nodes for geo shapes and arrows. ([#3283](https://github.com/tldraw/tldraw/pull/3283))
- Improve shape rendering performance. ([#3176](https://github.com/tldraw/tldraw/pull/3176))

## Bug fixes

- Fix copy error sound in Safari. ([#3536](https://github.com/tldraw/tldraw/pull/3536))
- Fix arrow label positioning overlapping bound shapes. ([#3512](https://github.com/tldraw/tldraw/pull/3512))
- Fix cursor chat button appearing when not in select tool. ([#3485](https://github.com/tldraw/tldraw/pull/3485))
- Fix alt-duplicating shapes sometimes not working. ([#3488](https://github.com/tldraw/tldraw/pull/3488))
- Fix camera sliding after pinch. ([#3462](https://github.com/tldraw/tldraw/pull/3462))
- Fix text shapes overflowing their bounds when resized. ([#3327](https://github.com/tldraw/tldraw/pull/3327))
- Fix incorrectly rotated handles on rotated cropping images. ([#3093](https://github.com/tldraw/tldraw/pull/3093))
- Fix videos not being sized correctly. ([#3047](https://github.com/tldraw/tldraw/pull/3047))
- Fix `localStorage` crash in React Native webviews. ([#3043](https://github.com/tldraw/tldraw/pull/3043))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.1.0)

---

## Patch releases

### v2.1.1

- Fix missing export for `createShapePropsMigrationIds`, part of the new migrations API. ([#3594](https://github.com/tldraw/tldraw/pull/3594))
- Add exports for `defaultEditorAssetUrls`, `PORTRAIT_BREAKPOINT`, `useDefaultColorTheme`, and `getPerfectDashProps`. ([#3594](https://github.com/tldraw/tldraw/pull/3594))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.1.1)

### v2.1.2

- Revert a performance optimization that caused computed caches to sometimes not invalidate correctly, leading to stale data and crashes. ([#3611](https://github.com/tldraw/tldraw/pull/3611))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.1.2)

### v2.1.3

- Expose migrations, validators, and versions from tlschema. ([#3613](https://github.com/tldraw/tldraw/pull/3613))
- Add `defaultShapeSchemas` which can be passed directly to `createTLSchema`. ([#3613](https://github.com/tldraw/tldraw/pull/3613))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.1.3)

### v2.1.4

- Fix text selection flakiness when clicking into text shapes. ([#3643](https://github.com/tldraw/tldraw/pull/3643))
- Fix edit→edit not working correctly when unfilled geo shapes are on top of other shapes. ([#3643](https://github.com/tldraw/tldraw/pull/3643))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.1.4)

--------

# v2.0.0

This is the initial public release of the tldraw SDK—a TypeScript library for creating infinite canvas experiences in React. After an extensive alpha and beta period, the SDK is ready for production use.

## What's new

### The editor

At the heart of tldraw is the `Editor` class, a single object that manages all editor state and provides the API for programmatic control. The editor maintains document state through a reactive store system containing JSON-serializable records.

```tsx
import { Tldraw } from 'tldraw'

function App() {
	return (
		<Tldraw
			onMount={(editor) => {
				// Full programmatic control
				editor.createShapes([{ type: 'geo', x: 100, y: 100 }])
				editor.selectAll()
				editor.zoomToFit()
			}}
		/>
	)
}
```

### Default shapes

The SDK ships with a complete set of default shapes:

- **Geo shapes**: Rectangle, ellipse, triangle, diamond, pentagon, hexagon, octagon, star, rhombus, oval, trapezoid, arrow-shapes, cloud, and x-box
- **Draw**: Freehand drawing with pressure sensitivity support
- **Arrow**: Connectable arrows with labels, multiple arrowhead styles, and curved/straight/elbow routing
- **Text**: Rich text with font, size, and alignment options
- **Note**: Sticky notes with customizable colors
- **Image & Video**: Media embedding with cropping support
- **Frame**: Grouping containers that clip their contents
- **Line**: Multi-point lines with various spline options
- **Highlight**: Transparent highlight strokes
- **Embed**: Web content embedding (YouTube, Figma, Google Maps, and more)
- **Bookmark**: URL previews with metadata

### Default tools

A full set of tools for interacting with the canvas:

- **Select**: Selection, multi-select, resize, rotate, and transform shapes
- **Hand**: Pan the canvas
- **Draw**: Freehand drawing
- **Eraser**: Remove shapes by drawing over them
- **Arrow, Line, Geo, Text, Note, Frame, Highlight**: Shape creation tools
- **Laser**: Temporary pointer for presentations
- **Zoom**: Zoom in/out with click or marquee

### State management

The SDK uses a reactive signals system for state management. All editor state is observable, with automatic dependency tracking to prevent unnecessary re-renders.

```tsx
import { track, useEditor } from 'tldraw'

const SelectedShapeCount = track(() => {
	const editor = useEditor()
	return <div>{editor.getSelectedShapeIds().length} selected</div>
})
```

### The store

Document data lives in a `TLStore`—a reactive client-side database that supports:

- JSON-serializable records for shapes, pages, assets, and instance state
- Reactive updates via signals
- Snapshot export/import for persistence
- Schema migrations for backwards compatibility

### Tool system

Tools are implemented as hierarchical state machines using `StateNode`. Events flow through a state chart, enabling complex multi-step interactions:

```tsx
class MyTool extends StateNode {
	static id = 'my-tool'

	onPointerDown(info) {
		const point = this.editor.inputs.currentPagePoint
		this.editor.createShape({ type: 'geo', x: point.x, y: point.y })
	}
}
```

### Shape system

Every shape type has a `ShapeUtil` class defining its behavior—geometry, rendering, interactions, and more. Create custom shapes by extending `ShapeUtil`:

```tsx
class CardShapeUtil extends ShapeUtil<CardShape> {
	static type = 'card'

	getGeometry(shape) {
		return new Rectangle2d({ width: shape.props.w, height: shape.props.h })
	}

	component(shape) {
		return <div className="card">{shape.props.title}</div>
	}
}
```

### User interface

A complete, responsive UI system with:

- Toolbar with tool selection and shape-specific options
- Style panel for colors, fills, fonts, and more
- Context menus with shape actions
- Keyboard shortcuts dialog
- Page management
- Zoom controls and minimap
- Actions menu and quick actions bar
- Help menu and debug panel

All UI components can be overridden or extended via the `components` prop.

### Features

- **Multi-page documents**: Create and manage multiple pages per document
- **Undo/redo**: Full history management with marks and batching
- **Copy/paste**: Between pages, documents, and external applications
- **Export**: SVG, PNG, and JSON export
- **Zoom & pan**: Pinch, scroll, keyboard shortcuts, and programmatic control
- **Grid & snapping**: Align shapes to grid and each other
- **Grouping**: Group shapes together
- **Locking**: Prevent shape modification
- **Duplication**: Alt-drag to duplicate
- **Alignment & distribution**: Align and distribute selected shapes
- **Flip**: Horizontal and vertical flipping
- **Styles**: Color, fill, dash, size, font, and more
- **Dark mode**: Full dark mode support
- **Localization**: 30+ languages supported
- **Accessibility**: Keyboard navigation and screen reader support
- **Touch support**: Full touch and pen input support
- **Pressure sensitivity**: For supported devices

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.0.0)

---

## Patch releases

### v2.0.1

- Avoid randomness at init time, improving consistency for SSR and testing scenarios. ([#3076](https://github.com/tldraw/tldraw/pull/3076))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.0.1)

### v2.0.2

- Fix JPG export functionality. ([#3199](https://github.com/tldraw/tldraw/pull/3199))

[View release on GitHub](https://github.com/tldraw/tldraw/releases/tag/v2.0.2)

--------

# Next release

This release adds 2D canvas rendering for shape indicators, R-tree spatial indexing for faster queries, telestrator-style laser behavior, a preference for inverting mouse wheel zoom direction, and improved sync performance. It also includes various bug fixes for collaborator indicators, hidden shape handling, and spatial indexing.

## What's new

### 2D canvas rendering for shape indicators ([#7708](https://github.com/tldraw/tldraw/pull/7708))

Shape indicators (selection outlines, hover states) now render using a 2D canvas instead of SVG elements. This significantly improves performance when selecting or hovering over many shapes, with up to 25x faster rendering in some scenarios.

Custom shapes can opt into canvas indicators by implementing the new `getIndicatorPath()` method on their ShapeUtil:

```tsx
class MyShapeUtil extends ShapeUtil<MyShape> {
	getIndicatorPath(shape: MyShape): TLIndicatorPath | null {
		return {
			path: new Path2D(),
			// optional clip path for complex shapes like arrows with labels
		}
	}

	// Return false to use the new canvas indicators (default is true for backwards compatibility)
	useLegacyIndicator(): boolean {
		return false
	}
}
```

### Invert mouse wheel zoom direction ([#7732](https://github.com/tldraw/tldraw/pull/7732))

Added a new user preference to invert mouse wheel zoom direction. Some users prefer "natural" scrolling behavior where scrolling down zooms out, which this option now enables.

Access it via Menu → Preferences → Input device → Invert mouse zoom.

### R-tree spatial indexing ([#7676](https://github.com/tldraw/tldraw/pull/7676))

Shape queries now use an R-tree (RBush) for O(log n) lookups instead of O(n) iteration. This significantly improves performance of brushing, scribble selection, and erasing operations, especially with many shapes on the canvas.

The spatial index is maintained internally and accessed through existing public methods like `editor.getShapesAtPoint()` and `editor.getShapeAtPoint()`.

### Telestrator-style laser pointer ([#7681](https://github.com/tldraw/tldraw/pull/7681))

The laser pointer now behaves like a telestrator: all strokes remain visible while you're drawing and fade together when you stop. Previously, each stroke segment would fade independently, creating a trailing effect.

New API additions for controlling laser sessions:

```tsx
// End the active laser session manually
editor.scribbles.endLaserSession()

// Check if a scribble belongs to the active session
editor.scribbles.isScribbleInLaserSession(scribbleId)
```

New options in `TldrawOptions`:

- `laserSessionTimeoutMs` (default: 2000ms) - Inactivity duration before the laser session ends
- `laserMaxSessionDurationMs` (default: 60000ms) - Maximum duration for a laser session

## API changes

- Remove `editor.spatialIndex` from public API. The spatial index is now internal; use `editor.getShapesAtPoint()` and `editor.getShapeAtPoint()` for shape queries. ([#7699](https://github.com/tldraw/tldraw/pull/7699))
- Add `ShapeUtil.getIndicatorPath()` method and `TLIndicatorPath` type for canvas-based indicator rendering. Add `ShapeUtil.useLegacyIndicator()` to control whether shapes use SVG or canvas indicators. ([#7708](https://github.com/tldraw/tldraw/pull/7708))
- Add `isZoomDirectionInverted` to `TLUserPreferences` interface and `UserPreferencesManager.getIsZoomDirectionInverted()` method. Add `ToggleInvertZoomItem` component export and `toggle-invert-zoom` action. ([#7732](https://github.com/tldraw/tldraw/pull/7732))
- Add `complete` to `TL_SCRIBBLE_STATES` enum and `ScribbleManager.complete(id)` method for marking scribbles as complete before fading. ([#7760](https://github.com/tldraw/tldraw/pull/7760))
- Add `ScribbleManager.endLaserSession()` and `ScribbleManager.isScribbleInLaserSession()` methods for controlling laser sessions. Add `laserSessionTimeoutMs` and `laserMaxSessionDurationMs` to `TldrawOptions`. ([#7681](https://github.com/tldraw/tldraw/pull/7681))
- Add `FpsScheduler` class to create FPS-throttled function queues with configurable target rates. ([#7418](https://github.com/tldraw/tldraw/pull/7418))

## Improvements

- Add R-tree spatial indexing for O(log n) shape queries, improving performance of brushing, selection, and erasing with many shapes. ([#7676](https://github.com/tldraw/tldraw/pull/7676))
- Improve laser pointer to keep all strokes visible during a session (telestrator pattern), with strokes fading together when drawing stops. ([#7681](https://github.com/tldraw/tldraw/pull/7681))
- Improve laser pointer strokes with proper taper when lifting the pointer by adding a 'complete' state to the scribble lifecycle. ([#7760](https://github.com/tldraw/tldraw/pull/7760))
- Reduce network traffic by squashing pending push requests before sending, so rapid edits result in fewer network calls. ([#7724](https://github.com/tldraw/tldraw/pull/7724))
- Reduce solo-mode network traffic by using a dedicated FPS-based scheduler that throttles to 1 FPS when no collaborators are present. ([#7657](https://github.com/tldraw/tldraw/pull/7657))
- Improve performance by separating UI and network scheduling into independent queues with configurable target FPS. ([#7418](https://github.com/tldraw/tldraw/pull/7418))
- Improve frame label sizing on smaller viewports and when zoomed out. ([#7746](https://github.com/tldraw/tldraw/pull/7746))

## Bug fixes

- Fix `zoomToFit` and `getCurrentPageBounds` to ignore hidden shapes when computing bounds. ([#7770](https://github.com/tldraw/tldraw/pull/7770))
- Fix collaborator shape indicators not rendering after the canvas indicator change. ([#7759](https://github.com/tldraw/tldraw/pull/7759))
- Fix rich text content not updating correctly with message squashing due to reference comparison. ([#7758](https://github.com/tldraw/tldraw/pull/7758))
- Fix keyboard shortcut menu item labels to use consistent ellipsis formatting. ([#7757](https://github.com/tldraw/tldraw/pull/7757))
- Fix spatial index not removing shapes when moved to a different page. ([#7700](https://github.com/tldraw/tldraw/pull/7700))

--------------------------------

# tldraw SDK Examples

--------

# Tldraw component

Category: Getting started

Keywords: basic, intro, simple, quick, start, hello world, installation

The simplest way to use the `Tldraw` component.

The `Tldraw` component provides the tldraw editor as a regular React component. You can put this component anywhere in your React project. In this example, we make the component take up the height and width of the container.

By default, the component does not persist between refreshes or sync locally between tabs. To keep your work after a refresh, check the [persistence key example](https://tldraw.dev/examples/persistence-key).

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw />
		</div>
	)
}
```

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	return (
		<div className="editor">
			<Tldraw
				onMount={(editor) => {
					editor.selectAll()
				}}
			/>
		</div>
	)
}
```

--------

# Editor options

Category: Configuration

Keywords:

Override default editor options like max number of pages and animation speed.

Use the `options` property to override tldraw's options. In this example, we limit the maximum number of pages to 3, and slow down camera animations like zoom in and zoom out.

## App.tsx

```tsx
import { Tldraw, TldrawOptions } from 'tldraw'
import 'tldraw/tldraw.css'

const options: Partial<TldrawOptions> = {
	maxPages: 3,
	animationMediumMs: 5000,
}

export default function CustomOptionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" options={options} />
		</div>
	)
}
```

--------

# Shape options

Category: Configuration

Keywords: config, configure, shape, util, frame

Change the behavior of built-in shapes by setting their options.

Some of the builtin tldraw shapes can be customized to behave differently based on your needs. This is done via the `ShapeUtil.configure` function which returns a new version of the shape's util class with custom options specified.

You can see a shape's options by looking at the `options` property of its `ShapeUtil`. For example, the note shape's options are listed at [`NoteShapeOptions`](https://tldraw.dev/reference/tldraw/NoteShapeOptions).

## App.tsx

```tsx
import { FrameShapeUtil, NoteShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const shapeUtils = [
	// Enable colors for frame shapes
	FrameShapeUtil.configure({ showColors: true }),

	// Enable resizing for note shapes
	NoteShapeUtil.configure({ resizeMode: 'scale' }),
]

export default function ConfigureShapeUtilExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw shapeUtils={shapeUtils}></Tldraw>
		</div>
	)
}
```

--------

# Camera options

Category: Configuration

Keywords: api, fixed, constraints, camera bounds, pan speed, zoom speed

Configure the camera's options and constraints.

The `Tldraw` component provides a prop, `cameraOptions`, that can be used to set the camera's constraints, zoom behavior, and other options. This example lets you modify those options to see how they affect the camera's behavior.

## App.tsx

```tsx
import { useEffect } from 'react'
import {
	BoxModel,
	TLCameraOptions,
	Tldraw,
	Vec,
	clamp,
	track,
	useEditor,
	useLocalStorageState,
} from 'tldraw'
import 'tldraw/tldraw.css'

const CAMERA_OPTIONS: TLCameraOptions = {
	isLocked: false,
	wheelBehavior: 'pan',
	panSpeed: 1,
	zoomSpeed: 1,
	zoomSteps: [0.1, 0.25, 0.5, 1, 2, 4, 8],
	constraints: {
		initialZoom: 'fit-max',
		baseZoom: 'fit-max',
		bounds: {
			x: 0,
			y: 0,
			w: 1600,
			h: 900,
		},
		behavior: { x: 'contain', y: 'contain' },
		padding: { x: 100, y: 100 },
		origin: { x: 0.5, y: 0.5 },
	},
}

const BOUNDS_SIZES: Record<string, BoxModel> = {
	a4: { x: 0, y: 0, w: 1050, h: 1485 },
	landscape: { x: 0, y: 0, w: 1600, h: 900 },
	portrait: { x: 0, y: 0, w: 900, h: 1600 },
	square: { x: 0, y: 0, w: 900, h: 900 },
}

export default function CameraOptionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// persistenceKey="camera-options"
				components={components}
			>
				<CameraOptionsControlPanel />
			</Tldraw>
		</div>
	)
}

const PaddingDisplay = track(() => {
	const editor = useEditor()
	const cameraOptions = editor.getCameraOptions()

	if (!cameraOptions.constraints) return null

	const {
		constraints: {
			padding: { x: px, y: py },
		},
	} = cameraOptions

	return (
		<div
			style={{
				position: 'absolute',
				top: py,
				left: px,
				width: `calc(100% - ${px * 2}px)`,
				height: `calc(100% - ${py * 2}px)`,
				border: '1px dotted var(--tl-color-text)',
				pointerEvents: 'none',
			}}
		/>
	)
})

const BoundsDisplay = track(() => {
	const editor = useEditor()
	const cameraOptions = editor.getCameraOptions()

	if (!cameraOptions.constraints) return null

	const {
		constraints: {
			bounds: { x, y, w, h },
		},
	} = cameraOptions

	const d = Vec.ToAngle({ x: w, y: h }) * (180 / Math.PI)
	const colB = '#00000002'
	const colA = '#0000001F'

	return (
		<>
			<div
				style={{
					position: 'absolute',
					top: y,
					left: x,
					width: w,
					height: h,
					// grey and white stripes
					border: '1px dashed var(--tl-color-text)',
					backgroundImage: `

				`,
					backgroundSize: '200px 200px',
					backgroundPosition: '0 0, 0 100px, 100px -100px, -100px 0px',
				}}
			>
				<div
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						backgroundImage: `
						linear-gradient(0deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(90deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(${d}deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%),
						linear-gradient(-${d}deg, ${colB} 0%, ${colA} 50%, ${colB} 50%, ${colA} 100%)`,
					}}
				></div>
			</div>
		</>
	)
})

const components = {
	// These components are just included for debugging / visualization!
	OnTheCanvas: BoundsDisplay,
	InFrontOfTheCanvas: PaddingDisplay,
}

const CameraOptionsControlPanel = track(() => {
	const editor = useEditor()

	const [cameraOptions, setCameraOptions] = useLocalStorageState('camera ex1', CAMERA_OPTIONS)

	useEffect(() => {
		if (!editor) return
		editor.run(() => {
			editor.setCameraOptions(cameraOptions)
			editor.setCamera(editor.getCamera(), {
				immediate: true,
			})
		})
	}, [editor, cameraOptions])

	const { constraints } = cameraOptions

	const updateOptions = (
		options: Partial<
			Omit<TLCameraOptions, 'constraints'> & {
				constraints: Partial<TLCameraOptions['constraints']>
			}
		>
	) => {
		const { constraints } = options
		const cameraOptions = editor.getCameraOptions()
		setCameraOptions({
			...cameraOptions,
			...options,
			constraints:
				constraints === undefined
					? cameraOptions.constraints
					: {
							...(cameraOptions.constraints! ?? CAMERA_OPTIONS.constraints),
							...constraints,
						},
		})
	}

	return (
		<div
			style={{
				pointerEvents: 'all',
				position: 'absolute',
				top: 50,
				left: 0,
				padding: 4,
				background: 'white',
				zIndex: 100,
			}}
		>
			<div
				style={{
					display: 'grid',
					gridTemplateColumns: 'auto 1fr',
					columnGap: 12,
					rowGap: 4,
					marginBottom: 12,
					alignItems: 'center',
					justifyContent: 'center',
				}}
			>
				<label htmlFor="lock">Lock</label>
				<select
					name="lock"
					value={cameraOptions.isLocked ? 'true' : 'false'}
					onChange={(e) => {
						const value = e.target.value
						updateOptions({
							...CAMERA_OPTIONS,
							isLocked: value === 'true',
						})
					}}
				>
					<option value="true">true</option>
					<option value="false">false</option>
				</select>
				<label htmlFor="wheelBehavior">Wheel behavior</label>
				<select
					name="wheelBehavior"
					value={cameraOptions.wheelBehavior}
					onChange={(e) => {
						const value = e.target.value
						updateOptions({
							...CAMERA_OPTIONS,
							wheelBehavior: value as 'zoom' | 'pan',
						})
					}}
				>
					<option>zoom</option>
					<option>pan</option>
				</select>
				<label htmlFor="panspeed">Pan Speed</label>
				<input
					name="panspeed"
					type="number"
					step={0.1}
					value={cameraOptions.panSpeed}
					onChange={(e) => {
						const val = clamp(Number(e.target.value), 0, 2)
						updateOptions({ panSpeed: val })
					}}
				/>
				<label htmlFor="zoomspeed">Zoom Speed</label>
				<input
					name="zoomspeed"
					type="number"
					step={0.1}
					value={cameraOptions.zoomSpeed}
					onChange={(e) => {
						const val = clamp(Number(e.target.value), 0, 2)
						updateOptions({ zoomSpeed: val })
					}}
				/>
				<label htmlFor="zoomsteps">Zoom Steps</label>
				<input
					name="zoomsteps"
					type="text"
					defaultValue={cameraOptions.zoomSteps.join(', ')}
					onChange={(e) => {
						try {
							const val = e.target.value.split(', ').map((v) => Number(v))
							if (val.every((v) => typeof v === 'number' && Number.isFinite(v))) {
								updateOptions({ zoomSteps: val })
							}
						} catch {
							// ignore
						}
					}}
				/>
				<label htmlFor="bounds">Bounds</label>
				<select
					name="bounds"
					value={
						Object.entries(BOUNDS_SIZES).find(([_, b]) => b.w === constraints?.bounds.w)?.[0] ??
						'none'
					}
					onChange={(e) => {
						const currentConstraints = constraints ?? CAMERA_OPTIONS.constraints
						const value = e.target.value

						if (value === 'none') {
							updateOptions({
								...CAMERA_OPTIONS,
								constraints: undefined,
							})
							return
						}

						updateOptions({
							...CAMERA_OPTIONS,
							constraints: {
								...currentConstraints,
								bounds: BOUNDS_SIZES[value] ?? BOUNDS_SIZES.a4,
							},
						})
					}}
				>
					<option value="none">none</option>
					<option value="a4">A4 Page</option>
					<option value="portrait">Portait</option>
					<option value="landscape">Landscape</option>
					<option value="square">Square</option>
				</select>
				{constraints ? (
					<>
						<label htmlFor="initialZoom">Initial Zoom</label>
						<select
							name="initialZoom"
							value={constraints.initialZoom}
							onChange={(e) => {
								updateOptions({
									constraints: {
										...constraints,
										initialZoom: e.target.value as any,
									},
								})
							}}
						>
							<option>fit-min</option>
							<option>fit-max</option>
							<option>fit-x</option>
							<option>fit-y</option>
							<option>fit-min-100</option>
							<option>fit-max-100</option>
							<option>fit-x-100</option>
							<option>fit-y-100</option>
							<option>default</option>
						</select>
						<label htmlFor="zoomBehavior">Base Zoom</label>
						<select
							name="zoomBehavior"
							value={constraints.baseZoom}
							onChange={(e) => {
								updateOptions({
									constraints: {
										...constraints,
										baseZoom: e.target.value as any,
									},
								})
							}}
						>
							<option>fit-min</option>
							<option>fit-max</option>
							<option>fit-x</option>
							<option>fit-y</option>
							<option>fit-min-100</option>
							<option>fit-max-100</option>
							<option>fit-x-100</option>
							<option>fit-y-100</option>
							<option>default</option>
						</select>
						<label htmlFor="originX">Origin X</label>
						<input
							name="originX"
							type="number"
							step={0.1}
							value={constraints.origin.x}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0, 1)
								updateOptions({
									constraints: {
										origin: {
											...constraints.origin,
											x: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="originY">Origin Y</label>
						<input
							name="originY"
							type="number"
							step={0.1}
							value={constraints.origin.y}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0, 1)
								updateOptions({
									constraints: {
										...constraints,
										origin: {
											...constraints.origin,
											y: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="paddingX">Padding X</label>
						<input
							name="paddingX"
							type="number"
							step={10}
							value={constraints.padding.x}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0)
								updateOptions({
									constraints: {
										...constraints,
										padding: {
											...constraints.padding,
											x: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="paddingY">Padding Y</label>
						<input
							name="paddingY"
							type="number"
							step={10}
							value={constraints.padding.y}
							onChange={(e) => {
								const val = clamp(Number(e.target.value), 0)
								updateOptions({
									constraints: {
										padding: {
											...constraints.padding,
											y: val,
										},
									},
								})
							}}
						/>
						<label htmlFor="behaviorX">Behavior X</label>
						<select
							name="behaviorX"
							value={(constraints.behavior as { x: any; y: any }).x}
							onChange={(e) => {
								setCameraOptions({
									...cameraOptions,
									constraints: {
										...constraints,
										behavior: {
											...(constraints.behavior as { x: any; y: any }),
											x: e.target.value as any,
										},
									},
								})
							}}
						>
							<option>free</option>
							<option>contain</option>
							<option>inside</option>
							<option>outside</option>
							<option>fixed</option>
						</select>
						<label htmlFor="behaviorY">Behavior Y</label>
						<select
							name="behaviorY"
							value={(constraints.behavior as { x: any; y: any }).y}
							onChange={(e) => {
								setCameraOptions({
									...cameraOptions,
									constraints: {
										...constraints,
										behavior: {
											...(constraints.behavior as { x: any; y: any }),
											y: e.target.value as any,
										},
									},
								})
							}}
						>
							<option>free</option>
							<option>contain</option>
							<option>inside</option>
							<option>outside</option>
							<option>fixed</option>
						</select>
					</>
				) : null}
			</div>
			<div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
				<button
					onClick={() => {
						editor.setCamera(editor.getCamera(), { reset: true })
						// eslint-disable-next-line no-console
						console.log(editor.getCameraOptions())
					}}
				>
					Reset Camera
				</button>
				<button
					onClick={() => {
						updateOptions(CAMERA_OPTIONS)
					}}
				>
					Reset Camera Options
				</button>
			</div>
		</div>
	)
})
```

--------

# Asset options

Category: Configuration

Keywords: images, videos, gif, dimensions, accepted image types

Control the assets (images, videos, etc.) that can be added to the canvas.

This example demonstrates the `<Tldraw/>` component's props that give you control over assets: which types are allowed, the maximum size, and maximum dimensions.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function AssetPropsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// only allow jpegs
				acceptedImageMimeTypes={['image/jpeg']}
				// don't allow any videos
				acceptedVideoMimeTypes={[]}
				// accept images of any dimension
				maxImageDimension={Infinity}
				// ...but only accept assets up to 1mb
				maxAssetSize={1 * 1024 * 1024}
			/>
		</div>
	)
}

/*
This example shows how to use props on the Tldraw component to control what types of
assets can be uploaded.

*/
```

--------

# Custom text outline

Category: Configuration

Keywords:

Disable text outlines on text and arrow labels.

This example shows how to configure the `ArrowShapeUtil` and `TextShapeUtil` to disable text outlines. By default, tldraw adds a text outline (using the canvas background color) to help text stand out when overlapping with other shapes. You can disable this feature by configuring the shape utilities.

This is particularly useful for:

- Performance optimization on certain browsers (we already skip on Safari)
- Different visual styling preferences

## App.tsx

```tsx
import { ArrowShapeUtil, GeoShapeUtil, TextShapeUtil, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// Configure the geo shape to disable outline
const CustomGeoShapeUtil = GeoShapeUtil.configure({
	showTextOutline: false,
})

// Configure the arrow shape to disable text outline
const CustomArrowShapeUtil = ArrowShapeUtil.configure({
	showTextOutline: false,
})

// Configure the text shape to disable outline
const CustomTextShapeUtil = TextShapeUtil.configure({
	showTextOutline: false,
})

// Use the configured shape utilities
const customShapeUtils = [CustomArrowShapeUtil, CustomTextShapeUtil, CustomGeoShapeUtil]

export default function CustomTextOutlineExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Use our custom shape utilities that have text outlines disabled
				shapeUtils={customShapeUtils}
				// Use a persistence key to save the state
				persistenceKey="custom-text-outline-example"
				onMount={(editor) => {
					if (editor.getCurrentPageShapeIds().size > 0) return

					const message = toRichText('very good whiteboard')

					// Lots of overlapping text shapes. These would normally be differentiated a bit using the text outline!
					editor.createShapes([
						{
							type: 'text',
							x: 100,
							y: 100,
							props: { richText: message },
						},
						{
							type: 'text',
							x: 110,
							y: 110,
							props: { richText: message },
						},
						{
							type: 'text',
							x: 120,
							y: 120,
							props: { richText: message },
						},
						{
							type: 'arrow',
							x: 0,
							y: 0,
							props: {
								richText: toRichText('hello world'),
								start: { x: 0, y: 0 },
								end: { x: 200, y: 200 },
							},
						},
					])
				}}
			/>
		</div>
	)
}
```

--------

# Persistence key

Category: Configuration

Keywords: local storage

Persist the editor's content between sessions by using a persistence key.

If the `persistenceKey` prop is provided to the `<Tldraw/>` component, the editor will persist its data locally under that key.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function PersistenceKeyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}
```

--------

# Read-only

Category: Configuration

Keywords: read, only mode

Use the editor in read-only mode.

This example shows how to make the editor read-only. This will disable all editing
functionality and show only the select tool, hand tool and laser pointer on the
toolbar.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ReadOnlyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				onMount={(editor) => {
					editor.updateInstanceState({ isReadonly: true })
				}}
			/>
		</div>
	)
}

/*
This example shows how to make the editor read-only. We use the `onMount` prop to
set the editor's `isReadonly` state to `true`. This will disable all editing
functionality and show only the select tool, hand tool and laser pointer on the
toolbar.
*/
```

--------

# Reduced motion preferences

Category: Configuration

Keywords: accessibility, a11y, reduced motion, animation, prefers-reduced-motion, custom shape

Respecting user motion preferences in custom shapes.

This example demonstrates how to build custom shapes that respect the user's reduced motion preferences using the `usePrefersReducedMotion()` hook.

The hook checks both the user's tldraw preference (`animationSpeed: 0`) and the OS-level `prefers-reduced-motion` setting. When reduced motion is preferred, animations are replaced with static alternatives.

The example includes:

- A custom shape with animated and static variants
- A toggle button to switch between animation modes
- CSS animations controlled by the motion preference

This is particularly important for accessibility, ensuring users with vestibular disorders or motion sensitivities can use your application comfortably.

## App.tsx

```tsx
import {
	Geometry2d,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	TLComponents,
	TLShape,
	Tldraw,
	TldrawUiButton,
	track,
	useEditor,
	usePrefersReducedMotion,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './reduced-motion.css'

const PULSE_SHAPE_TYPE = 'pulse-shape'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[PULSE_SHAPE_TYPE]: { w: number; h: number }
	}
}

type PulseShape = TLShape<typeof PULSE_SHAPE_TYPE>

// [2]
function PulseShapeComponent({ shape: _shape }: { shape: PulseShape }) {
	const prefersReducedMotion = usePrefersReducedMotion()

	return (
		<HTMLContainer className="pulse-shape">
			<div className="pulse-shape__content">
				{/* [3] */}
				<div className={prefersReducedMotion ? 'pulse-indicator--static' : 'pulse-indicator'} />
				<div className="pulse-shape__label">
					{prefersReducedMotion ? 'Static mode' : 'Animated mode'}
				</div>
			</div>
		</HTMLContainer>
	)
}

// [4]
export class PulseShapeUtil extends ShapeUtil<PulseShape> {
	static override type = PULSE_SHAPE_TYPE
	static override props: RecordProps<PulseShape> = {
		w: T.number,
		h: T.number,
	}

	getDefaultProps(): PulseShape['props'] {
		return { w: 200, h: 200 }
	}

	override canEdit() {
		return false
	}

	getGeometry(shape: PulseShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(shape: PulseShape) {
		return <PulseShapeComponent shape={shape} />
	}

	indicator(shape: PulseShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [5]
const MotionToggle = track(function MotionToggle() {
	const editor = useEditor()
	const prefersReducedMotion = usePrefersReducedMotion()

	const toggleMotion = () => {
		const currentSpeed = editor.user.getAnimationSpeed()
		editor.user.updateUserPreferences({
			animationSpeed: currentSpeed === 0 ? 1 : 0,
		})
	}

	return (
		<div className="motion-toggle">
			<span className="motion-toggle__label">
				Motion: {prefersReducedMotion ? 'Reduced' : 'Normal'}
			</span>
			<TldrawUiButton type="primary" onClick={toggleMotion}>
				Toggle
			</TldrawUiButton>
		</div>
	)
})

// [6]
const components: TLComponents = {
	InFrontOfTheCanvas: MotionToggle,
}

export default function ReducedMotionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={[PulseShapeUtil]}
				components={components}
				onMount={(editor) => {
					// [7]
					editor.createShape({ type: PULSE_SHAPE_TYPE, x: 200, y: 200 })
					editor.createShape({ type: PULSE_SHAPE_TYPE, x: 450, y: 200 })
					editor.createShape({ type: PULSE_SHAPE_TYPE, x: 325, y: 450 })
				}}
			/>
		</div>
	)
}

/*
[1]
Extend TLGlobalShapePropsMap to register our custom shape type with TypeScript. This shape
has width (w) and height (h) properties.

[2]
PulseShapeComponent is a React component that renders the shape's content. It uses
usePrefersReducedMotion() to check if the user prefers reduced motion. This hook returns
true when either:
- The user has set animationSpeed to 0 in tldraw preferences
- The OS has prefers-reduced-motion enabled

[3]
The visual indicator changes based on motion preference. When reduced motion is preferred,
it shows a static gray circle. Otherwise, it shows an animated blue circle with a pulsing
effect defined in the CSS file.

[4]
PulseShapeUtil class controls the shape's behavior. The component method returns the
PulseShapeComponent, which allows React hooks to be used for checking motion preferences.

[5]
MotionToggle is a custom component that displays the current motion state and provides a
button to toggle between animated and static modes. It uses track() to reactively update
when preferences change, and updateUserPreferences() to modify the animation speed setting.

[6]
Pass the toggle as the SharePanel component. This places it in the top-right corner of the
editor using tldraw's built-in layout system, avoiding custom positioning CSS.

[7]
On mount, we create three pulse shapes to demonstrate the effect. All shapes respond
simultaneously to the motion preference change.
*/
```

## reduced-motion.css

```css
/* Pulse shape container */
.pulse-shape {
	display: flex;
	align-items: center;
	justify-content: center;
	pointer-events: all;
	background-color: var(--tl-color-low);
	border: 1px solid var(--tl-color-low-border);
	border-radius: var(--tl-radius-3);
}

.pulse-shape__content {
	text-align: center;
}

.pulse-shape__label {
	font-size: 14px;
	color: var(--tl-color-text-1);
}

/* Shared pulse indicator styles */
.pulse-indicator,
.pulse-indicator--static {
	width: 40px;
	height: 40px;
	border-radius: 50%;
	margin: 0 auto 16px;
}

/* Animated indicator */
.pulse-indicator {
	background-color: var(--tl-color-primary);
	animation: pulse 2s ease-in-out infinite;
}

/* Static indicator - no animation */
.pulse-indicator--static {
	background-color: var(--tl-color-text-3);
}

@keyframes pulse {
	0%,
	100% {
		transform: scale(1);
		opacity: 1;
	}
	50% {
		transform: scale(1.2);
		opacity: 0.7;
	}
}

/* Motion toggle */
.motion-toggle {
	position: absolute;
	top: 100px;
	left: 20px;
	display: flex;
	gap: 8px;
	align-items: center;
	pointer-events: all;
}

.motion-toggle__label {
	font-size: 14px;
}
```

--------

# Custom embeds

Category: Configuration

Keywords: embed, custom

Allow custom embeds.

tldraw comes with support for many types of embeds out of the box, but it also comes with the ability to create custom embeds. In this example we'll remove some of the built in embeds and also create a JSFiddle embed.

## App.tsx

```tsx
import {
	CustomEmbedDefinition,
	DEFAULT_EMBED_DEFINITIONS,
	DefaultEmbedDefinitionType,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const defaultEmbedTypesToKeep: DefaultEmbedDefinitionType[] = ['tldraw', 'youtube']
const defaultEmbedsToKeep = DEFAULT_EMBED_DEFINITIONS.filter((embed) =>
	defaultEmbedTypesToKeep.includes(embed.type)
)

// [2]
const customEmbed: CustomEmbedDefinition = {
	type: 'jsfiddle',
	title: 'JSFiddle',
	hostnames: ['jsfiddle.net'],
	minWidth: 300,
	minHeight: 300,
	width: 720,
	height: 500,
	doesResize: true,
	toEmbedUrl: (url) => {
		const urlObj = new URL(url)
		const matches = urlObj.pathname.match(/\/([^/]+)\/([^/]+)\/(\d+)\/embedded/)
		if (matches) {
			return `https://jsfiddle.net/${matches[1]}/${matches[2]}/embedded/`
		}
		return
	},
	fromEmbedUrl: (url) => {
		const urlObj = new URL(url)
		const matches = urlObj.pathname.match(/\/([^/]+)\/([^/]+)\/(\d+)\/embedded/)
		if (matches) {
			return `https://jsfiddle.net/${matches[1]}/${matches[2]}/`
		}
		return
	},
	icon: 'https://jsfiddle.net/img/favicon.png',
}

// [3]
const embeds = [...defaultEmbedsToKeep, customEmbed]

export default function CustomEmbedExample() {
	return (
		<div className="tldraw__editor">
			{/* [4] */}
			<Tldraw embeds={embeds} />
		</div>
	)
}

/**

[1]
tldraw has built-in support for embedding content from several popular apps. In this example, we extract the definitions for handling 'tldraw' and 'youtube' content, and discard the rest.

[2]
We will also add support for embedding JSFiddles. Please note that you have to specify an icon that will be displayed in the `EmbedDialog` component.

[3]
We concatenate the filtered embed definitions with our custom JSFiddle one.

[4]
We now pass the custom embed definitions to the `Tldraw` component.

*/
```

--------

# Custom stroke and font sizes

Category: Configuration

Keywords: stroke, font, size, style

Customize the available stroke and font sizes in tldraw.

Override the `STROKE_SIZES`, and `FONT_SIZES` constants to override the default values.

Note that this will change the stroke and font sizes for ALL instances of tldraw. For example, if you run this example locally, and then open another example, the changes will be present there too until you reload!

## App.tsx

```tsx
import { FONT_SIZES, STROKE_SIZES, Tldraw } from 'tldraw'

// Mutate the built-in stroke sizes
STROKE_SIZES.s = 1
STROKE_SIZES.m = 2
STROKE_SIZES.l = 4
STROKE_SIZES.xl = 8

// Mutate the built-in font sizes
FONT_SIZES.s = 12
FONT_SIZES.m = 16
FONT_SIZES.l = 20
FONT_SIZES.xl = 24

export default function StrokeAndFontSizesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw />
		</div>
	)
}
```

--------

# Environment detection with tlenv and tlenvReactive

Category: Configuration

Keywords: tlenv, tlenvReactive, environment, platform, browser, pointer, touch, mobile

Detect platform, browser, and input device type.

This example demonstrates tldraw's environment detection APIs for building platform-aware and device-adaptive interfaces:

**Static detection (tlenv):**

- Platform detection (macOS, Windows, iOS, Android)
- Browser detection (Safari, Firefox, Chrome)
- Platform-specific keyboard shortcuts (Cmd vs Ctrl)

**Reactive detection (tlenvReactive with useValue):**

- Pointer type detection (coarse/fine) - can change mid-session on hybrid devices
- Real-time updates when switching between touch and mouse input

The example shows practical usage like adapting button sizes based on pointer type - larger touch targets (48px) for coarse pointers (touch) and smaller targets (32px) for fine pointers (mouse/trackpad).

Use `tlenv` for static properties that don't change during the session, and `tlenvReactive` with the `useValue` hook for properties that can change reactively, especially `isCoarsePointer` on touchscreen laptops.

## App.tsx

```tsx
import { Tldraw, TldrawUiButton, TldrawUiIcon, tlenv, tlenvReactive, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './environment-detection.css'

// [1]
function EnvironmentInfo() {
	// [2]
	const isCoarsePointer = useValue('coarse pointer', () => tlenvReactive.get().isCoarsePointer, [
		tlenvReactive,
	])

	// [3]
	const buttonSize = isCoarsePointer ? '48px' : '32px'

	return (
		<div className="tlui-menu environment-info">
			{/* [4] Static detection with tlenv */}
			<div>
				<strong>Platform (tlenv):</strong> {tlenv.isIos && 'iOS'}
				{tlenv.isDarwin && !tlenv.isIos && 'macOS'}
				{tlenv.isAndroid && 'Android'}
				{!tlenv.isDarwin && !tlenv.isIos && !tlenv.isAndroid && 'Other'}
			</div>
			<div>
				<strong>Browser:</strong> {tlenv.isSafari && 'Safari'}
				{tlenv.isFirefox && 'Firefox'}
				{tlenv.isChromeForIos && 'Chrome for iOS'}
				{!tlenv.isSafari && !tlenv.isFirefox && !tlenv.isChromeForIos && 'Other'}
			</div>
			<div>
				<strong>Modifier key:</strong> {tlenv.isDarwin ? '⌘ Cmd' : 'Ctrl'}
			</div>

			{/* [5] Reactive detection with tlenvReactive */}
			<div>
				<strong>Pointer type (reactive):</strong> {isCoarsePointer ? 'Touch' : 'Mouse'}
			</div>

			{/* [6] Adaptive button based on pointer type */}
			<TldrawUiButton
				type="normal"
				style={{
					width: buttonSize,
					height: buttonSize,
					border: '1px solid var(--tl-color-text-3)',
				}}
				onClick={() => alert(`Button size: ${buttonSize}`)}
			>
				<TldrawUiIcon icon="dot" label="Dot" />
			</TldrawUiButton>
		</div>
	)
}

export default function RequestEnvironmentDetectionWithTlenvAndTlenvreactiveExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				components={{
					// [7]
					TopPanel: EnvironmentInfo,
				}}
			/>
		</div>
	)
}

/*
This example demonstrates environment detection using tlenv and tlenvReactive.

[1] Component that displays environment information

[2] Subscribe to tlenvReactive using useValue hook. Since tlenvReactive is an Atom,
    call .get() to access its value. The isCoarsePointer property updates when users
    switch between touch and mouse input.

[3] Calculate button size based on pointer type - touch needs larger targets (48px)
    while mouse can use smaller buttons (32px)

[4] Display static environment detection with tlenv - platform (isDarwin, isIos, isAndroid)
    and browser (isSafari, isFirefox, isChromeForIos). Note: isIos is checked before isDarwin
    because iPadOS reports as Mac, making both isDarwin and isIos true on iPads.

[5] Display reactive pointer detection that updates when input method changes

[6] Adaptive button that changes size based on pointer type

[7] Render component in front of canvas using InFrontOfTheCanvas slot

Key differences:
- tlenv: Static object, direct property access (tlenv.isDarwin)
- tlenvReactive: Reactive Atom, requires useValue(() => tlenvReactive.get().property, [tlenvReactive])
*/
```

## environment-detection.css

```css
.environment-info {
	display: flex;
	flex-direction: column;
	gap: 8px;
	margin: 8px;
	padding: 12px;
}
```

--------

# Deep links

Category: Configuration

Keywords: basic, intro, simple, quick, start

Allow linking to specific parts of a tldraw canvas.

Deep Links are URLs which point to a specific part of a document. We provide a comprehensive set of tools to help you create and manage deep links in your application.

## The `deepLinks` prop

The highest-level API for managing deep links is the `deepLinks` prop on the `<Tldraw />` component. This prop is designed for manipulating `window.location` to add a search param which tldraw can use to navigate to a specific part of the document.

e.g. `https://my-app.com/document-name?d=v1234.-234.3.21`

If you set `deepLinks` to `true` e.g. `<Tldraw deepLinks />` the following default behavior will be enabled:

1. When the editor initializes, before the initial render, it will check the current `window.location` for a search param called `d`. If found, it will try to parse the value of this param as a deep link and navigate to that part of the document.
2. 500 milliseconds after every time the editor finishes navigating to a new part of the document, it will update `window.location` to add the latest version of the `d` param.

You can customize this behavior by passing a configuration object as the `deepLinks` prop. e.g.

```tsx
<Tldraw
	deepLinks={{
		// change the param name to `page`
		paramName: 'page',
		// only link to the current page
		getTarget(editor) {
			return { type: 'page', pageId: editor.getCurrentPageId() }
		},
		// log the new search params to the console instead of updating `window.location`
		onChange(url) {
			console.log('the new search params are', url.searchParams)
		},
		// set the debounce interval to 100ms instead of 500ms
		debounceMs: 100,
	}}
/>
```

For full options see the [`TLDeepLinkOptions`](/reference/editor/reference/editor/TLDeepLinkOptions) API reference.

## Handling deep links manually

We expose the core functionality for managing deep links as a set of methods and utilities. This gives you more control e.g. if you prefer not to use search params in the URL.

### Creating a deep link

You can create an isolated deep link string using the [`createDeepLinkString`](/reference/editor/reference/editor/createDeepLinkString) helper which takes a [`TLDeepLink`](/reference/editor/reference/editor/TLDeepLink) descriptor object.

```tsx
createDeepLinkString({ type: 'page', pageId: 'page:abc123' })
// => 'pabc123'
createDeepLinkString({ type: 'shapes', shapeIds: ['shape:foo', 'shape:bar'] })
// => 'sfoo.bar'
createDeepLinkString({
	type: 'viewport',
	pageId: 'page:abc123',
	bounds: {
		x: 0,
		y: 0,
		w: 1024,
		h: 768,
	},
})
// => 'v0.0.1024.768.abc123'
```

If you do prefer to put this in a URL as a query param, you can use the [`Editor.createDeepLink`](/reference/editor/reference/editor/Editor#createDeepLink) method.

```tsx
editor.createDeepLink({ to: { type: 'page', pageId: 'page:abc123' } })
// => 'https://my-app.com/document-name?d=pabc123'
```

### Handling a deep link

You can parse a deep link string with [`parseDeepLinkString`](/reference/editor/reference/editor/parseDeepLinkString) which returns a [`TLDeepLink`](/reference/editor/reference/editor/TLDeepLink) descriptor object.

You can then call [`Editor.navigateToDeepLink`](/reference/editor/reference/editor/Editor#navigateToDeepLink) with this descriptor to navigate to the part of the document described by the deep link.

`Editor#navigateToDeepLink` also can take a plain URL if the deep link is encoded as a query param.

```tsx
editor.navigateToDeepLink(parseDeepLinkString('pabc123'))
// or pass in a url
editor.navigateToDeepLink({ url: 'https://my-app.com/document-name?d=pabc123' })
// or call without options to use the current `window.location`
editor.navigateToDeepLink()
```

### Listening for deep link changes

You can listen for deep link changes with the [`Editor.registerDeepLinkListener`](/reference/editor/reference/editor/Editor#registerDeepLinkListener) method, which takes the same options as the `deepLinks` prop.

```tsx
useEffect(() => {
	const unlisten = editor.registerDeepLinkListener({
		paramName: 'page',
		getTarget(editor) {
			return { type: 'page', pageId: editor.getCurrentPageId() }
		},
		onChange(url) {
			console.log('the new search params are', url.searchParams)
		},
		debounceMs: 100,
	})
	return () => {
		unlisten()
	}
}, [])
```

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function DeepLinksExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" deepLinks />
		</div>
	)
}
```

--------

# Frame colors

Category: Configuration

Keywords: frame, color

Use the `showColors` option to display colored fills and headings on frame shapes.

Use the `showColors` option to display colored fills and headings on frame shapes.

Create a frame (keyboard shortcut **F**) and see how it looks with the `showColors` option enabled.

## App.tsx

```tsx
import { FrameShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const ConfiguredFrameShapeUtil = FrameShapeUtil.configure({ showColors: true })

export default function FrameColorsExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw persistenceKey="example" shapeUtils={[ConfiguredFrameShapeUtil]}></Tldraw>
			</div>
		</>
	)
}
```

--------

# Note resizing

Category: Configuration

Keywords: note, resize, sticky

Make the note shape resizable.

The editor's options include alternative resizing behavior for note shapes. Set `resizeMode` to either `none` for the default behavior or `scale` to allow a user to scale the note.

## App.tsx

```tsx
import { NoteShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// Configure the note shape util to allow scaling to resize
const shapeUtils = [NoteShapeUtil.configure({ resizeMode: 'scale' })]

export default function ResizeNoteExample() {
	return (
		<>
			<div className="tldraw__editor">
				{/* pass the configured shape utils to the editor */}
				<Tldraw persistenceKey="resize-note" shapeUtils={shapeUtils}></Tldraw>
			</div>
		</>
	)
}
```

--------

# Precise exact arrows

Category: Configuration

Keywords: arrow, configure, isPrecise, isExact

Make arrows adopt "isExact" behavior instead of "isPrecise".

Arrows can be precise, which means that instead of just pointing to the center of a shape, they point to a specific place within the shape. If they're precise, they can also be exact. When they're the exact, the arrow won't stop at the edge of the shape, it'll pass through the shape right the way to the point the arrow is targeting.

By default, arrows are precise when moving slowly, and exact when holding the alt key. This example shows how to customize this behavior, so that a precise arrow is always exact.

## App.tsx

```tsx
import { ArrowShapeUtil, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const shapeUtils = [
	ArrowShapeUtil.configure({
		shouldBeExact: (editor, isPrecise) => isPrecise,
	}),
]

export default function ArrowsPreciseExactExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw shapeUtils={shapeUtils} />
		</div>
	)
}
```

--------

# Disable pages

Category: Configuration

Keywords: basic, intro, simple, quick, start, page

Disabling page-related UI for single-page use cases.

You can set the `maxPages` option to `1` to disable the page selector and other UI related to managing pages.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// You can set the `maxPages` option to 1 to disable UI related to managing multiple pages.

export default function DisablePagesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="disable-pages" options={{ maxPages: 1 }} />
		</div>
	)
}
```

--------

# Minimal

Category: Configuration

Keywords: select, tool, editor, bare, bones

Use the `<TldrawEditor/>` component to render a bare-bones editor with minimal built-in shapes and tools.

This example shows how the `<TldrawEditor/>` component can be used to render a bare-bones editor. It uses minimal built-in shapes and tools.

## App.tsx

```tsx
/* eslint-disable import/no-extraneous-dependencies */

import { Editor, TldrawEditor, createShapeId } from '@tldraw/editor'
import 'tldraw/tldraw.css'
import { MiniBoxShapeUtil } from './MiniBoxShape'
import { MiniSelectTool } from './MiniSelectTool'

// There's a guide at the bottom of this page!

// [1]
const myTools = [MiniSelectTool]
const myShapeUtils = [MiniBoxShapeUtil]

// [2]
export default function OnlyEditorExample() {
	return (
		<div className="tldraw__editor">
			<TldrawEditor
				tools={myTools}
				shapeUtils={myShapeUtils}
				initialState="select"
				onMount={(editor: Editor) => {
					editor
						.selectAll()
						.deleteShapes(editor.getSelectedShapeIds())
						.createShapes([
							{
								id: createShapeId(),
								type: 'box',
								x: 100,
								y: 100,
							},
						])
				}}
				components={{
					// [3]
					OnTheCanvas: () => {
						return (
							<div
								style={{
									position: 'absolute',
									transform: `translate(16px, 16px)`,
									width: '320px',
								}}
							>
								<p>Double click to create or delete shapes.</p>
								<p>Click or Shift+Click to select shapes.</p>
								<p>Click and drag to move shapes.</p>
							</div>
						)
					},
				}}
			/>
		</div>
	)
}

/*
This example shows how to use the TldrawEditor component on its own. This is useful if you want to
create your own custom UI, shape and tool interactions.

[1]
We create a custom tool and shape util arrays. These are arrays of classes that extend
the built-in state node and shape util classes. Check out MiniSelectTool.ts and
MiniBoxShapeUtil.tsx to see how they work. Or check out the custom config example for
a more in-depth look at how to create custom tools and shapes.

There is an even simpler implementation of the select tool in MicroSelectTool.tsx, but it
isn't used in this example.

[2]
We pass our custom tools and shape utils to the TldrawEditor component. We also pass in our custom
background component to the background prop and set the initial state to the 'select' tool.
*/
```

## MicroSelectTool.ts

```ts
import { StateNode, TLClickEventInfo, TLPointerEventInfo, createShapeId } from 'tldraw'

// There's a guide at the bottom of this file!

//[1]
export class MicroSelectTool extends StateNode {
	static override id = 'select'
	//[2]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.getCurrentPagePoint())

				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}

				editor.selectNone()
				break
			}
			case 'shape': {
				editor.select(info.shape.id)
				break
			}
		}
	}
	//[3]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this

		if (info.phase !== 'up') return

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.getCurrentPagePoint())

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const currentPagePoint = editor.inputs.getCurrentPagePoint()
				editor.createShapes([
					{
						id: createShapeId(),
						type: 'box',
						x: currentPagePoint.x - 50,
						y: currentPagePoint.y - 50,
						props: {
							w: 100,
							h: 100,
						},
					},
				])
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}
/*
This is a very small example of a state node that implements a "select" tool. It
doesn't implement any children states.

The state handles two events: onPointerDown [2] and onDoubleClick [2].

When the user points down on the canvas, it deselects all shapes; and when
they point a shape it selects that shape. When the user double clicks on the
canvas, it creates a new shape; and when they double click on a shape, it
deletes that shape.

[1]
This is where we define our state node by extending the StateNode class. Since
there are no children states We can give it an id and define methods we
want to override to handle events.


[2] onPointerDown
	The user clicked on something, let's figure out what it was. We can
	access the editor via this.editor, and then use it to check if we hit
	a shape. If we did then we call the onPointerDown method again with the
	shape as the target, select the shape, and return. If we didn't hit a
	shape then we deselect all shapes.

[3] onDoubleClick
	The user double clicked on something, let's do the same as above. If we
	hit a shape then we call the onDoubleClick method again with the shape as
	the target, delete it, and return. If we didn't hit a shape then we create
	a new shape at the pointer's position.
*/
```

## MiniBoxShape.tsx

```tsx
import { BaseBoxShapeUtil, HTMLContainer, TLShape } from 'tldraw'

// There's a guide at the bottom of this page!

const BOX_TYPE = 'box'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[BOX_TYPE]: { w: number; h: number; color: string }
	}
}

// [2]
export type MiniBoxShape = TLShape<typeof BOX_TYPE>

// [3]
export class MiniBoxShapeUtil extends BaseBoxShapeUtil<MiniBoxShape> {
	//[a]
	static override type = BOX_TYPE
	//[b]
	override getDefaultProps(): MiniBoxShape['props'] {
		return { w: 100, h: 100, color: '#efefef' }
	}
	//[c]
	component(shape: MiniBoxShape) {
		return (
			<HTMLContainer>
				<div
					style={{
						width: shape.props.w,
						height: shape.props.h,
						border: '1px solid black',
						backgroundColor: shape.props.color,
						pointerEvents: 'all',
					}}
				/>
			</HTMLContainer>
		)
	}
	//[d]
	indicator(shape: MiniBoxShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/*
This is our shape util, in tldraw all shapes extend the shape util class. In this
example we're extending the built-in BaseBoxShapeUtil class. This class provides
the functionality for our shape.

[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape's properties. For this shape, we define width (w), height (h),
and color as the shape's properties.

[2]
Define the shape type using TLShape with the shape's type as a type argument.

[3]
The shape util itself.
	[a] The type of shape this util is for, this should match the shape type we defined in [2].
	[b] The default props for our shape. These will be used when creating a new shape.
	[c] The component for our shape. This returns JSX and is what will be rendered on the
		canvas. The HtmlContainer component is a div that provides some useful styles.
	[d] The indicator for our shape, this also returns JSX. This is what will be rendered
		on the canvas when the shape is selected.
*/
```

## MiniSelectTool.ts

```ts
import { StateNode, TLClickEventInfo, TLPointerEventInfo, TLShape, createShapeId } from 'tldraw'
// There's a guide at the bottom of this file!

//[1]
export class MiniSelectTool extends StateNode {
	static override id = 'select'
	static override children() {
		return [IdleState, PointingState, DraggingState]
	}
	static override initial = 'idle'
}
//[2]
class IdleState extends StateNode {
	static override id = 'idle'
	//[a]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.getCurrentPagePoint())

				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}

				editor.selectNone()
				break
			}
			case 'shape': {
				if (editor.inputs.getShiftKey()) {
					editor.select(...editor.getSelectedShapeIds(), info.shape.id)
				} else {
					if (!editor.getSelectedShapeIds().includes(info.shape.id)) {
						editor.select(info.shape.id)
					}
					this.parent.transition('pointing', info)
				}
				break
			}
		}
	}
	//[b]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this

		if (info.phase !== 'up') return

		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.getCurrentPagePoint())

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const currentPagePoint = editor.inputs.getCurrentPagePoint()
				editor.createShapes([
					{
						id: createShapeId(),
						type: 'box',
						x: currentPagePoint.x - 50,
						y: currentPagePoint.y - 50,
						props: {
							w: 100,
							h: 100,
						},
					},
				])
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}

//[3]
class PointingState extends StateNode {
	static override id = 'pointing'
	//[a]
	override onPointerUp(info: TLPointerEventInfo) {
		this.parent.transition('idle', info)
	}
	//[b]
	override onPointerMove() {
		if (this.editor.inputs.getIsDragging()) {
			this.parent.transition('dragging', { shapes: [...this.editor.getSelectedShapes()] })
		}
	}
}

//[4]
class DraggingState extends StateNode {
	static override id = 'dragging'
	//[a]
	private initialDraggingShapes: TLShape[] = []
	//[b]
	override onEnter(info: { shapes: TLShape[] }) {
		this.initialDraggingShapes = info.shapes
	}
	//[c]
	override onPointerUp(info: TLPointerEventInfo) {
		this.parent.transition('idle', info)
	}
	//[d]
	override onPointerMove() {
		const { initialDraggingShapes } = this
		const originPagePoint = this.editor.inputs.getOriginPagePoint()
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()

		this.editor.updateShapes(
			initialDraggingShapes.map((shape) => {
				return {
					...shape,
					x: shape.x + (currentPagePoint.x - originPagePoint.x),
					y: shape.y + (currentPagePoint.y - originPagePoint.y),
				}
			})
		)
	}
}

/*
This is where we implement our select tool. In tldraw, tools are part of the
tldraw state chart. Check out the docs for more info:
https://tldraw.dev/docs/editor#State-Chart


Our state node [1] has three children: idle [2], pointing [3], and dragging [4].
Only one child state can be "active" at a time. The parent state's initial active
state is "idle". Certain events received by the child states will cause the parent
state to transition to another child state, making that state active instead.

Note that when `transition()` is called, the parent state will call the new
active state(s)'s `onEnter` method with the second argument passed to the
transition method. This is useful for passing data between states.

[1]
This is where we define our state node by extending the StateNode class. We
give it an id, a list of children states, and its initial active state.

[2]
The idle state is the tool's default state. This is where most of the action is.
We have some handy methods available to help us handle events:

	[a] onPointerDown
		The user clicked on something, let's figure out what it was. We can
		access the editor via this.editor, and then use it to check if we hit
		a shape. If we did then we call the onPointerDown method again with the
		shape as the target, select the shape and transition to the pointing state.
		Otherwise we deselect everything.

	[b] onDoubleClick
		The user double clicked on something, let's do the same thing as above.
		If we hit a shape then we call the onDoubleClick method again with the
		shape as the target, and delete the shape. Otherwise we create a new shape.

[3]
The pointing state is something of a transitionary state. Its job is to transition
to the dragging state when the user starts dragging, or go back to the idle state
on pointer up.

	[a] onPointerUp
		The user let go of the mouse, let's go back to the idle state.
	[b] onPointerMove
		The user moved the mouse, let's double check they're dragging. If they are
		then let's transition to the dragging state and pass it the shapes that
		are being dragged.

[4]
The dragging state is where we actually move the shapes around. It's job is to
update the position of the shapes being dragged, and transition back to the idle
state when the user lets go of the mouse.

	[a] initialDraggingShapes
		We'll use this to keep track of the shapes being dragged when we enter
		the state.

	[b] onEnter
		When we enter the dragging state, we'll save the shapes being dragged.

	[c] onPointerUp
		The user let go of the mouse, let's go back to the idle state.

	[d] onPointerMove
		The user moved the mouse, let's update the position of the shapes being
		dragged using editor.updateShapes().
*/
```

--------

# Sublibraries

Category: Configuration

Keywords: ui, components, utils

Tldraw is built from several sublibraries - like the editor, default shapes & tools, and UI.

Tldraw is built from several sublibraries - like the editor, default shapes & tools, and UI. For full customization, you can use these sublibraries directly, or replace them with your own.

## App.tsx

```tsx
import { useEffect } from 'react'
import {
	ContextMenu,
	DEFAULT_SUPPORTED_IMAGE_TYPES,
	DEFAULT_SUPPORT_VIDEO_TYPES,
	DefaultContextMenuContent,
	TldrawEditor,
	TldrawHandles,
	TldrawOverlays,
	TldrawScribble,
	TldrawSelectionForeground,
	TldrawShapeIndicators,
	TldrawUi,
	defaultAddFontsFromNode,
	defaultBindingUtils,
	defaultEditorAssetUrls,
	defaultShapeTools,
	defaultShapeUtils,
	defaultTools,
	registerDefaultExternalContentHandlers,
	registerDefaultSideEffects,
	tipTapDefaultExtensions,
	useEditor,
	useToasts,
	useTranslation,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const defaultComponents = {
	Scribble: TldrawScribble,
	ShapeIndicators: TldrawShapeIndicators,
	CollaboratorScribble: TldrawScribble,
	SelectionForeground: TldrawSelectionForeground,
	Handles: TldrawHandles,
	Overlays: TldrawOverlays,
}

const allDefaultTools = [...defaultTools, ...defaultShapeTools]
const defaultTextOptions = {
	tipTapConfig: {
		extensions: tipTapDefaultExtensions,
	},
	addFontsFromNode: defaultAddFontsFromNode,
}

//[2]
export default function ExplodedExample() {
	return (
		<div className="tldraw__editor">
			<TldrawEditor
				initialState="select"
				shapeUtils={defaultShapeUtils}
				bindingUtils={defaultBindingUtils}
				tools={allDefaultTools}
				components={defaultComponents}
				persistenceKey="exploded-example"
				textOptions={defaultTextOptions}
				assetUrls={defaultEditorAssetUrls}
			>
				<TldrawUi>
					<InsideEditorAndUiContext />
				</TldrawUi>
			</TldrawEditor>
		</div>
	)
}

function InsideEditorAndUiContext() {
	const editor = useEditor()
	const toasts = useToasts()
	const msg = useTranslation()

	// [3]
	useEffect(() => {
		registerDefaultExternalContentHandlers(editor, {
			maxImageDimension: 5000,
			maxAssetSize: 10 * 1024 * 1024, // 10mb
			acceptedImageMimeTypes: DEFAULT_SUPPORTED_IMAGE_TYPES,
			acceptedVideoMimeTypes: DEFAULT_SUPPORT_VIDEO_TYPES,
			toasts,
			msg,
		})

		const cleanupSideEffects = registerDefaultSideEffects(editor)

		return () => {
			cleanupSideEffects()
		}
	}, [editor, msg, toasts])

	return (
		<ContextMenu>
			<DefaultContextMenuContent />
		</ContextMenu>
	)
}

/*
The tldraw library is built from many sublibraries. This example shows how to build the tldraw
component from its subcomponents for max customisation. You can edit, omit or add to these
subcomponents to create your app.

[1] Here we've imported some components from the tldraw library which we will later pass to the
TldrawEditor component. These components are not part of the more minimal defaults, so we need to
import them separately. For help creating your own components to pass into the components prop check
out the custom components example.

[2] Here we've passed the default components object to the TldrawEditor component. Along with
default tools and shapeutils, You could input your own custom shapes/tools here. For help creating
your own shapes/tools check out the custom config example.

We also set the initial state to 'select' and render the UI, context menu and canvas components. You
could add your own custom components here, omit these ones, and/or change the initial state of the
application to whatever you want.

[3] Inside of the editor and UI context, we need to set up extra pieces to get the editor working
with our default shapes and tools. We register the default external content handlers, which sets up
handling for things like images and pasted content. We also register the default side effects, which
react to changes to the editor's store.

*/
```

--------

# Controlling the canvas

Category: Editor API

Keywords: api, create shape, update shape, mount, context

Manipulate the contents of the canvas using the editor API.

You can manipulate the contents of the canvas using the editor API. This example creates and updates shapes, selects and rotates them, and zooms the camera.

## App.tsx

```tsx
import {
	DefaultColorStyle,
	Editor,
	TLGeoShape,
	TLShapePartial,
	Tldraw,
	toRichText,
	createShapeId,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { useEffect } from 'react'

// There's a guide at the bottom of this file!

//[1]
export default function APIExample() {
	const handleMount = (editor: Editor) => {
		// Create a shape id
		const id = createShapeId('hello')

		// Create a shape
		editor.createShapes([
			{
				id,
				type: 'geo',
				x: 128 + Math.random() * 500,
				y: 128 + Math.random() * 500,
				props: {
					geo: 'rectangle',
					w: 120,
					h: 100,
					dash: 'draw',
					color: 'blue',
					size: 'm',
				},
			},
		])

		// Get the created shape
		const shape = editor.getShape<TLGeoShape>(id)!

		// Update the shape
		editor.updateShape({
			id,
			type: 'geo',
			props: {
				h: shape.props.h * 3,
				richText: toRichText('hello world!'),
			},
		})

		// Rotate the shape around its center
		editor.rotateShapesBy([id], Math.PI / 8)

		// Zoom the camera to fit the shape
		editor.zoomToFit()

		// Select the shape
		editor.select(id)
	}

	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="api-example" onMount={handleMount}>
				<InsideOfEditorContext />
			</Tldraw>
		</div>
	)
}

//[2]
const InsideOfEditorContext = () => {
	const editor = useEditor()

	useEffect(() => {
		let i = 0

		const interval = setInterval(() => {
			const selection = [...editor.getSelectedShapeIds()]
			editor.selectAll()
			editor.setStyleForSelectedShapes(DefaultColorStyle, i % 2 ? 'blue' : 'light-blue')
			editor.setStyleForNextShapes(DefaultColorStyle, i % 2 ? 'blue' : 'light-blue')
			editor.setSelectedShapes(selection)
			i++
		}, 1000)

		return () => {
			clearInterval(interval)
		}
	}, [editor])

	return null
}

/*
Introduction:

This example shows how to use the tldraw editor instance to make changes
to the canvas. The editor instance is tldraw's "god object". You can use
the app to do just about everything that's possible in tldraw. Internally,
the canvas component and all shapes, tools, and UI components use this instance
to send events, observe changes, and perform actions.

There are two main ways to use the editor:

[1]
The tldraw component shares its editor instance via its onMount callback prop.
When you define a function for the onMount callback, it receives the editor
instance as an argument. You can use this to manipulate the canvas.


[2]
Another (sneakier) way to access the current app is through React context.
The Tldraw component provides the context, so you can add children to
the component and access the app through the useEditor hook. This is cool.

*/
```

--------

# Save and load snapshots

Category: Editor API

Keywords:

Sand and load a snapshot of the editor's contents.

Use `getSnapshot()` and `loadSnapshot()` to save and restore the editor's contents.

## App.tsx

```tsx
import { useCallback, useEffect, useState } from 'react'
import { TLEditorSnapshot, Tldraw, getSnapshot, loadSnapshot, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import _jsonSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

const jsonSnapshot = _jsonSnapshot as any as TLEditorSnapshot

// [1]
function SnapshotToolbar() {
	const editor = useEditor()

	const save = useCallback(() => {
		// [2]
		const { document, session } = getSnapshot(editor.store)
		// [3]
		localStorage.setItem('snapshot', JSON.stringify({ document, session }))
	}, [editor])

	const load = useCallback(() => {
		const snapshot = localStorage.getItem('snapshot')
		if (!snapshot) return

		// [4]
		loadSnapshot(editor.store, JSON.parse(snapshot))
	}, [editor])

	const [showCheckMark, setShowCheckMark] = useState(false)
	useEffect(() => {
		if (showCheckMark) {
			const timeout = setTimeout(() => {
				setShowCheckMark(false)
			}, 1000)
			return () => clearTimeout(timeout)
		}
		return
	})

	return (
		<div style={{ padding: 20, pointerEvents: 'all', display: 'flex', gap: '10px' }}>
			<span
				style={{
					display: 'inline-block',
					transition: 'transform 0.2s ease, opacity 0.2s ease',
					transform: showCheckMark ? `scale(1)` : `scale(0.5)`,
					opacity: showCheckMark ? 1 : 0,
				}}
			>
				Saved ✅
			</span>
			<button
				onClick={() => {
					save()
					setShowCheckMark(true)
				}}
			>
				Save Snapshot
			</button>
			<button onClick={load}>Load Snapshot</button>
		</div>
	)
}

export default function SnapshotExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [5]
				snapshot={jsonSnapshot}
				components={{
					SharePanel: SnapshotToolbar,
				}}
			/>
		</div>
	)
}

/*

[1] We'll add a toolbar to the top-right of the editor viewport that allows the user to save and load snapshots.

[2] Call `getSnapshot(editor.store)` to get the current state of the editor

[3] The 'document' state is the set of shapes and pages and images etc.
The 'session' state is the state of the editor like the current page, camera positions, zoom level, etc.
You probably need to store these separately if you're building a multi-user app, so that you can store per-user session state.
For this example we'll just store them together in localStorage.

[4] Call `loadSnapshot()` to load a snapshot into the editor
You can omit the `session` state, or load it later on its own.
e.g.
	loadSnapshot(editor.store, { document })
then optionally later
	loadSnapshot(editor.store, { session })

[5] You can load an initial snapshot into the editor by passing it to the `snapshot` prop.

*/
```

--------

# Coordinate system transformations

Category: Editor API

Keywords: coordinates, screenToPage, pageToScreen, pageToViewport, getViewportScreenBounds, getViewportPageBounds, viewport, transformation

Convert between screen, page, and viewport coordinate systems.

This example demonstrates how to work with tldraw's three coordinate systems:

- **Screen space**: Pixel coordinates relative to the browser window (from DOM events)
- **Page space**: Coordinates in the infinite canvas space (where shapes live)
- **Viewport space**: Coordinates relative to the editor container (useful for UI positioning)

The key transformation methods demonstrated are:

- `editor.screenToPage(point)` - Convert DOM event coordinates to canvas coordinates
- `editor.pageToScreen(point)` - Position DOM elements relative to shapes
- `editor.pageToViewport(point)` - Get coordinates relative to the editor container
- `editor.getViewportScreenBounds()` - Get visible area bounds in screen coordinates
- `editor.getViewportPageBounds()` - Get visible area bounds in page coordinates

Move your mouse to see coordinates in all three systems. Pan and zoom the canvas to see how screen coordinates stay constant while page coordinates change. Create and select a shape to see a DOM overlay positioned using pageToScreen().

## App.tsx

```tsx
import { useEffect, useState } from 'react'
import { Tldraw, TLEditorComponents, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './coordinate-system.css'

// [1]
const CoordinateDebugPanel = track(() => {
	const editor = useEditor()
	const [mouseScreen, setMouseScreen] = useState({ x: 0, y: 0 })
	const [mousePage, setMousePage] = useState({ x: 0, y: 0 })
	const [mouseViewport, setMouseViewport] = useState({ x: 0, y: 0 })

	// [2]
	useEffect(() => {
		const handlePointerMove = (e: PointerEvent) => {
			const screenPoint = { x: e.clientX, y: e.clientY }
			const pagePoint = editor.screenToPage(screenPoint)
			const viewportPoint = editor.pageToViewport(pagePoint)

			setMouseScreen(screenPoint)
			setMousePage(pagePoint)
			setMouseViewport(viewportPoint)
		}

		const container = editor.getContainer()
		container.addEventListener('pointermove', handlePointerMove)

		return () => {
			container.removeEventListener('pointermove', handlePointerMove)
		}
	}, [editor])

	// [3]
	const viewportScreenBounds = editor.getViewportScreenBounds()
	const viewportPageBounds = editor.getViewportPageBounds()

	return (
		<div className="coordinate-debug-panel">
			<h3>Coordinate Systems</h3>

			<div className="coordinate-section">
				<h4>Mouse Position</h4>
				<div className="coordinate-row">
					<span className="coordinate-label">Screen:</span>
					<span className="coordinate-value">
						({mouseScreen.x.toFixed(0)}, {mouseScreen.y.toFixed(0)})
					</span>
				</div>
				<div className="coordinate-row">
					<span className="coordinate-label">Page:</span>
					<span className="coordinate-value">
						({mousePage.x.toFixed(0)}, {mousePage.y.toFixed(0)})
					</span>
				</div>
				<div className="coordinate-row">
					<span className="coordinate-label">Viewport:</span>
					<span className="coordinate-value">
						({mouseViewport.x.toFixed(0)}, {mouseViewport.y.toFixed(0)})
					</span>
				</div>
			</div>

			{/* [4] */}
			<div className="coordinate-section">
				<h4>Viewport Bounds</h4>
				<div className="coordinate-row">
					<span className="coordinate-label">Screen:</span>
					<span className="coordinate-value">
						({viewportScreenBounds.x.toFixed(0)}, {viewportScreenBounds.y.toFixed(0)},{' '}
						{viewportScreenBounds.w.toFixed(0)}×{viewportScreenBounds.h.toFixed(0)})
					</span>
				</div>
				<div className="coordinate-row">
					<span className="coordinate-label">Page:</span>
					<span className="coordinate-value">
						({viewportPageBounds.x.toFixed(0)}, {viewportPageBounds.y.toFixed(0)},{' '}
						{viewportPageBounds.w.toFixed(0)}×{viewportPageBounds.h.toFixed(0)})
					</span>
				</div>
			</div>
		</div>
	)
})

// [5]
const SelectedShapeOverlay = track(() => {
	const editor = useEditor()
	const selectedShapeIds = editor.getSelectedShapeIds()

	if (selectedShapeIds.length !== 1) return null

	const selectedShapeId = selectedShapeIds[0]
	const shape = editor.getShape(selectedShapeId)
	if (!shape) return null

	const pageBounds = editor.getShapePageBounds(selectedShapeId)
	if (!pageBounds) return null

	// [6]
	const topLeftViewport = editor.pageToViewport({ x: pageBounds.x, y: pageBounds.y })

	return (
		<div
			className="shape-overlay"
			style={{
				left: topLeftViewport.x,
				top: topLeftViewport.y - 32,
			}}
		>
			Page: ({pageBounds.x.toFixed(0)}, {pageBounds.y.toFixed(0)})
		</div>
	)
})

// [7]
const components: TLEditorComponents = {
	InFrontOfTheCanvas: () => (
		<>
			<CoordinateDebugPanel />
			<SelectedShapeOverlay />
		</>
	),
}

export default function RequestCoordinateSystemTransformationsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="coordinate-transformations" components={components} />
		</div>
	)
}

/*
Introduction:

This example demonstrates tldraw's coordinate system transformations. The editor uses three
coordinate systems: screen space (browser pixels), page space (infinite canvas), and viewport space
(relative to the editor container). Understanding these transformations is essential for custom
tools, UI overlays, and interactive features.

[1]
The `CoordinateDebugPanel` displays real-time coordinate information. We use `track` to make it
reactive to editor state changes, ensuring it updates when the camera moves or zooms.

[2]
We track mouse movement to demonstrate coordinate transformations. For each pointer move:
- Screen coordinates come from the DOM event (clientX, clientY)
- Page coordinates are computed using `screenToPage()` - accounting for pan and zoom
- Viewport coordinates are computed using `pageToViewport()` - relative to the editor container

[3]
We also display the viewport bounds in both coordinate systems using `getViewportScreenBounds()`
and `getViewportPageBounds()`. These methods show the visible area of the canvas in screen and
page coordinates respectively. Watch how the screen bounds stay constant while page bounds change
as you pan and zoom the canvas.

[4]
The viewport bounds display shows position (x, y) and size (w×h) for both coordinate systems.
This is useful for visibility checks, culling, and understanding what portion of the infinite
canvas is currently visible.

[5]
The `SelectedShapeOverlay` demonstrates `pageToScreen()` by positioning a DOM element above
the selected shape. This component tracks editor state to update when selection or camera changes.

[6]
We convert the shape's page position to viewport coordinates using `pageToViewport()`. This is the
correct transformation for positioning DOM elements inside `InFrontOfTheCanvas`, which is positioned
relative to the editor container (not the browser window). Using `pageToScreen()` here would cause
the overlay to be displaced when the editor has an offset from the browser origin (e.g., a sidebar).

[7]
We use the `InFrontOfTheCanvas` component slot to render our UI. Components here are positioned
in screen space - they don't scale with zoom but maintain their screen position.
*/
```

## coordinate-system.css

```css
.coordinate-debug-panel {
	position: absolute;
	top: 64px;
	left: 16px;
	width: 280px;
	background: white;
	border: 1px solid #ccc;
	padding: 12px;
	font-family: system-ui, sans-serif;
	font-size: 12px;
	z-index: 10000;
	user-select: none;
}

.coordinate-debug-panel h3 {
	margin: 0 0 8px 0;
	font-size: 13px;
	font-weight: 600;
}

.coordinate-debug-panel h4 {
	margin: 8px 0 4px 0;
	font-size: 11px;
	font-weight: 600;
	color: #666;
}

.coordinate-section {
	margin-bottom: 8px;
}

.coordinate-row {
	display: flex;
	justify-content: space-between;
	padding: 2px 0;
}

.coordinate-label {
	color: #666;
}

.coordinate-value {
	font-family: monospace;
	font-size: 11px;
}

.shape-overlay {
	position: absolute;
	pointer-events: none;
	z-index: 10000;
	background: #333;
	color: white;
	padding: 4px 8px;
	font-size: 11px;
	font-family: monospace;
	white-space: nowrap;
}
```

--------

# Create an arrow

Category: Editor API

Keywords: arrow, between

Create an arrow between two shapes.

This example shows how you can use the Editor API to create an arrow between two shapes.

## App.tsx

```tsx
import { createShapeId, Editor, TLArrowBinding, Tldraw, TLShapeId, Vec } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function CreateArrowExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw
					onMount={(editor) => {
						// Only do this on an empty canvas
						if (editor.getCurrentPageShapeIds().size > 0) return

						const shapeAId = createShapeId()
						const shapeBId = createShapeId()

						editor.createShapes([
							{
								id: shapeAId,
								type: 'geo',
								x: 100,
								y: 100,
							},
							{
								id: shapeBId,
								type: 'geo',
								x: 400,
								y: 400,
							},
						])

						createArrowBetweenShapes(editor, shapeAId, shapeBId)
					}}
				/>
			</div>
		</>
	)
}

function createArrowBetweenShapes(
	editor: Editor,
	startShapeId: TLShapeId,
	endShapeId: TLShapeId,
	options = {} as {
		parentId?: TLShapeId
		start?: Partial<Omit<TLArrowBinding['props'], 'terminal'>>
		end?: Partial<Omit<TLArrowBinding['props'], 'terminal'>>
	}
) {
	const { start = {}, end = {}, parentId } = options

	// [1]
	const {
		normalizedAnchor: startNormalizedAnchor = { x: 0.5, y: 0.5 },
		isExact: startIsExact = false,
		isPrecise: startIsPrecise = false,
	} = start
	const {
		normalizedAnchor: endNormalizedAnchor = { x: 0.5, y: 0.5 },
		isExact: endIsExact = false,
		isPrecise: endIsPrecise = false,
	} = end

	const startTerminalNormalizedPosition = Vec.From(startNormalizedAnchor)
	const endTerminalNormalizedPosition = Vec.From(endNormalizedAnchor)

	const parent = parentId ? editor.getShape(parentId) : undefined
	if (parentId && !parent) throw Error(`Parent shape with id ${parentId} not found`)

	const startShapePageBounds = editor.getShapePageBounds(startShapeId)
	const endShapePageBounds = editor.getShapePageBounds(endShapeId)

	const startShapePageRotation = editor.getShapePageTransform(startShapeId).rotation()
	const endShapePageRotation = editor.getShapePageTransform(endShapeId).rotation()

	if (!startShapePageBounds || !endShapePageBounds) return

	const startTerminalPagePosition = Vec.Add(
		startShapePageBounds.point,
		Vec.MulV(
			startShapePageBounds.size,
			Vec.Rot(startTerminalNormalizedPosition, startShapePageRotation)
		)
	)
	const endTerminalPagePosition = Vec.Add(
		endShapePageBounds.point,
		Vec.MulV(
			startShapePageBounds.size,
			Vec.Rot(endTerminalNormalizedPosition, endShapePageRotation)
		)
	)

	const arrowPointInParentSpace = Vec.Min(startTerminalPagePosition, endTerminalPagePosition)
	if (parent) {
		arrowPointInParentSpace.setTo(
			editor.getShapePageTransform(parent.id)!.applyToPoint(arrowPointInParentSpace)
		)
	}

	const arrowId = createShapeId()
	editor.run(() => {
		editor.markHistoryStoppingPoint('creating_arrow')
		editor.createShape({
			id: arrowId,
			type: 'arrow',
			// [2]
			x: arrowPointInParentSpace.x,
			y: arrowPointInParentSpace.y,
			props: {
				// [3]
				start: {
					x: arrowPointInParentSpace.x - startTerminalPagePosition.x,
					y: arrowPointInParentSpace.x - startTerminalPagePosition.x,
				},
				end: {
					x: arrowPointInParentSpace.x - endTerminalPagePosition.x,
					y: arrowPointInParentSpace.x - endTerminalPagePosition.x,
				},
			},
		})

		editor.createBindings([
			{
				fromId: arrowId,
				toId: startShapeId,
				type: 'arrow',
				props: {
					terminal: 'start',
					normalizedAnchor: startNormalizedAnchor,
					isExact: startIsExact,
					isPrecise: startIsPrecise,
				},
			},
			{
				fromId: arrowId,
				toId: endShapeId,
				type: 'arrow',
				props: {
					terminal: 'end',
					normalizedAnchor: endNormalizedAnchor,
					isExact: endIsExact,
					isPrecise: endIsPrecise,
				},
			},
		])
	})
}

/*
Introduction:

This example shows how to create an arrow between two shapes.

[1]
The normalized anchor is the position inside the shape that the arrow connects to, where 0 0 is the
top left corner and 1 1 is the bottom right. `isPrecise` needs to be enabled for this position to be
used, otherwise it targets the center of the shape.

By default, arrows don't intersect shapes they're connected to, and instead gracefully touch the
outside of the shape's geometry. You can turn this off and make an arrow intersect a shape by
setting `isExact` to true.

[2]
The arrow shape's position is in parent space, which in this case means the page.

[3]
The arrow's start and end positions are "local", which means they're relative to the arrow's
position. Note: You don't need to set the arrow's start and end positions if they're bound to
another shape, as it gets calculated automatically.

*/
```

--------

# Custom clipping shape

Category: Editor API

Keywords: clipping, shape

# Custom clipping shape example

This example demonstrates the extensible clipping system in tldraw, showing how to create custom shapes that can clip their children with any polygon geometry.

## Key implementation details

### ShapeUtil methods

The clipping system uses two methods in the `ShapeUtil` base class:

```typescript
// Returns the clip path polygon in local coordinates
getClipPath(shape: Shape): Vec[] | undefined

// Determines which children should be clipped
shouldClipChild(child: TLShape): boolean
```

### Circle clip shape

The `CircleClipShapeUtil` demonstrates:

- **Custom Geometry**: Uses a polygon approximation of a circle for clipping.
- **Conditional Clipping**: Can be enabled/disabled via shape properties or other state.
- **Selective Clipping**: Text shapes can be selectively excluded from clipping via override.
- **Visual Indicators**: Different appearance based on clipping state.

## Usage

1. Use the **Circle Clip Tool** (circle icon) in the toolbar to create circular clipping shapes
2. Click the **"✂️ Toggle Clipping"** button in the top-left to enable/disable clipping for all circle shapes globally
3. Click the **"📝 Text Clipping Override"** button to toggle whether text shapes should be clipped (when override is ON, text shapes are not clipped regardless of global setting)
4. The example starts with demo content already clipped by a circular shape

## Technical notes

- Clip paths are defined in the shape's local coordinate system
- The Editor automatically transforms them to page space for rendering
- Multiple clipping ancestors are supported (intersected together)
- Performance is optimized through computed caching
- The `shouldClipChild` method can be used to selectively exclude certain shapes from clipping if needed.



## App.tsx

```tsx
import {
	createShapeId,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	Tldraw,
	TldrawUiMenuItem,
	TLGeoShapeProps,
	TLTextShapeProps,
	TLUiOverrides,
	toRichText,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { CircleClipShapeTool } from './CircleClipShapeTool'
import { CircleClipShapeUtil, isClippingEnabled$ } from './CircleClipShapeUtil'
import './CustomClipping.css'

// There's a guide at the bottom of this file!

// [1]
const shapeUtils = [CircleClipShapeUtil]
const tools = [CircleClipShapeTool]

// [2]
const customUiOverrides: TLUiOverrides = {
	tools: (editor: any, tools: any) => {
		return {
			...tools,
			'circle-clip': {
				id: 'circle-clip',
				label: 'Circle Clip',
				icon: 'color',
				kbd: 'c',
				onSelect() {
					editor.setCurrentTool('circle-clip')
				},
			},
		}
	},
}

// [3]
function ToggleClippingButton() {
	const editor = useEditor()

	const clippingEnabled = useValue('isClippingEnabled', () => isClippingEnabled$.get(), [editor])

	return (
		<div className="CustomClipping-toggleButton">
			<button
				className={`CustomClipping-button ${
					clippingEnabled ? 'CustomClipping-button--enabled' : 'CustomClipping-button--disabled'
				}`}
				onClick={() => {
					isClippingEnabled$.update((prev) => !prev)
				}}
				onPointerDown={editor.markEventAsHandled}
				onPointerUp={editor.markEventAsHandled}
			>
				{clippingEnabled ? '✂️ Disable Clipping' : '○ Enable Clipping'}
			</button>
		</div>
	)
}

// [4]
function CustomToolbar() {
	const tools = useTools()
	const isCircleClipSelected = useIsToolSelected(tools['circle-clip'])

	return (
		<DefaultToolbar>
			<TldrawUiMenuItem {...tools['circle-clip']} isSelected={isCircleClipSelected} />
			<DefaultToolbarContent />
		</DefaultToolbar>
	)
}

// [5]
const components: TLComponents = {
	Toolbar: CustomToolbar,
	InFrontOfTheCanvas: ToggleClippingButton,
}

// [6]
export default function CustomClippingExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={shapeUtils}
				tools={tools}
				components={components}
				overrides={customUiOverrides}
				onMount={(editor) => {
					editor.setCurrentTool('select')

					const clipShapeId = createShapeId()
					editor.createShape({
						id: clipShapeId,
						type: 'circle-clip',
						x: 200,
						y: 200,
						props: {
							w: 300,
							h: 300,
						},
					})

					editor.createShape({
						type: 'text',
						x: 0,
						y: 100,
						parentId: clipShapeId,
						props: {
							size: 'l',
							textAlign: 'middle',
							richText: toRichText('This text is clipped to the circle! ✂️'),
						} satisfies Partial<TLTextShapeProps>,
					})

					editor.createShape({
						type: 'geo',
						x: 100,
						y: 290,
						parentId: clipShapeId,
						props: {
							geo: 'rectangle',
							w: 200,
							h: 100,
							fill: 'solid',
							color: 'blue',
							richText: toRichText('Oops you found me!'),
						} satisfies Partial<TLGeoShapeProps>,
					})

					editor.zoomToFit()
				}}
			/>
		</div>
	)
}

/*
Introduction:

This example demonstrates the extensible clipping system in tldraw, showing how to create custom shapes
that can clip their children with any polygon geometry. The clipping system uses two key methods:
`getClipPath` to define the clip boundary and `shouldClipChild` to control which children get clipped.

[1]
We define arrays to hold our custom shape util and tool. It's important to do this outside of any React
component so that these arrays don't get redefined on every render.

[2]
Here we define UI overrides to add our custom circle clip tool to the toolbar. The `tools` override
allows us to add new tools with custom icons, labels, and keyboard shortcuts.

[3]
The ToggleClippingButton component demonstrates how to create global state management for clipping.
It uses the `isClippingEnabled$` atom to toggle clipping on/off for all circle clip shapes.

[4]
The CustomToolbar component shows how to integrate custom tools into the main toolbar. We use
`useIsToolSelected` to highlight the active tool and `TldrawUiMenuItem` to render the tool button.

[5]
We define custom components to override the default toolbar and add our toggle button in front of
the canvas. The `components` prop allows us to customize various parts of the tldraw UI.

[6]
This is where we render the Tldraw component with our custom shape utils, tools, components, and
overrides. The onMount callback sets up the initial demo content.

For more details on the clipping implementation, see CircleClipShapeUtil.tsx and CircleClipShapeTool.tsx.

*/
```

## CircleClipShapeTool.tsx

```tsx
import { StateNode, TLEventHandlers } from 'tldraw'

export class CircleClipShapeTool extends StateNode {
	static override id = 'circle-clip'

	override onEnter(): void {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: Parameters<TLEventHandlers['onPointerDown']>[0]) {
		if (info.target === 'canvas') {
			const originPagePoint = this.editor.inputs.getOriginPagePoint()

			this.editor.createShape({
				type: 'circle-clip',
				x: originPagePoint.x - 100,
				y: originPagePoint.y - 100,
				props: {
					w: 200,
					h: 200,
				},
			})
		}
	}
}
```

## CircleClipShapeUtil.tsx

```tsx
import {
	BaseBoxShapeUtil,
	Circle2d,
	Geometry2d,
	PI2,
	RecordProps,
	SVGContainer,
	T,
	TLResizeInfo,
	TLShape,
	Vec,
	atom,
	clamp,
	resizeBox,
	toDomPrecision,
} from 'tldraw'

const CIRCLE_CLIP_TYPE = 'circle-clip'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[CIRCLE_CLIP_TYPE]: {
			w: number
			h: number
		}
	}
}

export type CircleClipShape = TLShape<typeof CIRCLE_CLIP_TYPE>

export const isClippingEnabled$ = atom('isClippingEnabled', true)

// The stroke width used when rendering the circle
const STROKE_WIDTH = 3

export class CircleClipShapeUtil extends BaseBoxShapeUtil<CircleClipShape> {
	static override type = CIRCLE_CLIP_TYPE
	static override props: RecordProps<CircleClipShape> = {
		w: T.number,
		h: T.number,
	}

	override canBind() {
		return false
	}

	override canReceiveNewChildrenOfType(shape: TLShape) {
		return !shape.isLocked
	}

	override providesBackgroundForChildren(): boolean {
		return true
	}

	override getDefaultProps(): CircleClipShape['props'] {
		return {
			w: 200,
			h: 200,
		}
	}

	override getGeometry(shape: CircleClipShape): Geometry2d {
		const radius = Math.min(shape.props.w, shape.props.h) / 2
		return new Circle2d({
			radius,
			x: shape.props.w / 2 - radius,
			y: shape.props.h / 2 - radius,
			isFilled: true,
		})
	}

	override getClipPath(shape: CircleClipShape): Vec[] | undefined {
		// Generate a polygon approximation of the circle.
		// We inset the clip path by half the stroke width so that children are
		// clipped to the inner edge of the stroke, not the center line.
		const centerX = shape.props.w / 2
		const centerY = shape.props.h / 2
		const outerRadius = Math.min(shape.props.w, shape.props.h) / 2
		const clipRadius = outerRadius - STROKE_WIDTH / 2
		const segments = clamp(Math.round((PI2 * clipRadius) / 8), 3, 360) // More segments = smoother circle

		const points: Vec[] = []
		for (let i = 0; i < segments; i++) {
			const angle = (i / segments) * Math.PI * 2
			const x = centerX + Math.cos(angle) * clipRadius
			const y = centerY + Math.sin(angle) * clipRadius
			points.push(new Vec(x, y))
		}

		return points
	}

	override shouldClipChild(_child: TLShape): boolean {
		// For now, clip all children - we removed the onlyClipText feature for simplicity
		return isClippingEnabled$.get()
	}

	override component(shape: CircleClipShape) {
		const radius = Math.min(shape.props.w, shape.props.h) / 2
		const centerX = shape.props.w / 2
		const centerY = shape.props.h / 2

		const clippingEnabled = isClippingEnabled$.get()

		return (
			<SVGContainer>
				<circle
					cx={toDomPrecision(centerX)}
					cy={toDomPrecision(centerY)}
					r={toDomPrecision(radius)}
					fill={clippingEnabled ? 'rgba(100, 150, 255, 0.1)' : 'rgba(150, 150, 150, 0.1)'}
					stroke={clippingEnabled ? '#4285f4' : '#999'}
					strokeWidth={STROKE_WIDTH}
					strokeDasharray={clippingEnabled ? 'none' : '5,5'}
				/>
				{/* Visual indicator */}
				<text
					x={centerX}
					y={centerY + 4}
					textAnchor="middle"
					fontSize="12"
					fill={clippingEnabled ? '#4285f4' : '#999'}
				>
					{clippingEnabled ? '✂️' : '○'}
				</text>
			</SVGContainer>
		)
	}

	override indicator(shape: CircleClipShape) {
		const radius = Math.min(shape.props.w, shape.props.h) / 2
		const centerX = shape.props.w / 2
		const centerY = shape.props.h / 2

		return (
			<circle
				cx={toDomPrecision(centerX)}
				cy={toDomPrecision(centerY)}
				r={toDomPrecision(radius)}
			/>
		)
	}

	override onResize(shape: CircleClipShape, info: TLResizeInfo<CircleClipShape>) {
		return resizeBox(shape, info)
	}
}
```

## CustomClipping.css

```css
.CustomClipping-toggleButton {
	position: absolute;
	top: 64px;
	left: 12px;
	pointer-events: all;
	z-index: 1000;
}

.CustomClipping-button {
	padding: 8px 16px;
	color: white;
	border: none;
	border-radius: 4px;
	cursor: pointer;
	font-size: 14px;
	font-weight: 500;
	box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.CustomClipping-button--enabled {
	background-color: #ea4335;
}

.CustomClipping-button--disabled {
	background-color: #34a853;
}
```

--------

# Zoom to bounds

Category: Editor API

Keywords: zoom, camera, bounds, inset

Zoom the camera to specific bounds using the editor's `zoomToBounds` function.

This example shows how to use the `zoomToBounds` method to programmatically zoom the camera to specific areas of the canvas. The example creates two boxes at different positions and provides buttons to zoom to each one. Note that the bounds the camera ultimately moves to may be different than the bounds you pass into the function. This is because the values of the bounds are massaged to maintain your viewport's aspect ratio. Also, if an inset is not specified, a default one will be set, adding inset padding to the bounds.

## App.tsx

```tsx
import { Box, createShapeId, Tldraw, TldrawUiButton, useEditor } from 'tldraw'
import './zoom-to-bounds.css'

export default function ZoomToBoundsExample() {
	const zoomBox1 = new Box(50, 100, 900, 720)
	const zoomBox2 = new Box(1000, 500, 500, 400)

	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.createShapes([
						{
							id: createShapeId(),
							type: 'geo',
							x: zoomBox1.x,
							y: zoomBox1.y,
							isLocked: true,
							props: {
								w: zoomBox1.w,
								h: zoomBox1.h,
								color: 'violet',
							},
						},
						{
							id: createShapeId(),
							type: 'geo',
							x: zoomBox2.x,
							y: zoomBox2.y,
							isLocked: true,
							props: {
								w: zoomBox2.w,
								h: zoomBox2.h,
								color: 'blue',
							},
						},
					])
				}}
				components={{
					TopPanel: () => {
						const editor = useEditor()
						return (
							<div className="tlui-menu control-panel">
								<TldrawUiButton
									type="normal"
									// Zoom to bounds!
									onClick={() => editor.zoomToBounds(zoomBox1, { inset: 72 })}
								>
									Zoom to violet box
								</TldrawUiButton>
								<TldrawUiButton
									type="normal"
									// Zoom to bounds!
									onClick={() =>
										editor.zoomToBounds(zoomBox2, { inset: 72, animation: { duration: 200 } })
									}
								>
									Zoom to blue box
								</TldrawUiButton>
								<TldrawUiButton
									type="normal"
									// Zoom to bounds!
									onClick={() =>
										editor.zoomToBounds(Box.Common([zoomBox1, zoomBox2]), {
											inset: 200,
											animation: { duration: 200 },
										})
									}
								>
									Zoom to both boxes
								</TldrawUiButton>
							</div>
						)
					},
				}}
			/>
		</div>
	)
}
```

## zoom-to-bounds.css

```css
.control-panel {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	margin: 8px;
}
```

--------

# Create a video shape

Category: Editor API

Keywords: asset, video

Create a video shape using a local asset.

This example shows how to create a `TLVideoAsset` for a video file that's hosted locally and add a `VideoShape` referencing that asset to the canvas.

## App.tsx

```tsx
import { useCallback } from 'react'
import { AssetRecordType, Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function LocalVideosExample() {
	const handleMount = useCallback((editor: Editor) => {
		const assetId = AssetRecordType.createId()
		const videoWidth = 640
		const videoHeight = 360

		editor.createAssets([
			{
				id: assetId,
				type: 'video',
				typeName: 'asset',
				props: {
					name: 'fluid.mp4',
					src: '/fluid.mp4',
					w: videoWidth,
					h: videoHeight,
					mimeType: 'video/mp4',
					isAnimated: true,
				},
				meta: {},
			},
		])

		editor.createShape({
			type: 'video',
			x: (window.innerWidth - videoWidth) / 2,
			y: (window.innerHeight - videoHeight) / 2,
			props: {
				assetId,
				w: videoWidth,
				h: videoHeight,
			},
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw onMount={handleMount} />
		</div>
	)
}
```

--------

# Create an image shape

Category: Editor API

Keywords: asset, record, create asset

Create an image shape using a local asset.

This example shows how to use local images in the built-in `ImageShape` shape. You must first create an asset that holds the source of the image, then create a shape that references the asset.

## App.tsx

```tsx
import { useCallback } from 'react'
import { AssetRecordType, Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
// There's a guide at the bottom of this file!

export default function LocalImagesExample() {
	// [1]
	const handleMount = useCallback((editor: Editor) => {
		//[2]
		const assetId = AssetRecordType.createId()
		const imageWidth = 1200
		const imageHeight = 675
		//[2]
		editor.createAssets([
			{
				id: assetId,
				type: 'image',
				typeName: 'asset',
				props: {
					name: 'tldraw.png',
					src: '/tldraw.png', // You could also use a base64 encoded string here
					w: imageWidth,
					h: imageHeight,
					mimeType: 'image/png',
					isAnimated: false,
				},
				meta: {},
			},
		])
		//[3]
		editor.createShape({
			type: 'image',
			// Let's center the image in the editor
			x: (window.innerWidth - imageWidth) / 2,
			y: (window.innerHeight - imageHeight) / 2,
			props: {
				assetId,
				w: imageWidth,
				h: imageHeight,
			},
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw onMount={handleMount} />
		</div>
	)
}

/*
This is an example of how you can add a locally hosted image to the editor.
We need to first create an asset that holds the source image [2], and then
create the Image shape itself [3].

Because this is a Next.js app, we can use the `public` folder to store the
image locally, your framework may have a different way of serving static
assets.

If you want to allow users to upload the images please take a look at the
hosted images example.

[1]
We'll access the editor instance via the `onMount` callback. Check out the API
example for another way to do this.

[2]
Assets are records that store data about shared assets like images, videos, etc.
Each image has an associated asset record, so we'll create that first. We need an
`assetId` so that we can later associate it with the image.

[3]
We create the image shape and pass in the `assetId` that we created earlier. This
will link our image shape to the asset record. Notice that we create the shape with
the same dimensions as the image, later on the user may resize the image, but we
don't want to resize our asset, this is one of the reasons why it's important to
keep assets and shapes separate.
*/
```

--------

# Dynamic tools with setTool and removeTool

Category: Editor API

Keywords: setTool, removeTool, dynamic, tools, state chart, toolbar

Dynamically add and remove tools from the editor and toolbar after initialization.

The `setTool` and `removeTool` methods allow you to add and remove tools from the editor's state chart on demand, after the editor has been initialized. This example shows how to dynamically add a tool that appears in the toolbar when added and disappears when removed. This is useful when you need to conditionally enable or disable tools based on user permissions, feature flags, or other runtime conditions.

## App.tsx

```tsx
import { useMemo, useState } from 'react'
import {
	DefaultToolbar,
	DefaultToolbarContent,
	Editor,
	StateNode,
	TLComponents,
	TLTextShape,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	Tldraw,
	TldrawUiButton,
	TldrawUiMenuItem,
	toRichText,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './dynamic-tools.css'

// There's a guide at the bottom of this file!

const OFFSET = 12

// [1]
class HeartTool extends StateNode {
	static override id = 'heart'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown() {
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		this.editor.createShape<TLTextShape>({
			type: 'text',
			x: currentPagePoint.x - OFFSET,
			y: currentPagePoint.y - OFFSET,
			props: { richText: toRichText('❤️') },
		})
	}
}

// [2]
const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.heart = {
			id: 'heart',
			icon: 'heart-icon',
			label: 'Heart',
			kbd: 'r',
			onSelect: () => {
				editor.setCurrentTool('heart')
			},
		}
		return tools
	},
}

// [3]
export const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'heart-icon': '/heart-icon.svg',
	},
}

// [4]
export default function DynamicToolsExample() {
	const [editor, setEditor] = useState<Editor | null>(null)
	const [isHeartToolEnabled, setIsHeartToolEnabled] = useState(false)

	// [5]
	const components: TLComponents = useMemo(
		() => ({
			Toolbar: (props) => {
				const tools = useTools()
				const isHeartSelected = useIsToolSelected(tools['heart'])

				return (
					<DefaultToolbar {...props}>
						{isHeartToolEnabled && (
							<TldrawUiMenuItem {...tools['heart']} isSelected={isHeartSelected} />
						)}
						<DefaultToolbarContent />
					</DefaultToolbar>
				)
			},
			InFrontOfTheCanvas: () => {
				const toggleHeartTool = () => {
					if (!editor) return
					if (isHeartToolEnabled) {
						// [6]
						editor.removeTool(HeartTool)
						// Switch to select tool if we're currently on the heart tool
						if (editor.getCurrentToolId() === 'heart') {
							editor.setCurrentTool('select')
						}
					} else {
						// [7]
						editor.setTool(HeartTool)
					}
					setIsHeartToolEnabled(!isHeartToolEnabled)
				}

				return (
					<div className="toggle-button-container">
						<TldrawUiButton onClick={toggleHeartTool} type="normal">
							{isHeartToolEnabled ? '💔 Remove Heart Tool' : '💖 Add Heart Tool'}
						</TldrawUiButton>
					</div>
				)
			},
		}),
		[editor, isHeartToolEnabled]
	)

	return (
		<div className="tldraw__editor">
			<Tldraw
				overrides={uiOverrides}
				components={components}
				onMount={(editor) => setEditor(editor)}
				// pass in our custom asset urls
				assetUrls={customAssetUrls}
			/>
		</div>
	)
}

/*
Introduction:

This example demonstrates how to use the `setTool` and `removeTool` methods to dynamically
add and remove tools from the editor's state chart after initialization. When the tool is
added, it also appears in the toolbar dynamically. This is useful when you need to
conditionally enable or disable tools based on runtime conditions like user permissions,
feature flags, or application state.

[1]
We define a simple HeartTool that extends StateNode. It creates a heart emoji sticker
when you click on the canvas. This tool is NOT passed to the Tldraw component initially -
it will be added dynamically using setTool.

[2]
We define UI overrides to add the heart tool to the UI context. This makes it available
for the toolbar component to reference, even if the tool hasn't been added to the state
chart yet.

[3]
We override the Toolbar component to conditionally show the heart tool. The tool only
appears in the toolbar when it exists in the state chart (isHeartToolEnabled is true).
This creates a nice dynamic behavior where the toolbar updates when you add/remove the tool.

[4]
We pass the overrides and components to the Tldraw component. The toggle button will
appear on top of the canvas, and clicking it will add/remove the heart tool dynamically.
When added, the tool appears in the toolbar and can be used immediately.

[5]
We define the components object. We override the Toolbar component to conditionally show the heart tool. The tool only
appears in the toolbar when it exists in the state chart (isHeartToolEnabled is true).
This creates a nice dynamic behavior where the toolbar updates when you add/remove the tool.

[6]
We remove the heart tool from the state chart if it exists, and adds it back if it doesn't.

[7]
We add the heart tool to the state chart if it doesn't exist.

*/
```

## dynamic-tools.css

```css
.toggle-button-container {
	position: absolute;
	top: 16px;
	left: 50%;
	transform: translateX(-50%);
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 8px;
	pointer-events: auto;
}
```

--------

# Focus the editor

Category: Editor API

Keywords: instance, state, keyboard shortcuts

Manually manage the editor's focus to enable or disable keyboard shortcuts.

In this example, we drive the editor's focus in order to turn on and off keyboard shortcuts.

The editor's focus is different from—but usually corresponds to—the browser's concept of "focus", which is related to the document's [active element](https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement).

Unfortunately, the browser's focus cannot be relied on to determine whether the editor's keyboard shortcuts should work. While its possible to detect whether the document's active element is a descendant of the Tldraw component's own element, it's not 100% reliable. For example, iframes are not considered descendants of their parents, and many menus are portalled into different parts of the document tree.

For these reasons, the responsibility falls to you, dear developer, to manage focus for your Tldraw editor, especially in cases where there are more than one editor on the same page.

## App.tsx

```tsx
import { useRef } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import './editor-focus.css'

export default function EditorFocusExample() {
	const editorRef = useRef<Editor | null>(null)
	return (
		<div style={{ padding: 32, minHeight: '120vh' }}>
			<input type="text" placeholder="Test me" />
			<p>
				You should be able to type in this text input without worrying about triggering editor
				shortcuts even when the editor is focused.
			</p>
			<div>
				<h2>Controlled Focus</h2>
				<div style={{ display: 'flex', gap: 4 }}>
					<input
						id="focus"
						type="checkbox"
						onChange={(e) => {
							const editor = editorRef.current
							if (!editor) return
							if (e.target.checked) {
								editor.focus() // optional
							} else {
								editor.blur() // optional
							}
						}}
					/>
					<label htmlFor="focus">Focus</label>
				</div>
			</div>
			<p>The checkbox focuses and blurs the editor.</p>
			<p>
				When the editor is “focused”, its keyboard shortcuts will work and scrolling over the editor
				will scroll the canvas. When it is not focused, the keyboard shortcuts will not work and
				scrolling over the editor will not move the canvas.
			</p>
			<div style={{ width: 800, maxWidth: '100%', height: 500 }}>
				<Tldraw
					autoFocus={false}
					onMount={(editor) => {
						editorRef.current = editor
					}}
				/>
			</div>
		</div>
	)
}
```

## editor-focus.css

```css
.tl-container__focused {
	outline: 1px solid var(--tl-color-primary);
}
```

--------

# Lock camera zoom

Category: Editor API

Keywords: camera, lock, zoom

Lock the camera at a specific zoom level.

Need to lock the camera at its current zoom level? You can use the camera controls API to keep the zoom level from changing.

In this example, press Shift+K to lock the camera at its current zoom level. Press Shift+L to unlock the camera and allow it to zoom again.

## App.tsx

```tsx
import { Tldraw, TLUiOverrides } from 'tldraw'
import 'tldraw/tldraw.css'

const DEFAULT_CAMERA_STEPS = [0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8]

const overrides: TLUiOverrides = {
	actions(editor, actions) {
		actions.lockCameraZoom = {
			id: 'lock-camera-zoom',
			kbd: 'shift+k',
			onSelect() {
				const isCameraZoomLockedAlready = editor.getCameraOptions().zoomSteps.length === 1
				editor.setCameraOptions({
					zoomSteps: isCameraZoomLockedAlready ? DEFAULT_CAMERA_STEPS : [editor.getZoomLevel()],
				})
			},
		}

		return actions
	},
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" overrides={overrides} />
		</div>
	)
}
```

--------

# Search text on the canvas

Category: Editor API

Keywords: zoom, pan, camera bounds, search, text

Search through all the text on the canvas.

A simple example of how to use the API to search for text in shapes and display results in the `HelperButtons` part of the user interface. Press Ctrl+F or Cmd+F to open the search bar.

## App.tsx

```tsx
import { TLComponents, TLUiOverrides, Tldraw, atom, track } from 'tldraw'
import 'tldraw/tldraw.css'
import { TextSearchPanel } from './TextSearchPanel'
import './text-search.css'

export const showSearch = atom('showSearch', false)

const components: TLComponents = {
	HelperButtons: TextSearchPanel,
}

const overrides: TLUiOverrides = {
	actions(_editor, actions) {
		return {
			...actions,
			'text-search': {
				id: 'text-search',
				label: 'Search',
				kbd: 'cmd+f,ctrl+f',
				onSelect() {
					if (!showSearch.get()) {
						showSearch.set(true)
					}
				},
			},
		}
	},
}

const TextSearchExample = track(() => {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="text-search-example" overrides={overrides} components={components} />
		</div>
	)
})

export default TextSearchExample
```

## TextSearchPanel.tsx

```tsx
import { useEffect, useRef, useState } from 'react'
import { EASINGS, Editor, TLShape, TldrawUiButton, track, useEditor } from 'tldraw'
import { showSearch } from './TextSearchExample'

interface SearchResult {
	text: string
	shape: TLShape
}

function moveToShape(editor: Editor, shape: TLShape) {
	const bounds = editor.getShapePageBounds(shape.id)
	if (!bounds) return
	editor.setSelectedShapes([shape.id])
	editor.zoomToSelection({
		animation: { duration: 500, easing: EASINGS.easeInOutCubic },
	})
}

function keyDown(e: React.KeyboardEvent) {
	if (e.key === 'Escape') {
		showSearch.set(false)
	}
}

function getShapesWithText(editor: Editor, text: string): SearchResult[] {
	if (!text || text.length === 0) return []
	const shapes = editor.getCurrentPageShapes()
	const result: SearchResult[] = []
	shapes.forEach((shape) => {
		const util = editor.getShapeUtil(shape)
		const shapeText = util.getText(shape)
		if (shapeText && shapeText.includes(text)) {
			result.push({ text: shapeText, shape })
		}
	})
	return result.sort((a, b) => a.text.localeCompare(b.text))
}

export const TextSearchPanel = track(() => {
	const editor = useEditor()
	const [searchText, setSearchText] = useState('')
	const inputRef = useRef<HTMLInputElement>(null)
	const isVisible = showSearch.get()

	useEffect(() => {
		if (isVisible) {
			setSearchText('')
			inputRef.current?.focus()
		}
	}, [isVisible])

	if (!isVisible) return null

	const results = getShapesWithText(editor, searchText)
	return (
		<div
			className="text-search-panel scroll-light"
			onPointerDown={editor.markEventAsHandled}
			onKeyDown={keyDown}
		>
			<input
				className="text-search-input"
				ref={inputRef}
				onChange={(e) => setSearchText(e.target.value)}
			></input>
			{results.map((result) => {
				return (
					<TldrawUiButton
						key={'text-search-panel-button:' + result.shape.id}
						type="normal"
						className="text-search-panel-button"
						onClick={() => moveToShape(editor, result.shape)}
					>
						{result.text}
					</TldrawUiButton>
				)
			})}
		</div>
	)
})
```

## text-search.css

```css
.text-search-panel {
	display: flex;
	flex-direction: column;
	gap: 4px;
	max-height: calc(100% - 110px);
	margin: 50px 0px;
	padding: 4px;
	background-color: var(--tl-color-low);
	pointer-events: all;
	border-top-right-radius: var(--tl-radius-4);
	border-bottom-right-radius: var(--tl-radius-4);
	overflow: auto;
	border-right: 2px solid var(--tl-color-background);
	border-bottom: 2px solid var(--tl-color-background);
	border-top: 2px solid var(--tl-color-background);
}

.text-search-panel-button {
	border-radius: var(--tl-radius-4);
	outline-offset: -1px;
}

.text-search-shape-label {
	pointer-events: all;
	position: absolute;
	background: var(--tl-color-low);
	padding: calc(12px * var(--tl-scale));
	border-bottom-right-radius: calc(var(--tl-radius-4) * var(--tl-scale));
	font-size: calc(12px * var(--tl-scale));
	color: var(--tl-color-text);
	white-space: nowrap;
}

.text-search-input {
	border-radius: var(--tl-radius-2);
	margin: 4px;
}
```

--------

# Shape animation

Category: Editor API

Keywords: animate, animation, shape, easing, transition, movement, rotation, opacity

Animate shapes using `animateShape()` and `animateShapes()`.

This example demonstrates how to animate shapes using the editor's animation API. It shows:

- **Basic shape animation** - Animating a single shape's position using `animateShape()`
- **Rotation animation** - Spinning a shape 360 degrees
- **Opacity animation** - Fading shapes in and out
- **Combined animations** - Animating multiple properties (position, rotation, opacity) simultaneously
- **Multiple shape animation** - Animating all shapes at once with `animateShapes()`
- **Different easing functions** - Using `EASINGS.easeInOutCubic`, `EASINGS.easeInOutQuad`, and `EASINGS.easeOutCubic`

The animation system automatically interpolates between the current and target values of animated properties over the specified duration.

## App.tsx

```tsx
import {
	createShapeId,
	EASINGS,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './shape-animation.css'

// [1]
function AnimationControls() {
	const editor = useEditor()

	// [2]
	const animatePosition = () => {
		const shape = editor.getOnlySelectedShape()
		if (!shape) return

		editor.animateShape(
			{ ...shape, x: shape.x + 200, y: shape.y + 100 },
			{ animation: { duration: 800, easing: EASINGS.easeInOutCubic } }
		)
	}

	// [3]
	const animateRotation = () => {
		const shape = editor.getOnlySelectedShape()
		if (!shape) return

		editor.animateShape(
			{ ...shape, rotation: shape.rotation + Math.PI * 2 },
			{ animation: { duration: 1000, easing: EASINGS.easeInOutCubic } }
		)
	}

	// [4]
	const animateFade = () => {
		const shape = editor.getOnlySelectedShape()
		if (!shape) return

		editor.animateShape(
			{ ...shape, opacity: shape.opacity > 0.5 ? 0.2 : 1 },
			{ animation: { duration: 600, easing: EASINGS.easeInOutQuad } }
		)
	}

	// [5]
	const animateAll = () => {
		const shape = editor.getOnlySelectedShape()
		if (!shape) return

		editor.animateShape(
			{
				...shape,
				x: shape.x + 150,
				y: shape.y - 100,
				rotation: shape.rotation + Math.PI,
				opacity: 0.3,
			},
			{ animation: { duration: 1200, easing: EASINGS.easeInOutCubic } }
		)
	}

	// [6]
	const animateMultiple = () => {
		const shapeIds = editor.getCurrentPageShapeIds()
		const updates = Array.from(shapeIds).map((id) => {
			const shape = editor.getShape(id)
			if (!shape) return null

			return {
				...shape,
				x: shape.x + (Math.random() - 0.5) * 200,
				y: shape.y + (Math.random() - 0.5) * 200,
				rotation: shape.rotation + (Math.random() - 0.5) * Math.PI,
			}
		})

		editor.animateShapes(updates, { animation: { duration: 1000, easing: EASINGS.easeOutCubic } })
	}

	const hasOneSelected = useValue(
		'has one selected',
		() => editor.getSelectedShapeIds().length !== 1,
		[editor]
	)

	return (
		<div className="tlui-menu animation-controls">
			<TldrawUiButton type="normal" disabled={hasOneSelected} onClick={animatePosition}>
				Animate position
			</TldrawUiButton>
			<TldrawUiButton type="normal" disabled={hasOneSelected} onClick={animateRotation}>
				Animate rotation
			</TldrawUiButton>
			<TldrawUiButton type="normal" disabled={hasOneSelected} onClick={animateFade}>
				Fade in/out
			</TldrawUiButton>
			<TldrawUiButton type="normal" disabled={hasOneSelected} onClick={animateAll}>
				Animate all
			</TldrawUiButton>
			<TldrawUiButton type="normal" onClick={animateMultiple}>
				Animate multiple shapes
			</TldrawUiButton>
		</div>
	)
}

const components: TLComponents = {
	TopPanel: AnimationControls,
}

export default function AnimationShapesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				components={components}
				onMount={(editor) => {
					// Create some initial shapes for the demo
					const id = createShapeId()
					editor.createShapes([
						{
							id,
							type: 'geo',
							x: 200,
							y: 200,
							props: {
								w: 100,
								h: 100,
								color: 'blue',
							},
						},
						{
							id: createShapeId(),
							type: 'geo',
							x: 400,
							y: 300,
							props: {
								w: 80,
								h: 80,
								color: 'red',
								geo: 'ellipse',
							},
						},
						{
							id: createShapeId(),
							type: 'geo',
							x: 600,
							y: 200,
							props: {
								w: 120,
								h: 90,
								color: 'green',
								geo: 'triangle',
							},
						},
					])

					// Select the first shape
					editor.select(id)
				}}
			/>
		</div>
	)
}

/*
[1]
Create a component with buttons to trigger different animations. Use the `useEditor` hook to
access the editor instance.

[2]
`animateShape()` animates a single shape to new property values. Pass a partial shape with the
target values and animation options. The `easing` property accepts functions from the `EASINGS`
object. In this example, we move the shape to a new position with cubic easing.

[3]
Animate rotation by specifying a target rotation value in radians. Here we rotate the shape
360 degrees (2π radians) with smooth easing.

[4]
Opacity can be animated between 0 and 1. This creates a fade effect. We toggle between
low and high opacity values using quadratic easing.

[5]
Multiple properties can be animated simultaneously. This example combines position, rotation,
and opacity changes in a single animation.

[6]
`animateShapes()` animates multiple shapes at once. Build an array of shape partials and
pass them all together. All shapes will animate with the same duration and easing function.

*/
```

## shape-animation.css

```css
.animation-controls {
	display: flex;
	flex-wrap: wrap;
	margin: 8px;
}
```

--------

# Align and distribute shapes

Category: Editor API

Keywords: align, distribute, layout, position, arrange

Align and distribute shapes using the editor's built-in methods.

This example demonstrates how to use the `alignShapes` and `distributeShapes` methods to programmatically arrange shapes on the canvas. The example creates 5 shapes at different positions and provides buttons to align them (left, center-horizontal, right, top, center-vertical, bottom) or distribute them (horizontal, vertical). Select multiple shapes and click the buttons to see the alignment and distribution in action. Note that align operations require at least 2 shapes, while distribute operations require at least 3 shapes.

## App.tsx

```tsx
import { useRef } from 'react'
import { createShapeId, Tldraw, TldrawUiButton, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './align-and-distribute-shapes.css'

// [1]
const ALIGN_OPERATIONS = [
	{ operation: 'left', label: 'Align left' },
	{ operation: 'center-horizontal', label: 'Align center H' },
	{ operation: 'right', label: 'Align right' },
	{ operation: 'top', label: 'Align top' },
	{ operation: 'center-vertical', label: 'Align center V' },
	{ operation: 'bottom', label: 'Align bottom' },
] as const

function ControlPanel({
	originalPositions,
}: {
	originalPositions: React.RefObject<Map<string, { x: number; y: number }>>
}) {
	const editor = useEditor()

	return (
		<div className="tlui-menu control-panel">
			{ALIGN_OPERATIONS.map(({ operation, label }) => (
				<TldrawUiButton
					type="normal"
					key={operation}
					onClick={() => {
						// [2]
						const selectedIds = editor.getSelectedShapeIds()
						if (selectedIds.length > 1) {
							editor.alignShapes(selectedIds, operation)
						}
					}}
				>
					{label}
				</TldrawUiButton>
			))}
			{DISTRIBUTE_OPERATIONS.map(({ operation, label }) => (
				<TldrawUiButton
					type="normal"
					key={operation}
					onClick={() => {
						// [4]
						const selectedIds = editor.getSelectedShapeIds()
						if (selectedIds.length > 2) {
							editor.distributeShapes(selectedIds, operation)
						}
					}}
				>
					{label}
				</TldrawUiButton>
			))}
			<TldrawUiButton
				type="normal"
				onClick={() => {
					const shapes = editor.getCurrentPageShapes()
					editor.run(() => {
						for (const shape of shapes) {
							const originalPos = originalPositions.current?.get(shape.id)
							if (originalPos) {
								editor.updateShape({
									...shape,
									x: originalPos.x,
									y: originalPos.y,
								})
							}
						}
					})
				}}
			>
				Reset positions
			</TldrawUiButton>
		</div>
	)
}

// [3]
const DISTRIBUTE_OPERATIONS = [
	{ operation: 'horizontal', label: 'Distribute horizontal' },
	{ operation: 'vertical', label: 'Distribute vertical' },
] as const

export default function RequestAlignAndDistributeShapesExample() {
	const originalPositions = useRef(new Map<string, { x: number; y: number }>())

	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					const shapes = [
						{
							id: createShapeId(),
							type: 'geo' as const,
							x: 100,
							y: 100,
							props: {
								w: 100,
								h: 100,
								color: 'blue' as const,
							},
						},
						{
							id: createShapeId(),
							type: 'geo' as const,
							x: 300,
							y: 200,
							props: {
								w: 120,
								h: 80,
								color: 'red' as const,
							},
						},
						{
							id: createShapeId(),
							type: 'geo' as const,
							x: 500,
							y: 150,
							props: {
								w: 80,
								h: 120,
								color: 'green' as const,
							},
						},
						{
							id: createShapeId(),
							type: 'geo' as const,
							x: 150,
							y: 400,
							props: {
								w: 100,
								h: 100,
								color: 'violet' as const,
							},
						},
						{
							id: createShapeId(),
							type: 'geo' as const,
							x: 400,
							y: 450,
							props: {
								w: 90,
								h: 90,
								color: 'orange' as const,
							},
						},
					]

					for (const shape of shapes) {
						originalPositions.current.set(shape.id, { x: shape.x, y: shape.y })
					}

					editor.createShapes(shapes)
					editor.selectAll()
				}}
				components={{
					TopPanel: () => <ControlPanel originalPositions={originalPositions} />,
				}}
			/>
		</div>
	)
}

/*
[1]
Define an array of all align operations with their labels. This makes it easy to render buttons for each operation without repetition. The available operations are: left, center-horizontal, right (horizontal alignment), and top, center-vertical, bottom (vertical alignment).

[2]
The alignShapes method requires at least 2 shapes to be selected. It aligns the selected shapes based on the specified operation. The shapes parameter can be either shape IDs or shape objects.

[3]
Define an array of distribute operations. Distribution evenly spaces shapes along the specified axis: horizontal or vertical.

[4]
The distributeShapes method requires at least 3 shapes to be selected. It distributes shapes evenly along the horizontal or vertical axis, maintaining equal spacing between them.
*/
```

## align-and-distribute-shapes.css

```css
.control-panel {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	margin: 8px;
}
```

--------

# Lasso select tool

Category: Editor API

Keywords: tools, state machine, custom tool, selection, lasso, overlays, editor atom, freehand drawing

Add a lasso select tool to tldraw.

You can build different types of selection tools in tldraw. This example creates a lasso select tool that lets you freehand draw to select shapes on the canvas. It uses a reactive `atom` to reactively store the lasso points, and an `Overlay` to draw the lasso onto the canvas.

Only shapes that are fully enclosed in the lasso will be selected.

## App.tsx

```tsx
import { useMemo } from 'react'
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	getStrokePoints,
	getSvgPathFromStrokePoints,
	TLComponents,
	Tldraw,
	TldrawOverlays,
	TldrawUiMenuItem,
	TLUiOverrides,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import { LassoingState, LassoSelectTool } from './LassoSelectTool'
// There's a guide at the bottom of this file!

//[1]
const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		tools['lasso-select'] = {
			id: 'lasso-select',
			icon: 'color',
			label: 'Lasso Select',
			kbd: 'w', //w for wrangle 🤠
			onSelect: () => {
				editor.setCurrentTool('lasso-select')
			},
		}
		return tools
	},
}

//[2]
const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isLassoSelected = useIsToolSelected(tools['lasso-select'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['lasso-select']} isSelected={isLassoSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<DefaultKeyboardShortcutsDialogContent />
				<TldrawUiMenuItem {...tools['lasso-select']} />
			</DefaultKeyboardShortcutsDialog>
		)
	},
	//[a]
	Overlays: () => (
		<>
			<TldrawOverlays />
			<LassoSelectSvgComponent />
		</>
	),
}

//[3]
function LassoSelectSvgComponent() {
	const editor = useEditor()
	// const { addToast } = useToasts()

	//[a]
	const lassoPoints = useValue(
		'lasso points',
		() => {
			if (!editor.isIn('lasso-select.lassoing')) return []
			const lassoing = editor.getStateDescendant('lasso-select.lassoing') as LassoingState
			return lassoing.points.get()
		},
		[editor]
	)

	//[b]
	const svgPath = useMemo(() => {
		const smoothedPoints = getStrokePoints(lassoPoints)
		const svgPath = getSvgPathFromStrokePoints(smoothedPoints, true)
		return svgPath
	}, [lassoPoints])

	//[c]
	return (
		<>
			{lassoPoints.length > 0 && (
				<svg className="tl-overlays__item" aria-hidden="true">
					<path
						d={svgPath}
						fill="var(--color-selection-fill)"
						opacity={0.5}
						stroke="var(--color-selection-stroke)"
						strokeWidth="calc(2px / var(--tl-zoom))"
					/>
				</svg>
			)}
		</>
	)
}

export default function LassoSelectToolExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				tools={[LassoSelectTool]}
				overrides={uiOverrides}
				components={components}
				persistenceKey="lasso-select-example"
			/>
		</div>
	)
}

/*
This example shows how to build a lasso select tool using the StateNode and EditorAtom classes. For a simpler example of how to build a selection tool, see the `MiniSelectTool` in the only-editor example. If you want to see an even simpler select tool that doesn't implement any child states, see the `MicroSelectTool` in the same example.

[1]
Here are the UI overrides for the lasso select tool, which we'll pass into the <Tldraw> component. It adds a new tool to the toolbar and keyboard shortcuts dialog, as well as sets the keyboard shortcut. More info about this in the 'add-tool-to-toolbar' and 'custom-config' examples.

[2]
This is the set of custom components for the lasso select tool, which we'll also pass into the <Tldraw> component. It adds a new toolbar and keyboard shortcuts dialog. More info  about this in the 'add-tool-to-toolbar' and 'custom-config' examples.

	[a]
	The `Overlays` component override is where we'll pass in the component that will draw the lasso. We need to make sure that we pass in the <TldrawOverlays /> component as well, so that we get all the tldraw default overlays.
	We use `Overlays` instead of `InFrontOfTheCanvas` because `Overlays` get camera transforms applied to them automatically, so the points will always render where we want them to.

[3]
This component reads the lasso points from the lasso select tool and draws the lasso itself onto the Overlays layer. It is worth noting that this is only necessary for rendering the lasso.

	[a]
	Here we're using the tldraw's `useValue` hook to read the lasso points from the tool's state. We use `editor.isIn()` to check if we're in the lassoing state, then `editor.getStateDescendant()` to get the lassoing state instance. The thing that allows us to get these points reactively is the `lassoing.points.get()` call. This is because `LassoingState`'s `points` attribute is an instance of the `atom` class. As you'll see in `LassoSelectTool.tsx`, we're using an `atom<VecModel[]>` to store the lasso points.

	[b]
	Here we're smoothing the lasso points using tldraw's freehand library's `getStrokePoints` function, then converting the smoothed points to an SVG path.

	[c]
	Here we're actually defining the SVG path that we use to draw the lasso onto the Overlays layer. There are a couple things to note here.
	- One is `className="tl-overlays__item"` and `aria-hidden="true"` attributes of the svg. This class name is necessary for the svg to render at all, and the aria hidden attribute makes it accessible to screen readers.
	- The other noteworthy line here is: `strokeWidth="calc(2px / var(--tl-zoom))"` which takes advantage of one of tldraw's global css variables to always draw the svg with the same apparent stroke width at different zoom levels.

*/
```

## LassoSelectTool.ts

```ts
import {
	atom,
	pointInPolygon,
	polygonsIntersect,
	StateNode,
	TLPointerEventInfo,
	TLShape,
	VecModel,
} from 'tldraw'

// There's a guide at the bottom of this file!

export class LassoSelectTool extends StateNode {
	static override id = 'lasso-select'
	static override children() {
		return [IdleState, LassoingState]
	}
	static override initial = 'idle'
}

export class IdleState extends StateNode {
	static override id = 'idle'

	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this

		editor.selectNone()
		this.parent.transition('lassoing', info)
	}
}

//[1]
export class LassoingState extends StateNode {
	static override id = 'lassoing'

	info = {} as TLPointerEventInfo

	markId = null as null | string

	//[a]
	points = atom<VecModel[]>('lasso points', [])

	override onEnter(info: TLPointerEventInfo) {
		this.points.set([])
		this.markId = null
		this.info = info

		this.startLasso()
	}

	private startLasso() {
		this.markId = this.editor.markHistoryStoppingPoint('lasso start')
	}

	//[b]
	override onPointerMove(): void {
		this.addPointToLasso()
	}

	private addPointToLasso() {
		const { inputs } = this.editor

		const { x, y, z } = inputs.getCurrentPagePoint().toFixed()
		const newPoint = { x, y, z }

		this.points.set([...this.points.get(), newPoint])
	}

	//[c]
	private getShapesInLasso() {
		const { editor } = this

		const shapes = editor.getCurrentPageRenderingShapesSorted()
		const lassoPoints = this.points.get()
		const shapesInLasso = shapes.filter((shape) => {
			return this.doesLassoFullyContainShape(lassoPoints, shape)
		})

		return shapesInLasso
	}

	private doesLassoFullyContainShape(lassoPoints: VecModel[], shape: TLShape): boolean {
		const { editor } = this

		const geometry = editor.getShapeGeometry(shape)
		const pageTransform = editor.getShapePageTransform(shape)
		const shapeVertices = pageTransform.applyToPoints(geometry.vertices)

		const allVerticesInside = shapeVertices.every((vertex) => {
			return pointInPolygon(vertex, lassoPoints)
		})

		// Early return if any vertex is not inside the lasso
		if (!allVerticesInside) {
			return false
		}

		// If any shape edges intersect with the lasso, then we know it can't be fully contained by the lasso because of like the mean value theorem or something.
		if (geometry.isClosed) {
			if (polygonsIntersect(shapeVertices, lassoPoints)) {
				return false
			}
		}

		return true
	}

	override onPointerUp(): void {
		this.complete()
	}

	override onComplete() {
		this.complete()
	}

	//[d]
	complete() {
		const { editor } = this

		const shapesInLasso = this.getShapesInLasso()
		editor.setSelectedShapes(shapesInLasso)

		editor.setCurrentTool('select')
	}
}

/*
This is where we define the actual lasso select tool and its functionality.

For a general guide on how to built tools with child states, see the `MiniSelectTool` in the only-editor example.

[1]
The main meat of this tool is in the `LassoingState` class. This is the state that is active when the user has the tool selected and holds the mouse down.

    [a]
    The `points` attribute is an instance of the `atom` class. This makes the entire thing work by allowing us to reactively read the lasso points from the `Overlays` layer (which we then use to draw the lasso). As the user moves the mouse, `points` will be updated.

    [b]
    `onPointerMove()`, which is called when the user moves the mouse, calls `addPointToLasso()`, which adds the current mouse position in page space to `points`.

    [c]
    `getShapesInLasso()`, alongside `doesLassoFullyContainShape()` handles the logic of figuring out which shapes on the canvas are fully contained within the lasso.

    [d]
    `onPointerUp()`, which is called when the user releases the mouse, calls the state's `complete()` function. This gets all shapes inside the lasso and selects all of them using the editor's `setSelectedShapes()` function.

In general, if we wanted to add more functionality to the lasso select, we could:
- live update the selection as the user moves the mouse, similar to how the default select and brush select tools work
- use modifier keys to add or subtract from the selection instead of just setting the selection
- properly handle what happens when we select a shape that's grouped with other shapes (do we select the shape within the group or move up a level and select the entire group? what about layers?)
- extend the default selection tool to allow for lasso selection when a hotkey is pressed, similar to the brush select tool
- add a little bit of leeway to the lasso selection logic to allow for shapes that are mostly, but not fully, enclosed in the lasso to be selected

*/
```

--------

# Locked shapes

Category: Editor API

Keywords: lock, unlock, locked, isLocked, ignoreShapeLock, template, background

Lock shapes to prevent user editing, and use `ignoreShapeLock` to modify them programmatically.

- **Locked template** — The blue shapes are locked on mount. Try dragging them!
- **Scatter/Reset** — Uses `editor.run({ ignoreShapeLock: true })` to move locked shapes

## App.tsx

```tsx
import { createShapeId, Tldraw, TldrawUiButton, TLShapeId, toRichText, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const TEMPLATE_IDS: TLShapeId[] = [
	createShapeId('t1'),
	createShapeId('t2'),
	createShapeId('t3'),
	createShapeId('t4'),
]

// [2]
function ControlPanel() {
	const editor = useEditor()

	// [3] Update locked shapes using ignoreShapeLock option
	// Without ignoreShapeLock: true, these updates would be blocked
	const handleScatter = () => {
		editor.run(
			() => {
				editor.updateShapes(
					TEMPLATE_IDS.map((id) => ({
						id,
						type: 'geo',
						x: 50 + Math.random() * 300,
						y: 50 + Math.random() * 300,
					}))
				)
			},
			{ ignoreShapeLock: true }
		)
	}

	const handleReset = () => {
		editor.run(
			() => {
				editor.updateShapes([
					{ id: TEMPLATE_IDS[0], type: 'geo', x: 100, y: 100 },
					{ id: TEMPLATE_IDS[1], type: 'geo', x: 250, y: 100 },
					{ id: TEMPLATE_IDS[2], type: 'geo', x: 100, y: 250 },
					{ id: TEMPLATE_IDS[3], type: 'geo', x: 250, y: 250 },
				])
			},
			{ ignoreShapeLock: true }
		)
	}

	return (
		<div className="tlui-menu">
			<TldrawUiButton type="normal" onClick={handleScatter}>
				Scatter
			</TldrawUiButton>
			<TldrawUiButton type="normal" onClick={handleReset}>
				Reset
			</TldrawUiButton>
		</div>
	)
}

const components = {
	TopPanel: ControlPanel,
}

// [4]
export default function LockedShapesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				components={components}
				onMount={(editor) => {
					// Skip if shapes already exist
					if (editor.getShape(TEMPLATE_IDS[0])) {
						editor.zoomToFit({ animation: { duration: 0 } })
						return
					}

					// [5] Create locked template shapes
					const shapeProps = {
						geo: 'rectangle' as const,
						w: 130,
						h: 130,
						dash: 'dashed' as const,
						color: 'light-blue' as const,
						fill: 'semi' as const,
						richText: toRichText('Locked'),
					}

					editor.createShapes([
						{ id: TEMPLATE_IDS[0], type: 'geo', x: 100, y: 100, props: shapeProps },
						{ id: TEMPLATE_IDS[1], type: 'geo', x: 250, y: 100, props: shapeProps },
						{ id: TEMPLATE_IDS[2], type: 'geo', x: 100, y: 250, props: shapeProps },
						{ id: TEMPLATE_IDS[3], type: 'geo', x: 250, y: 250, props: shapeProps },
					])

					// [6] Lock them immediately
					editor.toggleLock(TEMPLATE_IDS)
					editor.zoomToFit({ animation: { duration: 0 } })
				}}
			/>
		</div>
	)
}

/*
This example demonstrates the key distinction between locked shapes and programmatic updates:

Locked shapes prevent ALL user interaction (dragging, deleting, etc.), but programs can still
modify them using the ignoreShapeLock option. This is useful for shapes that should be fixed
in place by the user but need to be repositioned programmatically.

[1] Pre-defined shape IDs so we can reference them later.

[2] Control panel with action buttons.

[3] Both buttons use editor.run() with { ignoreShapeLock: true } to bypass the lock constraint.
This option allows programmatic updates even though user interactions on these shapes are blocked.

[4] The main component sets up the editor.

[5] On mount, we create a 2x2 grid of template shapes.

[6] We immediately lock them with toggleLock(). The key behavior: users cannot move or delete
these shapes, but the Scatter/Reset buttons can still reposition them programmatically.

Try it:
- Try dragging any template shape (won't work - they're locked by the user interface)
- Click Scatter or Reset to see how programmatic updates work with ignoreShapeLock: true
*/
```

--------

# Reactive inputs

Category: Editor API

Keywords: input, mouse, pointer, position, velocity, reactive, state

Reactively track mouse positions and velocities using the editor's inputs manager.

The editor's inputs manager provides reactive access to pointer state including current, previous, and origin positions (in both screen and page space), as well as pointer velocity. All properties are backed by reactive atoms that automatically trigger updates when they change.

This example demonstrates how to use `useValue` to subscribe to these reactive inputs and display them in real-time as the user moves their mouse.

## App.tsx

```tsx
import { useState } from 'react'
import { Editor, Tldraw, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './reactive-inputs.css'

// There's a guide at the bottom of this file!

export default function ReactiveInputsExample() {
	const [editor, setEditor] = useState<Editor | null>(null)
	return (
		<div style={{ display: 'flex', height: '100vh' }}>
			<div style={{ flex: 1, minWidth: 0 }}>
				<Tldraw onMount={setEditor} />
				{editor && <ReactiveInputsPanel editor={editor} />}
			</div>
		</div>
	)
}

function ReactiveInputsPanel({ editor }: { editor: Editor }) {
	// [2]
	const currentScreenPoint = useValue(
		'current screen point',
		() => editor?.inputs.getCurrentScreenPoint(),
		[editor]
	)
	const currentPagePoint = useValue(
		'current page point',
		() => editor?.inputs.getCurrentPagePoint(),
		[editor]
	)
	const previousScreenPoint = useValue(
		'previous screen point',
		() => editor?.inputs.getPreviousScreenPoint(),
		[editor]
	)
	const previousPagePoint = useValue(
		'previous page point',
		() => editor?.inputs.getPreviousPagePoint(),
		[editor]
	)
	const originScreenPoint = useValue(
		'origin screen point',
		() => editor?.inputs.getOriginScreenPoint(),
		[editor]
	)
	const originPagePoint = useValue('origin page point', () => editor?.inputs.getOriginPagePoint(), [
		editor,
	])
	const pointerVelocity = useValue('pointer velocity', () => editor?.inputs.getPointerVelocity(), [
		editor,
	])

	return (
		<div className="reactive-inputs-panel">
			<h3>Reactive inputs</h3>
			<div className="reactive-inputs-content">
				{/* [3] */}
				<div className="input-group">
					<div className="input-label">Current screen point</div>
					<div className="input-value">
						x: {currentScreenPoint?.x.toFixed(2) ?? '0.00'}
						<br />
						y: {currentScreenPoint?.y.toFixed(2) ?? '0.00'}
					</div>
				</div>

				<div className="input-group">
					<div className="input-label">Current page point</div>
					<div className="input-value">
						x: {currentPagePoint?.x.toFixed(2) ?? '0.00'}
						<br />
						y: {currentPagePoint?.y.toFixed(2) ?? '0.00'}
					</div>
				</div>

				<div className="input-group">
					<div className="input-label">Previous screen point</div>
					<div className="input-value">
						x: {previousScreenPoint?.x.toFixed(2) ?? '0.00'}
						<br />
						y: {previousScreenPoint?.y.toFixed(2) ?? '0.00'}
					</div>
				</div>

				<div className="input-group">
					<div className="input-label">Previous page point</div>
					<div className="input-value">
						x: {previousPagePoint?.x.toFixed(2) ?? '0.00'}
						<br />
						y: {previousPagePoint?.y.toFixed(2) ?? '0.00'}
					</div>
				</div>

				<div className="input-group">
					<div className="input-label">Origin screen point</div>
					<div className="input-value">
						x: {originScreenPoint?.x.toFixed(2) ?? '0.00'}
						<br />
						y: {originScreenPoint?.y.toFixed(2) ?? '0.00'}
					</div>
				</div>

				<div className="input-group">
					<div className="input-label">Origin page point</div>
					<div className="input-value">
						x: {originPagePoint?.x.toFixed(2) ?? '0.00'}
						<br />
						y: {originPagePoint?.y.toFixed(2) ?? '0.00'}
					</div>
				</div>

				{/* [4] */}
				<div className="input-group">
					<div className="input-label">Pointer velocity</div>
					<div className="input-value">
						x: {pointerVelocity?.x.toFixed(4) ?? '0.0000'}
						<br />
						y: {pointerVelocity?.y.toFixed(4) ?? '0.0000'}
						<br />
						<span className="input-hint">px/ms</span>
					</div>
				</div>
			</div>
		</div>
	)
}
/*
[1]
Store the editor instance in React state so we can access it from the component.

[2]
Use the `useValue` hook to subscribe to reactive input state. The hook takes three arguments:
- A name for debugging
- A function that returns the value to track
- Dependencies array (similar to useEffect)

The editor's inputs manager exposes several reactive properties:
- getCurrentScreenPoint() / getCurrentPagePoint() - Current pointer position
- getPreviousScreenPoint() / getPreviousPagePoint() - Previous pointer position
- getOriginScreenPoint() / getOriginPagePoint() - Position where pointer went down
- getPointerVelocity() - Pointer velocity in pixels per millisecond

All of these are backed by reactive atoms, so calling them inside a `useValue` callback will
automatically trigger updates when they change.

[3]
Screen points are relative to the editor's container, while page points are in the canvas's
coordinate space (accounting for zoom and pan). The origin points track where the most recent
pointer down event occurred.

[4]
Pointer velocity is calculated and updated by the tick manager. It represents the speed and
direction of pointer movement in pixels per millisecond, useful for detecting quick gestures
or implementing physics-based interactions.
*/
```

## reactive-inputs.css

```css
.reactive-inputs-panel {
	width: 250px;
	flex-shrink: 0;
	padding: 16px;
	background: #f8f9fa;
	border-left: 2px solid #e0e0e0;
	overflow-y: auto;
	font-family:
		system-ui,
		-apple-system,
		sans-serif;
}

@media (max-width: 768px) {
	.reactive-inputs-panel {
		display: none;
	}
}

.reactive-inputs-panel h3 {
	margin: 0 0 16px 0;
	font-size: 16px;
	font-weight: 600;
	color: #1a1a1a;
}

.reactive-inputs-content {
	display: flex;
	flex-direction: column;
	gap: 12px;
}

.input-group {
	padding: 10px;
	background: white;
	border: 1px solid #e0e0e0;
	border-radius: 4px;
}

.input-label {
	font-size: 11px;
	font-weight: 600;
	color: #666;
	margin-bottom: 6px;
	text-transform: uppercase;
	letter-spacing: 0.5px;
}

.input-value {
	font-family:
		'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
	font-size: 13px;
	color: #1a1a1a;
	line-height: 1.5;
}

.input-hint {
	font-size: 11px;
	color: #999;
	font-style: italic;
}
```

--------

# Toggle focus mode

Category: Editor API

Keywords: focus, mode, editor, state, instance

How to enable focus mode by using the editor API.

This example demonstrates how to enable focus mode when the editor mounts. Focus mode provides a distraction-free environment by hiding the UI elements and focusing on the canvas content.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function FocusModeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// [1]
					editor.updateInstanceState({ isFocusMode: true })
				}}
			/>
		</div>
	)
}

/**
 * This example demonstrates how to enable focus mode when the editor mounts.
 *
 * [1] The editor's instance state is updated on mount to enable focus mode.
 */
```

--------

# Interaction end callback

Category: Editor API

Keywords: callback, interaction, drag, resize, rotate, tool

Control behavior after dragging, resizing, or rotating shapes.

When programmatically starting interactions like translating, resizing, or rotating, you can use the `onInteractionEnd` option to control what happens when the interaction completes. Pass a string to transition to a specific tool, or a function to execute custom logic.

In this example, we set the fill of a shape after we finish translating to be patterned.

## App.tsx

```tsx
import { StateNode, TLPointerEventInfo, Tldraw, createShapeId } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
class QuickShapeTool extends StateNode {
	static override id = 'quick-shape'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: TLPointerEventInfo) {
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		const shapeId = createShapeId()

		this.editor.createShape({
			id: shapeId,
			type: 'geo',
			x: currentPagePoint.x - 50,
			y: currentPagePoint.y - 50,
			props: { w: 100, h: 100, fill: 'solid' },
		})

		this.editor.setSelectedShapes([shapeId])

		// [2]
		this.editor.setCurrentTool('select.translating', {
			...info,
			target: 'shape',
			shape: this.editor.getShape(shapeId),
			isCreating: true,
			// [3]
			onInteractionEnd: () => {
				// Change fill to semi-transparent after dragging
				this.editor.updateShape({
					id: shapeId,
					type: 'geo',
					props: { fill: 'pattern' },
				})
				// Return to our custom tool
				this.editor.setCurrentTool('quick-shape')
			},
		})
	}
}

export default function InteractionEndExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw tools={[QuickShapeTool]} initialState="quick-shape" hideUi />
		</div>
	)
}

/*
[1]
Create a simple tool that creates shapes on click. This demonstrates using
onInteractionEnd to control what happens after the user drags the new shape.

[2]
After creating the shape, transition to the translating state so the user can
immediately position it.

[3]
Pass a function as onInteractionEnd to execute custom logic when dragging ends.
Here we change the shape's fill style and return to our custom tool. You can also
pass a string like 'quick-shape' or 'select.idle' to simply transition to that tool.
*/
```

--------

# Easter egg styles

Category: Editor API

Keywords: easter egg, white color, fill styles, labelColor, hidden features

Use tldraw's collection of easter egg styles programmatically.

tldraw includes several "easter egg" styles that aren't visible in the default UI but can be accessed through keyboard shortcuts or set programmatically. These styles include:

- **White** (`Option+T`): A white color option for shapes
- **Fill** (`Option+F`) - An alternative solid fill variant
- **Lined fill** (`Option+Shift+F`) - A lined fill pattern variant
- **Label color** - A separate color property for text labels on shapes, independent from the shape's main color
- **Scale** - A scale property for shapes, independent from the shape's size, available via the **Dynamic size** preference

This example programmatically creates shapes demonstrating each of these easter egg styles. While these styles aren't publicly exposed in the default UI, they can be useful for specific use cases or when you need more control over styling.

## App.tsx

```tsx
import { Editor, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function EasterEggStylesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor: Editor) => {
					editor.createShapes([
						{
							type: 'geo',
							x: 0,
							y: 0,
							props: {
								geo: 'rectangle',
								w: 250,
								h: 250,
								color: 'blue',
								fill: 'fill', // Easter egg: Fill style (keyboard shortcut: Option+F)
								richText: toRichText('Fill\n(Option+F)'),
							},
						},
						{
							type: 'geo',
							x: 300,
							y: 0,
							props: {
								geo: 'rectangle',
								w: 250,
								h: 250,
								color: 'blue',
								fill: 'lined-fill', // Easter egg: Lined fill style (keyboard shortcut: Option+Shift+F)
								richText: toRichText('Lined fill\n(Option+Shift+F)'),
							},
						},
						{
							type: 'geo',
							x: 600,
							y: 0,
							props: {
								geo: 'rectangle',
								w: 250,
								h: 250,
								color: 'white', // Easter egg: White color (keyboard shortcut: Option+T)
								fill: 'fill',
								richText: toRichText('White \n(Option+T)'),
							},
						},
						{
							type: 'geo',
							x: 900,
							y: 0,
							props: {
								geo: 'rectangle',
								w: 250,
								h: 250,
								color: 'blue',
								richText: toRichText('Label color'),
								labelColor: 'red', // Separate label color
							},
						},
						{
							type: 'geo',
							x: 1200,
							y: 0,
							props: {
								geo: 'rectangle',
								w: 250,
								h: 250,
								color: 'blue',
								scale: 2.5,
								richText: toRichText('Scale'), // Scale (available via the Dynamic size preference)
							},
						},
					])

					editor.zoomToFit()
				}}
			/>
		</div>
	)
}
```

--------

# Inspector panel

Category: UI & theming

Keywords: inspector, properties, props, selection, panel

Display an inspector panel that shows the properties of the currently selected shape.

This example demonstrates how to create an inspector panel that displays all properties of the currently selected shape. When a single shape is selected, the panel shows the shape's type, position, dimensions, and all custom properties. The panel updates reactively as you select different shapes or modify their properties.

The inspector shows:

- Basic shape properties (id, type, position, rotation, etc.)
- Shape-specific props (dimensions, colors, styles, etc.)
- Meta information and other attributes

This is useful for debugging, educational purposes, or creating admin interfaces where you need to inspect shape data.

## App.tsx

```tsx
import { useState } from 'react'
import { Editor, EditorProvider, Tldraw, useEditor, useIsDarkMode, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './inspector-panel.css'

// Inspector Panel Component that shows selected shape properties
function InspectorPanel() {
	const editor = useEditor()

	// Get the currently selected shapes, updates reactively
	const selectedShapes = useValue('selected shapes', () => editor.getSelectedShapes(), [editor])

	// Get shared styles when multiple shapes are selected
	const sharedStyles = useValue(
		'shared styles',
		() => {
			if (selectedShapes.length <= 1) return null
			return editor.getSharedStyles()
		},
		[editor, selectedShapes]
	)

	// Get bindings involving the selected shape (only for single selection)
	const bindings = useValue(
		'bindings',
		() => {
			if (selectedShapes.length !== 1) return []
			return editor.getBindingsInvolvingShape(selectedShapes[0].id)
		},
		[editor, selectedShapes]
	)

	const isDarkMode = useIsDarkMode()

	const selectedShape = selectedShapes.length === 1 ? selectedShapes[0] : null

	if (selectedShapes.length === 0) {
		return (
			<div
				className={`${isDarkMode ? 'inspector-panel inspector-panel-dark' : ''} inspector-panel`}
			>
				<h3>Inspector</h3>
				<p>No shape selected</p>
			</div>
		)
	}

	if (selectedShapes.length > 1) {
		return (
			<div
				className={`${isDarkMode ? 'inspector-panel inspector-panel-dark' : ''} inspector-panel`}
			>
				<h3>Inspector</h3>
				{sharedStyles && sharedStyles.size > 0 && (
					<div className="inspector-section">
						<h4>Shared Styles</h4>
						{Array.from(sharedStyles.entries()).map(([styleProp, sharedStyle]) => (
							<SharedStyleRow key={styleProp.id} styleProp={styleProp} sharedStyle={sharedStyle} />
						))}
					</div>
				)}
				<p>{selectedShapes.length} shapes selected</p>
			</div>
		)
	}

	// Single shape selected
	return (
		<div className={`${isDarkMode ? 'inspector-panel inspector-panel-dark' : ''} inspector-panel`}>
			<h3>Inspector</h3>
			<div className="inspector-section">
				{Object.entries(selectedShape!).map(([key, value]) => {
					if (key === 'props') return null // Skip props, we'll show them separately
					return <PropertyRow key={key} name={key} value={value} path={`basic.${key}`} />
				})}
			</div>

			{selectedShape!.props && Object.keys(selectedShape!.props).length > 0 && (
				<div className="inspector-section">
					<h4>Shape Props</h4>
					{Object.entries(selectedShape!.props).map(([key, value]) => (
						<PropertyRow key={key} name={key} value={value} path={`props.${key}`} />
					))}
				</div>
			)}

			{bindings.length > 0 && (
				<div className="inspector-section">
					<h4>Bindings ({bindings.length})</h4>
					{bindings.map((binding) => (
						<BindingRow key={binding.id} binding={binding} selectedShapeId={selectedShape!.id} />
					))}
				</div>
			)}
		</div>
	)
}

// Component to render a shared style row
function SharedStyleRow({ styleProp, sharedStyle }: { styleProp: any; sharedStyle: any }) {
	const formatStyleValue = (style: any): string => {
		if (style.type === 'mixed') {
			return '(mixed)'
		} else if (style.type === 'shared') {
			return typeof style.value === 'string' ? `"${style.value}"` : String(style.value)
		}
		return String(style)
	}

	const getStyleClass = (style: any): string => {
		return style.type === 'mixed' ? 'mixed-style' : 'shared-style'
	}

	return (
		<div className="property-row">
			<span className="property-name">{styleProp.id.replace('tldraw:', '')}:</span>
			<span className={`property-value ${getStyleClass(sharedStyle)}`}>
				{formatStyleValue(sharedStyle)}
			</span>
		</div>
	)
}

// Component to render an individual property row
function PropertyRow({ name, value, path: _path }: { name: string; value: any; path: string }) {
	const [isExpanded, setIsExpanded] = useState(false)

	const isObject = value !== null && value !== undefined && typeof value === 'object'

	const formatValue = (val: any): string => {
		if (val === null || val === undefined) return String(val)
		if (typeof val === 'string') return `"${val}"`
		if (typeof val === 'object') {
			if (Array.isArray(val)) return `Array(${val.length})`
			// Handle rich text objects
			if ('richText' in val && val.richText) {
				return `"${val.richText[0]?.children?.[0]?.text || ''}"`
			}
			return `Object(${Object.keys(val).length} keys)`
		}
		return String(val)
	}

	const formatJsonValue = (val: any): string => {
		try {
			return JSON.stringify(val, null, 2)
		} catch (_e) {
			return String(val)
		}
	}

	if (isObject) {
		return (
			<div className="property-row">
				<div className="property-row-header">
					<span className="property-name">{name}:</span>
					<button
						className="toggle-button"
						onClick={() => setIsExpanded(!isExpanded)}
						title={isExpanded ? 'Collapse' : 'Expand'}
					>
						{isExpanded ? '−' : '+'}
					</button>
					<span className="property-value">{formatValue(value)}</span>
				</div>
				{isExpanded && (
					<div className="property-json">
						<pre>{formatJsonValue(value)}</pre>
					</div>
				)}
			</div>
		)
	}

	return (
		<div className="property-row">
			<span className="property-name">{name}:</span>
			<span className="property-value">{formatValue(value)}</span>
		</div>
	)
}

// Component to render a binding row
function BindingRow({ binding, selectedShapeId }: { binding: any; selectedShapeId: string }) {
	const editor = useEditor()

	// Determine the relationship
	const isFrom = binding.fromId === selectedShapeId
	const otherShapeId = isFrom ? binding.toId : binding.fromId
	const relationship = isFrom ? 'from' : 'to'

	// Get info about the other shape
	const otherShape = useValue(
		'other shape',
		() => {
			return editor.getShape(otherShapeId)
		},
		[editor, otherShapeId]
	)

	return (
		<div className="binding-row">
			<div className="binding-header">
				<span className="binding-type">{binding.type}</span>
				<span className="binding-direction">({relationship})</span>
			</div>
			<PropertyRow name="id" value={binding.id} path={`binding.${binding.id}.id`} />
			<PropertyRow
				name={relationship === 'from' ? 'toId' : 'fromId'}
				value={otherShapeId}
				path={`binding.${binding.id}.otherId`}
			/>
			{otherShape && (
				<PropertyRow
					name="shape"
					value={otherShape.type}
					path={`binding.${binding.id}.shapeType`}
				/>
			)}
			{binding.props && Object.keys(binding.props).length > 0 && (
				<PropertyRow name="props" value={binding.props} path={`binding.${binding.id}.props`} />
			)}
		</div>
	)
}

export default function InspectorPanelExample() {
	const [editor, setEditor] = useState<Editor | null>(null)

	return (
		<div className="example-container">
			<div className="canvas-container">
				<Tldraw persistenceKey="inspector-panel-example" onMount={setEditor} />
			</div>
			{editor && (
				<EditorProvider editor={editor}>
					<InspectorPanel />
				</EditorProvider>
			)}
		</div>
	)
}
```

## inspector-panel.css

```css
.example-container {
	display: flex;
	height: 100vh;
	width: 100%;
}

.canvas-container {
	flex: 1;
	height: 100vh;
}

.inspector-panel {
	width: 300px;
	background: white;
	border-left: 1px solid #ccc;
	padding: 16px;
	font-family: monospace;
	font-size: 12px;
	overflow-y: auto;
}

.inspector-panel h3 {
	margin: 0 0 16px 0;
	font-size: 14px;
	font-weight: bold;
}

.inspector-panel h4 {
	margin: 16px 0 8px 0;
	font-size: 12px;
	font-weight: bold;
	color: #666;
	text-transform: uppercase;
}

.inspector-panel h4:first-child {
	margin-top: 0;
}

.inspector-panel p {
	margin: 0;
	color: #666;
	font-style: italic;
}

.inspector-section {
	margin-bottom: 16px;
}

.inspector-section:last-child {
	margin-bottom: 0;
}

.property-row {
	margin-bottom: 4px;
	line-height: 1.4;
}

.property-row-header {
	display: flex;
	align-items: center;
}

.property-name {
	flex: 0 0 1;
	font-weight: bold;
	margin-right: 8px;
}

.property-value {
	flex: 1;
	word-break: break-all;
	color: #333;
}

/* Shared style indicators */
.shared-style {
	color: #0066cc;
}

.mixed-style {
	color: #ff6600;
	font-style: italic;
}

.toggle-button {
	background: #e0e0e0;
	border: 1px solid #ccc;
	border-radius: 2px;
	width: 18px;
	height: 18px;
	font-size: 12px;
	font-weight: bold;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 0;
	line-height: 1;
	margin-right: 8px;
}

.toggle-button:hover {
	background: #d0d0d0;
}

.toggle-button:active {
	background: #c0c0c0;
}

.property-json {
	margin-top: 4px;
	margin-left: 8px;
	background: #f8f8f8;
	border: 1px solid #e0e0e0;
	border-radius: 4px;
	padding: 8px;
	overflow-x: auto;
}

.property-json pre {
	margin: 0;
	font-size: 11px;
	line-height: 1.3;
	color: #444;
	white-space: pre-wrap;
	word-break: break-word;
}

/* Binding-specific styles */
.binding-row {
	margin-bottom: 12px;
	padding: 8px;
	background: #f9f9f9;
	border-radius: 4px;
	border-left: 3px solid #007acc;
}

.binding-header {
	display: flex;
	align-items: center;
	margin-bottom: 4px;
	gap: 8px;
}

.binding-type {
	font-weight: bold;
	color: #007acc;
	text-transform: uppercase;
	font-size: 11px;
}

.binding-direction {
	font-size: 10px;
	color: #666;
	background: #e0e0e0;
	padding: 2px 6px;
	border-radius: 2px;
}

.binding-props {
	margin-top: 4px;
}

.binding-prop {
	margin-left: 8px;
}

.binding-row:last-child {
	margin-bottom: 0;
}

/* Simple dark mode */
.inspector-panel-dark {
	background: #2a2a2a;
	border-color: #555;
	color: #e0e0e0;
}

.inspector-panel-dark h4 {
	color: #aaa;
}

.inspector-panel-dark p {
	color: #aaa;
}

.inspector-panel-dark .property-value {
	color: #ddd;
}

.inspector-panel-dark .toggle-button {
	background: #555;
	border-color: #666;
	color: #e0e0e0;
}

.inspector-panel-dark .toggle-button:hover {
	background: #666;
}

.inspector-panel-dark .toggle-button:active {
	background: #777;
}

.inspector-panel-dark .property-json {
	background: #1e1e1e;
	border-color: #555;
}

.inspector-panel-dark .property-json pre {
	color: #ddd;
}

.inspector-panel-dark .binding-row {
	background: #333;
	border-left-color: #4da6ff;
}

.inspector-panel-dark .binding-type {
	color: #4da6ff;
}

.inspector-panel-dark .binding-direction {
	background: #555;
	color: #ccc;
}
```

--------

# Toolbar groups

Category: UI & theming

Keywords:

Create groups within the toolbar to separate related concepts.



## App.tsx

```tsx
import { useMemo, useState } from 'react'
import {
	ArrowDownToolbarItem,
	ArrowLeftToolbarItem,
	ArrowRightToolbarItem,
	ArrowUpToolbarItem,
	CloudToolbarItem,
	DefaultToolbar,
	DiamondToolbarItem,
	DrawToolbarItem,
	EllipseToolbarItem,
	EraserToolbarItem,
	HandToolbarItem,
	HexagonToolbarItem,
	HighlightToolbarItem,
	LaserToolbarItem,
	OvalToolbarItem,
	RectangleToolbarItem,
	RhombusToolbarItem,
	SelectToolbarItem,
	StarToolbarItem,
	TLComponents,
	Tldraw,
	TldrawUiMenuGroup,
	TldrawUiMenuItem,
	TriangleToolbarItem,
} from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	const [orientation, setOrientation] = useState<'horizontal' | 'vertical'>('horizontal')

	const components = useMemo((): TLComponents => {
		return {
			Toolbar: () => (
				<DefaultToolbar orientation={orientation}>
					<TldrawUiMenuGroup id="orientation">
						<TldrawUiMenuItem
							id="orientation"
							onSelect={() =>
								setOrientation(orientation === 'horizontal' ? 'vertical' : 'horizontal')
							}
							label="Toggle orientation"
							icon={<span style={{ fontSize: '2em' }}>🔄</span>}
						/>
					</TldrawUiMenuGroup>
					<TldrawUiMenuGroup id="controls">
						<SelectToolbarItem />
						<HandToolbarItem />
						<EraserToolbarItem />
					</TldrawUiMenuGroup>
					<TldrawUiMenuGroup id="pens">
						<DrawToolbarItem />
						<HighlightToolbarItem />
						<LaserToolbarItem />
					</TldrawUiMenuGroup>
					<TldrawUiMenuGroup id="shapes">
						<RectangleToolbarItem />
						<EllipseToolbarItem />
						<TriangleToolbarItem />
						<DiamondToolbarItem />
						<HexagonToolbarItem />

						<OvalToolbarItem />
						<RhombusToolbarItem />
						<StarToolbarItem />
						<CloudToolbarItem />
					</TldrawUiMenuGroup>
					<TldrawUiMenuGroup id="arrows">
						<ArrowLeftToolbarItem />
						<ArrowUpToolbarItem />
						<ArrowDownToolbarItem />
						<ArrowRightToolbarItem />
					</TldrawUiMenuGroup>
				</DefaultToolbar>
			),
		}
	}, [orientation])

	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}
```

--------

# Vertical toolbar

Category: UI & theming

Keywords:

Switch from a horizontal toolbar at the bottom of the screen to a vertical one on the left.

Tldraw supports a vertical toolbar out of the box. Override the toolbar component to set the orientation of the default toolbar to vertical.

## App.tsx

```tsx
import { DefaultToolbar, TLComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	Toolbar: () => <DefaultToolbar orientation="vertical" />,
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}
```

--------

# Add a tool to the toolbar

Category: UI & theming

Keywords:

Add your custom tool to the toolbar.

You can make an icon for your custom tool appear on tldraw's toolbar. To do this you will need to override the toolbar component, pass in a custom component for the keyboard shortcuts dialog, and pass in an asset url for your icon. This example shows how to do that. For more information on how to implement custom tools, check out the custom tool example.

## App.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { StickerTool } from './sticker-tool-util'

// There's a guide at the bottom of this file!

// [1]
const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.sticker = {
			id: 'sticker',
			icon: 'heart-icon',
			label: 'Sticker',
			kbd: 's',
			onSelect: () => {
				editor.setCurrentTool('sticker')
			},
		}
		return tools
	},
}

// [2]
const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isStickerSelected = useIsToolSelected(tools['sticker'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['sticker']} isSelected={isStickerSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<DefaultKeyboardShortcutsDialogContent />
				{/* Ideally, we'd interleave this into the tools group */}
				<TldrawUiMenuItem {...tools['sticker']} />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

// [3]
export const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'heart-icon': '/heart-icon.svg',
	},
}

// [4]
const customTools = [StickerTool]

export default function ToolInToolbarExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// Pass in our ui overrides
				overrides={uiOverrides}
				// pass in our custom components
				components={components}
				// pass in our custom asset urls
				assetUrls={customAssetUrls}
			/>
		</div>
	)
}

/*
Introduction:
You can make an icon for your custom tool appear on tldraw's toolbar. To do this
you will need to override the toolbar component, pass in a custom component for
the keyboard shortcuts dialog, and pass in an asset url for your icon. This
example shows how to do that. For more information on how to implement custom
tools, check out the custom tool example.

[1]
First, we define the uiOverrides object. We can override the tools function to
add our custom tool to the ui's context. We can also override the toolbar function
to add our custom tool to the toolbar. We are going to splice it into the toolbar
so it appears in between the eraser and arrow tools.

[2]
Next, we want to override the default keyboard shortcuts dialog so that the
shortcut for our custom tool appears in the dialog. We don't want to change its
appearance very much, so we can use the DefaultKeyboardShortcutsDialog component
and pass in the DefaultKeyboardShortcutsDialogContent component. With the useTools
hook, we can get the tools from context and pass in the sticker tool to the keyboard
shortcuts dialog. This will make the keyboard shortcut for the sticker tool appear
in the dialog.

[3]
We need to make sure the editor knows where to find the icon for our custom tool.
We do this by defining the customAssetUrls object and passing in the asset url for
our icon.

[4]
Finally, we define the customTools array. This array contains the custom tool
class. We then pass the customTools array, the uiOverrides object, the
components object, and the customAssetUrls object to the Tldraw component as
props. This will make the icon for the custom tool appear on the toolbar.

*/
```

## sticker-tool-util.tsx

```tsx
import { StateNode, toRichText } from 'tldraw'

// Check out the custom tool example for a more detailed explanation of the tool class.

const OFFSET = 12
export class StickerTool extends StateNode {
	static override id = 'sticker'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown() {
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		this.editor.createShape({
			type: 'text',
			x: currentPagePoint.x - OFFSET,
			y: currentPagePoint.y - OFFSET,
			props: { richText: toRichText('❤️') },
		})
	}
}
```

--------

# Remove a tool from the toolbar

Category: UI & theming

Keywords: remove, tool

You can remove a tool from the user interface.

Using overrides, you can remove a tool from the toolbar, keyboard shortcuts, and other parts of the user interface. The tool will still be present in the application but not accessible to the user.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function RemoveToolExample() {
	return (
		<>
			<div className="tldraw__editor">
				<Tldraw
					overrides={{
						tools: (_editor, tools) => {
							// Remove the text tool
							delete tools.text
							return tools
						},
					}}
				/>
			</div>
		</>
	)
}
```

--------

# Change default colors

Category: UI & theming

Keywords: colours, styles, palette, style panel

Change the tldraw theme colors.

While there's currently no way to add or remove our colors from our default shapes' colors, this example shows how you can adjust the values for the default color styles.

Note that this will change the colors for ALL instances of tldraw. For example, if you run this example locally, and then open another example, the changes will be present there too until you reload!

## App.tsx

```tsx
import { DefaultColorThemePalette, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
DefaultColorThemePalette.lightMode.black.solid = 'aqua'

export default function ChangingDefaultColorsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}

/*

[1]
The default color theme is exported from the tldraw library. You can
modify it directly outside of the React lifecycle, so that your changes
are used when the component mounts.

Remember that you can't add or remove colors here yet. These colors are
used by our default shapes and we need to make sure that we don't end
up with a color that we can't handle, or else this could get propagated
to other users in a multiplayer session.

At the moment, if you want to create new colors, you will need to create
your own shapes that understand those colors. We're working on making
this easier!
*/
```

--------

# Change default styles

Category: UI & theming

Keywords: size, styles, default

Change the default value for a style prop.

Want to set the default value for a property to something other than it's built-in default? In this example we make the size style have small as its default value.

## App.tsx

```tsx
import { DefaultSizeStyle, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

DefaultSizeStyle.setDefaultValue('s')

export default function ChangingDefaultStyleExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" />
		</div>
	)
}
```

--------

# Changing menus

Category: UI & theming

Keywords: menu, context menu, toolbar, main menu, page menu, panel

Customize tldraw's menus, including the toolbar, main menu, context menu, page menu, and more.

You can use the `components` prop to override tldraw's default menus. You can provide a React component of your own, import our default component and edit it, or return null to hide it completely. This example demonstrates how to do this with every menu in tldraw, including the following:

- Toolbar
- Main menu
- Context menu
- Page menu
- Actions menu
- Debug menu
- Help menu
- Keyboard shortcuts dialog
- Navigation panel
- Quick actions panel
- Style panel
- Zoom menu

## App.tsx

```tsx
import {
	DefaultActionsMenu,
	DefaultActionsMenuContent,
	DefaultColorStyle,
	DefaultContextMenu,
	DefaultContextMenuContent,
	DefaultDebugMenu,
	DefaultDebugMenuContent,
	DefaultHelpMenu,
	DefaultHelpMenuContent,
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultMainMenu,
	DefaultMainMenuContent,
	DefaultPageMenu,
	DefaultQuickActions,
	DefaultQuickActionsContent,
	DefaultStylePanel,
	DefaultStylePanelContent,
	DefaultToolbar,
	DefaultToolbarContent,
	DefaultZoomMenu,
	DefaultZoomMenuContent,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonLabel,
	TldrawUiMenuGroup,
	TldrawUiMenuItem,
	TLUiContextMenuProps,
	TLUiKeyboardShortcutsDialogProps,
	TLUiStylePanelProps,
	useEditor,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

//[1]

function CustomActionsMenu() {
	return (
		<div style={{ backgroundColor: 'thistle' }}>
			<DefaultActionsMenu>
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</div>
				<DefaultActionsMenuContent />
			</DefaultActionsMenu>
		</div>
	)
}
//[2]
function CustomContextMenu(props: TLUiContextMenuProps) {
	return (
		<DefaultContextMenu {...props}>
			<TldrawUiMenuGroup id="example">
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</div>
			</TldrawUiMenuGroup>
			<DefaultContextMenuContent />
		</DefaultContextMenu>
	)
}
//[3]
function CustomDebugMenu() {
	return (
		<div style={{ backgroundColor: 'thistle' }}>
			<DefaultDebugMenu>
				<DefaultDebugMenuContent />
				<div style={{ backgroundColor: 'thistle' }}>
					<TldrawUiMenuGroup id="example">
						<TldrawUiMenuItem
							id="like"
							label="Like my posts"
							icon="external-link"
							readonlyOk
							onSelect={() => {
								window.open('https://x.com/tldraw', '_blank')
							}}
						/>
					</TldrawUiMenuGroup>
				</div>
			</DefaultDebugMenu>
		</div>
	)
}
//[4]
function CustomHelpMenu() {
	return (
		<DefaultHelpMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultHelpMenuContent />
		</DefaultHelpMenu>
	)
}
//[5]
function CustomKeyboardShortcutsDialog(props: TLUiKeyboardShortcutsDialogProps) {
	return (
		<DefaultKeyboardShortcutsDialog {...props}>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuItem
					id="like-my-posts"
					label="Like my posts"
					icon="external-link"
					readonlyOk
					kbd=":)"
					onSelect={() => {
						window.open('https://x.com/tldraw', '_blank')
					}}
				/>
			</div>
			<DefaultKeyboardShortcutsDialogContent />
		</DefaultKeyboardShortcutsDialog>
	)
}
//[6]
function CustomMainMenu() {
	return (
		<DefaultMainMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultMainMenuContent />
		</DefaultMainMenu>
	)
}
//[7]
function CustomNavigationPanel() {
	return <div style={{ backgroundColor: 'thistle', padding: '14px' }}>here you are</div>
}
//[8]
function CustomPageMenu() {
	return (
		<div style={{ transform: 'rotate(3.14rad)', backgroundColor: 'thistle' }}>
			<DefaultPageMenu />
		</div>
	)
}
//[9]
function CustomQuickActions() {
	return (
		<DefaultQuickActions>
			<DefaultQuickActionsContent />
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuItem id="code" icon="code" onSelect={() => window.alert('code')} />
			</div>
		</DefaultQuickActions>
	)
}
//[10]
function CustomStylePanel(props: TLUiStylePanelProps) {
	const editor = useEditor()

	return (
		<DefaultStylePanel {...props}>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiButton
					type="menu"
					onClick={() => {
						editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
					}}
				>
					<TldrawUiButtonLabel>Red</TldrawUiButtonLabel>
				</TldrawUiButton>
			</div>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiButton
					type="menu"
					onClick={() => {
						editor.setStyleForSelectedShapes(DefaultColorStyle, 'green')
					}}
				>
					<TldrawUiButtonLabel>Green</TldrawUiButtonLabel>
				</TldrawUiButton>
			</div>
			<DefaultStylePanelContent />
		</DefaultStylePanel>
	)
}
//[11]
function CustomToolbar() {
	const editor = useEditor()
	const tools = useTools()
	const isScreenshotSelected = useIsToolSelected(tools['rhombus-2'])
	return (
		<div>
			<DefaultToolbar>
				<TldrawUiMenuItem {...tools['rhombus-2']} isSelected={isScreenshotSelected} />

				<DefaultToolbarContent />
				<TldrawUiButton
					type="icon"
					onClick={() => {
						editor.selectAll().deleteShapes(editor.getSelectedShapeIds())
					}}
					title="delete all"
				>
					🧨
				</TldrawUiButton>
			</DefaultToolbar>
		</div>
	)
}
//[12]
function CustomZoomMenu() {
	return (
		<DefaultZoomMenu>
			<div style={{ backgroundColor: 'thistle' }}>
				<TldrawUiMenuGroup id="example">
					<TldrawUiMenuItem
						id="like"
						label="Like my posts"
						icon="external-link"
						readonlyOk
						onSelect={() => {
							window.open('https://x.com/tldraw', '_blank')
						}}
					/>
				</TldrawUiMenuGroup>
			</div>
			<DefaultZoomMenuContent />
		</DefaultZoomMenu>
	)
}
const components: TLComponents = {
	ActionsMenu: CustomActionsMenu,
	ContextMenu: CustomContextMenu,
	DebugMenu: CustomDebugMenu,
	HelpMenu: CustomHelpMenu,
	KeyboardShortcutsDialog: CustomKeyboardShortcutsDialog,
	MainMenu: CustomMainMenu,
	NavigationPanel: CustomNavigationPanel,
	PageMenu: CustomPageMenu,
	QuickActions: CustomQuickActions,
	StylePanel: CustomStylePanel,
	Toolbar: CustomToolbar,
	ZoomMenu: CustomZoomMenu,
}

export default function CustomActionsMenuExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/*
You can use the `components` prop to override tldraw's default menus.
You can provide a React component of your own, import our default
component and edit it, or return null to hide it completely. This
example demonstrates how to do this with every menu in tldraw.

[1]
	The actions menu is a dropdown menu that can be found in the
	top-left of the tldraw component, or just above the toolbar on
	smaller screens. It contains actions related to editing shapes
	such as grouping, rotating or changing shape order.

[2]
	Create some shapes, select them and right click the selection to
	see the custom context menu.

[3]
	The debug menu contains helpful menu items for debugging the tldraw
	component. To show the debug menu, turn on debug mode in the
	preferences.
[4]
	The help menu contains menu items to change the language of the
	application, and to open the keyboard shortcuts dialog.


[5]
	The keyboard shortcuts dialog is a modal that shows all the
	keyboard shortcuts available in tldraw. You can open it via the help
	menu.

[6]
	The main menu contains important submenus: Edit, Shape, Preferences etc.
	To open the main menu, click the hamburger icon in the top left corner
	of the tldraw component.

[7]
	The navigation panel is in the bottom left of the tldraw component at
	larger breakpoints. It contains zoom controls and a mini map.

[8]
	The page menu contains options for creating and editing pages. To open
	the page menu, click the page name in the top left of the tldraw component.

[9]
	The quick actions menu is a dropdown menu that appears in the Main Menu,
	or above the toolbar on smaller screens.

[10]
	The style panel is a panel that appears on the right side of the tldraw
	component. It contains options to change the style of shapes, such as
	color, stroke width, and opacity.

[11]
	The toolbar contains tools to create shapes, select shapes, and more.

[12]
	The zoom menu is in the bottom left of the tldraw component, the button
	to open it is labeled with a percentage indicating the editor's current
	zoom level.

 */
```

--------

# Format rich text on multiple shapes

Category: UI & theming

Keywords: rich text, format, tiptap, multiple

Add a toggle button to the style panel that allows you to make all text bold (or remove bold) from multiple selected shapes at once.

This example demonstrates how to work with rich text formatting programmatically so that you can apply formatting changes to multiple shapes simultaneously.

Rich text in tldraw uses TipTap's document structure. Text nodes can have `marks` array that contains formatting information like `{ type: 'bold' }`. The example includes helper functions to:

- `makeAllTextBold()`: Recursively traverses the rich text document and adds bold marks to all text nodes
- `removeBoldFromAllText()`: Recursively removes bold marks from all text nodes
- `isAllTextBold()`: Checks if all text nodes in a rich text document have bold marks

## App.tsx

```tsx
import {
	DefaultStylePanel,
	DefaultStylePanelContent,
	ExtractShapeByProps,
	TLComponents,
	TLRichText,
	TLShape,
	TLUiStylePanelProps,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonIcon,
	TldrawUiButtonLabel,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'

type ShapeWithRichText = ExtractShapeByProps<{ richText: TLRichText }>

function isShapeWithRichText(shape: TLShape | null | undefined): shape is ShapeWithRichText {
	return !!(shape && 'richText' in shape.props)
}

/**
 * Recursively processes rich text content to make all text nodes bold.
 * Preserves the structure of the document while adding bold marks to all text.
 */
function makeAllTextBold(richText: TLRichText): TLRichText {
	if (!richText || !richText.content) {
		return richText
	}

	const processNode = (node: any): any => {
		if (node.type === 'text') {
			// Check if bold mark already exists
			const hasBold = node.marks?.some((mark: any) => mark.type === 'bold')
			if (hasBold) {
				return node
			}
			// Add bold mark to text node
			return {
				...node,
				marks: [...(node.marks || []), { type: 'bold' }],
			}
		}

		if (node.content && Array.isArray(node.content)) {
			// Recursively process child nodes
			return {
				...node,
				content: node.content.map(processNode),
			}
		}

		return node
	}

	return {
		...richText,
		content: richText.content.map(processNode),
	}
}

/**
 * Recursively checks if all text nodes in rich text have bold marks.
 */
function isAllTextBold(richText: TLRichText): boolean {
	if (!richText || !richText.content) {
		return false
	}

	const checkNode = (node: any): boolean => {
		if (node.type === 'text') {
			// If it's a text node, check if it has a bold mark
			const hasBold = node.marks?.some((mark: any) => mark.type === 'bold')
			return hasBold
		}

		if (node.content && Array.isArray(node.content)) {
			// Recursively check child nodes
			return node.content.every(checkNode)
		}

		// Non-text nodes without content are considered "bold" (they don't need bold)
		return true
	}

	return richText.content.every(checkNode)
}

/**
 * Removes bold marks from all text nodes in rich text.
 */
function removeBoldFromAllText(richText: TLRichText): TLRichText {
	if (!richText || !richText.content) {
		return richText
	}

	const processNode = (node: any): any => {
		if (node.type === 'text') {
			// Remove bold marks from text node
			const marks = node.marks?.filter((mark: any) => mark.type !== 'bold') || []
			return {
				...node,
				marks: marks.length > 0 ? marks : undefined,
			}
		}

		if (node.content && Array.isArray(node.content)) {
			// Recursively process child nodes
			return {
				...node,
				content: node.content.map(processNode),
			}
		}

		return node
	}

	return {
		...richText,
		content: richText.content.map(processNode),
	}
}

function CustomStylePanel(props: TLUiStylePanelProps) {
	const editor = useEditor()

	// Get currently selected shapes
	const selectedShapes = useValue('selected shapes', () => editor.getSelectedShapes(), [editor])

	// Filter to only shapes with rich text
	const shapesWithRichText = selectedShapes.filter(isShapeWithRichText)
	const hasRichTextSelection = shapesWithRichText.length > 0

	// Check if all selected shapes with rich text have all their text bold
	const allBold = useValue(
		'all bold',
		() => {
			if (shapesWithRichText.length === 0) return false
			return shapesWithRichText.every((shape) => {
				const richText = shape.props.richText
				return richText && isAllTextBold(richText)
			})
		},
		[shapesWithRichText]
	)

	const handleToggleBold = () => {
		if (!hasRichTextSelection) return

		editor.run(() => {
			shapesWithRichText.forEach((shape) => {
				const richText = shape.props.richText
				if (!richText) return

				const newRichText = allBold ? removeBoldFromAllText(richText) : makeAllTextBold(richText)

				editor.updateShape({
					id: shape.id,
					type: shape.type,
					props: { richText: newRichText },
				})
			})
		})
	}

	return (
		<DefaultStylePanel {...props}>
			<div className="tlui-style-panel__section">
				<TldrawUiButton
					type="menu"
					data-isactive={allBold}
					onClick={handleToggleBold}
					title="Bold all text in selected shapes"
					disabled={!hasRichTextSelection}
				>
					<TldrawUiButtonIcon icon="bold" />
					<TldrawUiButtonLabel>Bold All Text</TldrawUiButtonLabel>
				</TldrawUiButton>
			</div>
			<DefaultStylePanelContent />
		</DefaultStylePanel>
	)
}

const components: TLComponents = {
	StylePanel: CustomStylePanel,
}

export default function RichTextFormatOnMultipleShapesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}
```

--------

# Hide UI components

Category: UI & theming

Keywords: hide, ui, overrides

Hide individual UI components.

UI components can be hidden by providing `null` as their value within `components`. In this example, all configurable UI components are hidden.

## App.tsx

```tsx
import { TLUiComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// The type here is include only to ensure this example contains all possible ui components,
const components: Required<TLUiComponents> = {
	ContextMenu: null,
	ActionsMenu: null,
	HelpMenu: null,
	ZoomMenu: null,
	MainMenu: null,
	Minimap: null,
	StylePanel: null,
	PageMenu: null,
	NavigationPanel: null,
	Toolbar: null,
	KeyboardShortcutsDialog: null,
	QuickActions: null,
	HelperButtons: null,
	DebugPanel: null,
	DebugMenu: null,
	SharePanel: null,
	MenuPanel: null,
	TopPanel: null,
	CursorChatBubble: null,
	RichTextToolbar: null,
	ImageToolbar: null,
	VideoToolbar: null,
	Dialogs: null,
	Toasts: null,
	A11y: null,
	FollowingIndicator: null,
}

export default function UiComponentsHiddenExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}
```

--------

# Menu system hover

Category: UI & theming

Keywords: menu, hover, dropdown, programmatic, control

Programmatically control dropdown menus via hover interactions using the editor's menu tracking API.

This example demonstrates how to open and close menus programmatically using the `editor.menus` API. Instead of relying solely on click triggers, you can control menu state in response to any UI event—in this case, hovering over specific zones.

The key APIs used are:

- `editor.menus.addOpenMenu(id)` - Register a menu as open
- `editor.menus.deleteOpenMenu(id)` - Close a specific menu
- `useMenuIsOpen(id)` - Subscribe to menu state reactively

This pattern is useful for building custom toolbars, navigation systems, or any UI where menus should respond to external events rather than just their own triggers.

## App.tsx

```tsx
import {
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonLabel,
	TldrawUiDropdownMenuContent,
	TldrawUiDropdownMenuItem,
	TldrawUiDropdownMenuRoot,
	TldrawUiDropdownMenuTrigger,
	useEditor,
	useMenuIsOpen,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './menu-system-hover.css'

// [1]
function HoverControlledMenu() {
	const editor = useEditor()
	const [isOpen] = useMenuIsOpen('hover-menu')

	return (
		<div className="hover-menu-container">
			{/* [2] */}
			<div
				className="hover-zone hover-zone-open"
				onMouseEnter={() => editor.menus.addOpenMenu('hover-menu')}
			>
				Hover to open menu
			</div>

			{/* [3] */}
			<div
				className="hover-zone hover-zone-close"
				onMouseEnter={() => editor.menus.deleteOpenMenu('hover-menu')}
			>
				Hover to close menu
			</div>

			{/* [4] */}
			<TldrawUiDropdownMenuRoot id="hover-menu">
				<TldrawUiDropdownMenuTrigger>
					<TldrawUiButton type="normal">
						<TldrawUiButtonLabel>Menu {isOpen ? '(open)' : '(closed)'}</TldrawUiButtonLabel>
					</TldrawUiButton>
				</TldrawUiDropdownMenuTrigger>
				<TldrawUiDropdownMenuContent>
					<TldrawUiDropdownMenuItem>
						<TldrawUiButton type="menu">
							<TldrawUiButtonLabel>Menu item 1</TldrawUiButtonLabel>
						</TldrawUiButton>
					</TldrawUiDropdownMenuItem>
					<TldrawUiDropdownMenuItem>
						<TldrawUiButton type="menu">
							<TldrawUiButtonLabel>Menu item 2</TldrawUiButtonLabel>
						</TldrawUiButton>
					</TldrawUiDropdownMenuItem>
					<TldrawUiDropdownMenuItem>
						<TldrawUiButton type="menu">
							<TldrawUiButtonLabel>Menu item 3</TldrawUiButtonLabel>
						</TldrawUiButton>
					</TldrawUiDropdownMenuItem>
				</TldrawUiDropdownMenuContent>
			</TldrawUiDropdownMenuRoot>
		</div>
	)
}

export default function MenuSystemHoverExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				components={{
					InFrontOfTheCanvas: HoverControlledMenu,
				}}
			/>
		</div>
	)
}

/*
This example shows how to programmatically control menus using hover events.

[1]
The HoverControlledMenu component uses useMenuIsOpen to track the current state
of our menu. The hook returns a tuple where the first element is a boolean
indicating whether the menu is open.

[2]
The first hover zone calls editor.menus.addOpenMenu('hover-menu') on mouse enter.
This registers the menu as open in the global menu tracking system. The
TldrawUiDropdownMenuRoot will automatically respond to this state change.

[3]
The second hover zone calls editor.menus.deleteOpenMenu('hover-menu') on mouse
enter, which closes the menu.

[4]
The TldrawUiDropdownMenuRoot is linked to our menu ID ('hover-menu'). It
automatically syncs with the menu tracking system, so when we call addOpenMenu
or deleteOpenMenu, the dropdown responds accordingly. You can also click the
trigger button to toggle the menu normally.
*/
```

## menu-system-hover.css

```css
.hover-menu-container {
	position: absolute;
	top: 100px;
	left: 0;
	display: flex;
	flex-direction: column;
	gap: var(--tl-space-3);
	padding: var(--tl-space-3);
	z-index: var(--tl-layer-panels);
}

.hover-zone {
	padding: var(--tl-space-3) var(--tl-space-5);
	border-radius: var(--tl-radius-2);
	font-size: 13px;
	font-weight: 500;
	cursor: default;
	user-select: none;
	transition: opacity 0.15s ease;
	background-color: var(--tl-color-low);
	pointer-events: auto;
}

.hover-zone:hover {
	opacity: 0.8;
}

.hover-zone-open {
	color: var(--tl-color-success);
}

.hover-zone-close {
	color: var(--tl-color-danger);
}
```

--------

# Screen reader accessibility

Category: UI & theming

Keywords: accessibility, a11y, screen reader, aria

Implement accessible custom shapes and custom screen reader announcements.

This example demonstrates two key aspects of screen reader accessibility in tldraw:

## Custom shapes with screen reader descriptions

When shapes are selected, the announcement system uses the `getAriaDescriptor()` and `getText()` methods from ShapeUtil to generate appropriate accessibility announcements.

- **`getAriaDescriptor()`** - Returns alt-text-style descriptions for accessibility announcements. When a shape is selected, this description is announced to screen reader users. It returns a combined announcement like "Meeting Notes - Discussed Q4 planning" that describes the card's purpose and content.

- **`getText()`** - Returns visible text content from shapes (for text extraction and search). This is used for text extraction, search functionality, and as a fallback for accessibility if `getAriaDescriptor()` is not provided.

## Custom screen reader announcements

The example also demonstrates how to use the `useA11y()` hook to create custom screen reader announcements for your UI components. Screen readers use ARIA live regions to announce dynamic content changes to users.

The example shows three common use cases:

- **Polite announcements**: Use `priority: 'polite'` for informational messages that don't require immediate attention (e.g., "Action completed for 2 shapes"). These announcements wait for the screen reader to finish its current announcement.

- **Assertive announcements**: Use `priority: 'assertive'` for important messages that need immediate attention (e.g., validation errors). These announcements interrupt the current screen reader output.

- **State change announcements**: Announce state changes to keep users informed of the current application state.

The announcements are rendered in an off-screen ARIA live region by the `DefaultA11yAnnouncer` component, making them accessible to screen readers without cluttering the visual interface.

## App.tsx

```tsx
import { useState } from 'react'
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	RecordProps,
	T,
	Tldraw,
	TldrawUiButton,
	TLShape,
	useA11y,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './screen-reader-accessibility.css'

const CARD_SHAPE_TYPE = 'note-card'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[CARD_SHAPE_TYPE]: { w: number; h: number; title: string; description: string }
	}
}

type CardShape = TLShape<typeof CARD_SHAPE_TYPE>

export class CardShapeUtil extends BaseBoxShapeUtil<CardShape> {
	static override type = CARD_SHAPE_TYPE
	static override props: RecordProps<CardShape> = {
		w: T.number,
		h: T.number,
		title: T.string,
		description: T.string,
	}

	getDefaultProps(): CardShape['props'] {
		return {
			w: 300,
			h: 180,
			title: 'Untitled',
			description: '',
		}
	}

	// [1]
	override getAriaDescriptor(shape: CardShape): string | undefined {
		const { title, description } = shape.props
		if (description) {
			return `${title} - ${description}`
		}
		return title
	}

	// [2]
	override getText(shape: CardShape): string | undefined {
		return `${shape.props.title}\n${shape.props.description}`
	}

	component(shape: CardShape) {
		const { title, description } = shape.props

		return (
			<HTMLContainer className="card-shape">
				<div className="card-shape-title">{title}</div>
				{description && <div className="card-shape-description">{description}</div>}
			</HTMLContainer>
		)
	}

	indicator(shape: CardShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

const customShapes = [CardShapeUtil]

function CustomAnnouncementPanel() {
	const editor = useEditor()
	// [3]
	const a11y = useA11y()
	const [isEnabled, setIsEnabled] = useState(false)

	// [4]
	const handleActionConfirmation = () => {
		const selectedShapes = editor.getSelectedShapes()
		if (selectedShapes.length > 0) {
			// Simulate an action being performed
			a11y.announce({
				msg: `Action completed for ${selectedShapes.length} shape${selectedShapes.length === 1 ? '' : 's'}`,
				priority: 'polite',
			})
		} else {
			a11y.announce({
				msg: 'No shapes selected',
				priority: 'polite',
			})
		}
	}

	// [5]
	const handleValidation = () => {
		const selectedShapes = editor.getSelectedShapes()
		if (selectedShapes.length === 0) {
			a11y.announce({
				msg: 'Validation failed: No shapes selected',
				priority: 'assertive',
			})
		} else {
			const hasText = selectedShapes.some((shape) => {
				const util = editor.getShapeUtil(shape)
				return util.getText(shape)
			})
			if (!hasText) {
				a11y.announce({
					msg: 'Validation failed: Selected shapes must contain text',
					priority: 'assertive',
				})
			} else {
				a11y.announce({
					msg: 'Validation passed',
					priority: 'polite',
				})
			}
		}
	}

	// [6]
	const handleToggle = () => {
		const newState = !isEnabled
		setIsEnabled(newState)
		a11y.announce({
			msg: `Feature ${newState ? 'enabled' : 'disabled'}`,
			priority: 'polite',
		})
	}

	return (
		<div className="tlui-menu announcement-panel">
			<TldrawUiButton type="normal" onClick={handleActionConfirmation}>
				Perform action
			</TldrawUiButton>
			<TldrawUiButton type="normal" onClick={handleValidation}>
				Validate selection
			</TldrawUiButton>
			<TldrawUiButton type="normal" onClick={handleToggle}>
				{isEnabled ? 'Disable' : 'Enable'} feature
			</TldrawUiButton>
		</div>
	)
}

export default function ScreenReaderAccessibilityExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapes}
				components={{
					TopPanel: CustomAnnouncementPanel,
				}}
				onMount={(editor) => {
					// [7]
					editor.createShape({
						type: CARD_SHAPE_TYPE,
						x: 100,
						y: 100,
						props: {
							title: 'Meeting Notes',
							description: 'Discussed Q4 planning and team goals',
						},
					})

					editor.createShape({
						type: CARD_SHAPE_TYPE,
						x: 450,
						y: 100,
						props: {
							title: 'Project Ideas',
							description: 'Brainstorming session for new features',
						},
					})

					editor.createShape({
						type: CARD_SHAPE_TYPE,
						x: 100,
						y: 320,
						props: {
							title: 'Action Items',
							description: 'Follow up with design team by Friday',
						},
					})
				}}
			/>
		</div>
	)
}

/*

Introduction:

This example demonstrates how to create accessible custom shapes and custom screen reader announcements in tldraw.

[1]
The getAriaDescriptor() method provides accessibility-specific descriptions for screen readers.
When a shape is selected, this description is announced to screen reader users.
This is different from getText() - getAriaDescriptor() is specifically
for accessibility announcements, not for text extraction or search.

[2]
The getText() method returns the visible text content of the shape. This is used for text
extraction, search functionality, and as a fallback for accessibility if getAriaDescriptor()
is not provided. It returns the title and description separated by a newline.

[3]
The useA11y() hook provides access to the accessibility manager. It must be called
within a component that's rendered inside the Tldraw component.

[4]
Polite announcements are used for informational messages that don't require immediate
attention. They wait for the screen reader to finish its current announcement before
speaking. This is appropriate for action confirmations and status updates.

[5]
Assertive announcements are used for critical messages that need immediate attention,
such as validation errors. They interrupt the current screen reader output to ensure
the user hears the message right away.

[6]
State change announcements help keep users informed about the current state of the
application. Use polite priority for state changes unless they're critical.

[7]
Create three sample cards with different titles and descriptions. Try selecting different cards
to hear how screen readers announce them using the getAriaDescriptor() method. The announcement
will include the card's custom description followed by the shape type and position information.
You can also use the buttons in the top panel to trigger custom announcements that demonstrate
polite and assertive priority levels.
*/
```

## screen-reader-accessibility.css

```css
.announcement-panel {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	margin: 8px;
}

.card-shape {
	padding: var(--tl-space-5);
	background-color: white;
	border: 1px solid var(--tl-color-low-border);
	border-radius: var(--tl-radius-3);
	display: flex;
	flex-direction: column;
	gap: var(--tl-space-3);
}
```

--------

# Things on the canvas

Category: UI & theming

Keywords: in front of the canvas, scale, zoom, ui

Add custom components to the canvas.

This example shows how to add custom components to the canvas.

Components can either float on top of the canvas unaffected by the camera, or be a part of the canvas itself.

## App.tsx

```tsx
import { useState } from 'react'
import { Tldraw, TLEditorComponents, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
function MyComponent() {
	const [state, setState] = useState(0)
	const editor = useEditor()

	return (
		<>
			<div
				style={{
					position: 'absolute',
					top: 50,
					left: 50,
					width: 200,
					padding: 12,
					borderRadius: 8,
					backgroundColor: 'goldenrod',
					zIndex: 0,
					userSelect: 'unset',
					boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
				}}
				onPointerDown={editor.markEventAsHandled}
			>
				<p>The count is {state}! </p>
				<button onClick={() => setState((s) => s - 1)}>-1</button>
				<p>These components are on the canvas. They will scale with camera zoom like shapes.</p>
			</div>
			<div
				style={{
					position: 'absolute',
					top: 210,
					left: 150,
					width: 200,
					padding: 12,
					borderRadius: 8,
					backgroundColor: 'pink',
					zIndex: 99999999,
					userSelect: 'unset',
					boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
				}}
				onPointerDown={editor.markEventAsHandled}
			>
				<p>The count is {state}! </p>
				<button onClick={() => setState((s) => s + 1)}>+1</button>
				<p>Create and select a shape to see the in front of the canvas component</p>
			</div>
		</>
	)
}

//[2]
const MyComponentInFront = track(() => {
	const editor = useEditor()
	const selectionRotatedPageBounds = editor.getSelectionRotatedPageBounds()
	if (!selectionRotatedPageBounds) return null

	const pageCoordinates = editor.pageToViewport(selectionRotatedPageBounds.point)

	return (
		<div
			style={{
				position: 'absolute',
				top: Math.max(64, pageCoordinates.y - 64),
				left: Math.max(64, pageCoordinates.x),
				borderRadius: 8,
				paddingLeft: 10,
				paddingRight: 10,
				background: '#efefef',
				boxShadow: '0 0 0 1px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)',
			}}
		>
			<p>This won’t scale with zoom.</p>
		</div>
	)
})

// [3]
const components: TLEditorComponents = {
	OnTheCanvas: MyComponent,
	InFrontOfTheCanvas: MyComponentInFront,
}

// [4]
export default function OnTheCanvasExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="things-on-the-canvas-example" components={components} />
		</div>
	)
}

/*
This example shows how you can use the onTheCanvas and inFrontOfTheCanvas components.
onTheCanvas components will behave similarly to shapes, they will scale with the zoom
and move when the page is panned. inFrontOfTheCanvas components don't scale with the
zoom, but still move when the page is panned.

For another example that shows how to customize components, check out the custom
components example.

To have a component that ignores the camera entirely, you should check out the custom
UI example.


[1]
This is our onTheCanvas component. We also stop event propagation on the pointer events
so that we don't accidentally select shapes when interacting with the component.

[2]
This is our inFrontOfTheCanvas component. We want to render this next to a selected shape,
so we need to make sure it's reactive to changes in the editor. We use the track function
to make sure the component is re-rendered whenever the selection changes. Check out the
signals example for more info: https://tldraw.dev/examples/signals

Using the editor instance we can get the bounds of the selection box and convert them to
screen coordinates. We then render the component at those coordinates.


[3]
This is where we define the object that will be passed to the Tldraw component prop.

[4]
This is where we render the Tldraw component. Let's pass the components object to the
components prop.

*/
```

--------

# Toasts and dialogs

Category: UI & theming

Keywords: ui, components, dialogs, toasts

Add, remove and clear toasts and dialogs in your app using the `useToasts` and `useDialogs` hooks.

To control toasts and dialogs your app, you can use the `useToasts` and `useDialogs` hooks.
These hooks give you access to functions which allow you to add, remove and clear toasts
and dialogs.

Dialogs are especially customisable, allowing you to pass in a custom component to render
as the dialog content. Alternatively, you can use the `ExampleDialog` component which is
provided by the library.

## App.tsx

```tsx
import {
	TLComponents,
	Tldraw,
	TldrawUiButton,
	TldrawUiButtonLabel,
	TldrawUiDialogBody,
	TldrawUiDialogCloseButton,
	TldrawUiDialogFooter,
	TldrawUiDialogHeader,
	TldrawUiDialogTitle,
	useDialogs,
	useToasts,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file

// [1]
function MyDialog({ onClose }: { onClose(): void }) {
	return (
		<>
			<TldrawUiDialogHeader>
				<TldrawUiDialogTitle>Title</TldrawUiDialogTitle>
				<TldrawUiDialogCloseButton />
			</TldrawUiDialogHeader>
			<TldrawUiDialogBody style={{ maxWidth: 350 }}>Description...</TldrawUiDialogBody>
			<TldrawUiDialogFooter className="tlui-dialog__footer__actions">
				<TldrawUiButton type="normal" onClick={onClose}>
					<TldrawUiButtonLabel>Cancel</TldrawUiButtonLabel>
				</TldrawUiButton>
				<TldrawUiButton type="primary" onClick={onClose}>
					<TldrawUiButtonLabel>Continue</TldrawUiButtonLabel>
				</TldrawUiButton>
			</TldrawUiDialogFooter>
		</>
	)
}

// [2]
function MySimpleDialog({ onClose }: { onClose(): void }) {
	return (
		<div style={{ padding: 16 }}>
			<h2>Title</h2>
			<p>Description...</p>
			<button onClick={onClose}>Okay</button>
		</div>
	)
}

const CustomSharePanel = () => {
	const { addToast } = useToasts()
	const { addDialog } = useDialogs()

	return (
		<div style={{ padding: 16, gap: 16, display: 'flex', pointerEvents: 'all' }}>
			<button
				onClick={() => {
					addToast({ title: 'Hello world!', severity: 'success' })
				}}
			>
				Show toast
			</button>
			<button
				onClick={() => {
					addDialog({
						component: MyDialog,
						onClose() {
							// You can do something after the dialog is closed
							void null
						},
					})
				}}
			>
				Show dialog
			</button>
			<button
				onClick={() => {
					addDialog({
						component: MySimpleDialog,
						onClose() {
							// You can do something after the dialog is closed
							void null
						},
					})
				}}
			>
				Show simple dialog
			</button>
		</div>
	)
}

const components: TLComponents = {
	SharePanel: CustomSharePanel,
}

export default function ToastsDialogsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} persistenceKey="example" />
		</div>
	)
}

/*

To control toasts and dialogs your app, you can use the `useToasts` and `useDialogs` hooks.
These hooks give you access to functions which allow you to add, remove and clear toasts
and dialogs.

Dialogs are especially customisable, allowing you to pass in a custom component to render
as the dialog content. Alternatively, you can use the `ExampleDialog` component which is
provided by the library.

[1]
The tldraw library provides a set of components that you can use to build your dialogs.
The `onClose` function passed to the dialog component runs when the dialog closes or
is dismissed, but you can also call it from buttons to close the dialog.

[2]
...or you can build your own dialog component!
*/
```

--------

# UI zones

Category: UI & theming

Keywords: top zone, share zone

Inject custom components into tldraw's empty areas.

Our default UI has two empty areas that you can fill - the `TopPanel` (in the top-center of the screen) and `SharePanel` (in the top right).

You can set these zones to any React component you want.

## App.tsx

```tsx
import { TLComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const components: TLComponents = {
	SharePanel: CustomShareZone,
	TopPanel: CustomTopZone,
}

// [1]
export default function Example() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

// [2]
function CustomTopZone() {
	return (
		<div
			style={{
				backgroundColor: 'thistle',
				width: '100%',
				textAlign: 'center',
				padding: '2px',
				minWidth: '80px',
			}}
		>
			<p>Top Zone</p>
		</div>
	)
}

// [3]
function CustomShareZone() {
	return (
		<div
			style={{
				backgroundColor: 'thistle',
				width: '100%',
				textAlign: 'center',
				minWidth: '80px',
			}}
		>
			<p>Share Zone</p>
		</div>
	)
}

/*
This example shows how to pass in a custom component to the share panel and top panel.
The share panel is in the top right corner above the style menu, the top panel is in
the top center.

[1]
We pass in our custom components to the Tldraw topZone and shareZone props.

[2]
This is the component that will be rendered in the top zone.

[3]
This is the component that will be rendered in the share zone.
*/
```

--------

# Hide the entire UI

Category: UI & theming

Keywords:

Hide tldraw's UI with the `hideUi` prop.

Hide tldraw's UI with the `hideUi` prop.

This can be useful if you want a bare-bones editor, or if you want to build your own UI.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function HideUiExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="hide-ui-example" hideUi />
		</div>
	)
}

/*
This example shows how to hide the UI of the editor. Simply pass the hideUi prop
to the Tldraw component. This is useful if you want to build your own UI around
the editor. See the custom ui example if you need help building your own UI.
*/
```

--------

# Replace the entire UI

Category: UI & theming

Keywords: hide, ui, event listener

Replace tldraw's UI with your own.

If you want, you can replace tldraw's entire UI and start your own from scratch.

This example shows how you might begin doing that, with keyboard shortcuts and buttons for selecting tools.

## App.tsx

```tsx
import { useEffect } from 'react'
import { Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './custom-ui.css'

// There's a guide at the bottom of this file!

// [1]
export default function CustomUiExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw hideUi>
				<CustomUi />
			</Tldraw>
		</div>
	)
}

// [2]
const CustomUi = track(() => {
	const editor = useEditor()

	useEffect(() => {
		const handleKeyUp = (e: KeyboardEvent) => {
			switch (e.key) {
				case 'Delete':
				case 'Backspace': {
					editor.deleteShapes(editor.getSelectedShapeIds())
					break
				}
				case 'v': {
					editor.setCurrentTool('select')
					break
				}
				case 'e': {
					editor.setCurrentTool('eraser')
					break
				}
				case 'x':
				case 'p':
				case 'b':
				case 'd': {
					editor.setCurrentTool('draw')
					break
				}
			}
		}

		window.addEventListener('keyup', handleKeyUp)
		return () => {
			window.removeEventListener('keyup', handleKeyUp)
		}
	})

	return (
		<div className="custom-layout">
			<div className="custom-toolbar">
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'select'}
					onClick={() => editor.setCurrentTool('select')}
				>
					Select
				</button>
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'draw'}
					onClick={() => editor.setCurrentTool('draw')}
				>
					Pencil
				</button>
				<button
					className="custom-button"
					data-isactive={editor.getCurrentToolId() === 'eraser'}
					onClick={() => editor.setCurrentTool('eraser')}
				>
					Eraser
				</button>
			</div>
		</div>
	)
})

/*
This example shows how to create your own custom ui for the editor.

[1]
We render the Tldraw component with the `hideUi` prop. This will hide the default
toolbar, style menu and pages menu. We also render our custom ui component inside the
Tldraw component. This gives us access to the editor instance via React context.

The context menu isn't hidden by the `hideUi` prop, if you want to hide it you can
render the parts that make up the Tldraw component separately and omit the context
menu. Check out the exploded example to see how to do this.

[2]
We use the `track` function to wrap our component. This makes our component reactive- it will
re-render when the signals it is tracking change. Check out the signals example for more info:
https://tldraw.dev/examples/signals

We gain access to the editor instance via the `useEditor` hook. We use the `useEffect` hook
to add event listeners for keyboard shortcuts. We use editor methods to change the current
tool and delete shapes.

*/
```

## custom-ui.css

```css
.custom-layout {
	position: absolute;
	inset: 0px;
	z-index: 300;
	pointer-events: none;
}

.custom-toolbar {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.custom-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 64px;
}

.custom-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

--------

# Contextual toolbar

Category: UI & theming

Keywords: in front of the canvas, contextual

Show a contextual toolbar above shapes when they are selected.

This is an example of how to show a contextual toolbar which appears on top of the selected shapes. It is displayed above the canvas, but below other UI elements.

Select shapes of different types and adjust the size of the shapes - this works just like adjusting the size from the Style panel on the right side.

## App.tsx

```tsx
import {
	Box,
	DefaultSizeStyle,
	Tldraw,
	TldrawUiButtonIcon,
	TldrawUiContextualToolbar,
	TldrawUiToolbarButton,
	TLEditorComponents,
	TLEditorSnapshot,
	track,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import _jsonSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

const jsonSnapshot = _jsonSnapshot as any as TLEditorSnapshot

const SIZES = [
	{ value: 's', icon: 'size-small' },
	{ value: 'm', icon: 'size-medium' },
	{ value: 'l', icon: 'size-large' },
	{ value: 'xl', icon: 'size-extra-large' },
] as const

// [1]
const ContextualToolbarComponent = track(() => {
	const editor = useEditor()
	const showToolbar = editor.isIn('select.idle')

	// [2]
	const size = editor.getSharedStyles().get(DefaultSizeStyle)
	if (!size || !showToolbar) return null
	const currentSize = size.type === 'shared' ? size.value : undefined

	// [3]
	const getSelectionBounds = () => {
		const fullBounds = editor.getSelectionRotatedScreenBounds()
		if (!fullBounds) return undefined
		return new Box(fullBounds.x, fullBounds.y, fullBounds.width, 0)
	}

	return (
		<TldrawUiContextualToolbar getSelectionBounds={getSelectionBounds} label="Sizes">
			{SIZES.map(({ value, icon }) => {
				return (
					<TldrawUiToolbarButton
						key={value}
						title={value.toUpperCase()}
						type="icon"
						isActive={value === currentSize}
						onClick={() => editor.setStyleForSelectedShapes(DefaultSizeStyle, value)}
					>
						<TldrawUiButtonIcon small icon={icon} />
					</TldrawUiToolbarButton>
				)
			})}
		</TldrawUiContextualToolbar>
	)
})

const components: TLEditorComponents = {
	InFrontOfTheCanvas: ContextualToolbarComponent,
}

export default function ContextualToolbar() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} snapshot={jsonSnapshot} />
		</div>
	)
}

/*
This example shows how you can use our contextual toolbar primitive that can show up when you
select a shape. It's using the `InFrontOfTheCanvas` component to render the toolbar. This allows us to render
the toolbar on top of the shapes, but behind the existing UI.
[1]
This is our context toolbar. It's positioned absolutely on top of the selected shapes.
[2]
Different shapes support different style properties and this is how we get the styles that are
supported by all selected shapes. If none of the selected shapes supported the `DefaultSizeStyle`
we wouldn't show the toolbar at all.
We also get the current value of the size property. If all the shapes have the same size then the
type of the size property is `shared`. This will allow us to show the currently selected size in the
toolbar. If the shapes have different sizes then the type of the size property is `mixed` and none
of the sizes will be highlighted.
[3]
We pass in getSelectionBounds so that the toolbar knows where to position itself. You can use the
selection bounds of the current shapes or some other logic.
*/
```

--------

# Custom canvas components

Category: UI & theming

Keywords: custom, Background, SvgDefs, Brush, ZoomBrush, ShapeIndicator, Cursor, Canvas, CollaboratorBrush, CollaboratorCursor, CollaboratorHint, CollaboratorShapeIndicator, Grid, Scribble, CollaboratorScribble, SnapIndicator, Handles, Handle, Spinner, SelectionForeground, SelectionBackground, OnTheCanvas, InFrontOfTheCanvas, LoadingScreen

Replace tldraw's on-canvas UI with your own.

tldraw's on-canvas UI is built from replaceable React components.

This example shows how to replace these default components with your own. Try dragging to select or using the eraser tool to see the custom components in this example.

## App.tsx

```tsx
import { useRef } from 'react'
import { Tldraw, TLEditorComponents, toDomPrecision, useTransform } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const components: TLEditorComponents = {
	Brush: function MyBrush({ brush }) {
		const rSvg = useRef<SVGSVGElement>(null)

		useTransform(rSvg, brush.x, brush.y)

		const w = toDomPrecision(Math.max(1, brush.w))
		const h = toDomPrecision(Math.max(1, brush.h))

		return (
			<svg ref={rSvg} className="tl-overlays__item">
				<rect className="tl-brush" stroke="red" fill="none" width={w} height={h} />
			</svg>
		)
	},
	Scribble: ({ scribble, opacity, color }) => {
		return (
			<svg className="tl-overlays__item">
				<polyline
					points={scribble.points.map((p) => `${p.x},${p.y}`).join(' ')}
					stroke={color ?? 'black'}
					opacity={opacity ?? '1'}
					fill="none"
				/>
			</svg>
		)
	},
	SnapIndicator: null,
}

export default function CustomComponentsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="custom-components-example" components={components} />
		</div>
	)
}

/*
This example shows how to change the default components that tldraw uses on the canvas via the `components` prop.
Components include things like the background, the grid, handles, spinners etc. In this case we change the box
that appears when drag-selecting shapes, and the scribble left behind when using the eraser and laser pointer.

*/
```

--------

# Custom grid

Category: UI & theming

Keywords: grid, background, ui, layout

Draw a custom grid on the canvas.

This example shows how to draw a custom grid on the canvas. It uses a 2d canvas context to draw major and minor grid lines.

## App.tsx

```tsx
import { useLayoutEffect, useRef } from 'react'
import { TLComponents, Tldraw, approximately, useEditor, useIsDarkMode, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

/**
 * There's a guide at the bottom of this file!
 */

const components: TLComponents = {
	// [1]
	Grid: ({ size, ...camera }) => {
		const editor = useEditor()

		// [2]
		const screenBounds = useValue('screenBounds', () => editor.getViewportScreenBounds(), [])
		const devicePixelRatio = useValue('dpr', () => editor.getInstanceState().devicePixelRatio, [])
		const isDarkMode = useIsDarkMode()

		const canvas = useRef<HTMLCanvasElement>(null)

		useLayoutEffect(() => {
			if (!canvas.current) return
			// [3]
			const canvasW = screenBounds.w * devicePixelRatio
			const canvasH = screenBounds.h * devicePixelRatio
			canvas.current.width = canvasW
			canvas.current.height = canvasH

			const ctx = canvas.current?.getContext('2d')
			if (!ctx) return

			// [4]
			ctx.clearRect(0, 0, canvasW, canvasH)

			// [5]
			const pageViewportBounds = editor.getViewportPageBounds()

			const startPageX = Math.ceil(pageViewportBounds.minX / size) * size
			const startPageY = Math.ceil(pageViewportBounds.minY / size) * size
			const endPageX = Math.floor(pageViewportBounds.maxX / size) * size
			const endPageY = Math.floor(pageViewportBounds.maxY / size) * size
			const numRows = Math.round((endPageY - startPageY) / size)
			const numCols = Math.round((endPageX - startPageX) / size)

			ctx.strokeStyle = isDarkMode ? '#555' : '#BBB'

			// [6]
			for (let row = 0; row <= numRows; row++) {
				const pageY = startPageY + row * size
				// convert the page-space Y offset into our canvas' coordinate space
				const canvasY = (pageY + camera.y) * camera.z * devicePixelRatio
				const isMajorLine = approximately(pageY % (size * 10), 0)
				drawLine(ctx, 0, canvasY, canvasW, canvasY, isMajorLine ? 3 : 1)
			}
			for (let col = 0; col <= numCols; col++) {
				const pageX = startPageX + col * size
				// convert the page-space X offset into our canvas' coordinate space
				const canvasX = (pageX + camera.x) * camera.z * devicePixelRatio
				const isMajorLine = approximately(pageX % (size * 10), 0)
				drawLine(ctx, canvasX, 0, canvasX, canvasH, isMajorLine ? 3 : 1)
			}
		}, [screenBounds, camera, size, devicePixelRatio, editor, isDarkMode])

		// [7]
		return <canvas className="tl-grid" ref={canvas} />
	},
}

export default function CustomGridExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="custom-grid-example"
				components={components}
				onMount={(e) => {
					e.updateInstanceState({ isGridMode: true })
				}}
			/>
		</div>
	)
}

function drawLine(
	ctx: CanvasRenderingContext2D,
	x1: number,
	y1: number,
	x2: number,
	y2: number,
	width: number
) {
	ctx.beginPath()
	ctx.moveTo(x1, y1)
	ctx.lineTo(x2, y2)
	ctx.lineWidth = width
	ctx.stroke()
}

/**
 * This example demonstrates how to draw a custom grid component using a 2d canvas.
 *
 * 1. To add a custom grid you must override this Grid component. It is passed props for the camera position, along with the size of the grid in page space.
 * 2. In addition to updating when the camera moves, we want the grid to rerender if the screen bounds change, or if the devicePixelRatio changes, or if the theme changes.
 * 3. To avoid pixelation we want to render at the device's actual resolution, so we need to set the canvas size in terms of the devicePixelRatio.
 * 4. Start by clearing the canvas and making it transparent.
 * 5. Calculate the start and end offsets for the grid, in page space.
 * 6. Draw the grid lines. We draw major lines every 10 grid units.
 * 7. The 'tl-grid' class is important for correct rendering and interaction handling.
 */
```

--------

# Drag and drop tray

Category: UI & theming

Keywords:

Create a drag and drop tray to create shapes on the canvas.

This example shows how to create a drag and drop tray with items that can be dragged onto the canvas to create shapes.

The tray is positioned as a fixed UI element using the `InFrontOfTheCanvas` component, and includes interactive items that can be dragged to create shapes on the canvas. The interaction can be cancelled by pressing the Escape key.

## App.tsx

```tsx
import { useMemo, useRef } from 'react'
import {
	Box,
	TLEditorComponents,
	Tldraw,
	Vec,
	useAtom,
	useEditor,
	useQuickReactor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './drag-and-drop-tray.css'
import { TRAY_ITEMS, TrayItem } from './trayitems'

// There's a guide at the bottom of this file!

// [1]
type DragState =
	| {
			name: 'idle'
	  }
	| {
			name: 'pointing_item'
			item: TrayItem
			startPosition: Vec
	  }
	| {
			name: 'dragging'
			item: TrayItem
			currentPosition: Vec
	  }

// [2]
const DragAndDropTray = () => {
	const rTrayContainer = useRef<HTMLDivElement>(null)
	const rDraggingImage = useRef<HTMLDivElement>(null)

	const editor = useEditor()

	// [3]
	const dragState = useAtom<DragState>('dragState', () => ({
		name: 'idle',
	}))

	// [4]
	const { handlePointerUp, handlePointerDown } = useMemo(() => {
		let target: HTMLDivElement | null = null

		function handlePointerMove(e: PointerEvent) {
			const current = dragState.get()
			const screenPoint = new Vec(e.clientX, e.clientY)

			switch (current.name) {
				case 'idle': {
					break
				}
				case 'pointing_item': {
					const dist = Vec.Dist(screenPoint, current.startPosition)
					if (dist > 10) {
						// [a]
						dragState.set({
							name: 'dragging',
							item: current.item,
							currentPosition: screenPoint,
						})
					}
					break
				}
				case 'dragging': {
					// [b]
					dragState.set({
						...current,
						currentPosition: screenPoint,
					})
					break
				}
			}
		}

		function handlePointerUp(e: React.PointerEvent) {
			const current = dragState.get()

			target = e.currentTarget as HTMLDivElement
			target.releasePointerCapture(e.pointerId)

			switch (current.name) {
				case 'idle': {
					break
				}
				case 'pointing_item': {
					dragState.set({
						name: 'idle',
					})
					break
				}
				case 'dragging': {
					// [c]
					const screenPoint = new Vec(e.clientX, e.clientY)
					const pagePoint = editor.screenToPage(screenPoint)

					editor.markHistoryStoppingPoint('create shape from tray')

					editor.createShape({
						...current.item.shapeBase,
						x: pagePoint.x - 50, // center on cursor at 100x100
						y: pagePoint.y - 50,
					})

					dragState.set({
						name: 'idle',
					})

					break
				}
			}

			removeEventListeners()
		}

		function handlePointerDown(e: React.PointerEvent) {
			e.preventDefault()
			target = e.currentTarget as HTMLDivElement
			target.setPointerCapture(e.pointerId)

			const itemIndex = target.dataset.drag_item_index!
			const item = TRAY_ITEMS[+itemIndex]

			if (!item) return

			const startPosition = new Vec(e.clientX, e.clientY)

			// [d]
			dragState.set({
				name: 'pointing_item',
				item,
				startPosition,
			})

			target.addEventListener('pointermove', handlePointerMove)
			document.addEventListener('keydown', handleKeyDown)
		}

		function handleKeyDown(e: KeyboardEvent) {
			const current = dragState.get()
			if (e.key === 'Escape' && current.name === 'dragging') {
				removeEventListeners()
			}
		}

		function removeEventListeners() {
			if (target) {
				target.removeEventListener('pointermove', handlePointerMove)
				document.removeEventListener('keydown', handleKeyDown)
			}

			dragState.set({
				name: 'idle',
			})
		}

		return {
			handlePointerDown,
			handlePointerUp,
		}
	}, [dragState, editor])

	const state = useValue('dragState', () => dragState.get(), [dragState])

	// [5]
	useQuickReactor(
		'drag-image-style',
		() => {
			const current = dragState.get()
			const imageRef = rDraggingImage.current
			const trayContainerRef = rTrayContainer.current
			if (!imageRef || !trayContainerRef) return

			switch (current.name) {
				case 'idle':
				case 'pointing_item': {
					imageRef.style.display = 'none'
					break
				}
				case 'dragging': {
					const trayContainerRect = trayContainerRef.getBoundingClientRect()
					const box = new Box(
						trayContainerRect.x,
						trayContainerRect.y,
						trayContainerRect.width,
						trayContainerRect.height
					)
					const viewportScreenBounds = editor.getViewportScreenBounds()
					const isInside = Box.ContainsPoint(box, current.currentPosition)
					if (isInside) {
						imageRef.style.display = 'none'
					} else {
						imageRef.style.display = 'block'
						imageRef.style.position = 'absolute'
						imageRef.style.pointerEvents = 'none'
						imageRef.style.left = '0px'
						imageRef.style.top = '0px'
						imageRef.style.transform = `translate(${current.currentPosition.x - viewportScreenBounds.x - 25}px, ${current.currentPosition.y - viewportScreenBounds.y - 25}px)`
						imageRef.style.width = '50px'
						imageRef.style.height = '50px'
						imageRef.style.fontSize = '40px'
						imageRef.style.display = 'flex'
						imageRef.style.alignItems = 'center'
					}
				}
			}
		},
		[dragState]
	)

	return (
		<>
			{/* [6] */}
			<div className="drag-tray" ref={rTrayContainer}>
				<div className="drag-tray-items">
					{TRAY_ITEMS.map((item, index) => (
						<div
							key={item.id}
							className="drag-tray-item"
							data-drag_item_index={index}
							onPointerDown={handlePointerDown}
							onPointerUp={handlePointerUp}
						>
							{item.emoji}
						</div>
					))}
				</div>
			</div>
			{/* [7] */}
			<div ref={rDraggingImage}>{state.name === 'dragging' && state.item.emoji}</div>
		</>
	)
}

// [8]
const components: TLEditorComponents = {
	InFrontOfTheCanvas: DragAndDropTray,
}

export default function DragAndDropTrayExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="drag-and-drop-tray-example" components={components} />
		</div>
	)
}

/*
Introduction:

This example demonstrates how to create a drag-and-drop tray component that allows users
to drag items from a custom UI tray and drop them onto the canvas as tldraw shapes. The
example uses a state machine pattern to manage the drag interaction states and creates
a custom UI component that renders in front of the canvas.

[1]
We define a union type `DragState` to represent the different states of our drag interaction:
- `idle`: Nothing is being dragged
- `pointing_item`: User has pressed down on an item but hasn't started dragging yet
- `dragging`: User is actively dragging an item

This state machine pattern helps us handle the complex drag interaction logic cleanly.

[2]
The main `DragAndDropTray` component uses two refs:
- `rTrayContainer`: References the tray container div for bounds checking
- `rDraggingImage`: References the dragging preview image that follows the cursor

We also get access to the tldraw editor instance to create shapes and handle coordinate
transformations.

[3]
We use tldraw's `useAtom` hook to create reactive state that can be observed and updated.
The `dragState` atom holds our current drag state and automatically triggers re-renders
when it changes.

[4]
The event handlers are memoized using `useMemo` to avoid recreating them on every render.
The main logic handles the drag interaction:

	[a] When transitioning from `pointing_item` to `dragging`, we check if the user has
	moved their pointer more than 10 pixels from the start position to avoid accidental
	drags from simple clicks.

	[b] During dragging, we continuously update the current position to track the cursor.

	[c] When the drag ends (pointer up during dragging), we convert the screen coordinates
	to page coordinates and create a new shape at that position using the editor API.

	[d] When starting a drag (pointer down), we capture the pointer, get the item data
	from the DOM, and transition to the `pointing_item` state.

[5]
The `useQuickReactor` hook efficiently manages the drag preview image styling. It:
- Hides the preview when not dragging
- Shows/hides the preview based on whether the cursor is inside the tray bounds
- Positions the preview image to follow the cursor during dragging
- Applies appropriate styling for the drag preview

[6]
The tray UI renders each item from `TRAY_ITEMS` with pointer event handlers attached.
We use `data-drag_item_index` to identify which item was clicked, allowing us to retrieve
the correct item data during drag operations.

[7]
The drag preview image is a separate div that shows the emoji being dragged. It's only
visible during the dragging state and follows the cursor position.

[8]
We configure the tldraw editor to include our custom tray component using the `components`
prop. The `InFrontOfTheCanvas` component renders on top of the canvas, making it perfect
for UI elements like our drag tray.
*/
```

## drag-and-drop-tray.css

```css
.drag-tray {
	position: absolute;
	left: 10px;
	top: 50px;
	background: var(--tl-color-panel);
	border-radius: 9px;
	box-shadow: var(--tl-shadow-1);
	z-index: 1000;
	pointer-events: all;
	overflow: hidden;
}

.drag-tray-items {
	display: flex;
	flex-direction: column;
	gap: 4px;
}

.drag-tray-item {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 12px;
	width: 40px;
	height: 40px;
	border-radius: 8px;
	cursor: grab;
	transition: all 0.2s ease;
	user-select: none;
	font-size: 18px;
}
```

## trayitems.ts

```ts
import { TLShape, toRichText } from 'tldraw'

// [1]
export type TrayItem<T extends TLShape = TLShape> = T extends T
	? {
			id: string
			emoji: string
			label: string
			shapeBase: {
				type: T['type']
				props: Partial<T['props']>
			}
		}
	: never

export const TRAY_ITEMS: TrayItem<TLShape>[] = [
	{
		id: 'snowman',
		emoji: '⛄',
		label: 'Snowman',
		shapeBase: {
			type: 'geo',
			props: {
				richText: toRichText('⛄'),
				size: 'm',
			},
		},
	},
	{
		id: 'ice-cream',
		emoji: '🍦',
		label: 'Ice Cream',
		shapeBase: {
			type: 'geo',
			props: {
				richText: toRichText('🍦'),
				size: 'm',
			},
		},
	},
	{
		id: 'smiley',
		emoji: '😊',
		label: 'Smiley',
		shapeBase: {
			type: 'geo',
			props: {
				richText: toRichText('😊'),
				size: 'm',
			},
		},
	},
	{
		id: 'star',
		emoji: '⭐',
		label: 'Star',
		shapeBase: {
			type: 'geo',
			props: {
				richText: toRichText('⭐'),
				size: 'm',
			},
		},
	},
	{
		id: 'heart',
		emoji: '❤️',
		label: 'Heart',
		shapeBase: {
			type: 'geo',
			props: {
				richText: toRichText('❤️'),
				size: 'm',
			},
		},
	},
]
```

--------

# Error boundary

Category: UI & theming

Keywords: shape

Customize the error fallback that appears when a shape throws an error.

When something goes wrong in a shape, it won't crash the whole editor. An error fallback gets shown instead, which you can customize by overriding the `ShapeErrorFallback` component in the `components` prop.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { ErrorShapeUtil } from './ErrorShape'

// There's a guide at the bottom of this file!

// [1]
const shapes = [ErrorShapeUtil]

export default function ErrorBoundaryExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={shapes}
				components={{
					// [2]
					ShapeErrorFallback: ({ error }) => <div>Shape error! {String(error)}</div>,
				}}
				onMount={(editor) => {
					// [3]
					editor.createShape({ type: 'error' })
				}}
			/>
		</div>
	)
}

/*
This example shows how to customize the error fallback that appears when a shape throws an error. We
simulate this scenario by creating a shape that always throws an error when it renders.

[1]
This is the custom shape that always throws an error when it renders. Check out ErrorShape.ts to see
how it works.

[2]
Pass in the custom error fallback component.

[3]
When the app starts, create our error shape so that we can see the custom error fallback.

*/
```

## ErrorShape.ts

```ts
import { BaseBoxShapeUtil, TLShape } from 'tldraw'

const ERROR_TYPE = 'error'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[ERROR_TYPE]: { w: number; h: number }
	}
}

export type ErrorShape = TLShape<typeof ERROR_TYPE>

export class ErrorShapeUtil extends BaseBoxShapeUtil<ErrorShape> {
	static override type = ERROR_TYPE
	getDefaultProps() {
		return { w: 100, h: 100 }
	}
	component() {
		throw new Error('Error!')
	}
	indicator() {
		throw new Error('Error!')
	}
}
```

--------

# Selection UI

Category: UI & theming

Keywords: duplication controls, handles

Add extra UI elements around the user's selection.

You can use the `InFrontOfTheCanvas` component to show extra user interface elements around the user's selection.

## App.tsx

```tsx
import { TLComponents, Tldraw, Vec, intersectLineSegmentPolygon, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	InFrontOfTheCanvas: () => {
		const editor = useEditor()

		const info = useValue(
			'selection bounds',
			() => {
				const screenBounds = editor.getViewportScreenBounds()
				const rotation = editor.getSelectionRotation()
				const rotatedScreenBounds = editor.getSelectionRotatedScreenBounds()
				if (!rotatedScreenBounds) return
				return {
					// we really want the position within the
					// tldraw component's bounds, not the screen itself
					x: rotatedScreenBounds.x - screenBounds.x,
					y: rotatedScreenBounds.y - screenBounds.y,
					width: rotatedScreenBounds.width,
					height: rotatedScreenBounds.height,
					rotation: rotation,
				}
			},
			[editor]
		)

		if (!info) return

		return (
			<div
				style={{
					position: 'absolute',
					top: 0,
					left: 0,
					transformOrigin: 'top left',
					transform: `translate(${info.x}px, ${info.y}px) rotate(${info.rotation}rad)`,
					pointerEvents: 'all',
				}}
				onPointerDown={editor.markEventAsHandled}
			>
				<DuplicateInDirectionButton y={-40} x={info.width / 2 - 16} rotation={-(Math.PI / 2)} />
				<DuplicateInDirectionButton y={info.height / 2 - 16} x={info.width + 8} rotation={0} />
				<DuplicateInDirectionButton
					y={info.height + 8}
					x={info.width / 2 - 16}
					rotation={Math.PI / 3}
				/>
				<DuplicateInDirectionButton y={info.height / 2 - 16} x={-40} rotation={Math.PI} />
			</div>
		)
	},
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}

/**
 * This button will duplicate the editor's current selected shapes in
 * a certain direction. Its rotation determines the appearance of the
 * button (its actual css rotation) as well as the direction in which
 * the duplicated shapes are offset from the original shapes. It's
 * zeroed to the right.
 */
function DuplicateInDirectionButton({
	x,
	y,
	rotation,
}: {
	x: number
	y: number
	rotation: number
}) {
	const editor = useEditor()

	return (
		<button
			style={{
				position: 'absolute',
				width: 32,
				height: 32,
				pointerEvents: 'all',
				transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,
			}}
			onPointerDown={editor.markEventAsHandled}
			onClick={() => {
				const selectionRotation = editor.getSelectionRotation() ?? 0
				const rotatedPageBounds = editor.getSelectionRotatedPageBounds()!
				const selectionPageBounds = editor.getSelectionPageBounds()!
				if (!(rotatedPageBounds && selectionPageBounds)) return

				editor.markHistoryStoppingPoint()

				const PADDING = 32

				// Find an intersection with the page bounds
				const center = Vec.Rot(rotatedPageBounds.center, selectionRotation)
				const int = intersectLineSegmentPolygon(
					center,
					Vec.Add(center, new Vec(100000, 0).rot(selectionRotation + rotation)),
					rotatedPageBounds
						.clone()
						.expandBy(PADDING)
						.corners.map((c) => c.rot(selectionRotation))
				)
				if (!int?.[0]) return

				// Get the direction and distance to the intersection
				const delta = Vec.Sub(int[0], center)
				const dist = delta.len()
				const dir = delta.uni()

				// Get the offset for the duplicated shapes
				const offset = dir.mul(dist * 2)

				editor.duplicateShapes(editor.getSelectedShapes(), offset)
			}}
		>
			→
		</button>
	)
}
```

--------

# Custom actions

Category: UI & theming

Keywords: keyboard, shortcut, copy, paste, group, align

Customize and override tldraw's actions.

This example shows how you can override tldraw's actions object to change keyboard shortcuts and add your own custom actions. In this case we've changed the delete action's shortcut to 'Shift + X', and we've added a new action that shows a toast when you press the 'S' key. For more information on keyboard shortcuts see the [keyboard shortcuts example](https://tldraw.dev/examples/keyboard-shortcuts).

## App.tsx

```tsx
import { Tldraw, TLUiActionItem, TLUiActionsContextType } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				overrides={{
					actions: (_editor, actions, helpers) => {
						const myCustomAction: TLUiActionItem = {
							id: 'my-action',
							label: 'My action',
							icon: 'circle',
							// [2]
							kbd: 's',
							onSelect(source) {
								// [3]
								helpers.addToast({ title: `My action was selected from ${source}!` })
							},
						}

						// [4]
						const newActions: TLUiActionsContextType = {
							...actions,
							'my-action': myCustomAction,
							delete: {
								...actions['delete'],
								kbd: 'shift+x',
							},
						}

						return newActions
					},
				}}
			/>
		</div>
	)
}

/*
Tldraw's actions can be fired via keyboard shortcuts, or from anywhere in the user interface via
the `useActions` hook. This example shows how you can override tldraw's actions object via the Tldraw
component's `overrides` prop. To learn more about using this actions via a customized menu, see the
custom actions menu example.

[2]
For more information on keyboard shortcuts see the keyboard shortcuts example.

[3]
You can access UI helpers like addToast, removeToast, etc. from the helpers object.

[4]
Return a new object with the new actions added. You can also modify existing actions as shown here with the delete action.
*/
```

--------

# Custom error capture

Category: UI & theming

Keywords: error, fallback, capture, sentry, boundary, crash

Customize the error screen that appears when the editor crashes.

This example shows how to capture errors in the editor and send them to your error tracking service (like Sentry).

When a critical error occurs in the editor, tldraw displays an error screen with options to refresh or reset. You can customize this screen by overriding the `ErrorFallback` component in the `components` prop.

The editor will annotate errors with additional information that you can use to troubleshoot issues. This is useful for capturing data about the user's application state at the time of the error, such as what tool was active or what the user's selected shapes were.

There is a separate component, `ShapeErrorFallback`, that handles errors in individual shapes. There is a separate example showing how to use that component. By contrast, the `ErrorFallback` component handles editor-level errors that affect the entire application.

## App.tsx

```tsx
import { getErrorAnnotations, Tldraw, TLEditorComponents, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './custom-error-capture.css'

// There's a guide at the bottom of this file!

// [1]
const components: TLEditorComponents = {
	// [2]
	ErrorFallback: ({ error }) => {
		// [3]
		// eslint-disable-next-line local/no-at-internal
		const annotations = error instanceof Error ? getErrorAnnotations(error) : null

		return (
			<div className="custom-error">
				<h1>Something went wrong</h1>
				<div>{error instanceof Error ? error.message : String(error)}</div>

				{/* [4] */}
				{annotations && (
					<pre className="custom-error__annotations">{JSON.stringify(annotations, null, 2)}</pre>
				)}

				<button onClick={() => window.location.reload()}>Refresh</button>
			</div>
		)
	},
	// [5]
	InFrontOfTheCanvas: () => {
		const editor = useEditor()
		return (
			<button
				className="custom-error__button"
				onClick={() => {
					// [6]
					editor.createShape({
						// @ts-expect-error
						type: 'does-not-exist',
					})
				}}
			>
				Throw an error
			</button>
		)
	},
}

export default function CustomErrorCaptureExample() {
	return (
		<div className="tldraw__editor">
			{/* [7] */}
			<Tldraw components={components} />
		</div>
	)
}

/*
[1]
Define your component overrides outside of the React component so that they're static. If you must
define them inside of the component, be sure to use a `useMemo` hook to prevent them from being
re-created on every component update.

[2]
The ErrorFallback component is displayed when a critical error occurs in the editor that would
otherwise crash the entire application. This is different from ShapeErrorFallback, which handles
errors in individual shapes only.

The ErrorFallback component receives an error prop that contains information about what went wrong.
You can customize this component to match your app's design and provide helpful recovery options to
your users.

[3]
Use getErrorAnnotations to retrieve additional debugging information that tldraw attaches to errors.
These annotations include tags (key-value pairs for categorization) and extras (additional context
data). This is particularly useful for error reporting services like Sentry.

[4]
Display the annotations in a scrollable pre element so developers can see the additional context.
In production, you might want to send these annotations to your error tracking service (like Sentry)
instead of displaying them to users.

[5]
For this example, we've added a button using the InFrontOfTheCanvas component that intentionally
triggers an error so you can see the custom ErrorFallback in action. In a real application, you
wouldn't need this - the ErrorFallback would only appear when genuine errors occur.

[6]
We trigger an error by attempting to create a shape with an invalid type. This simulates what would
happen if there was a critical error in the editor.

[7]
Pass your custom components to the Tldraw component via the components prop.
*/
```

## custom-error-capture.css

```css
.custom-error__button {
	position: absolute;
	top: 100px;
	left: 100px;
	pointer-events: all;
}

.custom-error {
	position: absolute;
	inset: 0;
	display: flex;
	flex-direction: column;
	gap: 8px;
	align-items: center;
	justify-content: center;
	background: #f5f5f5;
}

.custom-error__annotations {
	margin: 8px 0;
	padding: 8px;
	background: white;
	border: 1px solid #ccc;
	border-radius: 4px;
	font-size: 12px;
	max-width: 600px;
	max-height: 300px;
	overflow-y: auto;
	text-align: left;
}
```

--------

# Custom indicators

Category: UI & theming

Keywords: indicators

Change when indicators are shown and how they appear.

This example shows how you can change when indicators are shown and how they appear.

## App.tsx

```tsx
import { TLComponents, Tldraw, useEditor, useEditorComponents, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLComponents = {
	OnTheCanvas: () => {
		const editor = useEditor()

		// [1]
		const renderingShapes = useValue(
			'rendering shapes',
			() => editor.getRenderingShapes().filter((_info) => true),
			[editor]
		)

		// [2]
		const { ShapeIndicator } = useEditorComponents()
		if (!ShapeIndicator) return null

		return (
			<div style={{ position: 'absolute', top: 0, left: 0, zIndex: 9999 }}>
				{renderingShapes.map(({ id }) => (
					<ShapeIndicator key={id + '_indicator'} shapeId={id} />
				))}
			</div>
		)
	},
	// [3]
	// ShapeIndicators: () => {
	// 	return <DefaultShapeIndicators showAll />
	// },
}

export default function IndicatorsLogicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				components={components}
				onMount={(editor) => {
					if (editor.getCurrentPageShapeIds().size === 0) {
						editor.createShapes([
							{
								type: 'geo',
								x: 100,
								y: 100,
							},
							{
								type: 'geo',
								x: 500,
								y: 150,
							},
							{
								type: 'geo',
								x: 100,
								y: 500,
							},
							{
								type: 'geo',
								x: 500,
								y: 500,
							},
						])
					}
				}}
			/>
		</div>
	)
}

/*
[1]
Get which indicators to show (based on the shapes currently on screen).
You could include logic here using the filter to narrow down which shapes
you want to show the indicators for.

[2]
You could override the default ShapeIndicator component in this
same TLComponents object, but the default (DefaultIndicator.tsx)
has a lot of logic for where and how to display the indicator.

[3]
If all you want to do is show or hide all the indicators, you could
create an override for the ShapeIndicators component that returns the
DefaultShapeIndicators component with `hideAll` or `showAll` props
set to true.
*/
```

--------

# Custom keyboard shortcuts

Category: UI & theming

Keywords: dialog, overrides, actions, tools

Replace tldraw's default keyboard shortcuts with your own.

This example shows how you can replace tldraw's default keyboard shortcuts with your own,
or add a shortcut for an action that doesn't have one. An example of how to add shortcuts
for custom tools can be found in the custom-config example.

- Toggle show grid by pressing 'x'
- Select the Draw tool by pressing 'p'
- Copy as png by pressing 'ctrl/cmd + 1'

## App.tsx

```tsx
import { TLUiActionsContextType, TLUiOverrides, TLUiToolsContextType, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const overrides: TLUiOverrides = {
	//[a]
	actions(_editor, actions): TLUiActionsContextType {
		const newActions = {
			...actions,
			'toggle-grid': { ...actions['toggle-grid'], kbd: 'x' },
			'copy-as-png': { ...actions['copy-as-png'], kbd: 'cmd+1,ctrl+1' },
		}

		return newActions
	},
	//[b]
	tools(_editor, tools): TLUiToolsContextType {
		const newTools = { ...tools, draw: { ...tools.draw, kbd: 'p' } }
		return newTools
	},
}

// [2]
export default function KeyboardShortcuts() {
	return (
		<div className="tldraw__editor">
			<Tldraw overrides={overrides} />
		</div>
	)
}

/*
This example shows how you can replace tldraw's default keyboard shortcuts with your own,
or add a shortcut for an action that doesn't have one. An example of how to add shortcuts
for custom tools can be found in the custom-config example.

In this case we are overriding the toggle grid and draw tool shortcuts, and creating a
shortcut for copy-as-png. An override of an existing shortcut will automatically update
the keyboard shortcuts dialog. However, adding a new shortcut won't, we'll need to add it
ourselves.

You can describe modifier keys with the following syntax:

	shift: !
 ctrl/cmd: $
	  alt: ?

[1]
We start by defining our overrides, this is an object with functions that we can use to
change the ui. Keyboard shortcuts are associated with either tools (draw, eraser, etc) or
actions (group, undo/redo etc). We're going to override two actions [a], one tool [b], and
add a new shortcut to the keyboard shortcuts dialog [c].

[a] actions
	There are two actions we're modifying here, copy-as-png and toggle-grid. copy-as-png
	doesn't have an existing shortcut, but we can still add the property and later add it
	to the keyboard shortcuts dialog [c].

[b] tools
	We're overriding the draw tool's shortcut to 'p', maybe we want to rename it to the pen
	tool or something.

[2]
Finally, we pass our overrides object into the Tldraw component's overrides prop. Now when
the component mounts, our overrides will be applied. If you open the keyboard shortcuts
dialog, you'll see the changes we made.
*/
```

--------

# Selection color condition

Category: UI & theming

Keywords: selection, color, condition, rectangle, geo shapes

Change the selection color based on the types of shapes selected.

This example shows how to change the selection color when the selection contains only rectangle geo shapes. The selection will appear red when all selected shapes are rectangles, and use the default blue color otherwise.

The example uses the `react` function to listen for selection changes and updates the container's CSS class accordingly.

## App.tsx

```tsx
import { Tldraw, react } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
export default function SelectionColorConditionExample() {
	return (
		<div className="tldraw__editor">
			<style>{`
				/* Custom selection color for rectangle shapes */
				.tl-container.rectangle-selection {
					--tl-color-selection: #ff4444;
					--tl-color-selection-stroke: #cc0000;
				}
			`}</style>

			<Tldraw
				onMount={(editor) => {
					// [2]
					const stopListening = react('update selection classname', () => {
						const selectedShapes = editor.getSelectedShapes()

						// [3]
						const allAreRectangles =
							selectedShapes.length > 0 &&
							selectedShapes.every(
								(shape) => editor.isShapeOfType(shape, 'geo') && shape.props.geo === 'rectangle'
							)

						// [4]
						if (allAreRectangles) {
							editor.getContainer().classList.add('rectangle-selection')
						} else {
							editor.getContainer().classList.remove('rectangle-selection')
						}
					})

					// [5]
					editor
						.createShapes([
							{ type: 'geo', x: 0, y: 0 },
							{ type: 'geo', x: 120, y: 0 },
						])
						.selectAll()
						.zoomToSelection()
						.createShape({ type: 'geo', x: 60, y: 120, props: { geo: 'ellipse' } })

					return stopListening
				}}
			/>
		</div>
	)
}

/*

Introduction:

This example shows how to change the selection color based on the types of shapes selected.
When all selected shapes are rectangles, the selection will appear red instead of the default blue.

[1]
We use the onMount prop to set up our selection listener when the editor is first mounted.

[2]
We use the react function to create a reactive effect that runs whenever the selection changes.
The first parameter is a unique name for this effect, and the second is a function that will
be called whenever the selection updates.

[3]
Here we check if all selected shapes are rectangle geo shapes. You can customize this condition
to check for any shape type or combination. For example:
- Check for circles: shape.type === 'geo' && shape.props.geo === 'ellipse'
- Check for text: shape.type === 'text'
- Check for mixed types: shape.type === 'geo' && (shape.props.geo === 'rectangle' || shape.props.geo === 'ellipse')

[4]
Based on our condition, we add or remove a CSS class from the editor's container. The CSS
file (selection-color-condition.css) defines the custom colors for the .rectangle-selection class.

[5]
We create some shapes to test our condition.

*/
```

--------

# Force mobile layout

Category: UI & theming

Keywords: force, mobile, breakpoint

Force the editor UI to render as if it were on a mobile device.

This example shows how you can force the editor to use the mobile breakpoint's UI layout.
To do this, pass the `forceMobile` prop to the editor component.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ForceMobileExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" forceMobile />
		</div>
	)
}

/*
This example shows how you can force the editor to use the mobile breakpoint.
Simply pass the `forceMobile` prop to the editor component.
*/
```

--------

# Infer dark mode

Category: UI & theming

Keywords: props

Infer dark mode based on system preferences.

When the `Tldraw` component's `inferDarkMode` is true, the editor will infer its initial theme based on the user's system preferences, if available. You can toggle the dark mode by pressing `Command + /`.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InferDarkModeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw inferDarkMode />
		</div>
	)
}
```

--------

# Toggle dark mode

Category: UI & theming

Keywords: theme, dark mode

Toggle dark mode.

This example demonstrates how to change the user's current `colorScheme` preference back-and-forth between dark mode and light mode. Try it out by clicking the button at the top of the page.

## App.tsx

```tsx
import { Tldraw, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

function DarkModeButton() {
	const editor = useEditor()

	const handleClick = () => {
		const isDark = editor.user.getIsDarkMode()
		editor.user.updateUserPreferences({ colorScheme: isDark ? 'light' : 'dark' })
	}

	return (
		<button style={{ pointerEvents: 'all' }} onClick={handleClick}>
			Toggle dark mode
		</button>
	)
}

export default function DarkModeToggleExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={{ TopPanel: DarkModeButton }} />
		</div>
	)
}
```

--------

# Layer panel

Category: UI & theming

Keywords:

Implementing a minimal layers panel for tldraw.

This example adds a simple layers panel to show shapes, groups, and frames in a tree view. It also allows showing/hiding shapes and selecting shapes.

## App.tsx

```tsx
import { TLComponents, TLEditorSnapshot, Tldraw, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import { ShapeList } from './ShapeList'
import './layer-panel.css'
import snapshot from './snapshot.json'

// There's a guide a the bottom of this file!

const components: TLComponents = {
	// [1]
	InFrontOfTheCanvas: () => {
		const editor = useEditor()
		const shapeIds = useValue(
			'shapeIds',
			() => editor.getSortedChildIdsForParent(editor.getCurrentPageId()),
			[editor]
		)
		return (
			<div className="layer-panel">
				<div className="layer-panel-title">Shapes</div>

				<ShapeList
					// [2]
					shapeIds={shapeIds}
					depth={0}
				/>
			</div>
		)
	},
}

export default function LayerPanelExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="layer-panel-example"
				components={components}
				// [3]
				getShapeVisibility={(s) =>
					s.meta.force_show ? 'visible' : s.meta.hidden ? 'hidden' : 'inherit'
				}
				// this is just to provide some initial content, so visitors can see the layer panel in action
				snapshot={snapshot as any as TLEditorSnapshot}
			/>
		</div>
	)
}

/*
Guide:

1. Here we override the `InFrontOfTheCanvas` component with a custom component that renders a simple layer panel.
2. We pass the root ids of the current page to the recursive ShapeList component. (see ShapeList.tsx)
3. This is a function that determines whether a shape is hidden. We use this to hide shapes that have the `hidden` meta property set to true.
*/
```

## ShapeList.tsx

```tsx
import { capitalize } from 'lodash'
import { useRef, useState } from 'react'
import { Editor, TLShapeId, useEditor, useValue } from 'tldraw'
import { VisibilityOff, VisibilityOn } from '../../icons/icons'

const selectedBg = '#E8F4FE'
const childSelectedBg = '#F3F9FE'
const childBg = '#00000006'

function ShapeItem({
	shapeId,
	depth,
	parentIsSelected,
	parentIsHidden,
}: {
	shapeId: TLShapeId
	depth: number
	parentIsSelected?: boolean
	parentIsHidden?: boolean
}) {
	const editor = useEditor()

	const shape = useValue('shape', () => editor.getShape(shapeId), [editor])
	const children = useValue('children', () => editor.getSortedChildIdsForParent(shapeId), [editor])
	const isHidden = useValue('isHidden', () => editor.isShapeHidden(shapeId), [editor])
	const isSelected = useValue('isSelected', () => editor.getSelectedShapeIds().includes(shapeId), [
		editor,
	])
	const shapeName = useValue('shapeName', () => getShapeName(editor, shapeId), [editor])

	const [isEditingName, setIsEditingName] = useState(false)

	const timeSinceLastVisibilityToggle = useRef(Date.now())

	if (!shape) return null

	return (
		<>
			{!!shape && (
				<div
					className="shape-item"
					onDoubleClick={() => {
						setIsEditingName(true)
					}}
					onPointerDown={() => {
						// We synchronize the selection state of the layer panel items with the selection state of the shapes in the editor.
						if (editor.inputs.getCtrlKey() || editor.inputs.getShiftKey()) {
							if (isSelected) {
								editor.deselect(shape)
							} else {
								editor.select(...editor.getSelectedShapes(), shape)
							}
						} else {
							editor.select(shape)
						}
					}}
					style={{
						paddingLeft: 10 + depth * 20,
						opacity: isHidden ? 0.5 : 1,
						background: isSelected
							? selectedBg
							: parentIsSelected
								? childSelectedBg
								: depth > 0
									? childBg
									: undefined,
					}}
				>
					{isEditingName ? (
						<input
							autoFocus
							className="shape-name-input"
							defaultValue={shapeName}
							onBlur={() => setIsEditingName(false)}
							onChange={(ev) => {
								if (shape.type === 'frame') {
									editor.updateShape({ ...shape, props: { name: ev.target.value } })
								} else {
									editor.updateShape({ ...shape, meta: { name: ev.target.value } })
								}
							}}
							onKeyDown={(ev) => {
								// finish editing on enter
								if (ev.key === 'Enter' || ev.key === 'Escape') {
									ev.currentTarget.blur()
								}
							}}
						/>
					) : (
						<div className="shape-name">{shapeName}</div>
					)}
					<button
						className="shape-visibility-toggle"
						onPointerDown={(ev) => {
							// prevent the event from bubbling up to the shape list item
							ev.stopPropagation()
							const now = Date.now()
							if (now - timeSinceLastVisibilityToggle.current < 200) {
								editor.updateShape({
									...shape,
									meta: { hidden: false, force_show: true },
								})
								timeSinceLastVisibilityToggle.current = 0
							} else {
								editor.updateShape({
									...shape,
									meta: { hidden: !shape.meta.hidden, force_show: false },
								})
								timeSinceLastVisibilityToggle.current = now
							}
						}}
					>
						{shape.meta.hidden ? <VisibilityOff /> : <VisibilityOn />}
					</button>
				</div>
			)}
			{!!children?.length && (
				<ShapeList
					shapeIds={children}
					depth={depth + 1}
					parentIsHidden={parentIsHidden || isHidden}
					parentIsSelected={parentIsSelected || isSelected}
				/>
			)}
		</>
	)
}

export function ShapeList({
	shapeIds,
	depth,
	parentIsSelected,
	parentIsHidden,
}: {
	shapeIds: TLShapeId[]
	depth: number
	parentIsSelected?: boolean
	parentIsHidden?: boolean
}) {
	if (!shapeIds.length) return null
	return (
		<div className="shape-tree">
			{shapeIds.map((shapeId) => (
				<ShapeItem
					key={shapeId}
					shapeId={shapeId}
					depth={depth}
					parentIsHidden={parentIsHidden}
					parentIsSelected={parentIsSelected}
				/>
			))}
		</div>
	)
}

function getShapeName(editor: Editor, shapeId: TLShapeId) {
	const shape = editor.getShape(shapeId)
	if (!shape) return 'Unknown shape'
	return (
		// meta.name is the first choice, then the shape's text, then the capitalized shape type
		(shape.meta.name as string) ||
		editor.getShapeUtil(shape).getText(shape) ||
		capitalize(shape.type + ' shape')
	)
}
```

## layer-panel.css

```css
.layer-panel {
	position: absolute;
	left: 0;
	top: 42px;
	width: 200px;
	height: calc(100% - 42px);
	background: white;
	display: flex;
	flex-direction: column;
	pointer-events: all;
}
.shape-tree {
	display: flex;
	flex-direction: column;
}
.shape-item {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 6px 10px;
}

.shape-visibility-toggle {
	padding: 3px 6px;
	border-radius: 3px;
	outline: none;
	border: none;
	background: none;
	flex-shrink: 0;
}
.shape-visibility-toggle:hover {
	cursor: pointer;
	background-color: #0000000b;
}

.layer-panel-title {
	padding: 10px;
	font-size: smaller;
	font-weight: bolder;
}

.shape-name-input {
	border: none;
	background: none;
	width: 0;
	flex-grow: 1;
	padding: 0;
}

.shape-name {
	overflow: hidden;
	text-overflow: ellipsis;
	text-wrap: nowrap;
}
```

--------

# Floaty window

Category: UI & theming

Keywords:

Create an illusion of a floating window.

This example shows how to create a 'floating window' illusion that was [popular on social media](https://x.com/steveruizok/status/1727436505440981099) for a while.

## App.tsx

```tsx
import { useEffect } from 'react'
import { Tldraw, Vec, useContainer, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

export default function FloatyExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="tldraw_floaty_example">
				<SneakyFloatyHook />
			</Tldraw>
		</div>
	)
}

function SneakyFloatyHook() {
	const editor = useEditor()
	const container = useContainer()

	useEffect(() => {
		if (!window.screenLeft) {
			window.screenLeft = window.screenX
			window.screenTop = window.screenY
		}

		let x = window.screenLeft ?? window.screenX
		let y = window.screenTop ?? window.screenY

		function updatePositions() {
			const sx = window.screenLeft ?? window.screenX
			const sy = window.screenTop ?? window.screenY

			if (sx !== x || sy !== y) {
				x = sx
				y = sy
				editor.setCamera(new Vec(-x, -y))
			}
		}

		editor.on('tick', updatePositions)

		return () => {
			editor.off('tick', updatePositions)
		}
	}, [editor, container])

	return null
}
```

--------

# Custom translations and overrides

Category: UI & theming

Keywords: translation, i18n, localization, language, custom, override, useTranslation

Customize tldraw's translation strings and use them in custom components.

Apps often need to customize UI text to match their brand voice or terminology. This example demonstrates how to:

- Override existing translation strings (e.g., changing "Duplicate" to "Make a copy")
- Support multiple languages with custom terminology
- Use the `useTranslation` hook in your own components to access translations

The example creates a custom toolbar that uses translated strings via the `useTranslation` hook, and shows how to override those translations for multiple languages using the `overrides` prop on the `Tldraw` component.

## App.tsx

```tsx
import {
	TLComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiButton,
	useEditor,
	useTranslation,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './custom-language-translations.css'

// There's a guide at the bottom of this file!

// [1]
function CustomToolbar() {
	const editor = useEditor()
	const msg = useTranslation()

	return (
		<div className="tlui-menu custom-language-toolbar">
			<TldrawUiButton
				type="normal"
				onClick={() => editor.duplicateShapes(editor.getSelectedShapeIds())}
			>
				{/* [2] */}
				{msg('action.duplicate')}
			</TldrawUiButton>
			<TldrawUiButton
				type="normal"
				onClick={() => editor.deleteShapes(editor.getSelectedShapeIds())}
			>
				{msg('action.delete')}
			</TldrawUiButton>
		</div>
	)
}

// [3]
const overrides: TLUiOverrides = {
	translations: {
		en: {
			'action.duplicate': 'Make a copy',
			'action.delete': 'Remove',
		},
		es: {
			'action.duplicate': 'Hacer una copia',
			'action.delete': 'Eliminar',
		},
	},
}

// [4]
const components: TLComponents = {
	TopPanel: CustomToolbar,
}

export default function CustomLanguageTranslationExample() {
	return (
		<div className="tldraw__editor">
			{/* [5] */}
			<Tldraw overrides={overrides} components={components} />
		</div>
	)
}

/*
This example shows how to customize tldraw's translation strings and use them in your own
components. This is useful when you need to match your app's brand voice or terminology.

[1]
We create a custom toolbar component that will use the translation system. The useTranslation
hook returns a function (commonly named 'msg') that retrieves translated strings by their key.

[2]
We call the msg function with translation keys like 'action.duplicate' and 'action.delete'.
These will return our customized strings instead of tldraw's defaults.

[3]
We define translation overrides in the overrides object. The translations property accepts an
object where each key is a language code (like 'en' or 'es') and the value is an object mapping
translation keys to custom strings. This allows you to override existing translations or add
new ones for multiple languages.

[4]
We define our component overrides outside of the React component to keep them static. This
prevents unnecessary re-renders and follows React best practices. The CustomToolbar component
is placed in the TopPanel to demonstrate how custom UI can use the translation system.

[5]
We pass both the overrides and components to the Tldraw component. The overrides provide the
custom translations, and the components prop adds our custom toolbar that uses those translations.

In addition to our custom menu, our custom translations can be found in the other menus as well.
Try creating a shape and right clicking it to see the custom translations in the context menu, or
in the main menu, keyboard shortcuts dialog, and more.
*/
```

## custom-language-translations.css

```css
.custom-language-toolbar {
	pointer-events: all;
	display: flex;
	margin: 8px;
}
```

--------

# Custom renderer

Category: UI & theming

Keywords: html, canvas, background, context

You can _sort of_ use a custom renderer with tldraw.

This example shows how you might use a custom renderer with tldraw.

## App.tsx

```tsx
import { useLayoutEffect } from 'react'
import { DefaultCanvas, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CustomRenderer } from './CustomRenderer'

export default function CustomRendererExample() {
	useLayoutEffect(() => {
		// Hide the regular shapes layer using CSS.
		const script = document.createElement('style')
		if (!script) return
		script.innerHTML = `.tl-shapes { display: none; }`
		document.body.appendChild(script)
		return () => {
			script.remove()
		}
	})

	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				components={{
					// We're replacing the Background component with our custom renderer
					Background: CustomRenderer,
					// Even though we're hiding the shapes, we'll still do a bunch of work
					// in react to figure out which shapes to create. In reality, you might
					// want to set the Canvas component to null and render it all yourself.
					Canvas: DefaultCanvas,
				}}
			/>
		</div>
	)
}
```

## CustomRenderer.tsx

```tsx
import { useLayoutEffect, useRef } from 'react'
import { getColorValue, getDefaultColorTheme, getPointsFromDrawSegment, useEditor } from 'tldraw'

export function CustomRenderer() {
	const editor = useEditor()
	const rCanvas = useRef<HTMLCanvasElement>(null)

	useLayoutEffect(() => {
		const canvas = rCanvas.current
		if (!canvas) return

		canvas.style.width = '100%'
		canvas.style.height = '100%'

		const rect = canvas.getBoundingClientRect()

		canvas.width = rect.width
		canvas.height = rect.height

		const ctx = canvas.getContext('2d')!

		let raf = -1

		function render() {
			if (!canvas) return

			ctx.resetTransform()
			ctx.clearRect(0, 0, canvas.width, canvas.height)

			const camera = editor.getCamera()
			ctx.scale(camera.z, camera.z)
			ctx.translate(camera.x, camera.y)

			const renderingShapes = editor.getRenderingShapes()
			const theme = getDefaultColorTheme({ isDarkMode: editor.user.getIsDarkMode() })
			const currentPageId = editor.getCurrentPageId()

			for (const { shape, opacity } of renderingShapes) {
				const maskedPageBounds = editor.getShapeMaskedPageBounds(shape)
				if (!maskedPageBounds) continue
				ctx.save()

				if (shape.parentId !== currentPageId) {
					ctx.beginPath()
					ctx.rect(
						maskedPageBounds.minX,
						maskedPageBounds.minY,
						maskedPageBounds.width,
						maskedPageBounds.height
					)
					ctx.clip()
				}

				ctx.beginPath()

				ctx.globalAlpha = opacity

				const transform = editor.getShapePageTransform(shape.id)
				ctx.transform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f)

				if (editor.isShapeOfType(shape, 'draw')) {
					// Draw a freehand shape
					for (const segment of shape.props.segments) {
						const points = getPointsFromDrawSegment(segment, shape.props.scaleX, shape.props.scaleY)
						ctx.moveTo(points[0].x, points[0].y)
						if (segment.type === 'straight') {
							ctx.lineTo(points[1].x, points[1].y)
						} else {
							for (const point of points.slice(1)) {
								ctx.lineTo(point.x, point.y)
							}
						}
					}
					ctx.strokeStyle = getColorValue(theme, shape.props.color, 'solid')
					ctx.lineWidth = 4
					ctx.stroke()
					if (shape.props.fill !== 'none' && shape.props.isClosed) {
						ctx.fillStyle = getColorValue(theme, shape.props.color, 'semi')
						ctx.fill()
					}
				} else if (editor.isShapeOfType(shape, 'geo')) {
					// Draw a geo shape
					const bounds = editor.getShapeGeometry(shape).bounds
					ctx.strokeStyle = getColorValue(theme, shape.props.color, 'solid')
					ctx.lineWidth = 2
					ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height)
				} else {
					// Draw any other kind of shape
					const bounds = editor.getShapeGeometry(shape).bounds
					ctx.strokeStyle = 'black'
					ctx.lineWidth = 2
					ctx.strokeRect(bounds.minX, bounds.minY, bounds.width, bounds.height)
				}
				ctx.restore()
			}

			raf = requestAnimationFrame(render)
		}

		render()

		return () => {
			cancelAnimationFrame(raf)
		}
	}, [editor])

	return <canvas ref={rCanvas} />
}
```

--------

# Inset editor

Category: Page layout

Keywords: inline

Using the tldraw component in a non-fullscreen layout.

The `<Tldraw/>` component may be placed in any layout, even if it's not full-screen. In this example, the editor is inset within the screen layout. The component's interactions should still behave as you'd expect them to.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InsetExample() {
	return (
		<div style={{ position: 'absolute', inset: 100 }}>
			<div className="tldraw__editor">
				<Tldraw />
			</div>
		</div>
	)
}
```

--------

# Inset editor (fixed sizes)

Category: Page layout

Keywords: focus, auto, focus, multiple, editors

Use the `Tldraw` component with a set height and width.

The `Tldraw` component can be used with a set height and width.
This example shows the editor's default appearance at various different sizes.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function InlineExample() {
	return (
		<>
			<InlineEditor width={400} height={300} />
			<InlineEditor width={500} height={300} />
			<InlineEditor width={600} height={400} />
			<InlineEditor width={700} height={500} />
			<InlineEditor width={900} height={600} />
		</>
	)
}

function InlineEditor({ width, height }: { width: number; height: number }) {
	const title = `${width} x ${height}`
	return (
		<section style={{ padding: '12px 32px' }}>
			<h2>{title}</h2>
			<div style={{ width, height }}>
				<Tldraw persistenceKey="inset-size-example" />
			</div>
		</section>
	)
}
```

--------

# Inset editor (common practices)

Category: Page layout

Keywords: focus, blur, multiple

Common practices for using the `Tldraw` component as a block within a larger page.

This example demonstrates some common best practices for using tldraw as a block within a larger page. It includes:

- Making sure that only one editor has focus at a time.
- Always defaulting to the hand tool when you click into an editor.
- Deselecting everything when an editor loses focus.
- Hiding the UI when an editor is not focused.
- Disabling edge scrolling by default.
- Using a stripped down UI to make the most of the available space.
- Removing actions from the context menu to match the stripped down UI.

## App.tsx

```tsx
import { createContext, useContext, useState } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
const focusedEditorContext = createContext(
	{} as {
		focusedEditor: Editor | null
		setFocusedEditor(id: Editor | null): void
	}
)

// [2]
function blurEditor(editor: Editor) {
	editor.blur({ blurContainer: false })
	editor.selectNone()
	editor.setCurrentTool('hand')
}

export default function InlineBehaviorExample() {
	const [focusedEditor, setFocusedEditor] = useState<Editor | null>(null)

	return (
		<focusedEditorContext.Provider value={{ focusedEditor, setFocusedEditor }}>
			<div
				style={{
					display: 'flex',
					flexDirection: 'column',
					padding: 20,
					gap: 20,
				}}
				// [3]
				onPointerDown={() => {
					if (!focusedEditor) return
					blurEditor(focusedEditor)
					setFocusedEditor(null)
				}}
			>
				<InlineBlock persistenceKey="block-a" />
				<InlineBlock persistenceKey="block-b" />
				<InlineBlock persistenceKey="block-c" />
			</div>
		</focusedEditorContext.Provider>
	)
}

function InlineBlock({ persistenceKey }: { persistenceKey: string }) {
	const { focusedEditor, setFocusedEditor } = useContext(focusedEditorContext)
	const [editor, setEditor] = useState<Editor>()

	return (
		<div
			style={{ width: 600, height: 400, maxWidth: '100%' }}
			// [4]
			onFocus={() => {
				if (!editor) return
				if (focusedEditor && focusedEditor !== editor) {
					blurEditor(focusedEditor)
				}
				editor.focus({ focusContainer: false })
				setFocusedEditor(editor)
			}}
			onPointerDown={(e) => e.stopPropagation()}
		>
			<Tldraw
				persistenceKey={persistenceKey}
				autoFocus={false}
				// [5]
				hideUi={focusedEditor !== editor}
				// [6]
				options={{
					maxPages: 0,
					edgeScrollSpeed: 0,
				}}
				// [7]
				components={{
					HelpMenu: null,
					NavigationPanel: null,
					MainMenu: null,
				}}
				// [8]
				onMount={(editor) => {
					setEditor(editor)
					editor.setCurrentTool('hand')
				}}
			/>
		</div>
	)
}

/*
This example demonstrates some common best practices for using tldraw as an inline block within a
larger document editor.

It includes:

- Making sure that only one editor has focus at a time.
- Always defaulting to the hand tool when you click into an editor.
- Deselecting everything when an editor loses focus.
- Hiding the UI when an editor is not focused.
- Disabling edge scrolling by default.
- Using a stripped down UI to make the most of the available space.

[1]
We use a context to manage which editor is currently focused. This allows us to have multiple
editors on the same page, without them interfering with each other, or hijacking any keyboard
shortcuts. For more information about handling focus, check out the 'Multiple editors' and 'Editor
focus' examples.

[2]
We have a helper function that we call on any editor that loses focus. We deselect everything, and
switch back to the hand tool, essentially 'resetting' the user's tool state.

[3]
When the user clicks anywhere on the page outside of an editor, we blur the currently focused
editor.

[4]
When the user clicks into an editor, we focus it, and blur any other editor.
We also prevent pointer down events from passing through to the parent.

[5]
We hide the UI of any unfocused editor.

[6]
We disable pages to hide the pages menu. We disable edge scrolling, which can sometimes be too
easily triggered when the editor is in a small space.

[7]
We disable many of tldraw's default UI components to make the most of the available space.

[8]
When an editor mounts, we default to the hand tool. We also store a reference to the editor so that
we can access it later.

*/
```

--------

# Inset canvas

Category: Page layout

Keywords:

Handling events when the canvas is inset within the editor.

If for some reason you need to move the canvas around, that should still work.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import './inset-canvas.css'

export default function InsetCanvasExample() {
	return (
		<div className="tldraw__editor tldraw__editor-with-inset-canvas">
			<Tldraw />
		</div>
	)
}
```

## inset-canvas.css

```css
.tldraw__editor-with-inset-canvas .tl-canvas {
	position: absolute;
	inset: 25%;
	width: 50%;
	height: 50%;
}
```

--------

# Scrollable container

Category: Page layout

Keywords: focus, mouse wheel

Use the editor inside a scrollable container.

The `Tldraw` component can be used inside of any layout, including a scrollable container. Note that the editor will accept mousewheel events unless it is "unfocused".

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ScrollExample() {
	return (
		<div
			style={{
				width: '150vw',
				height: '150vh',
				display: 'flex',
				justifyContent: 'center',
				alignItems: 'center',
				backgroundColor: '#fff',
			}}
		>
			<div style={{ width: '60vw', height: '80vh' }}>
				<Tldraw persistenceKey="scroll-example" autoFocus={true} />
			</div>
		</div>
	)
}

/*
This example shows how you can use the Tldraw component inside a scrollable container.
The component will still accept mousewheel events while "focused". Try turning off the
autoFocus prop to see the difference.
*/
```

--------

# Multiple editors

Category: Page layout

Keywords: multiple, focus

Use multiple `<Tldraw/>` components on the same page.

This example shows how to use multiple `<Tldraw/>` components on the same page.

## App.tsx

```tsx
import { createContext, useCallback, useContext, useState } from 'react'
import { Editor, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

// [1]
const focusedEditorContext = createContext(
	{} as {
		focusedEditor: Editor | null
		setFocusedEditor(id: Editor | null): void
	}
)

// [2]
export default function MultipleExample() {
	const [focusedEditor, _setFocusedEditor] = useState<Editor | null>(null)

	const setFocusedEditor = useCallback(
		(editor: Editor | null) => {
			if (focusedEditor !== editor) {
				if (focusedEditor) {
					focusedEditor.blur()
				}
				if (editor) {
					editor.focus()
				}
				_setFocusedEditor(editor)
			}
		},
		[focusedEditor]
	)

	const focusName =
		focusedEditor === (window as any).EDITOR_A
			? 'A'
			: focusedEditor === (window as any).EDITOR_B
				? 'B'
				: focusedEditor === (window as any).EDITOR_C
					? 'C'
					: 'none'

	return (
		<div
			style={{
				padding: 32,
			}}
			// Sorry you need to do this yourself
			onPointerDown={() => setFocusedEditor(null)}
		>
			<focusedEditorContext.Provider value={{ focusedEditor, setFocusedEditor }}>
				<h1>Focusing: {focusName}</h1>
				<EditorA />
				<textarea data-testid="textarea" placeholder="type in me" style={{ margin: 10 }} />
				<div
					style={{
						width: '100%',
						display: 'grid',
						gridTemplateColumns: 'repeat(auto-fit, minmax(420px, 1fr))',
						gap: 64,
					}}
				>
					<EditorB />
					<EditorC />
				</div>
				<p>
					These two editors share the same persistence key so they will share a (locally)
					synchronized document.
				</p>
				<ABunchOfText />
			</focusedEditorContext.Provider>
		</div>
	)
}

// [3]
function EditorA() {
	const { setFocusedEditor } = useContext(focusedEditorContext)

	return (
		<div style={{ padding: 32 }}>
			<h2>A</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_A)}
				style={{ height: 600 }}
				// Capture pointer down events that happen within the editor
				onPointerDown={(e) => e.stopPropagation()}
			>
				<Tldraw
					persistenceKey="steve"
					className="A"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_A = editor
						setFocusedEditor(editor)
					}}
				/>
			</div>
		</div>
	)
}

// [4]
function EditorB() {
	const { setFocusedEditor } = useContext(focusedEditorContext)
	return (
		<div>
			<h2>B</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_B)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="david"
					className="B"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_B = editor
					}}
				/>
			</div>
		</div>
	)
}

function EditorC() {
	const { setFocusedEditor } = useContext(focusedEditorContext)
	return (
		<div>
			<h2>C</h2>
			<div
				tabIndex={-1}
				onFocus={() => setFocusedEditor((window as any).EDITOR_C)}
				style={{ height: 600 }}
			>
				<Tldraw
					persistenceKey="david"
					className="C"
					autoFocus={false}
					onMount={(editor) => {
						;(window as any).EDITOR_C = editor
					}}
				/>
			</div>
		</div>
	)
}

// [5]
function ABunchOfText() {
	return (
		<article style={{ maxWidth: 500 }}>
			<h1>White Board</h1>
			<h2>Chapter 1: The First Strokes</h2>
			<p>
				The fluorescent lights flickered overhead as John sat hunched over his desk, his fingers
				tapping rhythmically on the keyboard. He was a software developer, and tonight, he had a
				peculiar mission. A mission that would take him deep into the labyrinthine world of web
				development. John had stumbled upon a new whiteboard library called “tldraw”, a seemingly
				simple tool that promised to revolutionize collaborative drawing on the web. Little did he
				know that this discovery would set off a chain of events that would challenge his skills,
				test his perseverance, and blur the line between reality and imagination.
			</p>
			<p>
				With a newfound sense of excitement, John began integrating “tldraw” into his latest
				project. As lines of code danced across his screen, he imagined the possibilities that lay
				ahead. The potential to create virtual spaces where ideas could be shared, concepts could be
				visualized, and teams could collaborate seamlessly from different corners of the world. It
				was a dream that seemed within reach, a vision of a future where creativity and technology
				merged into a harmonious symphony.
			</p>
			<p>
				As the night wore on, John’s mind became consumed with the whiteboard library. He couldn’t
				help but marvel at its elegance and simplicity. With each stroke of his keyboard, he felt a
				surge of inspiration, a connection to something greater than himself. It was as if the lines
				of code he was writing were transforming into a digital canvas, waiting to be filled with
				the strokes of imagination. In that moment, John realized that he was not just building a
				tool, but breathing life into a new form of expression. The whiteboard was no longer just a
				blank slate; it had become a portal to a world where ideas could flourish and dreams could
				take shape.
			</p>
			<p>
				Little did John know, this integration of “tldraw” was only the beginning. It would lead him
				down a path filled with unforeseen challenges, where he would confront his own limitations
				and question the very nature of creation. The journey ahead would test his resolve, pushing
				him to the edge of his sanity. And as he embarked on this perilous adventure, he could not
				shake the feeling that the whiteboard held secrets far beyond his understanding. Secrets
				that would unfold before his eyes, one stroke at a time.
			</p>
		</article>
	)
}

/*
This example shows how to use multiple editors on the same page. When doing this, you'll
need to make sure that only one editor is focused at a time. We can manage this using
the autofocus prop on the tldraw component, along with React's context and set state
APIs.

[1]
We first create a context that will hold the focused editor id and a setter for that id.
We'll use this to keep track of which editor is focused.

[2]
Wrap the editors in the context provider. This will make the context available to all
of the editors.

[3]
Get the focused editor id and the setter from the context. We'll use these to determine
if the editor should be focused or not. We wrap the Tldraw component in a div and use
the onFocus event to set the focused editor id.

[4]
Same again, but we're using the same persistence key for editors B and C. This means
that they will share a document.

[5]
A long story that doesn't really go anywhere, clearly written by a computer. But it's
a good way to test the scroll behavior of the page.
*/
```

--------

# External dialog

Category: Page layout

Keywords: css

Make dialogs open outside of the `Tldraw` component.

You can make dialogs open outside of the `Tldraw` component by overriding our default styles. To see this in action, open the Insert embed dialog through the menu or by pressing 'Cmd + I'.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// This CSS file overrides the default styles for dialogs
import './external-dialog.css'

export default function ExternalDialog() {
	return (
		<div style={{ margin: 32, width: 600, height: 400 }}>
			<Tldraw />
		</div>
	)
}
```

## external-dialog.css

```css
.tlui-dialog__overlay {
	position: fixed;
}
```

--------

# External UI (using context)

Category: Page layout

Keywords: outside, editor, context

This example shows how to control the tldraw editor from an external UI, using React context.

This example shows how to control the tldraw editor from an external UI, outside
of the `Tldraw` component. There are a few ways of doing this—for example, by putting the editor on the window object, passing it around via props, or using React context.

In this example, we use React context to distribute a reference to the editor to child components.

## App.tsx

```tsx
import { createContext, useContext, useState } from 'react'
import { Editor, GeoShapeGeoStyle, Tldraw, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './external-ui.css'

// There's a guide at the bottom of this file!

// [1]
const editorContext = createContext({} as { editor: Editor })

export default function ExternalUiExample2() {
	const [editor, setEditor] = useState<Editor | null>(null)

	return (
		<div style={{ margin: 32, width: 600 }}>
			<div style={{ height: 400 }}>
				<Tldraw
					// [2]
					onMount={(editor) => setEditor(editor)}
					components={{ Toolbar: null }}
				/>
			</div>
			{/* [3] */}
			{editor && (
				<editorContext.Provider value={{ editor }}>
					<ExternalToolbar />
				</editorContext.Provider>
			)}
		</div>
	)
}

// [4]
const ExternalToolbar = () => {
	const { editor } = useContext(editorContext)

	const currentToolId = useValue('current tool id', () => editor?.getCurrentToolId(), [editor])

	return (
		<div>
			<div className="external-toolbar">
				<button
					className="external-button"
					data-isactive={currentToolId === 'select'}
					onClick={() => editor.setCurrentTool('select')}
				>
					Select
				</button>
				<button
					className="external-button"
					data-isactive={currentToolId === 'draw'}
					onClick={() => editor.setCurrentTool('draw')}
				>
					Pencil
				</button>
				<button
					className="external-button"
					data-isactive={
						currentToolId === 'geo' && editor?.getStyleForNextShape(GeoShapeGeoStyle) === 'oval'
					}
					onClick={() => {
						editor.run(() => {
							editor.setStyleForNextShapes(GeoShapeGeoStyle, 'oval')
							editor.setCurrentTool('geo')
						})
					}}
				>
					Oval
				</button>
			</div>
		</div>
	)
}

/*

[1]
Use React context to store the editor at a higher place in the React component tree.

[2]
Use the `onMount` prop to get the editor instance and store it in state.

[3]
When we have an editor in state, render the context provider and its descendants.

[4]
You can access the editor from any of the provider's descendants.
*/
```

## external-ui.css

```css
.external-toolbar {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.external-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 16px;
}

.external-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

--------

# External UI (using state)

Category: Page layout

Keywords: outside, editor

This example shows how to control the tldraw editor from an external UI, using state.

This example shows how to control the tldraw editor from an external UI, outside
of the `Tldraw` component. There are a few ways of doing this—for example, by putting the editor on the window object, passing it around via props, or using React context.

In this example, we'll just put the editor instance in state and use it in the same component. See the [other External UI example](https://tldraw.dev/examples/external-ui-context) for an alternative (and more realistic) solution using React context.

## App.tsx

```tsx
import { useState } from 'react'
import { Editor, GeoShapeGeoStyle, Tldraw, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './external-ui.css'

// There's a guide at the bottom of this file!

export default function ExternalUiExample() {
	// [1]
	const [editor, setEditor] = useState<Editor | null>(null)

	const currentToolId = useValue('current tool id', () => editor?.getCurrentToolId(), [editor])

	return (
		<div style={{ margin: 32, width: 600 }}>
			<div style={{ height: 400 }}>
				<Tldraw
					// [2]
					onMount={(editor) => setEditor(editor)}
					components={{ Toolbar: null }}
				/>
			</div>
			{/* [3] */}
			<div>
				<div className="external-toolbar">
					<button
						className="external-button"
						data-isactive={currentToolId === 'select'}
						onClick={() => editor?.setCurrentTool('select')}
					>
						Select
					</button>
					<button
						className="external-button"
						data-isactive={currentToolId === 'draw'}
						onClick={() => editor?.setCurrentTool('draw')}
					>
						Pencil
					</button>
					<button
						className="external-button"
						data-isactive={
							currentToolId === 'geo' && editor?.getStyleForNextShape(GeoShapeGeoStyle) === 'oval'
						}
						onClick={() => {
							if (!editor) return
							editor.run(() => {
								// [4]
								editor.setStyleForNextShapes(GeoShapeGeoStyle, 'oval')
								editor.setCurrentTool('geo')
							})
						}}
					>
						Oval
					</button>
				</div>
			</div>
		</div>
	)
}

/*
[1]
Use React state to store the editor instance.

[2]
Use the `onMount` prop to get the editor instance and store it in state.

[3]
Use data from the editor instance or use the editor's methods to control the editor.
Note that these callbacks also need to work if the editor isn't mounted yet.

[4]
The geo tool is a bit special since it controls the creation of many geo shapes (oval, rectangle, etc).
This is why we first set the type of the shape we wish to add, then we set the tool to 'geo'.
You can see all the available geo shapes in the `GeoShapeGeoStyle` enum.
*/
```

## external-ui.css

```css
.external-toolbar {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 8px;
	gap: 8px;
}

.external-button {
	pointer-events: all;
	padding: 4px 12px;
	background: white;
	border: 1px solid black;
	border-radius: 16px;
}

.external-button[data-isactive='true'] {
	background-color: black;
	color: white;
}
```

--------

# Snapshot image component

Category: Page layout

Keywords: snapshot, export

Display a tldraw snapshot as an image by using the `TldrawImage` component.

The `TldrawImage` component is a simple way to display a tldraw snapshot as an image. This example shows how to use it.

## App.tsx

```tsx
import { useState } from 'react'
import {
	Box,
	Editor,
	StoreSnapshot,
	TLPageId,
	TLRecord,
	TLStoreSnapshot,
	Tldraw,
	TldrawImage,
	getSnapshot,
} from 'tldraw'
import 'tldraw/tldraw.css'
import initialSnapshot from './snapshot.json'

// There's a guide at the bottom of this file!

export default function TldrawImageExample() {
	const [editor, setEditor] = useState<Editor>()
	const [snapshot, setSnapshot] = useState<StoreSnapshot<TLRecord>>(
		initialSnapshot as TLStoreSnapshot
	)
	const [currentPageId, setCurrentPageId] = useState<TLPageId | undefined>()
	const [showBackground, setShowBackground] = useState(true)
	const [isDarkMode, setIsDarkMode] = useState(false)
	const [viewportPageBounds, setViewportPageBounds] = useState(new Box(0, 0, 600, 400))
	const [isEditing, setIsEditing] = useState(false)
	const [format, setFormat] = useState<'svg' | 'png'>('svg')

	return (
		<div style={{ padding: 30 }}>
			<div>
				<button
					style={{ cursor: 'pointer', marginRight: 8 }}
					onClick={() => {
						if (isEditing) {
							if (!editor) return
							setIsDarkMode(editor.user.getIsDarkMode())
							setShowBackground(editor.getInstanceState().exportBackground)
							setViewportPageBounds(editor.getViewportPageBounds())
							setCurrentPageId(editor.getCurrentPageId())
							setSnapshot(getSnapshot(editor.store).document)
							setIsEditing(false)
						} else {
							setIsEditing(true)
						}
					}}
				>
					{isEditing ? '✓ Save drawing' : '✎ Edit drawing'}
				</button>
				{!isEditing && (
					<>
						<label htmlFor="format" style={{ marginRight: 8 }}>
							Format
						</label>
						<select
							name="format"
							value={format}
							onChange={(e) => {
								setFormat(e.currentTarget.value as 'svg' | 'png')
							}}
						>
							<option value="svg">SVG</option>
							<option value="png">PNG</option>
						</select>
					</>
				)}
			</div>
			<div style={{ width: 600, height: 400, marginTop: 15 }}>
				{isEditing ? (
					<Tldraw
						snapshot={snapshot}
						onMount={(editor: Editor) => {
							setEditor(editor)
							editor.user.updateUserPreferences({ colorScheme: isDarkMode ? 'dark' : 'light' })
							if (currentPageId) {
								editor.setCurrentPage(currentPageId)
							}
							if (viewportPageBounds) {
								editor.zoomToBounds(viewportPageBounds, { inset: 0 })
							}
						}}
					/>
				) : (
					<TldrawImage
						//[1]
						snapshot={snapshot}
						// [2]
						pageId={currentPageId}
						// [3]
						background={showBackground}
						darkMode={isDarkMode}
						bounds={viewportPageBounds}
						padding={0}
						scale={1}
						format={format}
					/>
				)}
			</div>
		</div>
	)
}

/*

This example shows how to use the `TldrawImage` component to display a snapshot
as an image. The example also allows you to toggle between editing the snapshot
and viewing it.

[1] Pass your snapshot to the `snapshot` prop of the `TldrawImage` component.

[2] You can specify which page to display by using the `pageId` prop. By
    default, the first page is shown.

[3] You can customize the appearance of the image by passing other props to the
        `TldrawImage` component. For example, you can toggle the background, set
        the dark mode, and specify the viewport bounds.
 */
```

--------

# Unsaved changes

Category: Events & effects

Keywords: save, unsaved, changes, document, listen, state

Track unsaved changes and enable save functionality.

This example shows how to track when the document has unsaved changes by listening to document scope events. A save button is enabled only when there are unsaved changes, and clicking it clears the unsaved state. The example uses `Editor.store.listen` with the `document` scope to monitor changes to the tldraw document.

## App.tsx

```tsx
import { useCallback, useEffect, useRef, useState } from 'react'
import {
	RecordsDiff,
	TLComponents,
	TLEditorSnapshot,
	TLEventMapHandler,
	TLRecord,
	Tldraw,
	squashRecordDiffs,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

function SaveButton() {
	const editor = useEditor()
	const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

	const rUnsavedChanges = useRef<RecordsDiff<TLRecord>>({ added: {}, removed: {}, updated: {} })

	useEffect(() => {
		// [1]
		const handleDocumentChange: TLEventMapHandler<'change'> = (diff) => {
			squashRecordDiffs([rUnsavedChanges.current, diff.changes], { mutateFirstDiff: true })
			setHasUnsavedChanges(
				!isPlainObjectEmpty(rUnsavedChanges.current.added) ||
					!isPlainObjectEmpty(rUnsavedChanges.current.removed) ||
					!isPlainObjectEmpty(rUnsavedChanges.current.updated)
			)
		}

		// [2]
		return editor.store.listen(handleDocumentChange, { scope: 'document' })
	}, [editor])

	// [3]
	const handleSave = useCallback(() => {
		// The diff is the difference between the current document and the last saved document
		const diff = rUnsavedChanges.current

		// Maybe also get the current document / schema snapshot
		const snapshot = editor.getSnapshot()

		// Save everything somewhere...
		saveChanges(diff, snapshot)

		// Clear the unsaved changes state
		setHasUnsavedChanges(false)

		// Reset the diff
		rUnsavedChanges.current = {
			added: {},
			removed: {},
			updated: {},
		}
	}, [editor])

	return (
		<button
			onClick={handleSave}
			disabled={!hasUnsavedChanges}
			style={{
				pointerEvents: 'all',
				padding: '8px 16px',
				marginTop: '6px',
				backgroundColor: hasUnsavedChanges ? '#2d7d32' : '#ccc',
				color: hasUnsavedChanges ? 'white' : '#666',
				border: 'none',
				borderRadius: '4px',
				cursor: hasUnsavedChanges ? 'pointer' : 'not-allowed',
				fontWeight: '500',
			}}
		>
			{hasUnsavedChanges ? 'Save Changes' : 'No Changes'}
		</button>
	)
}

function saveChanges(_diff: RecordsDiff<TLRecord>, _snapshot: TLEditorSnapshot) {
	// todo: do something with the diff, or save the whole document snapshot somewhere
}

function isPlainObjectEmpty(obj: object) {
	for (const key in obj) return false
	return true
}

// [4]
const components: TLComponents = {
	TopPanel: SaveButton,
}

export default function UnsavedChangesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/*
This example shows how to track unsaved changes in a tldraw document using the store's
listen method with document scope, and how to accumulate a diff of all changes since
the last save.

[1]
We create a handler that will be called whenever there are changes to the document.
The handler receives a diff of the changes that occurred. We use `squashRecordDiffs`
to accumulate all changes since the last save into a single diff object. This gives
us a complete picture of what has changed without storing redundant intermediate states.

[2]
We listen to store changes with the 'document' scope, which means we only get notified
about changes to document content (shapes, pages, etc.) and not to instance data like
camera position or selected shapes.

[3]
The save function demonstrates how you might handle saving in a real application. We
pass both the accumulated diff (showing exactly what changed since last save) and a
complete snapshot of the current document state to our save function. After saving,
we reset both the unsaved changes flag and the accumulated diff. In a real application,
you might send just the diff to minimize bandwidth, or save the full snapshot for
simpler server-side handling.

[4]
We define our component overrides outside of the React component to keep them static.
This prevents unnecessary re-renders and follows React best practices. The SaveButton
component is placed in the TopPanel to provide a prominent save interface.
*/
```

--------

# Signals

Category: Events & effects

Keywords: signia, state, store, side, effects, subscribe, track

React to changes by using signals.

tldraw uses signals to manage its state and store. You can subscribe to values in the store and run
side effects when they change. This example shows some ways of doing that.

## App.tsx

```tsx
import { TLComponents, Tldraw, track, useEditor, useReactor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const InfoPanel = track(() => {
	const editor = useEditor()
	const tool = editor.getCurrentToolId()
	const zoom = editor.getZoomLevel().toFixed(2)
	useReactor(
		'change title',
		() => {
			const shapes = editor.getCurrentPageShapes()
			document.title = `shapes: ${shapes.length}`
		},
		[editor]
	)
	return (
		<div style={{ pointerEvents: 'all', backgroundColor: 'thistle', fontSize: 14, padding: 8 }}>
			<div>tool: {tool}</div>
			<div>zoom: {zoom}</div>
		</div>
	)
})

// [2]
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function AlternativeInfoPanel() {
	const editor = useEditor()
	const tool = useValue(
		'current tool',
		() => {
			if (!editor) throw new Error('No editor')
			return `Current Tool: ${editor.getCurrentToolId()}`
		},
		[editor]
	)
	const zoom = useValue(
		'zoom',
		() => {
			if (!editor) throw new Error('No editor')
			return `Zoom Level: ${editor.getZoomLevel().toFixed(2)}`
		},
		[editor]
	)

	return (
		<div style={{ pointerEvents: 'all', backgroundColor: 'thistle', fontSize: 14, padding: 8 }}>
			<div>{tool}</div>
			<div>{zoom}</div>
		</div>
	)
}

const components: TLComponents = {
	SharePanel: InfoPanel,
}

export default function StateStoreExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/*

tldraw uses signals to manage its state and store. You can subscribe to values in the store
and run side effects when they change.

[1]
	Our InfoPanel component will display above the style panel. We want it to show the current
	selected tool and zoom level of the editor. In order to make sure it displays up-to-date
	information, we can wrap the component in the track function. This will track any signals
	used in the component and re-render it when they change.

	We also use the useReactor hook to update the document title with the number of shapes. This
	side effect will run whenever the shapes on the page change. We pass the editor as a
	dependency to the useReactor hook so it will always have the latest editor instance.
	useQuickReactor runs immediately, whereas useReactor runs on the next animation frame.

[2]
	We can also use the useValue hook to subscribe to a value in the store. You can pass it a
	value or a function. Functions will be memoized and only re-run when the dependencies change.

*/
```

--------

# Canvas events

Category: Events & effects

Keywords: cursor, pointer, mouse, click, keyboard, handler, input

Listen to events from tldraw's canvas.

This example listens to events from tldraw's canvas and shows them on the right-hand-side. Try moving your cursor, dragging, using modifier keys, etc.

## App.tsx

```tsx
import { useCallback, useState } from 'react'
import { TLEventInfo, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!
type TimedEvent = TLEventInfo & { lastUpdated: number }

export default function CanvasEventsExample() {
	const [events, setEvents] = useState<Record<string, TimedEvent>>({})

	const handleEvent = useCallback((data: TLEventInfo) => {
		// Update the event entry for this event type with new data
		// This replaces previous event data of this type completely, keeping one per type
		setEvents((prevEvents) => ({
			...prevEvents,
			[data.type]: {
				...data,
				lastUpdated: Date.now(),
			},
		}))
	}, [])

	// Convert events to array and sort by lastUpdated ascending (newest at bottom)
	const eventsArray = Object.values(events).sort((a, b) => a.lastUpdated - b.lastUpdated)

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '50%', height: '100vh' }}>
				<Tldraw
					onMount={(editor) => {
						editor.on('event', (event) => handleEvent(event))
					}}
				/>
			</div>
			<div
				style={{
					width: '50%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					display: 'flex',
					flexDirection: 'column-reverse',
					overflow: 'auto',
					whiteSpace: 'pre-wrap',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				<pre>{JSON.stringify(eventsArray, undefined, 2)}</pre>
			</div>
		</div>
	)
}

/*
This example shows how to listen to canvas events. This includes things like pointer and
keyboard events, but not things such as undo/redo, create/delete shapes, etc. Those are store events.

To listen to changes to the store, check out the store events example.
*/
```

--------

# Store events

Category: Events & effects

Keywords: listen, changes

Listen to changes from tldraw's store.

This example listens to changes from tldraw's store and shows them on the right-hand-side. Try creating & deleting shapes, or switching pages. The changes will be logged next to the canvas.

## App.tsx

```tsx
import _ from 'lodash'
import { useCallback, useEffect, useState } from 'react'
import { Editor, TLEventMapHandler, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function StoreEventsExample() {
	const [editor, setEditor] = useState<Editor>()

	const setAppToState = useCallback((editor: Editor) => {
		setEditor(editor)
	}, [])

	const [storeEvents, setStoreEvents] = useState<string[]>([])

	useEffect(() => {
		if (!editor) return

		function logChangeEvent(eventName: string) {
			setStoreEvents((events) => [...events, eventName])
		}

		//[1]
		const handleChangeEvent: TLEventMapHandler<'change'> = (change) => {
			// Added
			for (const record of Object.values(change.changes.added)) {
				if (record.typeName === 'shape') {
					logChangeEvent(`created shape (${record.type})\n`)
				}
			}

			// Updated
			for (const [from, to] of Object.values(change.changes.updated)) {
				if (
					from.typeName === 'instance' &&
					to.typeName === 'instance' &&
					from.currentPageId !== to.currentPageId
				) {
					logChangeEvent(`changed page (${from.currentPageId}, ${to.currentPageId})`)
				} else if (from.id.startsWith('shape') && to.id.startsWith('shape')) {
					let diff = _.reduce(
						from,
						(result: any[], value, key: string) =>
							_.isEqual(value, (to as any)[key]) ? result : result.concat([key, (to as any)[key]]),
						[]
					)
					if (diff?.[0] === 'props') {
						diff = _.reduce(
							(from as any).props,
							(result: any[], value, key) =>
								_.isEqual(value, (to as any).props[key])
									? result
									: result.concat([key, (to as any).props[key]]),
							[]
						)
					}
					logChangeEvent(`updated shape (${JSON.stringify(diff)})\n`)
				}
			}

			// Removed
			for (const record of Object.values(change.changes.removed)) {
				if (record.typeName === 'shape') {
					logChangeEvent(`deleted shape (${record.type})\n`)
				}
			}
		}

		// [2]
		const cleanupFunction = editor.store.listen(handleChangeEvent, { source: 'user', scope: 'all' })

		return () => {
			cleanupFunction()
		}
	}, [editor])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '60%', height: '100vh' }}>
				<Tldraw onMount={setAppToState} />
			</div>
			<div
				style={{
					width: '40%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					display: 'flex',
					flexDirection: 'column-reverse',
					overflow: 'auto',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				<pre>{storeEvents}</pre>
			</div>
		</div>
	)
}

/*
This example shows how to listen to store events. This includes things creating/deleting shapes,
or moving between pages, but not things such as pointer and keyboard events. Those are canvas events.
To listen to changes to the canvas, check out the canvas events example.

[1]
This is the fire hose, it will be called at the end of every transaction. We're checking to see what
kind of changes were made and logging a more readable message to the to our panel.

[2]
This is the function that subscribes to changes to the store. You pass in the callback function that
you want to execute along with a handy filter object. In this case, we're only listening to changes
that were made by the user. It also returns a cleanup function that you can shove into the return of
a useeffect hook.

*/
```

--------

# UI events

Category: Events & effects

Keywords: ui, events, api, x-ray

Listen to UI events.

This example listens to UI events and shows them on the right-hand-side. Try creating & deleting shapes, or switching pages. The events will be logged next to the canvas.

Try selecting tools, using keyboard shortcuts, undo/redo, etc. Events will be logged next to the canvas.

## App.tsx

```tsx
import { Fragment, useCallback, useState } from 'react'
import { TLUiEventHandler, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { getCodeSnippet } from './codeSnippets'

// There's a guide at the bottom of this file!

export default function UiEventsExample() {
	const [uiEvents, setUiEvents] = useState<string[]>([])

	const handleUiEvent = useCallback<TLUiEventHandler>((name, data: any) => {
		const codeSnippet = getCodeSnippet(name, data)
		setUiEvents((events) => [
			...events,
			`event: ${name} ${JSON.stringify(data)}${codeSnippet && `\ncode:  ${codeSnippet}`}`,
		])
	}, [])

	return (
		<div style={{ display: 'flex' }}>
			<div style={{ width: '60%', height: '100vh' }}>
				<Tldraw onUiEvent={handleUiEvent} />
			</div>
			<div
				style={{
					width: '40%',
					height: '100vh',
					padding: 8,
					background: '#eee',
					border: 'none',
					fontFamily: 'monospace',
					fontSize: 12,
					borderLeft: 'solid 2px #333',
					overflow: 'auto',
				}}
				onCopy={(event) => event.stopPropagation()}
			>
				{uiEvents.map((t, i) => (
					<Fragment key={i}>
						<pre style={{ borderBottom: '1px solid #000', marginBottom: 0, paddingBottom: '12px' }}>
							{t}
						</pre>
					</Fragment>
				))}
			</div>
		</div>
	)
}

/*
This example shows how to listen to UI events. This includes includes things like selecting a tool,
grouping shapes, zooming etc. Events are included even if they are triggered by a keyboard shortcut.
However, interactions with the style panel are not included. For a full list of events and sources,
check out the TLUiEventSource and TLUiEventMap types.

It also shows the relevant code snippet for each event. This is useful for debugging and learning
the tldraw SDK.

We can pass a handler function to the onUiEvent prop of the Tldraw component. This handler function
will be called with the name of the event and the data associated with the event. We're going to
display these events in a list on the right side of the screen.

To listen to canvas events or changes to the store, check out the canvas events and store events
examples.

*/
```

## codeSnippets.ts

```ts
const STYLE_EVENT = {
	'tldraw:color': 'DefaultColorStyle',
	'tldraw:dash': 'DefaultDashStyle',
	'tldraw:fill': 'DefaultFillStyle',
	'tldraw:font': 'DefaultFontStyle',
	'tldraw:horizontalAlign': 'DefaultHorizontalAlignStyle',
	'tldraw:size': 'DefaultSizeStyle',
	'tldraw:verticalAlign': 'DefaultVerticalAlignStyle',
	'tldraw:geo': 'GeoShapeGeoStyle',
}

const REORDER_EVENT = {
	toFront: 'bringToFront',
	forward: 'bringForward',
	backward: 'sendBackward',
	toBack: 'sendToBack',
}

const SHAPES_META_EVENT = {
	'group-shapes': 'groupShapes',
	'ungroup-shapes': 'ungroupShapes',
	'delete-shapes': 'deleteShapes',
}

const SHAPES_EVENT = {
	'distribute-shapes': 'distributeShapes',
	'align-shapes': 'alignShapes',
	'stretch-shapes': 'stretchShapes',
	'flip-shapes': 'flipShapes',
}

const USER_PREFS_EVENT = {
	'toggle-snap-mode': 'isSnapMode',
	'toggle-dark-mode': 'isDarkMode',
	'toggle-reduce-motion': 'animationSpeed',
	'toggle-edge-scrolling': 'edgeScrollSpeed',
}

const PREFS_EVENT = {
	'toggle-transparent': 'exportBackground',
	'toggle-tool-lock': 'isToolLocked',
	'toggle-focus-mode': 'isFocusMode',
	'toggle-grid-mode': 'isGridMode',
	'toggle-debug-mode': 'isDebugMode',
}

const ZOOM_EVENT = {
	'zoom-in': 'zoomIn',
	'zoom-out': 'zoomOut',
	'reset-zoom': 'resetZoom',
	'zoom-to-fit': 'zoomToFit',
	'zoom-to-selection': 'zoomToSelection',
}

export function getCodeSnippet(name: string, data: any) {
	let codeSnippet = ''

	if (name === 'set-style') {
		if (data.id === 'opacity') {
			codeSnippet = `editor.setOpacityForNextShapes(${data.value});`
		} else {
			codeSnippet = `editor.setStyleForNextShapes(${
				STYLE_EVENT[data.id as keyof typeof STYLE_EVENT] ?? '?'
			}, '${data.value}');`
		}
	} else if (['rotate-ccw', 'rotate-cw'].includes(name)) {
		codeSnippet = 'editor.rotateShapesBy(editor.getSelectedShapeIds(), <number>)'
	} else if (name === 'edit-link') {
		codeSnippet =
			'editor.updateShapes([{ id: editor.getOnlySelectedShape().id, type: editor.getOnlySelectedShape().type, props: { url: <url> }, }, ])'
	} else if (name.startsWith('export-as')) {
		codeSnippet = `exportAs(editor.getSelectedShapeIds(), '${data.format}')`
	} else if (name.startsWith('copy-as')) {
		codeSnippet = `copyAs(editor.getSelectedShapeIds(), '${data.format}')`
	} else if (name === 'select-all-shapes') {
		codeSnippet = `editor.selectAll()`
	} else if (name === 'select-none-shapes') {
		codeSnippet = `editor.selectNone()`
	} else if (name === 'reorder-shapes') {
		codeSnippet = `editor.${
			REORDER_EVENT[data.operation as keyof typeof REORDER_EVENT] ?? '?'
		}(editor.getSelectedShapeIds())`
	} else if (['group-shapes', 'ungroup-shapes', 'delete-shapes'].includes(name)) {
		codeSnippet = `editor.${
			SHAPES_META_EVENT[name as keyof typeof SHAPES_META_EVENT] ?? '?'
		}(editor.getSelectedShapeIds())`
	} else if (name === 'stack-shapes') {
		codeSnippet = `editor.stackShapes(editor.getSelectedShapeIds(), '${data.operation}', 16)`
	} else if (name === 'pack-shapes') {
		codeSnippet = `editor.packShapes(editor.getSelectedShapeIds(), 16)`
	} else if (name === 'duplicate-shapes') {
		codeSnippet = `editor.duplicateShapes(editor.getSelectedShapeIds(), {x: <value>, y: <value>})`
	} else if (name.endsWith('-shapes')) {
		codeSnippet = `editor.${
			SHAPES_EVENT[name as keyof typeof SHAPES_EVENT] ?? '?'
		}(editor.getSelectedShapeIds(), '${data.operation}')`
	} else if (name === 'select-tool') {
		if (data.id === 'media') {
			codeSnippet = 'insertMedia()'
		} else if (data.id.startsWith('geo-')) {
			codeSnippet = `\n  editor.updateInstanceState({
  stylesForNextShape: {
    ...editor.getInstanceState().stylesForNextShape,
    [GeoShapeGeoStyle.id]: '${data.id.replace('geo-', '')}',
  },
}, { ephemeral: true });
editor.setCurrentTool('${data.id}')`
		} else {
			codeSnippet = `editor.setCurrentTool('${data.id}')`
		}
	} else if (name === 'print') {
		codeSnippet = 'printSelectionOrPages()'
	} else if (name === 'unlock-all') {
		codeSnippet = `\n  const updates = [] as TLShapePartial[]
for (const shape of editor.getCurrentPageShapes()) {
  if (shape.isLocked) {
    updates.push({ id: shape.id, type: shape.type, isLocked: false })
  }
}
if (updates.length > 0) {
  editor.updateShapes(updates)
}`
	} else if (['undo', 'redo'].includes(name)) {
		codeSnippet = `editor.${name}()`
	} else if (['cut', 'copy'].includes(name)) {
		codeSnippet = `\n  const { ${name} } = useMenuClipboardEvents();\n  ${name}()`
	} else if (name === 'paste') {
		codeSnippet = `\n  const { paste } = useMenuClipboardEvents();\n  navigator.clipboard?.read().then((clipboardItems) => {\n    paste(clipboardItems)\n  })`
	} else if (name === 'stop-following') {
		codeSnippet = `editor.stopFollowingUser()`
	} else if (name === 'exit-pen-mode') {
		codeSnippet = `editor.updateInstanceState({ isPenMode: false })`
	} else if (name === 'remove-frame') {
		codeSnippet = `removeFrame(editor, editor.getSelectedShapes().map((shape) => shape.id))`
	} else if (name === 'fit-frame-to-content') {
		codeSnippet = `fitFrameToContent(editor, editor.getOnlySelectedShape().id)`
	} else if (name.startsWith('zoom-') || name === 'reset-zoom') {
		codeSnippet = `editor.${ZOOM_EVENT[name as keyof typeof ZOOM_EVENT]}(${
			name !== 'zoom-to-fit' && name !== 'zoom-to-selection'
				? 'editor.getViewportScreenCenter(), '
				: ''
		}{ duration: 320 })`
	} else if (name.startsWith('toggle-')) {
		if (name === 'toggle-lock') {
			codeSnippet = `editor.toggleLock(editor.getSelectedShapeIds())`
		} else {
			const userPrefName = USER_PREFS_EVENT[name as keyof typeof USER_PREFS_EVENT]
			const prefName = PREFS_EVENT[name as keyof typeof PREFS_EVENT]
			codeSnippet = userPrefName
				? `editor.user.updateUserPreferences({ ${userPrefName}: <value> })`
				: `editor.updateInstanceState({ ${prefName}: !editor.getInstanceState().${prefName} })`
		}
	}

	return codeSnippet
}
```

--------

# Block events

Category: Events & effects

Keywords: event, block, propagation, stop, no, select, user-select

Stop events from reaching the canvas.

If you don't want the user's interactions to reach the canvas, you can call `stopPropagation` on the user's pointer events.

## App.tsx

```tsx
import { TLComponents, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

function WelcomeScreen() {
	return (
		<div
			style={{
				position: 'absolute',
				inset: 0,
				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center',
				pointerEvents: 'none', // [1]
			}}
		>
			<div
				style={{
					padding: 32,
					borderRadius: 20,
					boxShadow: '2px 2px 12px rgba(0,0,0,.2)',
					backgroundColor: 'white',
					pointerEvents: 'all', // [2]
					width: 400,
				}}
			>
				<p
					style={{
						userSelect: 'text', // [3]
					}}
				>
					Notice that if you click on this box or start a drag from in here, you will not be
					interacting with the canvas. However, you can still interact with the canvas by clicking
					anywhere else!
				</p>
				<div>
					<button onClick={() => window.alert('Thanks')}>Click here</button>
				</div>
			</div>
		</div>
	)
}

const components: TLComponents = {
	InFrontOfTheCanvas: WelcomeScreen,
}

export default function EventBlockerExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}

/*
[1]
This div will overlay the whole canvas. We want the user's pointer events to
pass through this div rather than getting blocked by it div, so we turn
pointer events off.

[2]
This is the container that's centered on the screen. For this div, we want to
block pointer events so that the user can't interact with the canvas behind it,
so we turn pointer events on.

[3]
As a side note, we also turn off user-select for anything inside of the canvas.
If you want the user to be able to select text, you can set this style to 'all'.
*/
```

--------

# Prevent instance changes

Category: Events & effects

Keywords: side, effect, instance, grid, mode, prevent

Prevent a change to the "instance" record that would turn off grid mode.

You can use Editor's side effects API to prevent certain changes from occurring in the instance state. In this example, we prevent the user from changing the instance's `isGridMode` property.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

export default function PreventInstanceChangeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.updateInstanceState({ isGridMode: true })

					// [1]
					editor.sideEffects.registerBeforeChangeHandler('instance', (prev, next) => {
						if (!next.isGridMode) {
							return prev
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
In this example, we want to prevent the user from changing the isGridMode property.

[1]
Here we register a handler that will run whenever a change is about to be made to
to an "instance" type record.

The logic we want is that: if the new instance has `isGridMode` set to `false`, then
we want to reject the change; otherwise, we want to allow it.

To reject the change, we return the previous record. To allow the change, we
return the next record.
*/
```

--------

# Prevent shape changes

Category: Events & effects

Keywords: side, effect, move, prevent

Prevent changes to a shape's properties.

You can use Editor's side effects API to prevent certain changes from occurring in a shape. In this example, we prevent any changes to the shape's position, rotation, or size.

## App.tsx

```tsx
import { Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this page!

export default function PreventMoveExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.createShape({
						type: 'geo',
						x: 100,
						y: 100,
						props: {
							w: 300,
							h: 300,
							richText: toRichText("style me but don't transform me"),
						},
					})

					// [1]
					editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
						if (
							editor.isShapeOfType(prev, 'geo') &&
							editor.isShapeOfType(next, 'geo') &&
							next.props.geo === 'rectangle'
						) {
							if (
								next.x !== prev.x ||
								next.y !== prev.y ||
								next.rotation !== prev.rotation ||
								next.props.w !== prev.props.w ||
								next.props.h !== prev.props.h
							) {
								return prev
							}
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
[1]
Here we register a handler that will run whenever a change is about to be made to
a shape's record.

The logic we want is that: if the shape is a geo shape and a rectangle, and then
if the x, y, or rotation properties would be different in the next version of
the shape record, or if the props.w, or props.h properties would change, then
we want to reject the change; otherwise, we want to allow it.

To reject the change, we return the previous record. To allow the change, we
return the next record.
*/
```

--------

# Prevent multi-shape selection

Category: Events & effects

Keywords: selection, editor, instance, state

This example demonstrates how to prevent users from selecting multiple shapes at once in tldraw.

You can prevent multiple shape selection by registering a before-change handler for the `instance_page_state` type. This handler intercepts selection changes and ensures only one shape can be selected at a time.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function PreventMultiShapeSelectionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// [1]
					editor.sideEffects.registerBeforeChangeHandler('instance_page_state', (prev, next) => {
						// [2]
						if (
							prev.selectedShapeIds !== next.selectedShapeIds &&
							next.selectedShapeIds.length > 1
						) {
							return {
								...next,
								selectedShapeIds: [next.selectedShapeIds[next.selectedShapeIds.length - 1]],
							}
						}
						return next
					})
				}}
			/>
		</div>
	)
}

/*
In this example, we want to prevent the user from selecting multiple shapes at once.

[1]
Here we register a handler that will run whenever a change is about to be made to
an "instance_page_state" type record, which contains the current selection state.

[2]
We check if this is a selection change and if it would result in multiple shapes being selected.
If both conditions are true, we modify the change to only select the most recently
selected shape by returning a new record with a single selected shape id.
*/
```

--------

# Before create/update shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run before shapes are created or updated.

You can intercept the creation or update of any record in the store and return a new record to be
used in it place. In this example, we lock shapes to a circle in the center of the screen.

## App.tsx

```tsx
import { Box, Editor, SVGContainer, TLShape, Tldraw, Vec, isShapeId } from 'tldraw'
import 'tldraw/tldraw.css'

// This function takes a shape and returns a new shape where the x/y origin is within `radius`
// distance of the center of the page. If the shape is already within `radius` (or isn't parented to
// the page) it returns the same shape.
function constrainShapeToRadius(editor: Editor, shape: TLShape, radius: number) {
	// if the shape is parented to another shape (instead of the page) leave it as-is
	if (isShapeId(shape.parentId)) return shape

	// get the position of the shape
	const shapePoint = Vec.From(shape)
	const distanceFromCenter = shapePoint.len()

	// if the shape is outside the radius, move it to the edge of the radius:
	if (distanceFromCenter > radius) {
		const newPoint = shapePoint.uni().mul(radius)
		return {
			...shape,
			x: newPoint.x,
			y: newPoint.y,
		}
	}

	// otherwise, leave the shape as-is
	return shape
}

export default function BeforeCreateUpdateShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// we can run our `constrainShapeToRadius` function before any shape is created
					// or changed. These `sideEffects` handlers let us take modify the shape that
					// will be created or updated by returning a new one to be used in its place.
					editor.sideEffects.registerBeforeCreateHandler('shape', (shape) => {
						return constrainShapeToRadius(editor, shape, 500)
					})
					editor.sideEffects.registerBeforeChangeHandler('shape', (prevShape, nextShape) => {
						return constrainShapeToRadius(editor, nextShape, 500)
					})

					// center the camera on the area we're constraining shapes to
					editor.zoomToBounds(new Box(-500, -500, 1000, 1000))

					// lock the camera on that area
					editor.setCameraOptions({ isLocked: true })
				}}
				components={{
					// to make it a little clearer what's going on in this example, we'll draw a
					// circle on the canvas showing where shapes are being constrained to.
					OnTheCanvas: () => (
						<SVGContainer>
							<circle cx={0} cy={0} r={500} fill="none" stroke="black" />
						</SVGContainer>
					),
				}}
			/>
		</div>
	)
}
```

--------

# Before delete shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run before shapes are deleted.

You can intercept the creation of any record in the store. This example intercepts arrow creation to
make sure each arrow has a label. You can do the same thing to change the props of any newly created
shape.

## App.tsx

```tsx
import { Editor, Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function BeforeDeleteShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// register a handler to run before any shape is deleted:
					editor.sideEffects.registerBeforeDeleteHandler('shape', (shape) => {
						// if the shape is red, prevent the deletion:
						if ('color' in shape.props && shape.props.color === 'red') {
							return false
						}

						return
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// create some shapes to demonstrate the side-effect we added
function createDemoShapes(editor: Editor) {
	editor
		.createShapes([
			{
				id: createShapeId(),
				type: 'text',
				props: {
					richText: toRichText("Red shapes can't be deleted"),
					color: 'red',
				},
			},
			{
				id: createShapeId(),
				type: 'text',
				y: 30,
				props: {
					richText: toRichText('but other shapes can'),
					color: 'black',
				},
			},
		])
		.zoomToFit({ animation: { duration: 0 } })
}
```

--------

# Custom double-click behavior

Category: Events & effects

Keywords: double click, runtime override, state node, select tool, custom behavior

Override the default double-click behavior by replacing the SelectTool's Idle state method at runtime.

This example shows how to customize the double-click behavior on canvas by overriding the SelectTool's Idle state's `handleDoubleClickOnCanvas` method from the `onMount` callback.

The example demonstrates runtime method replacement, which is a powerful technique for customizing built-in tool behavior without creating entirely new tools. In this simplified version, double-clicking on the canvas shows an alert instead of creating a text shape, demonstrating the basic pattern for method override.

This pattern is useful when you want to extend existing tool behavior, add conditional logic, or customize built-in interactions without forking the entire tool.

## App.tsx

```tsx
import { StateNode, TLClickEventInfo, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function CustomDoubleClickBehaviorExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [1]
				onMount={(editor) => {
					// [2]
					type IdleStateNode = StateNode & {
						handleDoubleClickOnCanvas(info: TLClickEventInfo): void
					}

					// [3]
					const selectIdleState = editor.getStateDescendant<IdleStateNode>('select.idle')
					if (!selectIdleState) throw Error('SelectTool Idle state not found')

					// [4]
					function customDoubleClickOnCanvasHandler(_info: TLClickEventInfo) {
						// Your custom behavior goes here...
						window.alert('double clicked on the canvas')
					}

					// [5]
					selectIdleState.handleDoubleClickOnCanvas =
						customDoubleClickOnCanvasHandler.bind(selectIdleState)
				}}
			/>
		</div>
	)
}

/*
This example demonstrates how to customize the double-click behavior on canvas
by overriding the SelectTool's Idle state's handleDoubleClickOnCanvas method.

Key concepts:

[1] onMount callback:
    The onMount callback gives us access to the editor instance after it's
    fully initialized. This is where we can access and modify built-in tools.

[2] Type definition for IdleStateNode:
    We create a type that extends StateNode and includes the handleDoubleClickOnCanvas
    method. This gives us proper TypeScript support when accessing the method.

[3] Getting the SelectTool's Idle state:
    We use `editor.getStateDescendant<IdleStateNode>('select.idle')` to get a
    reference to the Idle state of the SelectTool. The path 'select.idle'
    refers to the SelectTool's 'idle' child state.

[4] Custom handler function:
    We define our custom behavior in a separate function. This keeps the code
    clean and makes it easy to test or reuse the handler logic.

[5] Method replacement with binding:
    We replace the original handleDoubleClickOnCanvas method with our custom
    implementation, binding it to the selectIdleState context so that `this`
    refers to the correct state node when the function is called. This
    completely overrides the default behavior.

The handleDoubleClickOnCanvas method is called when the user double-clicks on
the canvas (not on a shape). By overriding this method, we can customize what
happens when the user double-clicks on empty space.

Note: This approach completely replaces the original method. If you want to
preserve the original behavior and add to it, you should store a reference
to the original method before replacing it, then call it from your custom
implementation when appropriate.
*/
```

--------

# After create/update shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run after shapes are created or updated.

You can register handlers to run after any record is created or updated. This is most useful for
updating _other_ records in response to a particular record changing. In this example, we make sure
there's only ever one red shape on a page.

## App.tsx

```tsx
import { Editor, TLShape, TLShapeId, Tldraw, createShapeId, toRichText } from 'tldraw'

type ShapeWithColor = Extract<TLShape, { props: { color: string } }>

// this function takes a shape ID, and if that shape is red, sets all other red shapes on the same
// page to black.
function ensureOnlyOneRedShape(editor: Editor, shapeId: TLShapeId) {
	// grab the shape and check it's red:
	const shape = editor.getShape(shapeId)!
	if (!isRedShape(shape)) return

	// get the ID of the page that shape belongs to:
	const pageId = editor.getAncestorPageId(shape.id)!

	// find any other red shapes on the same page:
	const otherRedShapesOnPage = Array.from(editor.getPageShapeIds(pageId))
		.map((id) => editor.getShape(id)!)
		.filter(
			(otherShape): otherShape is ShapeWithColor =>
				otherShape.id !== shape.id && isRedShape(otherShape)
		)

	// set the color of all those shapes to black:
	editor.updateShapes(
		otherRedShapesOnPage.map((shape) => ({
			id: shape.id,
			type: shape.type,
			props: {
				color: 'black',
			},
		}))
	)
}

function isRedShape(shape: TLShape) {
	return 'color' in shape.props && shape.props.color === 'red'
}

export default function AfterCreateUpdateShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// we can run our `ensureOnlyOneRedShape` function after any shape is created or
					// changed. this means we can enforce our "only one red shape at a time" rule,
					// while making sure that the shape most recently set to red is the one that
					// stays red.
					editor.sideEffects.registerAfterCreateHandler('shape', (shape) => {
						ensureOnlyOneRedShape(editor, shape.id)
					})
					editor.sideEffects.registerAfterChangeHandler('shape', (prevShape, nextShape) => {
						ensureOnlyOneRedShape(editor, nextShape.id)
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// create some shapes to demonstrate the side-effects we added
function createDemoShapes(editor: Editor) {
	editor
		.createShapes(
			'there can only be one red shape'.split(' ').map((word, i) => ({
				id: createShapeId(),
				type: 'text',
				y: i * 30,
				props: {
					color: i === 5 ? 'red' : 'black',
					richText: toRichText(word),
				},
			}))
		)
		.zoomToFit({ animation: { duration: 0 } })
}
```

--------

# After delete shape

Category: Events & effects

Keywords: handler, register, side effects, records

Register a handler to run after shapes are deleted.

You can register handlers to run after any record is deleted. In this example, we delete frames
after the last shape inside them is deleted.

## App.tsx

```tsx
import { Editor, Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function AfterDeleteShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// register a handler to run after any shape is deleted:
					editor.sideEffects.registerAfterDeleteHandler('shape', (shape) => {
						// grab the parent of the shape and check if it's a frame:
						const parentShape = editor.getShape(shape.parentId)
						if (parentShape && parentShape.type === 'frame') {
							// if it is, get the IDs of all its remaining children:
							const siblings = editor.getSortedChildIdsForParent(parentShape.id)

							// if there are none (so the frame is empty), delete the frame:
							if (siblings.length === 0) {
								editor.deleteShape(parentShape.id)
							}
						}
					})

					createDemoShapes(editor)
				}}
			/>
		</div>
	)
}

// crate some demo shapes to show off the new side-effect we added
function createDemoShapes(editor: Editor) {
	const frameId = createShapeId()
	editor.createShapes([
		{
			id: frameId,
			type: 'frame',
			props: { w: 400, h: 200 },
		},
		{
			id: createShapeId(),
			type: 'text',
			parentId: frameId,
			x: 50,
			y: 40,
			props: {
				richText: toRichText('Frames will be deleted when their last child is.'),
				w: 300,
				autoSize: false,
			},
		},
		...[50, 180, 310].map((x) => ({
			id: createShapeId(),
			type: 'geo' as const,
			parentId: frameId,
			x,
			y: 120,
			props: { w: 40, h: 40 },
		})),
	])

	editor.zoomToFit({ animation: { duration: 0 } })
}
```

--------

# Permissions

Category: Events & effects

Keywords: constraints, bounds, side effects, permissions, clamping

Use side effect APIs to constrain shape movement within a bounding box.

This example demonstrates how to use tldraw's side effect APIs to enforce permissions or
constraints on shapes. Try dragging the rectangle around - its movement is constrained to
stay within the dashed container using the `registerBeforeChangeHandler` side effect.
This pattern is useful for implementing permission systems, bounded regions, or any scenario
where you need to restrict where shapes can be positioned.

## App.tsx

```tsx
import { Box, Editor, SVGContainer, TLGeoShape, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const CONTAINER_BOUNDS = new Box(100, 100, 400, 300)

// [2]
function constrainShapeToBounds(editor: Editor, shape: TLGeoShape) {
	const shapeGeometry = editor.getShapeGeometry(shape)
	const shapeBounds = shapeGeometry.bounds

	// Calculate the shape's world-space bounds
	const shapeWorldBounds = Box.From({
		x: shape.x + shapeBounds.x,
		y: shape.y + shapeBounds.y,
		w: shapeBounds.w,
		h: shapeBounds.h,
	})

	// Check if the shape is completely within the container
	if (CONTAINER_BOUNDS.contains(shapeWorldBounds)) {
		return shape
	}

	// [3]
	// Clamp the shape's position so it stays within bounds
	const clampedX = Math.max(
		CONTAINER_BOUNDS.x - shapeBounds.x,
		Math.min(shape.x, CONTAINER_BOUNDS.maxX - shapeBounds.x - shapeBounds.w)
	)
	const clampedY = Math.max(
		CONTAINER_BOUNDS.y - shapeBounds.y,
		Math.min(shape.y, CONTAINER_BOUNDS.maxY - shapeBounds.y - shapeBounds.h)
	)

	return {
		...shape,
		x: clampedX,
		y: clampedY,
	}
}

export default function PermissionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// [4]
					editor.sideEffects.registerBeforeChangeHandler('shape', (prevShape, nextShape) => {
						// Only constrain geo shapes (our rectangle)
						if (nextShape.type === 'geo') {
							return constrainShapeToBounds(editor, nextShape as TLGeoShape)
						}
						return nextShape
					})

					// [5]
					// Create the constrained rectangle
					editor.createShape({
						type: 'geo',
						x: 250,
						y: 200,
						props: {
							geo: 'rectangle',
							w: 150,
							h: 100,
						},
					})

					// Zoom to show the container area
					editor.zoomToBounds(new Box(0, 0, 600, 500), { animation: { duration: 0 } })
				}}
				components={{
					// [6]
					OnTheCanvas: () => (
						<SVGContainer>
							<rect
								x={CONTAINER_BOUNDS.x}
								y={CONTAINER_BOUNDS.y}
								width={CONTAINER_BOUNDS.w}
								height={CONTAINER_BOUNDS.h}
								fill="none"
								stroke="rgba(0, 0, 0, 0.2)"
								strokeWidth={2}
								strokeDasharray="8 4"
							/>
						</SVGContainer>
					),
				}}
			/>
		</div>
	)
}

/*
[1]
Define the invisible container bounds that our shape will be constrained to. This is a box
with top-left at (100, 100) and dimensions of 400x300.

[2]
This function checks if a shape's bounds extend outside the container and returns a modified
shape with clamped position if needed. We use editor.getShapeGeometry() to get the shape's
actual geometry including any padding or offsets.

[3]
Clamp the shape's x and y coordinates so that the shape's bounds stay completely within
the container bounds. We account for the shape's geometry offset and dimensions.

[4]
Register a beforeChange handler that runs whenever any shape is about to be modified. We only
apply the constraint to geo shapes (rectangles). This handler intercepts changes and returns
a modified version of the shape with position clamped to the container.

[5]
Create a rectangle shape positioned inside our container bounds. Users can drag this shape,
but it will be prevented from leaving the container area.

[6]
Draw a dashed rectangle on the canvas to visualize the container bounds. This uses SVGContainer
to render directly on the canvas in world coordinates.
*/
```

--------

# Permissions 2

Category: Events & effects

Keywords: constraints, bounds, side effects, permissions, clamping

A second example of how to use side effect APIs to constrain shape movement within a bounding box.

This example demonstrates how to use tldraw's side effect APIs to enforce permissions or
constraints on shapes. We create a rectangle that can be dragged around, but its movement
is constrained to stay within an invisible container using the `registerBeforeChangeHandler`
side effect. This pattern is useful for implementing permission systems, bounded regions,
or any scenario where you need to restrict where shapes can be positioned.

## App.tsx

```tsx
import { Box, Editor, SVGContainer, TLGeoShape, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const CONTAINER_BOUNDS = new Box(100, 100, 400, 300)

// [2]
function constrainShapeToBounds(editor: Editor, shape: TLGeoShape) {
	const shapeGeometry = editor.getShapeGeometry(shape)
	const shapeBounds = shapeGeometry.bounds

	// Calculate the shape's world-space bounds
	const shapeWorldBounds = editor.getShapePageBounds(shape)

	if (!shapeWorldBounds) return shape

	// Check if the shape is completely within the container
	if (CONTAINER_BOUNDS.contains(shapeWorldBounds)) {
		return shape
	}

	// [3]
	// Calculate maximum allowed dimensions based on container size
	const maxWidth = CONTAINER_BOUNDS.w - shapeBounds.x * 2
	const maxHeight = CONTAINER_BOUNDS.h - shapeBounds.y * 2

	// Clamp the shape's size if it would exceed the container
	const clampedW = Math.min(shape.props.w, maxWidth)
	const clampedH = Math.min(shape.props.h, maxHeight)

	// Recalculate bounds with the clamped size
	const clampedShapeBounds = Box.From({
		x: shape.x + shapeBounds.x,
		y: shape.y + shapeBounds.y,
		w: (clampedW / shape.props.w) * shapeBounds.w,
		h: (clampedH / shape.props.h) * shapeBounds.h,
	})

	// Clamp the shape's position so it stays within bounds
	let clampedX = Math.max(
		CONTAINER_BOUNDS.x - shapeBounds.x,
		Math.min(shape.x, CONTAINER_BOUNDS.maxX - shapeBounds.x - clampedShapeBounds.w)
	)
	let clampedY = Math.max(
		CONTAINER_BOUNDS.y - shapeBounds.y,
		Math.min(shape.y, CONTAINER_BOUNDS.maxY - shapeBounds.y - clampedShapeBounds.h)
	)

	if (shapeBounds.w >= CONTAINER_BOUNDS.w) {
		clampedX = CONTAINER_BOUNDS.x
	}

	if (shapeBounds.h >= CONTAINER_BOUNDS.h) {
		clampedY = CONTAINER_BOUNDS.y
	}
	return {
		...shape,
		x: clampedX,
		y: clampedY,
		props: {
			...shape.props,
			w: clampedW,
			h: clampedH,
		},
	}
}

export default function PermissionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// [4]
					editor.sideEffects.registerBeforeChangeHandler('shape', (prevShape, nextShape) => {
						// Only constrain geo shapes (our rectangle)
						if (nextShape.type === 'geo') {
							return constrainShapeToBounds(editor, nextShape as TLGeoShape)
						}
						return nextShape
					})

					// [5]
					// Create the constrained rectangle
					editor.createShape({
						type: 'geo',
						x: 250,
						y: 200,
						props: {
							geo: 'rectangle',
							w: 150,
							h: 100,
							richText: toRichText('Try to drag me around'),
						},
					})

					// Zoom to show the container area
					editor.zoomToBounds(new Box(0, 0, 600, 500))
				}}
				components={{
					// [6]
					OnTheCanvas: () => (
						<SVGContainer>
							<rect
								x={CONTAINER_BOUNDS.x}
								y={CONTAINER_BOUNDS.y}
								width={CONTAINER_BOUNDS.w}
								height={CONTAINER_BOUNDS.h}
								fill="none"
								stroke="rgba(0, 0, 0, 0.2)"
								strokeWidth={2}
								strokeDasharray="8 4"
							/>
						</SVGContainer>
					),
				}}
			/>
		</div>
	)
}

/*
[1]
Define the invisible container bounds that our shape will be constrained to. This is a box
with top-left at (100, 100) and dimensions of 400x300.

[2]
This function checks if a shape's bounds extend outside the container and returns a modified
shape with clamped position if needed. We use editor.getShapeGeometry() to get the shape's
actual geometry including any padding or offsets.

[3]
First, calculate the maximum allowed dimensions and clamp the shape's size if needed. Then
clamp the position to keep the shape within bounds. This ensures the shape can neither be
moved nor resized outside the container.

[4]
Register a beforeChange handler that runs whenever any shape is about to be modified. We only
apply the constraint to geo shapes (rectangles). This handler intercepts changes and returns
a modified version of the shape with position clamped to the container.

[5]
Create a rectangle shape with text positioned inside our container bounds. Users can drag and
resize this shape, but it will be prevented from leaving or exceeding the container area.

[6]
Draw a dashed rectangle on the canvas to visualize the container bounds. This uses SVGContainer
to render directly on the canvas in world coordinates.
*/
```

--------

# Derived view

Category: Events & effects

Keywords: basic, intro, simple, quick, start

Derive data from the editor's document in an efficient way.

You can use incremental derivations to get a specific view of data.

## App.tsx

```tsx
import { isUninitialized, RESET_VALUE } from '@tldraw/state'
import { useMemo, useRef } from 'react'
import { computed, Editor, isShape, Tldraw, TLShapeId, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'

export default function DerivedViewExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="derived-view">
				<ShowNumberOfDrawShapesOnPage />
			</Tldraw>
		</div>
	)
}

function ShowNumberOfDrawShapesOnPage() {
	const editor = useEditor()
	const rRenders = useRef(0)

	// Create a computed value that tracks the number of draw shapes in the document, returning a set of ids
	const computed = useMemo(() => deriveNumberOfDrawShapesInDocument(editor), [editor])
	// Get the size of the computed value whenever the computed value changes
	const value = useValue('computed value', () => computed.get().size, [computed])

	return (
		<div style={{ position: 'absolute', top: 50, left: 20, zIndex: 99999 }}>
			<p>{value} draw shapes in project</p>
			{/* Will go up by two in dev, NAB */}
			<p>{rRenders.current++} renders</p>
		</div>
	)
}

export const deriveNumberOfDrawShapesInDocument = (editor: Editor) => {
	const { store } = editor
	const shapesIndex = store.query.ids('shape')

	// Create an index of all the shape ids of all the draw shapes
	function fromScratch() {
		return new Set([...shapesIndex.get()].filter((id) => editor.getShape(id)!.type === 'draw'))
	}

	return computed<Set<TLShapeId>>('_shapeIdsInCurrentPage', (prevValue, lastComputedEpoch) => {
		// On first load, return the initial value
		if (isUninitialized(prevValue)) {
			return fromScratch()
		}

		// Get the changes since the last computed value
		const diff = store.history.getDiffSince(lastComputedEpoch)

		// Something caused the store to reset, compute a new value from scratch
		if (diff === RESET_VALUE) {
			return fromScratch()
		}

		// This will be the new set that includes the changes, if we find any
		let nextValue: Set<TLShapeId> | undefined

		for (const changes of diff) {
			// Check all of the added records for new draw shapes
			for (const record of Object.values(changes.added)) {
				if (isShape(record) && record.type === 'draw') {
					// If we haven't created the new set yet, do it now
					if (!nextValue) {
						nextValue = new Set(prevValue)
					}
					// mutate the new set
					nextValue.add(record.id)
				}
			}

			for (const record of Object.values(changes.removed)) {
				// Check all of the removed records for deleted draw shapes
				if (isShape(record) && record.type === 'draw') {
					// If we haven't created the new set yet, do it now
					if (!nextValue) {
						nextValue = new Set(prevValue)
					}
					// mutate the new set
					nextValue.delete(record.id)
				}
			}
		}

		// if something changed, return the new value
		if (nextValue) return nextValue

		// if nothing changed, return the previous value
		return prevValue
	})
}
```

--------

# Shape meta (on change)

Category: Events & effects

Keywords: side, effects, register, change, initial

Add custom metadata to shapes when they're changed.

We can update a shape's metadata whenever it changes. A UI displays the current selected shape's metadata. Create a shape, select it, and move it around. The metadata will updated any time the shape changes.

## App.tsx

```tsx
import { TLShape, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function OnChangeShapeMetaExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="tldraw_change_meta_example"
				onMount={(editor) => {
					// [1]
					editor.getInitialMetaForShape = (_shape) => {
						return {
							updatedBy: editor.user.getId(),
							updatedAt: Date.now(),
						}
					}
					// [2]
					editor.sideEffects.registerBeforeChangeHandler('shape', (_prev, next, source) => {
						if (source !== 'user') return next
						return {
							...next,
							meta: {
								updatedBy: editor.user.getId(),
								updatedAt: Date.now(),
							},
						}
					})
				}}
			>
				<MetaUiHelper />
			</Tldraw>
		</div>
	)
}

// [3]
type ShapeWithMyMeta = TLShape & { meta: { updatedBy: string; updatedAt: string } }

// [4]
export const MetaUiHelper = track(function MetaUiHelper() {
	const editor = useEditor()
	const onlySelectedShape = editor.getOnlySelectedShape() as ShapeWithMyMeta | null

	return (
		<pre style={{ position: 'absolute', zIndex: 300, top: 64, left: 12, margin: 0 }}>
			{onlySelectedShape
				? JSON.stringify(onlySelectedShape.meta, null, '\t')
				: 'Select one shape to see its meta data.'}
		</pre>
	)
})

/*
This example shows how to add meta data to shapes when they are created and
updated. In this case we are adding `updatedBy` and `updatedAt` fields.

[1]
getInitialMetaForShape is a method you can replace at runtime. Here we use
a callback on the onMount prop to replace the default implementation with
our own.

[2]
Here we're using the side effects API to add meta data to shapes when they are
updated. You can use the side effects API to do something on create, update or
delete, and you can target many things including: shapes, pages, the camera,
the pointer etc.

[3]
All tldraw shapes have a meta property with a type of unknown. To type your
meta data you can use a union like this.

[4]
A minimal ui component that displays the meta data of the selected shape. We
use track to make sure that the component is re-rendered when the signals it's
tracking change. Check out the signals example for more info:
https://tldraw.dev/examples/signals
*/
```

--------

# Shape meta (on create)

Category: Events & effects

Keywords: side, effects, initial, meta, register

Add custom metadata to shapes when they're created.

We can update a shape's metadata whenever it is created. A UI displays the current selected shape's metadata. Create a shape and select it. The metadata will display its created at / created by data.

## App.tsx

```tsx
import { TLShape, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

export default function OnCreateShapeMetaExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="example"
				onMount={(editor) => {
					//[1]
					editor.getInitialMetaForShape = (_shape) => {
						return {
							createdBy: editor.user.getId(),
							createdAt: Date.now(),
						}
					}
				}}
			>
				<MetaUiHelper />
			</Tldraw>
		</div>
	)
}

// [2]
type ShapeWithMyMeta = TLShape & { meta: { updatedBy: string; updatedAt: string } }

// [3]
export const MetaUiHelper = track(function MetaUiHelper() {
	const editor = useEditor()
	const onlySelectedShape = editor.getOnlySelectedShape() as ShapeWithMyMeta | null

	return (
		<pre style={{ position: 'absolute', zIndex: 300, top: 64, left: 12, margin: 0 }}>
			{onlySelectedShape
				? JSON.stringify(onlySelectedShape.meta, null, '\t')
				: 'Select one shape to see its meta data.'}
		</pre>
	)
})

/*
This example demonstrates how to add your own data to shapes using the meta property as they're
created. Check out the docs for a more detailed explanation of the meta property:
https://tldraw.dev/docs/shapes#Meta-information

[1]
getInitialMetaForShape is a method you can replace at runtime. Here we use a callback on the onMount
prop to replace the default implementation with our own.

[2]
All tldraw shapes have a meta property with a type of unknown. To type your meta data you can use
a union like this.

[3]
A minimal ui component that displays the meta data of the selected shape. We use track to make sure
that the component is re-rendered when the signals it's tracking change. Check out the signals example
for more info: https://tldraw.dev/examples/signals

*/
```

--------

# Custom shape wrapper

Category: Shapes & tools

Keywords:

Customize the wrapper used for each shape in the DOM.

Use a custom shape wrapper to apply a special class names to shapes.

## App.tsx

```tsx
import { forwardRef } from 'react'
import {
	atom,
	DefaultShapeWrapper,
	Editor,
	TLComponents,
	Tldraw,
	TLShapeId,
	TLShapeWrapperProps,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const specialShapeId = atom<TLShapeId | null>('special shape id', null)

// [2]
const CustomShapeWrapper = forwardRef(function CustomShapeWrapper(
	{ children, shape, isBackground }: TLShapeWrapperProps,
	ref: React.Ref<HTMLDivElement>
) {
	// [a]
	const isSpecial = useValue('is special', () => specialShapeId.get() === shape.id, [shape.id])

	// [b]
	return (
		<DefaultShapeWrapper
			ref={ref}
			shape={shape}
			isBackground={isBackground}
			className={isSpecial ? 'custom-special-shape' : undefined}
		>
			{children}
		</DefaultShapeWrapper>
	)
})

// [3]
const components: TLComponents = {
	ShapeWrapper: CustomShapeWrapper,
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<style>{`
				.custom-special-shape {
					filter: drop-shadow(0 0 3px rgba(255, 0, 0));
				}
			`}</style>
			<Tldraw
				components={components}
				onMount={(editor) => {
					createSomeRandomShapes(editor)

					const timer = setInterval(() => {
						const allShapes = editor.getCurrentPageShapesSorted()
						const randomShape = allShapes[Math.floor(Math.random() * allShapes.length)]
						specialShapeId.set(randomShape.id)
					}, 1000)

					return () => {
						clearInterval(timer)
					}
				}}
			/>
		</div>
	)
}

function createSomeRandomShapes(editor: Editor) {
	const bounds = editor.getViewportPageBounds()
	for (let i = 0; i < 10; i++) {
		editor.createShape({
			type: 'geo',
			x: bounds.x + Math.random() * bounds.width,
			y: bounds.y + Math.random() * bounds.height,
		})
	}
}

/*
Introduction:

You can customize how shapes are wrapped in tldraw by creating a custom shape wrapper component and
passing it to the Tldraw component. In this example, we'll create a custom shape wrapper that adds a
red drop shadow to a randomly selected shape every second.

[1] We create an atom to store the ID of the currently "special" shape. Atoms are part of tldraw's
reactive state system and allow us to create reactive values that can be observed and updated. This
atom will hold the ID of the shape that should have the special styling applied to it.

[2] This is our custom shape wrapper component. Shape wrappers are React components that wrap around
every shape in the editor, allowing you to add custom styling, behavior, or data attributes to
shapes. We use forwardRef to properly forward the ref that tldraw passes to us.

    [a]
    We use the useValue hook to create a reactive value that checks if the current shape is the "special" shape.
    This will automatically update whenever the specialShapeId atom changes. We also check if the shape is filled
    by looking at its props.

    [b]
    We re-use the DefaultShapeWrapper component, but add a custom class to the shape when it's the "special" shape.

[3] We create a components object that tells tldraw to use our custom shape wrapper. The
TLComponents type allows us to override various parts of the tldraw UI, including the ShapeWrapper
component.

[4] In the main component, we add CSS that applies a red drop shadow to any element with the
'custom-special-shape' class. We also set up a timer that randomly selects a shape every second and
makes it the "special" shape by updating the specialShapeId atom.

The shape wrapper approach is useful when you want to:
- Add custom styling to all shapes or specific shapes
- Add data attributes for CSS targeting
- Implement custom behavior that affects how shapes are rendered
- Create visual effects that apply to the shape container rather than the shape content

This is different from custom shapes (like in the CustomShapeExample) because it doesn't change what
the shape is, only how it's wrapped and styled in the editor.
*/
```

--------

# Globs

Category: Shapes & tools

Keywords:

A globs based vector editor, based on the https://jcgt.org/published/0004/03/01/paper-lowres.pdf paper.

Some useful shortcuts:

- Place a node by pressing 'n'
- Create a glob by selecting a node and pressing 'c' and either place a new node or connect to an existing one
- Hold 'cmd' whilst dragging "d" handles to drag that handle and its opposite
- Hold 'cmd' whilst dragging tension handles to drag its opposite handle
- Hold 'cmd + shift' to drag all four tension handles on a glob together



## App.tsx

```tsx
import { useState } from 'react'
import {
	DefaultToolbar,
	DefaultToolbarContent,
	StateNode,
	TLComponents,
	Tldraw,
	TldrawUiButtonIcon,
	TldrawUiMenuItem,
	TldrawUiPopover,
	TldrawUiPopoverContent,
	TldrawUiPopoverTrigger,
	TldrawUiToolbar,
	TldrawUiToolbarButton,
	TLKeyboardEventInfo,
	tlmenus,
	TLPointerEventInfo,
	TLShape,
	TLShapeId,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	track,
	useEditor,
	useTools,
	useValue,
} from 'tldraw'
import { CustomHandles } from './CustomHandles'
import { GlobBinding, GlobBindingUtil } from './GlobBindingUtil'
import { GlobShape, GlobShapeUtil } from './GlobShapeUtil'
import { GlobTool } from './GlobTool/GlobTool'
import { NodeShape, NodeShapeUtil } from './NodeShapeUtil'

const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'glob-icon': '/glob-icon.svg',
		'node-icon': '/node-icon.svg',
		'connect-node-icon': '/connect-node.svg',
	},
}

const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		tools['glob.node'] = {
			id: 'glob.node',
			icon: 'node-icon',
			label: 'Node',
			kbd: 'n',
			meta: { variant: 'node' },
			onSelect: () => {
				editor.setCurrentTool('glob.node')
			},
		}

		tools['glob.connect'] = {
			id: 'glob.connect',
			icon: 'connect-node-icon',
			label: 'Connect Nodes',
			kbd: 'c',
			meta: { variant: 'connect' },
			onSelect: () => {
				// Only allow connecting if nodes are selected
				const selectedShapes = editor.getSelectedShapes()
				const hasNodesSelected =
					selectedShapes.length > 0 &&
					selectedShapes.every((shape) => editor.isShapeOfType<NodeShape>(shape, 'node'))
				if (hasNodesSelected) {
					editor.setCurrentTool('glob.connect')
				}
			},
		}

		return tools
	},
}

const GlobToolWithPopover = track(() => {
	const tools = useTools()

	const editor = useEditor()
	const [isOpen, setIsOpen] = useState(false)

	const currentGlobTool = useValue(
		'current glob tool',
		() => {
			const tool = editor.getPath()
			if (tool === 'glob.connect') return 'glob.connect'
			return 'glob.node'
		},
		[editor]
	)

	// Check if any nodes are selected
	const hasNodesSelected = useValue(
		'has nodes selected',
		() => {
			const selectedShapes = editor.getSelectedShapes()
			return (
				selectedShapes.length > 0 &&
				selectedShapes.every((shape) => editor.isShapeOfType<NodeShape>(shape, 'node'))
			)
		},
		[editor]
	)

	const isSelected = editor.getPath() === currentGlobTool
	const popoverId = 'glob-tool-popover'

	const handleToolSelect = (id: string) => {
		if (id === 'glob.connect' && !hasNodesSelected) return
		editor.setCurrentTool(id)
		tlmenus.deleteOpenMenu(popoverId, editor.contextId)
		setIsOpen(false)
	}

	return (
		<>
			<TldrawUiPopover id={popoverId} open={isOpen} onOpenChange={setIsOpen}>
				<TldrawUiPopoverTrigger>
					<TldrawUiToolbarButton title="Glob" type="tool">
						<TldrawUiButtonIcon icon="glob-icon" />
					</TldrawUiToolbarButton>
				</TldrawUiPopoverTrigger>
				<TldrawUiPopoverContent side="top" align="center">
					<TldrawUiToolbar label="Glob">
						<TldrawUiToolbarButton
							title="Add Node"
							type="tool"
							onClick={() => handleToolSelect('glob.node')}
						>
							<TldrawUiButtonIcon icon="node-icon" />
						</TldrawUiToolbarButton>
						<TldrawUiToolbarButton
							title="Connect Nodes"
							type="tool"
							onClick={() => handleToolSelect('glob.connect')}
							disabled={!hasNodesSelected}
						>
							<TldrawUiButtonIcon icon="connect-node-icon" />
						</TldrawUiToolbarButton>
					</TldrawUiToolbar>
				</TldrawUiPopoverContent>
				<TldrawUiMenuItem {...tools[currentGlobTool]} isSelected={isSelected} />
			</TldrawUiPopover>
		</>
	)
})

const components: TLComponents = {
	Toolbar: (props) => {
		return (
			<DefaultToolbar {...props}>
				<GlobToolWithPopover />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	Handles: CustomHandles,
}

const shapes = [NodeShapeUtil, GlobShapeUtil]
const tools = [GlobTool]
const bindings = [GlobBindingUtil]

export default function GlobsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				options={{
					spacebarPanning: false,
				}}
				onMount={(editor) => {
					editor.updateInstanceState({ isDebugMode: true })

					// Override dragging_handle state to prevent space from interrupting handle dragging
					const draggingHandleState = editor.getStateDescendant<StateNode>('select.dragging_handle')

					if (draggingHandleState) {
						const originalOnKeyDown = draggingHandleState.onKeyDown?.bind(draggingHandleState)

						draggingHandleState.onKeyDown = (info: TLKeyboardEventInfo) => {
							originalOnKeyDown?.(info)
						}
					}

					// Override pointing_handle state to allow handle dragging with modifier keys, otherwise
					// it starts brushing instead
					const pointingHandleState = editor.getStateDescendant<StateNode>('select.pointing_handle')

					if (!pointingHandleState) {
						throw new Error('SelectTool pointing_handle state not found')
					}

					// Store original handlers with proper binding
					const originalOnPointerMove = pointingHandleState.onPointerMove?.bind(pointingHandleState)

					// Return to idle state after dragging a handle
					pointingHandleState.onPointerMove = (info: TLPointerEventInfo) => {
						if (!info.shape) return

						if (editor.isShapeOfType<GlobShape>(info.shape, 'glob')) {
							editor.updateInstanceState({ isToolLocked: true })
							editor.setCurrentTool('select.dragging_handle', {
								...info,
							})
							return
						}

						originalOnPointerMove?.(info)
					}

					// if we have a just a glob selected, expand the selection to include the nodes it's connected to
					const originalGetContent = editor.getContentFromCurrentPage.bind(editor)
					editor.getContentFromCurrentPage = (shapes) => {
						// Extract shape IDs
						const ids =
							typeof shapes[0] === 'string'
								? (shapes as TLShapeId[])
								: (shapes as TLShape[]).map((s) => s.id)

						// Expand selection to include bound nodes for any globs
						const expandedIds = new Set(ids)

						for (const id of ids) {
							const shape = editor.getShape(id)
							if (shape && editor.isShapeOfType<GlobShape>(shape, 'glob')) {
								const bindings = editor.getBindingsFromShape<GlobBinding>(id, 'glob')
								for (const binding of bindings) {
									expandedIds.add(binding.toId)
								}
							}
						}

						// Call original with expanded selection
						return originalGetContent(Array.from(expandedIds))
					}
				}}
				shapeUtils={shapes}
				tools={tools}
				bindingUtils={bindings}
				overrides={uiOverrides}
				assetUrls={customAssetUrls}
				components={components}
			/>
		</div>
	)
}
```

## CustomHandles.tsx

```tsx
import {
	DefaultHandle,
	Mat,
	TLHandle,
	TLShapeId,
	toDomPrecision,
	useEditor,
	useValue,
} from 'tldraw'
import { ControlLine, getGlobInfo, getNeighborGlobs, GlobShape } from './GlobShapeUtil'

export function CustomHandles({ children }: { children: React.ReactNode }) {
	const editor = useEditor()

	const shouldDisplayHandles = useValue(
		'shouldDisplayHandles',
		() => {
			if (
				editor.isInAny(
					'select.idle',
					'select.pointing_handle',
					'select.pointing_shape',
					'select.dragging_handle'
				)
			) {
				return true
			}
			if (editor.isInAny('select.editing_shape')) {
				const onlySelectedShape = editor.getOnlySelectedShape()
				return onlySelectedShape && editor.isShapeOfType(onlySelectedShape, 'note')
			}
			return false
		},
		[editor]
	)

	const shouldDisplayGlobHandles = useValue(
		'shouldDisplayGlobHandles',
		() => {
			const selectedGlobs = editor
				.getSelectedShapeIds()
				.filter((shape) => editor.isShapeOfType<GlobShape>(shape, 'glob'))
				.map((shape) => editor.getShape<GlobShape>(shape))
			return selectedGlobs && selectedGlobs.length > 0
		},
		[editor]
	)

	if (!shouldDisplayHandles) return null

	const selectedGlobs = editor
		.getSelectedShapeIds()
		.filter((shape) => editor.isShapeOfType<GlobShape>(shape, 'glob'))
		.map((shape) => editor.getShape<GlobShape>(shape))

	const neighborGlobs: Set<GlobShape> = new Set()
	for (const selectedGlob of selectedGlobs) {
		if (!selectedGlob) continue
		getNeighborGlobs(editor, selectedGlob).forEach((neighbor) => neighborGlobs.add(neighbor))
	}

	return (
		<svg className="tl-user-handles tl-overlays__item" aria-hidden="true">
			{children}
			{shouldDisplayGlobHandles && (
				<>
					{Array.from(neighborGlobs).map((glob) => {
						if (!glob) return null
						return <GlobHandlesWithControlLines key={glob.id} glob={glob} />
					})}
				</>
			)}
		</svg>
	)
}

function GlobHandlesWithControlLines({ glob }: { glob: GlobShape }) {
	const editor = useEditor()
	const handles = editor.getShapeHandles(glob)
	const transform = editor.getShapePageTransform(glob.id)
	const zoomLevel = editor.getZoomLevel()
	const isCoarse = editor.getInstanceState().isCoarsePointer

	const globPoints = getGlobInfo(editor, glob)

	if (!handles || !transform || !globPoints) return null

	const dxA = toDomPrecision(glob.props.edges.edgeA.d.x)
	const dyA = toDomPrecision(glob.props.edges.edgeA.d.y)
	const dxB = toDomPrecision(glob.props.edges.edgeB.d.x)
	const dyB = toDomPrecision(glob.props.edges.edgeB.d.y)

	const txAA = toDomPrecision(globPoints.edgeA.tangentA.x)
	const tyAA = toDomPrecision(globPoints.edgeA.tangentA.y)
	const txAB = toDomPrecision(globPoints.edgeA.tangentB.x)
	const tyAB = toDomPrecision(globPoints.edgeA.tangentB.y)

	const txBA = toDomPrecision(globPoints.edgeB.tangentA.x)
	const tyBA = toDomPrecision(globPoints.edgeB.tangentA.y)
	const txBB = toDomPrecision(globPoints.edgeB.tangentB.x)
	const tyBB = toDomPrecision(globPoints.edgeB.tangentB.y)

	return (
		<g transform={Mat.toCssString(transform)}>
			<ControlLine x1={dxA} y1={dyA} x2={txAA} y2={tyAA} />
			<ControlLine x1={dxA} y1={dyA} x2={txAB} y2={tyAB} />
			<ControlLine x1={dxB} y1={dyB} x2={txBA} y2={tyBA} />
			<ControlLine x1={dxB} y1={dyB} x2={txBB} y2={tyBB} />

			{handles.map((handle) => (
				<HandleWrapper
					key={handle.id}
					shapeId={glob.id}
					handle={handle}
					zoom={zoomLevel}
					isCoarse={isCoarse}
				/>
			))}
		</g>
	)
}

function HandleWrapper({
	shapeId,
	handle,
	zoom,
	isCoarse,
}: {
	shapeId: TLShapeId
	handle: TLHandle
	zoom: number
	isCoarse: boolean
}) {
	return (
		<g transform={`translate(${handle.x}, ${handle.y})`}>
			<DefaultHandle shapeId={shapeId} handle={handle} zoom={zoom} isCoarse={isCoarse} />
		</g>
	)
}
```

## GlobBindingUtil.tsx

```tsx
import {
	BindingOnShapeChangeOptions,
	BindingOnShapeDeleteOptions,
	BindingUtil,
	Editor,
	TLBinding,
	TLParentId,
	TLShapeId,
	Vec,
} from 'tldraw'
import { GlobShape } from './GlobShapeUtil'
import { NodeShape } from './NodeShapeUtil'
import { getGlobBindings, getGlobTangentUpdate } from './shared'

const GLOB_BINDING_TYPE = 'glob'

declare module 'tldraw' {
	export interface TLGlobalBindingPropsMap {
		[GLOB_BINDING_TYPE]: GlobBindingProps
	}
}

export type GlobBinding = TLBinding<'glob'>

interface GlobBindingProps {
	terminal: 'start' | 'end'
}
export class GlobBindingUtil extends BindingUtil<GlobBinding> {
	static override type = 'glob' as const

	override getDefaultProps(): Partial<GlobBindingProps> {
		return {
			terminal: 'start',
		}
	}

	override onAfterChangeFromShape({
		binding,
		shapeBefore,
		shapeAfter,
	}: BindingOnShapeChangeOptions<GlobBinding>): void {
		const glob = this.editor.getShape<GlobShape>(binding.fromId)
		const node = this.editor.getShape<NodeShape>(binding.toId)

		if (!glob || !node) return
		if (glob.props.isGhosting) return

		const selectedIds = this.editor.getSelectedShapeIds()
		if (selectedIds.includes(node.id)) return
		if (!selectedIds.includes(glob.id)) return

		if (
			glob.parentId === node.parentId &&
			glob.parentId !== this.editor.getCurrentPageId() &&
			!selectedIds.includes(glob.id)
		) {
			return
		}

		// if a glob has been reparented (moved into/out of a frame), we need to move the nodes along with it
		if (shapeBefore.parentId !== shapeAfter.parentId) {
			const bindings = getGlobBindings(this.editor, glob)
			const boundNodes: NodeShape[] = []
			if (bindings.start) {
				const node = this.editor.getShape<NodeShape>(bindings.start.toId)
				if (node) boundNodes.push(node)
			}
			if (bindings.end) {
				const node = this.editor.getShape<NodeShape>(bindings.end.toId)
				if (node) boundNodes.push(node)
			}

			// Move each node to maintain its page position while reparenting to match the glob
			for (const node of boundNodes) {
				const nodePagePos = this.editor.getShapePageTransform(node).point()
				const newParentTransform = this.editor.getShapeParentTransform(shapeAfter)
				const newLocalPos = newParentTransform.clone().invert().applyToPoint(nodePagePos)

				this.editor.reparentShapes([node.id], shapeAfter.parentId)
				this.editor.updateShape<NodeShape>({
					id: node.id,
					type: 'node',
					x: newLocalPos.x,
					y: newLocalPos.y,
				})
			}

			// reparent and update
			reparentGlob(this.editor, glob.id)
			updateGlobGeometry(this.editor, glob.id)
			return
		}

		const beforePageTransform = this.editor.getShapeParentTransform(shapeBefore)
		const afterPageTransform = this.editor.getShapeParentTransform(shapeAfter)

		const beforePagePos = beforePageTransform.applyToPoint(shapeBefore)
		const afterPagePos = afterPageTransform.applyToPoint(shapeAfter)

		const deltaInPageSpace = Vec.Sub(afterPagePos, beforePagePos)

		const nodePagePos = this.editor.getShapePageTransform(node).point()

		const newNodePagePos = Vec.Add(nodePagePos, deltaInPageSpace)

		const nodeParentTransform = this.editor.getShapeParentTransform(node)
		const newNodeLocalPos = nodeParentTransform.clone().invert().applyToPoint(newNodePagePos)

		this.editor.run(
			() => {
				this.editor.updateShape<NodeShape>({
					id: node.id,
					type: 'node',
					x: newNodeLocalPos.x,
					y: newNodeLocalPos.y,
				})
			},
			{ history: 'ignore' }
		)
	}

	override onAfterChangeToShape({
		binding,
		shapeBefore,
		shapeAfter,
		reason,
	}: BindingOnShapeChangeOptions<GlobBinding>): void {
		const glob = this.editor.getShape<GlobShape>(binding.fromId)
		if (!glob) return
		if (glob.props.isGhosting) return

		const selectedIds = this.editor.getSelectedShapeIds()
		const node = this.editor.getShape<NodeShape>(binding.toId)
		if (!node) return

		if (!selectedIds.includes(node.id) && selectedIds.includes(glob.id)) {
			return
		}

		// If both glob and node share a frame parent and neither is selected,
		// they're moving together (e.g., frame is being moved), don't update
		if (
			glob.parentId === node.parentId &&
			glob.parentId !== this.editor.getCurrentPageId() &&
			!selectedIds.includes(glob.id) &&
			!selectedIds.includes(node.id) &&
			reason !== 'ancestry'
		) {
			return
		}

		if (
			reason !== 'ancestry' &&
			shapeBefore.parentId === shapeAfter.parentId &&
			shapeBefore.index === shapeAfter.index
		) {
			return
		}

		reparentGlob(this.editor, binding.fromId)
		updateGlobGeometry(this.editor, binding.fromId)
	}

	override onBeforeDeleteToShape({ binding }: BindingOnShapeDeleteOptions<GlobBinding>): void {
		this.editor.deleteShape(binding.fromId)
	}
}

function reparentGlob(editor: Editor, globId: TLShapeId) {
	const glob = editor.getShape<GlobShape>(globId)
	if (!glob) return
	const bindings = getGlobBindings(editor, glob)
	const { start, end } = bindings
	const startShape = start ? editor.getShape(start.toId) : undefined
	const endShape = end ? editor.getShape(end.toId) : undefined

	const parentPageId = editor.getAncestorPageId(glob)
	if (!parentPageId) return

	let nextParentId: TLParentId
	if (startShape && endShape) {
		nextParentId = editor.findCommonAncestor([startShape, endShape]) ?? parentPageId
	} else if (startShape || endShape) {
		const bindingParentId = (startShape || endShape)?.parentId
		if (bindingParentId && bindingParentId === glob.parentId) {
			nextParentId = glob.parentId
		} else {
			nextParentId = parentPageId
		}
	} else {
		return
	}

	if (nextParentId && nextParentId !== glob.parentId) {
		editor.reparentShapes([globId], nextParentId)
	}
}

function updateGlobGeometry(editor: Editor, globId: TLShapeId) {
	const glob = editor.getShape<GlobShape>(globId)
	if (!glob) return
	if (glob.props.isGhosting) return

	const bindings = getGlobBindings(editor, glob)
	const { start, end } = bindings
	const startShape = start ? editor.getShape<NodeShape>(start.toId) : undefined
	const endShape = end ? editor.getShape<NodeShape>(end.toId) : undefined

	if (!startShape || !endShape) return

	const startNodePagePos = editor.getShapePageTransform(startShape.id).point()
	const endNodePagePos = editor.getShapePageTransform(endShape.id).point()

	const update = getGlobTangentUpdate(
		editor,
		globId,
		startNodePagePos,
		startShape.props.radius,
		endNodePagePos,
		endShape.props.radius
	)

	editor.updateShape<GlobShape>(update)
}
```

## GlobShapeUtil.tsx

```tsx
import { round } from 'lodash'
import {
	createComputedCache,
	Editor,
	getIndicesAbove,
	HandleSnapGeometry,
	Mat,
	PathBuilder,
	PointsSnapIndicator,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	SVGContainer,
	T,
	TLHandle,
	TLHandleDragInfo,
	TLResizeInfo,
	TLShape,
	TLShapePartial,
	toDomPrecision,
	track,
	uniqueId,
	useEditor,
	useValue,
	Vec,
	VecModel,
	vecModelValidator,
	ZERO_INDEX_KEY,
} from 'tldraw'
import { GlobBinding } from './GlobBindingUtil'
import { getStartAndEndNodes } from './shared'
import {
	getArcFlag,
	getClosestPointOnCircle,
	getGlobEndPoint,
	getOuterTangentPoints,
	projectTensionPoint,
} from './utils'

export interface NodeGeometry {
	position: VecModel
	radius: number
}

export interface EdgeGeometry {
	tangentA: VecModel
	tangentB: VecModel
	tensionA: VecModel
	tensionB: VecModel
}
export interface GlobGeometry {
	startNode: NodeGeometry
	endNode: NodeGeometry
	edgeA: EdgeGeometry
	edgeB: EdgeGeometry
}
export interface EdgeProps {
	d: VecModel
	tensionRatioA: number
	tensionRatioB: number
}

export type EdgeCurveType = 'edgeA' | 'edgeB'
export interface GlobProps {
	edges: {
		edgeA: EdgeProps
		edgeB: EdgeProps
	}
	opacity: number
	isGhosting: boolean
}

const GLOB_TYPE = 'glob'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[GLOB_TYPE]: GlobProps
	}
}

export type GlobShape = TLShape<'glob'>

interface SnapData {
	nudge: VecModel
	indicators: PointsSnapIndicator[]
}

const edgeCurveValidator = T.object({
	d: vecModelValidator,
	tensionRatioA: T.number,
	tensionRatioB: T.number,
})

const globInfoCache = createComputedCache<Editor, GlobGeometry | null, GlobShape>(
	'glob info',
	(editor: Editor, shape: GlobShape): GlobGeometry | null => {
		const nodes = getStartAndEndNodes(editor, shape.id)
		if (!nodes) return null

		const { startNodeShape, endNodeShape } = nodes

		const startNodePagePos = editor.getShapePageTransform(startNodeShape.id).point()
		const endNodePagePos = editor.getShapePageTransform(endNodeShape.id).point()
		const globPagePos = editor.getShapePageTransform(shape.id).point()

		const localStartNode = Vec.Sub(startNodePagePos, globPagePos)
		const localEndNode = Vec.Sub(endNodePagePos, globPagePos)

		let tangentA_A = getGlobEndPoint(
			localStartNode,
			shape.props.edges.edgeA.d,
			startNodeShape.props.radius,
			0
		)
		let tangentB_A = getGlobEndPoint(
			localEndNode,
			shape.props.edges.edgeA.d,
			endNodeShape.props.radius,
			1
		)

		let tangentA_B = getGlobEndPoint(
			localStartNode,
			shape.props.edges.edgeB.d,
			startNodeShape.props.radius,
			1
		)

		let tangentB_B = getGlobEndPoint(
			localEndNode,
			shape.props.edges.edgeB.d,
			endNodeShape.props.radius,
			0
		)

		// if we drag a node over an existing d handle, the solution does not exist so collapse the points
		//
		if (!tangentA_A && tangentA_B) {
			tangentA_A = tangentA_B
		} else if (!tangentA_B && tangentA_A) {
			tangentA_B = tangentA_A
		}

		if (!tangentB_A && tangentB_B) {
			tangentB_A = tangentB_B
		} else if (!tangentB_B && tangentB_A) {
			tangentB_B = tangentB_A
		}

		if (!tangentA_A || !tangentB_A || !tangentA_B || !tangentB_B) return null

		return {
			startNode: {
				position: localStartNode,
				radius: startNodeShape.props.radius,
			},
			endNode: {
				position: localEndNode,
				radius: endNodeShape.props.radius,
			},
			edgeA: {
				tangentA: tangentA_A,
				tangentB: tangentB_A,
				tensionA: Vec.Lrp(
					tangentA_A,
					shape.props.edges.edgeA.d,
					shape.props.edges.edgeA.tensionRatioA
				),
				tensionB: Vec.Lrp(
					shape.props.edges.edgeA.d,
					tangentB_A,
					shape.props.edges.edgeA.tensionRatioB
				),
			},
			edgeB: {
				tangentA: tangentA_B,
				tangentB: tangentB_B,
				tensionA: Vec.Lrp(
					tangentA_B,
					shape.props.edges.edgeB.d,
					shape.props.edges.edgeB.tensionRatioA
				),
				tensionB: Vec.Lrp(
					shape.props.edges.edgeB.d,
					tangentB_B,
					shape.props.edges.edgeB.tensionRatioB
				),
			},
		}
	}
)

export function getGlobInfo(editor: Editor, shape: GlobShape): GlobGeometry | null {
	return globInfoCache.get(editor, shape.id) ?? null
}

export class GlobShapeUtil extends ShapeUtil<GlobShape> {
	static override type = 'glob' as const
	static override props: RecordProps<GlobShape> = {
		edges: T.object({
			edgeA: edgeCurveValidator,
			edgeB: edgeCurveValidator,
		}),
		opacity: T.number,
		isGhosting: T.boolean,
	}

	override getDefaultProps(): GlobShape['props'] {
		return {
			edges: {
				edgeA: {
					d: { x: 0, y: 0 },
					tensionRatioA: 0.5,
					tensionRatioB: 0.5,
				},
				edgeB: {
					d: { x: 0, y: 0 },
					tensionRatioA: 0.5,
					tensionRatioB: 0.5,
				},
			},
			opacity: 1,
			isGhosting: false,
		}
	}

	override hideSelectionBoundsBg(_shape: GlobShape): boolean {
		return true
	}

	override hideResizeHandles(_shape: GlobShape): boolean {
		return true
	}

	override hideRotateHandle(_shape: GlobShape): boolean {
		return true
	}

	override hideSelectionBoundsFg(_shape: GlobShape): boolean {
		return true
	}

	override onResize(_shape: GlobShape, info: TLResizeInfo<GlobShape>) {
		const { scaleX, scaleY, initialShape } = info

		const scaledEdgeA_d = {
			x: initialShape.props.edges.edgeA.d.x * scaleX,
			y: initialShape.props.edges.edgeA.d.y * scaleY,
		}
		const scaledEdgeB_d = {
			x: initialShape.props.edges.edgeB.d.x * scaleX,
			y: initialShape.props.edges.edgeB.d.y * scaleY,
		}

		const didFlipX = scaleX < 0
		const didFlipY = scaleY < 0

		const shouldSwap = didFlipX !== didFlipY

		const finalEdgeA = shouldSwap
			? {
					...initialShape.props.edges.edgeB,
					d: scaledEdgeB_d,
				}
			: {
					...initialShape.props.edges.edgeA,
					d: scaledEdgeA_d,
				}

		const finalEdgeB = shouldSwap
			? {
					...initialShape.props.edges.edgeA,
					d: scaledEdgeA_d,
				}
			: {
					...initialShape.props.edges.edgeB,
					d: scaledEdgeB_d,
				}

		return {
			props: {
				edges: {
					edgeA: finalEdgeA,
					edgeB: finalEdgeB,
				},
			},
		}
	}

	override onRotate(initial: GlobShape, current: GlobShape): TLShapePartial<GlobShape> {
		const delta = current.rotation - initial.rotation

		const rotatedDA = Vec.Rot(initial.props.edges.edgeA.d, delta).toJson()
		const rotatedDB = Vec.Rot(initial.props.edges.edgeB.d, delta).toJson()

		// rotating nodes will handle rotating the glob, but we still need to update the d handles
		return {
			id: current.id,
			type: current.type,
			rotation: 0,
			props: {
				edges: {
					edgeA: {
						...initial.props.edges.edgeA,
						d: rotatedDA,
					},
					edgeB: {
						...initial.props.edges.edgeB,
						d: rotatedDB,
					},
				},
			},
		}
	}

	override getGeometry(shape: GlobShape) {
		const globPoints = getGlobInfo(this.editor, shape)
		if (!globPoints) return new Rectangle2d({ width: 1, height: 1, isFilled: false })

		const pathBuilder = buildGlobPath(globPoints, true)
		if (!pathBuilder) return new Rectangle2d({ width: 1, height: 1, isFilled: false })

		return pathBuilder.toGeometry()
	}

	override getHandles(shape: GlobShape) {
		const globPoints = getGlobInfo(this.editor, shape)
		if (!globPoints) return []

		const NUM_D_POINTS = 2
		const NUM_TENSION_POINTS = 4

		const indices = getIndicesAbove(ZERO_INDEX_KEY, NUM_D_POINTS + NUM_TENSION_POINTS)
		let idx = 0

		const handles: TLHandle[] = []
		handles.push({
			id: 'edgeA.d',
			type: 'vertex',
			x: shape.props.edges.edgeA.d.x,
			y: shape.props.edges.edgeA.d.y,
			index: indices[idx++],
			snapType: 'point',
		})
		handles.push({
			id: 'edgeB.d',
			type: 'vertex',
			x: shape.props.edges.edgeB.d.x,
			y: shape.props.edges.edgeB.d.y,
			index: indices[idx++],
			snapType: 'point',
		})

		const tensions = [
			'tensionA',
			'tensionB',
		] as const satisfies readonly (keyof GlobGeometry['edgeA'])[]

		for (const edge of ['edgeA', 'edgeB'] as const satisfies readonly (keyof GlobGeometry)[]) {
			for (const tension of tensions) {
				handles.push({
					id: `${edge}.${tension}`,
					type: 'vertex',
					x: globPoints[edge][tension].x,
					y: globPoints[edge][tension].y,
					index: indices[idx++],
					snapType: 'point',
					snapReferenceHandleId: `${edge}.${tension}`, // this is a hack to make these handles not have angle snapping, when we shift drag which moves all tension handles at the same time
				})
			}
		}

		return handles
	}

	override getHandleSnapGeometry(shape: GlobShape): HandleSnapGeometry {
		const editor = this.editor
		const globPoints = getGlobInfo(editor, shape)
		if (!globPoints) return {}

		return {
			getSelfSnapPoints(handle) {
				const { edgeType, point } = getHandleData(handle.id)
				const d = shape.props.edges[edgeType].d

				switch (point) {
					case 'tensionA': {
						const mid = Vec.Lrp(globPoints[edgeType].tangentA, d, 0.5)
						return [mid]
					}
					case 'tensionB': {
						const mid = Vec.Lrp(globPoints[edgeType].tangentB, d, 0.5)
						return [mid]
					}
				}
				return []
			},
		}
	}

	override onHandleDrag(shape: GlobShape, info: TLHandleDragInfo<GlobShape>) {
		const { handle, initial } = info
		if (!initial) return shape

		const globPoints = getGlobInfo(this.editor, shape)
		if (!globPoints) return shape

		const { edgeType, point } = getHandleData(handle.id)
		const edge = shape.props.edges[edgeType]

		const oppositeEdgeType = edgeType === 'edgeA' ? 'edgeB' : 'edgeA'

		const initialEdge = initial.props.edges[edgeType]
		const initialOppositeEdge = initial.props.edges[oppositeEdgeType]

		switch (point) {
			case 'd': {
				let d = { x: handle.x, y: handle.y }

				this.editor.snaps.clearIndicators()
				const snapPoint = this.getSnaps(shape, handle)

				const isSnapMode = this.editor.user.getIsSnapMode()
				if (
					snapPoint &&
					!this.editor.inputs.getMetaKey() &&
					(isSnapMode ? !this.editor.inputs.getCtrlKey() : this.editor.inputs.getCtrlKey())
				) {
					this.editor.snaps.setIndicators(snapPoint.indicators)

					return {
						...shape,
						props: {
							...shape.props,
							edges: {
								...shape.props.edges,
								[edgeType]: {
									...edge,
									d: Vec.Add(d, snapPoint.nudge).toJson(),
								},
							},
						},
					}
				}

				// constrain the d handle around the node if we try drag it inside a node
				const distStart = Vec.Dist(handle, globPoints.startNode.position)
				if (distStart <= globPoints.startNode.radius) {
					d = getClosestPointOnCircle(
						globPoints.startNode.position,
						globPoints.startNode.radius,
						handle
					)
				}

				// constrain the d handle around the node if we try drag it inside a node
				const distEnd = Vec.Dist(handle, globPoints.endNode.position)
				if (distEnd <= globPoints.endNode.radius) {
					d = getClosestPointOnCircle(
						globPoints.endNode.position,
						globPoints.endNode.radius,
						handle
					)
				}

				// drag both d handles at the same time
				if (this.editor.inputs.getMetaKey()) {
					const delta = Vec.Sub(handle, initialEdge.d)

					return {
						...shape,
						props: {
							...shape.props,
							edges: {
								...shape.props.edges,
								[oppositeEdgeType]: {
									...initialOppositeEdge,
									d: Vec.Add(initialOppositeEdge.d, delta).toJson(),
								},
								[edgeType]: {
									...edge,
									d: d,
								},
							},
						},
					}
				}

				return {
					...shape,
					props: {
						...shape.props,
						edges: {
							...shape.props.edges,
							[edgeType]: {
								...edge,
								d: d,
							},
							[oppositeEdgeType]: {
								...initialOppositeEdge,
							},
						},
					},
				}
			}
			case 'tensionA': {
				const lineStart = globPoints[edgeType].tangentA
				const lineEnd = shape.props.edges[edgeType].d
				const projectedPoint = projectTensionPoint(lineStart, lineEnd, handle)

				// drag ALL the tension handles
				if (this.editor.inputs.getMetaKey() && this.editor.inputs.getShiftKey()) {
					return {
						...shape,
						props: {
							...shape.props,
							edges: {
								...shape.props.edges,
								[edgeType]: {
									...initialEdge,
									tensionRatioA: projectedPoint,
									tensionRatioB: 1 - projectedPoint,
								},
								[oppositeEdgeType]: {
									...initialOppositeEdge,
									tensionRatioA: projectedPoint,
									tensionRatioB: 1 - projectedPoint,
								},
							},
						},
					}
				}

				// drag opposite tension handles at the same time
				if (this.editor.inputs.getMetaKey()) {
					return {
						...shape,
						props: {
							...shape.props,
							edges: {
								...shape.props.edges,
								[edgeType]: {
									...initialEdge,
									tensionRatioA: projectedPoint,
									tensionRatioB: 1 - projectedPoint,
								},
							},
						},
					}
				}

				return {
					...shape,
					props: {
						...shape.props,
						edges: {
							...shape.props.edges,
							[edgeType]: {
								...initialEdge,
								tensionRatioA: projectedPoint,
							},
							[oppositeEdgeType]: {
								...initialOppositeEdge,
							},
						},
					},
				}
			}
			case 'tensionB': {
				const lineStart = shape.props.edges[edgeType].d
				const lineEnd = globPoints[edgeType].tangentB
				const projectedPoint = projectTensionPoint(lineStart, lineEnd, handle)

				// drag ALL the tension handles
				if (this.editor.inputs.getMetaKey() && this.editor.inputs.getShiftKey()) {
					return {
						...shape,
						props: {
							...shape.props,
							edges: {
								...shape.props.edges,
								[edgeType]: {
									...initialEdge,
									tensionRatioA: 1 - projectedPoint,
									tensionRatioB: projectedPoint,
								},
								[oppositeEdgeType]: {
									...initialOppositeEdge,
									tensionRatioA: 1 - projectedPoint,
									tensionRatioB: projectedPoint,
								},
							},
						},
					}
				}

				// drag opposite tension handles at the same time
				if (this.editor.inputs.getMetaKey()) {
					return {
						...shape,
						props: {
							...shape.props,
							edges: {
								...shape.props.edges,
								[edgeType]: {
									...initialEdge,
									tensionRatioA: 1 - projectedPoint,
									tensionRatioB: projectedPoint,
								},
							},
						},
					}
				}

				return {
					...shape,
					props: {
						...shape.props,
						edges: {
							...shape.props.edges,
							[edgeType]: {
								...initialEdge,
								tensionRatioB: projectedPoint,
							},
							[oppositeEdgeType]: {
								...initialOppositeEdge,
							},
						},
					},
				}
			}
		}

		return shape
	}

	override component(shape: GlobShape) {
		const showControlLines =
			this.editor.isInAny(
				'select.idle',
				'select.pointing_handle',
				'select.pointing_shape',
				'select.dragging_handle'
			) && this.editor.getOnlySelectedShape() === shape

		return <GlobShape shape={shape} showControlLines={showControlLines} />
	}

	override indicator(shape: GlobShape) {
		const zoomLevel = this.editor.getZoomLevel()

		const globPoints = getGlobInfo(this.editor, shape)
		if (!globPoints) return null

		const pathBuilder = buildGlobPath(globPoints)
		if (!pathBuilder) return null

		return (
			<SVGContainer>
				<path
					pointerEvents="none"
					d={pathBuilder.toD()}
					stroke="black"
					strokeWidth={2 / zoomLevel}
					opacity={0.25}
					fill="blue"
				/>
			</SVGContainer>
		)
	}

	override toSvg(shape: GlobShape) {
		const globPoints = getGlobInfo(this.editor, shape)
		if (!globPoints) return null

		const pathBuilder = buildGlobPath(globPoints)
		if (!pathBuilder) return null

		return pathBuilder.toSvg({
			style: 'solid',
			strokeWidth: 2,
			forceSolid: false,
			props: { stroke: 'black', fill: 'black' },
		})
	}

	private getSnaps(shape: GlobShape, handle: TLHandle): SnapData | null {
		const INFINITE_LENGTH = 100000
		const pageToCurrentShape = this.editor.getShapePageTransform(shape.id).clone().invert()

		const neighborGlobs: Set<GlobShape> = getNeighborGlobs(this.editor, shape)

		// infinite lines going from direction of d handles to tangent points
		// for neighboring globs of the selected glob
		const snapEdges: { start: VecModel; end: VecModel; d: VecModel }[] = []
		for (const neighborGlob of neighborGlobs) {
			const transform = Mat.Compose(
				pageToCurrentShape,
				this.editor.getShapePageTransform(neighborGlob.id)
			)
			const neighborGeo = getGlobInfo(this.editor, neighborGlob)
			if (!neighborGeo) continue

			for (const edge of ['edgeA', 'edgeB'] as const) {
				for (const tangent of ['tangentA', 'tangentB'] as const) {
					const dLocal = neighborGlob.props.edges[edge].d
					const tangentLocal = neighborGeo[edge][tangent]
					const direction = Vec.Sub(tangentLocal, dLocal).uni()

					const infiniteEndPoint = Vec.Add(dLocal, Vec.Mul(direction, INFINITE_LENGTH))

					const p1Transformed = transform.applyToPoint(dLocal)
					const p2Transformed = transform.applyToPoint(infiniteEndPoint)

					snapEdges.push({
						start: p1Transformed,
						end: p2Transformed,
						d: p1Transformed,
					})
				}
			}
		}

		let nearestPoint: Vec | null = null
		const endPoints: VecModel[] = []
		let minDistance = this.editor.snaps.getSnapThreshold()

		for (const { start, end, d } of snapEdges) {
			const snapPoint = Vec.NearestPointOnLineSegment(start, end, handle, true)
			const distance = Vec.Dist(handle, snapPoint)

			if (round(distance) <= round(minDistance)) {
				if (round(distance) < round(minDistance)) {
					endPoints.length = 0
					minDistance = distance
					nearestPoint = snapPoint
				}
				endPoints.push(d)
			}
		}

		const globInfo = getGlobInfo(this.editor, shape)
		if (!globInfo) return null

		const { edgeType } = getHandleData(handle.id)
		const outerTangentPoints = getOuterTangentPoints(
			globInfo.startNode.position,
			globInfo.startNode.radius,
			globInfo.endNode.position,
			globInfo.endNode.radius,
			edgeType
		)

		// mid point, outer tangent edge, perp to that edge
		const midD = Vec.Lrp(outerTangentPoints[0], outerTangentPoints[1], 0.5)
		const outerLine = Vec.Sub(outerTangentPoints[0], outerTangentPoints[1]).uni()

		// infinite line of the perpendicular outer line
		const perpendicularOuterLine = Vec.Per(outerLine).uni()
		const normalDStart = Vec.Add(midD, Vec.Mul(perpendicularOuterLine, -INFINITE_LENGTH))
		const normalDEnd = Vec.Add(midD, Vec.Mul(perpendicularOuterLine, INFINITE_LENGTH))

		// check snap to the outer line
		let snappedToOuterLine = false
		const outerLineSnapPoint = Vec.NearestPointOnLineSegment(
			outerTangentPoints[0],
			outerTangentPoints[1],
			handle,
			false
		)
		const outerLineDistance = Vec.Dist(handle, outerLineSnapPoint)

		if (round(outerLineDistance) <= round(minDistance)) {
			if (round(outerLineDistance) < round(minDistance)) {
				minDistance = outerLineDistance
				nearestPoint = outerLineSnapPoint
			}
			snappedToOuterLine = true
		}

		// check snap to the perpendicular line
		let snappedToPerpLine = false
		const perpLineSnapPoint = Vec.NearestPointOnLineSegment(normalDStart, normalDEnd, handle, true)
		const perpLineDistance = Vec.Dist(handle, perpLineSnapPoint)

		if (round(perpLineDistance) <= round(minDistance)) {
			if (round(perpLineDistance) < round(minDistance)) {
				minDistance = perpLineDistance
				nearestPoint = perpLineSnapPoint
			}
			snappedToPerpLine = true
		}

		// if both outer line and perp line are snapped, snap to their intersection (midD)
		if (snappedToOuterLine && snappedToPerpLine) {
			nearestPoint = midD
		}

		// if no snap found, return null
		if (!nearestPoint) return null

		// transform to page space and calculate final snapped handle position
		const getShapePageTransform = this.editor.getShapePageTransform(shape.id)
		const handleInPageSpace = getShapePageTransform.applyToPoint(handle)
		const nearestPointInPageSpace = getShapePageTransform.applyToPoint(nearestPoint)

		const snappedHandle = Vec.Add(
			handleInPageSpace,
			Vec.Sub(nearestPointInPageSpace, handleInPageSpace)
		)

		const indicators: PointsSnapIndicator[] = endPoints.map((endPoint) => ({
			id: uniqueId(),
			type: 'points',
			points: [getShapePageTransform.applyToPoint(endPoint), snappedHandle],
		}))

		if (snappedToOuterLine) {
			indicators.push({
				id: uniqueId(),
				type: 'points',
				points: [
					getShapePageTransform.applyToPoint(outerTangentPoints[0]),
					getShapePageTransform.applyToPoint(outerTangentPoints[1]),
				],
			})
		}

		if (snappedToPerpLine) {
			indicators.push({
				id: uniqueId(),
				type: 'points',
				points: [snappedHandle, getShapePageTransform.applyToPoint(midD)],
			})
		}

		return {
			nudge: Vec.Sub(nearestPoint, handle),
			indicators,
		}
	}
}

function buildGlobPath(globPoints: GlobGeometry, geometry: boolean = false) {
	const pathBuilder = new PathBuilder()
	pathBuilder.moveTo(globPoints.edgeA.tangentA.x, globPoints.edgeA.tangentA.y, {
		geometry: { isFilled: true },
	})

	const arcFlagA = getArcFlag(
		globPoints.startNode.position,
		globPoints.edgeA.tangentA,
		globPoints.edgeB.tangentA
	)

	const arcFlagB = getArcFlag(
		globPoints.endNode.position,
		globPoints.edgeB.tangentB,
		globPoints.edgeA.tangentB
	)

	pathBuilder.circularArcTo(
		globPoints.startNode.radius,
		geometry ? !arcFlagA : arcFlagA,
		geometry ? false : true,
		globPoints.edgeB.tangentA.x,
		globPoints.edgeB.tangentA.y
	)

	pathBuilder.cubicBezierTo(
		globPoints.edgeB.tangentB.x,
		globPoints.edgeB.tangentB.y,
		globPoints.edgeB.tensionA.x,
		globPoints.edgeB.tensionA.y,
		globPoints.edgeB.tensionB.x,
		globPoints.edgeB.tensionB.y
	)

	pathBuilder.circularArcTo(
		globPoints.endNode.radius,
		geometry ? !arcFlagB : arcFlagB,
		geometry ? false : true,
		globPoints.edgeA.tangentB.x,
		globPoints.edgeA.tangentB.y
	)

	pathBuilder.cubicBezierTo(
		globPoints.edgeA.tangentA.x,
		globPoints.edgeA.tangentA.y,
		globPoints.edgeA.tensionB.x,
		globPoints.edgeA.tensionB.y,
		globPoints.edgeA.tensionA.x,
		globPoints.edgeA.tensionA.y
	)

	pathBuilder.close()

	return pathBuilder
}

export const GlobShape = track(function GlobShape({
	shape,
	showControlLines,
}: {
	shape: GlobShape
	showControlLines: boolean
}) {
	const editor = useEditor()
	const zoomLevel = editor.getZoomLevel()

	// Use reactive inputs to track if space key is pressed
	const fillGlob = useValue('space key pressed', () => editor.inputs.keys.has('Space'), [editor])

	const globPoints = getGlobInfo(editor, shape)
	if (!globPoints) return null

	const pathBuilder = buildGlobPath(globPoints)
	if (!pathBuilder) return null

	const dxA = toDomPrecision(shape.props.edges.edgeA.d.x)
	const dyA = toDomPrecision(shape.props.edges.edgeA.d.y)
	const dxB = toDomPrecision(shape.props.edges.edgeB.d.x)
	const dyB = toDomPrecision(shape.props.edges.edgeB.d.y)

	const txAA = toDomPrecision(globPoints.edgeA.tangentA.x)
	const tyAA = toDomPrecision(globPoints.edgeA.tangentA.y)
	const txAB = toDomPrecision(globPoints.edgeA.tangentB.x)
	const tyAB = toDomPrecision(globPoints.edgeA.tangentB.y)

	const txBA = toDomPrecision(globPoints.edgeB.tangentA.x)
	const tyBA = toDomPrecision(globPoints.edgeB.tangentA.y)
	const txBB = toDomPrecision(globPoints.edgeB.tangentB.x)
	const tyBB = toDomPrecision(globPoints.edgeB.tangentB.y)

	return (
		<SVGContainer>
			{showControlLines && (
				<>
					<ControlLine x1={dxA} y1={dyA} x2={txAA} y2={tyAA} />
					<ControlLine x1={dxA} y1={dyA} x2={txAB} y2={tyAB} />
					<ControlLine x1={dxB} y1={dyB} x2={txBA} y2={tyBA} />
					<ControlLine x1={dxB} y1={dyB} x2={txBB} y2={tyBB} />
				</>
			)}
			<path
				d={pathBuilder.toD()}
				stroke="black"
				fill={fillGlob ? 'black' : 'white'}
				opacity={fillGlob ? 1 : 0.75}
				strokeWidth={2 / zoomLevel}
			/>
		</SVGContainer>
	)
})

export function ControlLine({
	x1,
	y1,
	x2,
	y2,
}: {
	x1: number
	y1: number
	x2: number
	y2: number
}) {
	const editor = useEditor()
	const zoomLevel = editor.getZoomLevel()
	const dashArray = `${3 / zoomLevel} ${3 / zoomLevel}`

	return (
		<line
			x1={x1}
			y1={y1}
			x2={x2}
			y2={y2}
			stroke="#4169E1"
			strokeDasharray={dashArray}
			strokeWidth={1 / zoomLevel}
		/>
	)
}

const getHandleData = (id: string) => {
	const [edgeType, point] = id.split('.') as [EdgeCurveType, keyof EdgeGeometry | keyof EdgeProps]

	return { edgeType, point }
}

export const getNeighborGlobs = (editor: Editor, shape: GlobShape) => {
	const currentGlobBindings = editor.getBindingsFromShape<GlobBinding>(shape.id, 'glob')

	const neighborGlobs: Set<GlobShape> = new Set()
	// try find nodes that attach to other globs
	for (const binding of currentGlobBindings) {
		const nodeBindings = editor.getBindingsToShape<GlobBinding>(binding.toId, 'glob')
		for (const nodeBinding of nodeBindings) {
			const neighborGlob = editor.getShape<GlobShape>(nodeBinding.fromId)

			// if this is the glob we selecting or a glob we've already added, skip
			if (!neighborGlob || neighborGlob.id === shape.id) continue
			if (neighborGlobs.has(neighborGlob)) continue

			neighborGlobs.add(neighborGlob)
		}
	}

	return neighborGlobs
}
```

## NodeShapeUtil.tsx

```tsx
import {
	Circle2d,
	Editor,
	getColorValue,
	getIndicesAbove,
	RecordProps,
	ShapeUtil,
	SVGContainer,
	T,
	TLHandle,
	TLHandleDragInfo,
	TLResizeInfo,
	TLShape,
	useDefaultColorTheme,
	useValue,
	Vec,
	ZERO_INDEX_KEY,
} from 'tldraw'

export interface NodeProps {
	opacity: number
	radius: number
}

const NODE_TYPE = 'node'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[NODE_TYPE]: NodeProps
	}
}

export type NodeShape = TLShape<'node'>

export class NodeShapeUtil extends ShapeUtil<NodeShape> {
	static override type = 'node' as const
	static override props: RecordProps<NodeShape> = {
		opacity: T.number,
		radius: T.number,
	}

	override getDefaultProps(): NodeShape['props'] {
		return {
			opacity: 1,
			radius: 50,
		}
	}

	override hideResizeHandles(_shape: NodeShape): boolean {
		return true
	}

	override hideRotateHandle(_shape: NodeShape): boolean {
		return true
	}

	override hideSelectionBoundsBg(_shape: NodeShape): boolean {
		return true
	}

	override hideSelectionBoundsFg(_shape: NodeShape): boolean {
		return true
	}

	override getGeometry(shape: NodeShape) {
		return new Circle2d({
			x: -shape.props.radius,
			y: -shape.props.radius,
			radius: shape.props.radius,
			isFilled: true,
		})
	}

	override onResize(_shape: NodeShape, info: TLResizeInfo<NodeShape>) {
		const { scaleX, scaleY, initialShape } = info
		const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2

		return {
			props: {
				radius: initialShape.props.radius * avgScale,
			},
		}
	}

	override getHandles(shape: NodeShape): TLHandle[] {
		const east = Vec.Uni({ x: -1, y: 0 }).mul(shape.props.radius)
		const west = Vec.Uni({ x: 1, y: 0 }).mul(shape.props.radius)

		const indices = getIndicesAbove(ZERO_INDEX_KEY, 2)

		return [
			{
				id: 'east',
				type: 'vertex',
				index: indices[0],
				x: east.x,
				y: east.y,
			},
			{
				id: 'west',
				type: 'vertex',
				index: indices[1],
				x: west.x,
				y: west.y,
			},
		]
	}

	override onHandleDrag(shape: NodeShape, info: TLHandleDragInfo<NodeShape>) {
		const { handle, initial } = info
		if (!initial) return shape

		const mag = Vec.Len(handle) - initial.props.radius

		return {
			...shape,
			props: {
				...shape.props,
				radius: initial.props.radius + mag,
			},
		}
	}

	override indicator(shape: NodeShape) {
		const zoom = this.editor.getZoomLevel()

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const theme = useDefaultColorTheme()
		const blue = getColorValue(theme, 'blue', 'solid')

		return <circle r={shape.props.radius} strokeWidth={1 / zoom} stroke={blue} fill="none" />
	}

	override component(shape: NodeShape) {
		const isSingleNode = this.editor.getBindingsToShape(shape.id, 'glob').length === 0

		return <NodeComponent shape={shape} editor={this.editor} isSingleNode={isSingleNode} />
	}
}

function NodeComponent({
	shape,
	editor,
	isSingleNode,
}: {
	shape: NodeShape
	editor: Editor
	isSingleNode: boolean
}) {
	const zoom = useValue('zoom', () => editor.getZoomLevel(), [editor])
	const { radius } = shape.props
	const dashArray = `${3 / zoom} ${3 / zoom}`

	// Use reactive inputs to track if space key is pressed
	const isSpacePressed = useValue('space key pressed', () => editor.inputs.keys.has('Space'), [
		editor,
	])

	const fillNode = isSingleNode && isSpacePressed
	if (!isSingleNode && isSpacePressed) return null

	return (
		<SVGContainer>
			<g opacity={shape.props.opacity}>
				<circle
					r={radius}
					stroke={'black'}
					strokeDasharray={isSingleNode ? 'none' : dashArray}
					strokeWidth={1 / zoom}
					fill={fillNode ? 'black' : 'white'}
				/>
				<circle x={0} y={0} r={1 / zoom} stroke="black" strokeWidth={1 / zoom} fill="black" />
			</g>
		</SVGContainer>
	)
}
```

## shared.ts

```ts
import { Editor, TLShapeId, Vec, VecLike } from 'tldraw'
import { GlobBinding } from './GlobBindingUtil'
import { GlobShape } from './GlobShapeUtil'
import { NodeShape } from './NodeShapeUtil'
import { getOuterTangentPoints } from './utils'

export const getStartAndEndNodes = (editor: Editor, glob: TLShapeId) => {
	const bindings = editor.getBindingsFromShape<GlobBinding>(glob, 'glob')
	if (!bindings.length) return null

	const startNode = bindings.find((b) => b.props.terminal === 'start')
	if (!startNode) return null
	const startNodeShape = editor.getShape<NodeShape>(startNode.toId)
	if (!startNodeShape) return null

	const endNode = bindings.find((b) => b.props.terminal === 'end')
	if (!endNode) return null
	const endNodeShape = editor.getShape<NodeShape>(endNode.toId)
	if (!endNodeShape) return null

	return { startNodeShape, endNodeShape }
}

export interface GlobBindings {
	start?: GlobBinding
	end?: GlobBinding
}

export function getGlobBindings(editor: Editor, shape: GlobShape): GlobBindings {
	const bindings = editor.getBindingsFromShape<GlobBinding>(shape.id, 'glob')

	const start = bindings.find((b) => b.props.terminal === 'start')
	const end = bindings.find((b) => b.props.terminal === 'end')

	return { start, end }
}

export const getGlobTangentUpdate = (
	editor: Editor,
	globId: TLShapeId,
	startNodePagePos: VecLike,
	startRadius: number,
	endNodePagePos: VecLike,
	endRadius: number
) => {
	// Calculate midpoint in page space
	const midPagePos = Vec.Average([startNodePagePos, endNodePagePos])

	// Get the glob shape to determine its parent
	const glob = editor.getShape<GlobShape>(globId)
	if (!glob) return null

	// Convert midpoint to glob's parent space
	const globParentTransform = editor.getShapeParentTransform(glob)
	const midInGlobParentSpace = globParentTransform.clone().invert().applyToPoint(midPagePos)

	// Calculate local node positions relative to midpoint in page space
	const localStartNode = Vec.Sub(startNodePagePos, midPagePos)
	const localEndNode = Vec.Sub(endNodePagePos, midPagePos)

	const tangentPoints = getOuterTangentPoints(localStartNode, startRadius, localEndNode, endRadius)

	const d0 = Vec.Lrp(tangentPoints[0], tangentPoints[1], 0.5)
	const d1 = Vec.Lrp(tangentPoints[2], tangentPoints[3], 0.5)

	return {
		id: globId,
		type: 'glob' as const,
		x: midInGlobParentSpace.x,
		y: midInGlobParentSpace.y,
		props: {
			edges: {
				edgeA: { d: { x: d0.x, y: d0.y }, tensionRatioA: 0.5, tensionRatioB: 0.5 },
				edgeB: { d: { x: d1.x, y: d1.y }, tensionRatioA: 0.5, tensionRatioB: 0.5 },
			},
		},
	}
}
```

## utils.ts

```ts
import { Vec, VecLike, VecModel } from 'tldraw'

export const getOuterTangentPoints = (
	c0: VecLike,
	r0: number,
	c1: VecLike,
	r1: number,
	side?: 'edgeA' | 'edgeB'
): VecModel[] => {
	const offsetAngle = Vec.Angle(c0, c1)
	const d = Vec.Dist(c0, c1)

	const theta = Math.acos((r0 - r1) / d)

	const angle0 = offsetAngle + theta
	const angle1 = offsetAngle - theta

	const t00 = Vec.Add(c0, Vec.FromAngle(angle0).mul(r0))
	const t01 = Vec.Add(c1, Vec.FromAngle(angle0).mul(r1))

	const t10 = Vec.Add(c0, Vec.FromAngle(angle1).mul(r0))
	const t11 = Vec.Add(c1, Vec.FromAngle(angle1).mul(r1))

	if (side) {
		if (side === 'edgeA') {
			return [
				{ x: t00.x, y: t00.y },
				{ x: t01.x, y: t01.y },
			]
		}

		return [
			{ x: t10.x, y: t10.y },
			{ x: t11.x, y: t11.y },
		]
	}

	return [
		{ x: t00.x, y: t00.y },
		{ x: t01.x, y: t01.y },
		{ x: t10.x, y: t10.y },
		{ x: t11.x, y: t11.y },
	]
}

export const getGlobEndPoint = (c: VecModel, d: VecModel, r: number, side: number = 0) => {
	const angle = Vec.Angle(c, d)

	const displacement = Vec.Sub(c, d)
	const dist = Vec.Len(displacement)

	// we are inside the circle no solutions, so return null
	if (dist <= r) {
		return
	}

	const theta = Math.acos(r / dist)

	const sideTheta = side === 0 ? theta : -theta
	const p = Vec.Add(c, Vec.FromAngle(angle + sideTheta).mul(r))

	return p
}

export const getArcFlag = (c: VecModel, e0: VecModel, e1: VecModel) => {
	const d0 = Vec.Angle(c, e0)
	const d1 = Vec.Angle(c, e1)

	const diff = d1 - d0

	const theta = Math.atan2(Math.sin(diff), Math.cos(diff))

	return theta > 0 ? false : true
}

export const projectTensionPoint = (lineStart: VecModel, lineEnd: VecModel, handle: VecModel) => {
	const lineDir = Vec.Sub(lineEnd, lineStart)
	const lineLength = lineDir.len()

	const toHandle = Vec.Sub(handle, lineStart)
	const projection = Vec.Dpr(toHandle, Vec.Uni(lineDir))
	const clampedProjection = Math.max(0, Math.min(lineLength, projection))

	return clampedProjection / lineLength
}

export const circleCentresOverlap = (c0: VecModel, r0: number, c1: VecModel) => {
	const d = Vec.Dist(c0, c1)
	return d <= r0
}

export const getClosestPointOnCircle = (c: VecModel, r: number, p: VecModel) => {
	const pDirection = Vec.Sub(p, c).uni()

	return Vec.Add(c, Vec.Mul(pDirection, r + 1)).toJson()
}
```

## GlobTool.tsx

```tsx
import {
	createShapeId,
	snapAngle,
	StateNode,
	TLBindingUpdate,
	TLParentId,
	TLPointerEventInfo,
	TLShapeId,
	Vec,
} from 'tldraw'
import { GlobBinding } from '../GlobBindingUtil'
import { GlobShape } from '../GlobShapeUtil'
import { NodeShape } from '../NodeShapeUtil'
import { getGlobTangentUpdate, getStartAndEndNodes } from '../shared'

export class GlobTool extends StateNode {
	static override id = 'glob'
	static override initial = 'idle'

	static override children() {
		return [IdleState, NodeState, ConnectState]
	}
}

export class IdleState extends StateNode {
	static override id = 'idle'

	override onCancel() {
		this.editor.setCurrentTool('select')
	}
}

export class NodeState extends StateNode {
	static override id = 'node'

	private ghostShapeId: TLShapeId | null = null

	override onEnter() {
		this.editor.setCursor({ type: 'cross' })
	}

	override onPointerMove(_info: TLPointerEventInfo) {
		const pagePoint = this.editor.inputs.getCurrentPagePoint()

		if (!this.ghostShapeId) {
			const id = createShapeId()
			this.editor.createShape<NodeShape>({
				id: id,
				type: 'node',
				x: pagePoint.x,
				y: pagePoint.y,
				props: {
					radius: 50,
					opacity: 0.25,
				},
			})
			this.ghostShapeId = id
			return
		}

		const shape = this.editor.getShape<NodeShape>(this.ghostShapeId)
		if (!shape) return

		// could be inside a frame, so we need to get the point in the parent space
		const parentPoint = this.editor.getPointInParentSpace(shape, pagePoint)

		this.editor.updateShape<NodeShape>({
			...shape,
			x: parentPoint.x,
			y: parentPoint.y,
		})
	}

	override onPointerDown(_info: TLPointerEventInfo) {
		if (!this.ghostShapeId) return

		const node = this.editor.getShape<NodeShape>(this.ghostShapeId)!
		if (!node) return

		// if we try place another node such that it overlaps with an existing node radii, don't allow it
		const pagePoint = this.editor.inputs.getCurrentPagePoint()
		const shapes = this.editor
			.getShapesAtPoint(pagePoint, {
				hitInside: true,
			})
			.filter(
				(shape) =>
					shape.id !== this.ghostShapeId && this.editor.isShapeOfType<NodeShape>(shape, 'node')
			)

		if (shapes.length) {
			return
		}

		const parentPoint = this.editor.getPointInParentSpace(node, pagePoint)
		this.editor.updateShape<NodeShape>({
			...node,
			x: parentPoint.x,
			y: parentPoint.y,
			props: {
				...node.props,
				opacity: 1,
			},
		})

		this.ghostShapeId = null

		this.complete()
	}

	override onCancel() {
		this.complete()
	}

	private complete() {
		if (this.ghostShapeId) {
			this.editor.deleteShapes([this.ghostShapeId])
			this.ghostShapeId = null
		}

		this.editor.setCurrentTool('select')
	}
}

export class ConnectState extends StateNode {
	static override id = 'connect'

	selectedNodeIds: TLShapeId[] = []
	ghostGlobIds: TLShapeId[] = []

	ghostNodeId: TLShapeId | null = null

	override onEnter() {
		this.selectedNodeIds = this.editor.getSelectedShapeIds()
		this.editor.setCursor({ type: 'cross' })
	}

	override onPointerMove(info: TLPointerEventInfo) {
		// selected nodes go to the ghost node
		const selectedNode = this.editor.getShape<NodeShape>(this.selectedNodeIds[0])
		if (!selectedNode) return

		// Apply shift snapping for angle constraints
		let pagePoint = this.editor.inputs.getCurrentPagePoint()
		if (info.shiftKey) {
			const selectedNodeCenter = new Vec(selectedNode.x, selectedNode.y)
			const angle = Vec.Angle(selectedNodeCenter, pagePoint)
			const snappedAngle = snapAngle(angle, 24)
			const distance = Vec.Dist(selectedNodeCenter, pagePoint)
			pagePoint = Vec.FromAngle(snappedAngle, distance).add(selectedNodeCenter)
		}

		// if there is no ghost node, create one
		if (!this.ghostNodeId) {
			const id = createShapeId()
			this.editor.createShape<NodeShape>({
				id: id,
				type: 'node',
				x: pagePoint.x,
				y: pagePoint.y,
				props: {
					radius: selectedNode.props.radius,
				},
			})

			this.ghostNodeId = id
		}

		const parentPoint = this.editor.getPointInParentSpace(this.ghostNodeId, pagePoint)
		this.editor.updateShape<NodeShape>({
			id: this.ghostNodeId,
			type: 'node',
			x: parentPoint.x,
			y: parentPoint.y,
		})

		// if there are no ghost globs, create them, we could be ghosting a whole selection of nodes
		if (!this.ghostGlobIds.length) {
			for (let i = 0; i < this.selectedNodeIds.length; i++) {
				const id = createShapeId()

				// Determine the proper parent for the glob based on the bound nodes
				const startNode = this.editor.getShape(this.selectedNodeIds[i])
				const endNode = this.editor.getShape(this.ghostNodeId)

				let globParentId: TLParentId = this.editor.getCurrentPageId()
				if (startNode && endNode) {
					// Find common ancestor of the two nodes
					const commonAncestor = this.editor.findCommonAncestor([startNode, endNode])
					if (commonAncestor) {
						globParentId = commonAncestor
					}
				}

				this.editor.createShape<GlobShape>({
					id: id,
					type: 'glob',
					parentId: globParentId,
					x: 0,
					y: 0,
					props: {
						opacity: 0.25,
						isGhosting: true,
					},
				})

				const glob = this.editor.getShape<GlobShape>(id)
				if (!glob) continue

				this.ghostGlobIds.push(id)

				// bind each node to the glob
				this.editor.createBindings<GlobBinding>([
					{
						fromId: id,
						toId: this.selectedNodeIds[i],
						type: 'glob',
						props: {
							terminal: 'start',
						},
					},
					{
						fromId: id,
						toId: this.ghostNodeId,
						type: 'glob',
						props: {
							terminal: 'end',
						},
					},
				])
			}
		}

		// update each ghost globs as we drag the ghost node around
		for (let i = 0; i < this.ghostGlobIds.length; i++) {
			const selectedNode = this.editor.getShape<NodeShape>(this.selectedNodeIds[i])
			if (!selectedNode) continue

			const pageNode = this.editor.getShapePageTransform(this.selectedNodeIds[i]).point()
			const update = getGlobTangentUpdate(
				this.editor,
				this.ghostGlobIds[i],
				pageNode,
				selectedNode.props.radius,
				pagePoint,
				selectedNode.props.radius
			)

			this.editor.updateShape<GlobShape>(update)
		}
	}

	override onPointerDown(info: TLPointerEventInfo) {
		if (!this.ghostNodeId) return

		const pagePoint = this.editor.screenToPage(info.point)
		const shapes = this.editor.getShapesAtPoint(pagePoint, {
			hitInside: true,
		})

		// find any existing node we may be trying to connect to
		const nodes = shapes.filter(
			(shape) =>
				this.editor.isShapeOfType<NodeShape>(shape, 'node') && shape.id !== this.ghostNodeId
		)

		// if we don't find a node, just place the ghost node and complete
		if (!nodes.length) {
			this.complete()
			return
		}

		// we found a node, we need to update the bindings to connect to the existing node,
		// recalculate the tangent points for the glob, with different radii as well as the bindings
		const updates: TLBindingUpdate[] = []
		const bindings = this.editor.getBindingsToShape(this.ghostNodeId, 'glob')
		if (!bindings.length) {
			this.complete()
			return
		}

		// update all current bindings to connect to the existing node
		for (const binding of bindings) {
			updates.push({
				...binding,
				toId: nodes[0].id,
			})
		}

		this.editor.updateBindings(updates)

		// update the outer tangents because the radii may have changed
		for (const glob of this.ghostGlobIds) {
			const globShape = this.editor.getShape<GlobShape>(glob)
			if (!globShape) continue

			const nodes = getStartAndEndNodes(this.editor, glob)
			if (!nodes) continue

			const startNodePagePos = this.editor.getShapePageTransform(nodes.startNodeShape.id).point()
			const endNodePagePos = this.editor.getShapePageTransform(nodes.endNodeShape.id).point()

			const update = getGlobTangentUpdate(
				this.editor,
				glob,
				startNodePagePos,
				nodes.startNodeShape.props.radius,
				endNodePagePos,
				nodes.endNodeShape.props.radius
			)
			this.editor.updateShape<GlobShape>(update)
		}

		if (this.ghostNodeId) {
			this.editor.deleteShape(this.ghostNodeId)
		}

		this.complete()
	}

	override onCancel() {
		if (this.ghostGlobIds.length) {
			this.editor.deleteShapes(this.ghostGlobIds)
			this.ghostGlobIds = []
		}
		if (this.ghostNodeId) {
			this.editor.deleteShapes([this.ghostNodeId])
			this.ghostNodeId = null
		}

		this.editor.setCurrentTool('select')
	}

	override onComplete() {
		this.complete()
	}

	private complete() {
		// remove the ghosting from the globs
		for (let i = 0; i < this.ghostGlobIds.length; i++) {
			this.editor.updateShape<GlobShape>({
				id: this.ghostGlobIds[i],
				type: 'glob',
				props: { isGhosting: false },
			})
		}

		this.ghostNodeId = null

		this.editor.setSelectedShapes(this.ghostGlobIds)
		this.selectedNodeIds = []
		this.ghostGlobIds = []

		this.editor.setCurrentTool('select')
	}
}
```

--------

# Custom shape

Category: Shapes & tools

Keywords: util

A simple custom shape.

You can create custom shapes in tldraw by creating a shape util and passing it to the Tldraw component.
In this example, we'll create a custom shape that is a simple rectangle with some text inside of it.

## App.tsx

```tsx
import {
	Geometry2d,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	TLResizeInfo,
	TLShape,
	Tldraw,
	resizeBox,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const MY_CUSTOM_SHAPE_TYPE = 'my-custom-shape'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_CUSTOM_SHAPE_TYPE]: { w: number; h: number; text: string }
	}
}

// [2]
type ICustomShape = TLShape<typeof MY_CUSTOM_SHAPE_TYPE>

// [3]
export class MyShapeUtil extends ShapeUtil<ICustomShape> {
	// [a]
	static override type = MY_CUSTOM_SHAPE_TYPE
	static override props: RecordProps<ICustomShape> = {
		w: T.number,
		h: T.number,
		text: T.string,
	}

	// [b]
	getDefaultProps(): ICustomShape['props'] {
		return {
			w: 200,
			h: 200,
			text: "I'm a shape!",
		}
	}

	// [c]
	override canEdit() {
		return false
	}
	override canResize() {
		return true
	}
	override isAspectRatioLocked() {
		return false
	}

	// [d]
	getGeometry(shape: ICustomShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	// [e]
	override onResize(shape: any, info: TLResizeInfo<any>) {
		return resizeBox(shape, info)
	}

	// [f]
	component(shape: ICustomShape) {
		return <HTMLContainer style={{ backgroundColor: '#efefef' }}>{shape.props.text}</HTMLContainer>
	}

	// [g]
	indicator(shape: ICustomShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [4]
const customShape = [MyShapeUtil]

export default function CustomShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShape}
				onMount={(editor) => {
					editor.createShape({ type: MY_CUSTOM_SHAPE_TYPE, x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
Introduction:

You can create custom shapes in tldraw by creating a shape util and passing it to the Tldraw component.
In this example, we'll create a custom shape that is a simple rectangle with some text inside of it.

[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape's properties. For this shape, we define width (w), height (h),
and text as the shape's properties.

[2]
Define the shape type using TLShape with the shape's type as a type argument.

[3]
This is our shape util. In tldraw shape utils are classes that define how a shape behaves and renders.
We can extend the ShapeUtil class and provide the shape type as a generic. If we extended the
BaseBoxShapeUtil class instead, we wouldn't have define methods such as `getGeometry` and `onResize`.

	[a]
	This is where we define out shape's props and type for the editor. It's important to use the same
	string for the type as we did in [2]. We need to define the shape's props using tldraw's validator
	library. The validator will help make sure the store always has shape data we can trust.

	[b]
	This is a method that returns the default props for our shape.

	[c]
	Some handy methods for controlling different shape behaviour. You don't have to define these, and
	they're only shown here so you know they exist. Check out the editable shape example to learn more
	about creating an editable shape.

	[d]
	The getGeometry method is what the editor uses for hit-testing, binding etc. We're using the
	Rectangle2d class from tldraw's geometry library to create a rectangle shape. If we extended the
	BaseBoxShapeUtil class, we wouldn't have to define this method.

	[e]
	We're using the resizeBox utility method to handle resizing our shape. If we extended the
	BaseBoxShapeUtil class, we wouldn't have to define this method.

	[f]
	The component method defines how our shape renders. We're returning an HTMLContainer here, which
	is a handy component that tldraw exports. It's essentially a div with some special css. There's a
	lot of flexibility here, and you can use any React hooks you want and return any valid JSX.

	[g]
	The indicator is the blue outline around a selected shape. We're just returning a rectangle with the
	same width and height as the shape here. You can return any valid JSX here.

[4]
This is where we render the Tldraw component with our custom shape. We're passing in our custom shape
util as an array to the shapeUtils prop. We're also using the onMount callback to create a shape on
the canvas. If you want to learn how to add a tool for your shape, check out the custom config example.
If you want to learn how to programmatically control the canvas, check out the Editor API examples.

*/
```

--------

# Custom tool (sticker)

Category: Shapes & tools

Keywords: state, machine, chart, node, sticker

A simple custom tool.

Tools are nodes in tldraw's state chart. They are responsible for handling user input.

You can create custom tools by extending the `StateNode` class and overriding its methods. In this example we make a very simple sticker tool that adds a heart emoji to the canvas when you click.

## App.tsx

```tsx
import { StateNode, Tldraw, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const OFFSET = 12

// [1]
class StickerTool extends StateNode {
	static override id = 'sticker'

	// [a]
	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	// [b]
	override onPointerDown() {
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		this.editor.createShape({
			type: 'text',
			x: currentPagePoint.x - OFFSET,
			y: currentPagePoint.y - OFFSET,
			props: { richText: toRichText('❤️') },
		})
	}
}

// [2]
const customTools = [StickerTool]
export default function CustomToolExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// hide the ui
				hideUi
				// Put some helpful text on the canvas
				onMount={(editor) => {
					editor.createShape({
						type: 'text',
						x: 100,
						y: 100,
						props: { richText: toRichText('Click anywhere to add a sticker') },
					})
				}}
			/>
		</div>
	)
}

/*
Introduction:

Tools are nodes in tldraw's state machine. They are responsible for handling user input.
You can create custom tools by extending the `StateNode` class and overriding its methods.
In this example we make a very simple sticker tool that adds a heart emoji to the canvas
when you click.

[1]
We extend the `StateNode` class to create a new tool called `StickerTool`. We set its id
to "sticker". We are not implementing any child states in this example, so we don't need
to set an initial state or define any children states. To see an example of a custom tool
with child states, check out the screenshot tool or minimal examples.

	[a] The onEnter method is called when the tool is activated. We use it to set the cursor
		to a crosshair.

	[b] The onPointerDown method is called when the user clicks on the canvas. We use it to
		create a new shape at the click location. We can get the click location from the
		editor's inputs.

[2]
We pass our custom tool to the Tldraw component using the `tools` prop. We also set the
initial state to our custom tool. We hide the ui and add some helpful text to the canvas
using the `onMount` prop. This is not necessary for the tool to work but it helps make the
example more visually clear.
*/
```

--------

# Custom tool (screenshot)

Category: Shapes & tools

Keywords: state chart, state machine, child states

A custom tool that takes a screenshot of the canvas.

Tools are the parts of tldraw's state chart. Most interactions in tldraw are tools.

This example shows how to create a custom tool that takes a screenshot of a specific area of the canvas.

## App.tsx

```tsx
import {
	Box,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { ScreenshotTool } from './ScreenshotTool/ScreenshotTool'
import { ScreenshotDragging } from './ScreenshotTool/childStates/Dragging'

// There's a guide at the bottom of this file!

// [1]
const customTools = [ScreenshotTool]

// [2]
const customUiOverrides: TLUiOverrides = {
	tools: (editor, tools) => {
		return {
			...tools,
			screenshot: {
				id: 'screenshot',
				label: 'Screenshot',
				icon: 'tool-screenshot',
				kbd: 'j',
				onSelect() {
					editor.setCurrentTool('screenshot')
				},
			},
		}
	},
}

function CustomToolbar() {
	const tools = useTools()
	const isScreenshotSelected = useIsToolSelected(tools['screenshot'])
	return (
		<DefaultToolbar>
			<TldrawUiMenuItem {...tools['screenshot']} isSelected={isScreenshotSelected} />
			<DefaultToolbarContent />
		</DefaultToolbar>
	)
}

// [3]
const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'tool-screenshot': '/tool-screenshot.svg',
	},
}

// [4]
function ScreenshotBox() {
	const editor = useEditor()

	const screenshotBrush = useValue(
		'screenshot brush',
		() => {
			// Check whether the screenshot tool (and its dragging state) is active
			if (editor.getPath() !== 'screenshot.dragging') return null

			// Get screenshot.dragging state node
			const draggingState = editor.getStateDescendant<ScreenshotDragging>('screenshot.dragging')!

			// Get the box from the screenshot.dragging state node
			const box = draggingState.screenshotBox.get()

			// The box is in "page space", i.e. panned and zoomed with the canvas, but we
			// want to show it in front of the canvas, so we'll need to convert it to
			// "page space", i.e. uneffected by scale, and relative to the tldraw
			// page's top left corner.
			const zoomLevel = editor.getZoomLevel()
			const { x, y } = editor.pageToViewport({ x: box.x, y: box.y })
			return new Box(x, y, box.w * zoomLevel, box.h * zoomLevel)
		},
		[editor]
	)

	if (!screenshotBrush) return null

	return (
		<div
			style={{
				position: 'absolute',
				top: 0,
				left: 0,
				transform: `translate(${screenshotBrush.x}px, ${screenshotBrush.y}px)`,
				width: screenshotBrush.w,
				height: screenshotBrush.h,
				border: '1px solid var(--tl-color-text-0)',
				zIndex: 999,
			}}
		/>
	)
}

const customComponents: TLComponents = {
	InFrontOfTheCanvas: ScreenshotBox,
	Toolbar: CustomToolbar,
}

// [5]
export default function ScreenshotToolExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="tldraw_screenshot_example"
				tools={customTools}
				overrides={customUiOverrides}
				assetUrls={customAssetUrls}
				components={customComponents}
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a custom tool. In tldraw, tools are parts of the
tldraw state chart. While the most common use for tools is creating shapes, you can
use tools to create other types of interactions too! In this example, we create a
"screenshot tool" that lets the user draw a box on the canvas. When the user finishes
drawing their box, we'll export (or copy) a screenshot of that area.

[1]
Our custom tool is a class that extends the StateNode class. See the ScreenshotTool
files for more about the too. We define an array (outside of any React component)
to hold the custom tools. We'll pass this into the Tldraw component's `tools` prop.

[2]
Here we make sure the UI knows about our new tool. We do this by adding it to the
`tools` object, which tells other parts of the UI a tool's label, icon, what should
happen when it's selected, etc. We'll pass our customUiOverrides object into the
Tldraw component's `overrides` prop.

[3]
Our toolbar item is using a custom icon, so we need to provide the asset url for it.
We do this by providing a custom assetUrls object to the Tldraw component.
This object is a map of icon ids to their urls. The icon ids are the same as the
icon prop on the toolbar item. We'll pass our assetUrls object into the Tldraw
component's `assetUrls` prop.

[4]
We want to show a box on the canvas when the screenshot tool is active. We do this
by providing an override to the InFrontOfTheCanvas component. This component will be shown
in front of the canvas but behind any other UI elements, such as menus and the toolbar.
We'll pass our components object into the Tldraw component's `components` prop.

[5]
Finally we pass all of our customizations into the Tldraw component. It's important
that the customizations are defined outside of the React component, otherwise they
will cause the Tldraw component to see them as new values on every render, which may
produce unexpected results.
*/
```

## ScreenshotTool.ts

```ts
import { StateNode } from 'tldraw'
import { ScreenshotDragging } from './childStates/Dragging'
import { ScreenshotIdle } from './childStates/Idle'
import { ScreenshotPointing } from './childStates/Pointing'

// There's a guide at the bottom of this file!

export class ScreenshotTool extends StateNode {
	// [1]
	static override id = 'screenshot'
	static override initial = 'idle'
	static override children() {
		return [ScreenshotIdle, ScreenshotPointing, ScreenshotDragging]
	}

	// [2]
	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onExit() {
		this.editor.setCursor({ type: 'default', rotation: 0 })
	}

	// [3]
	override onInterrupt() {
		this.complete()
	}

	override onCancel() {
		this.complete()
	}

	private complete() {
		this.parent.transition('select', {})
	}
}

/*
This file contains our screenshot tool. The tool is a StateNode with the `id` "screenshot".

[1]
It has three child state nodes, ScreenshotIdle, ScreenshotPointing, and ScreenshotDragging.
Its initial state is `idle`.

[2]
When the screenshot tool is entered, we set the cursor to a crosshair. When it is exited, we
set the cursor back to the default cursor.

[3]
When the screenshot tool is interrupted or cancelled, we transition back to the select tool.
*/
```

## Dragging.ts

```ts
import { Box, StateNode, atom, copyAs, exportAs } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotDragging extends StateNode {
	static override id = 'dragging'

	// [1]
	screenshotBox = atom('screenshot brush', new Box())

	// [2]
	override onEnter() {
		this.update()
	}

	override onPointerMove() {
		this.update()
	}

	override onKeyDown() {
		this.update()
	}

	override onKeyUp() {
		this.update()
	}

	private update() {
		const inputs = this.editor.inputs
		const shiftKey = inputs.getShiftKey()
		const altKey = inputs.getAltKey()
		const originPagePoint = inputs.getOriginPagePoint()
		const currentPagePoint = inputs.getCurrentPagePoint()

		const box = Box.FromPoints([originPagePoint, currentPagePoint])

		if (shiftKey) {
			if (box.w > box.h * (16 / 9)) {
				box.h = box.w * (9 / 16)
			} else {
				box.w = box.h * (16 / 9)
			}

			if (currentPagePoint.x < originPagePoint.x) {
				box.x = originPagePoint.x - box.w
			}

			if (currentPagePoint.y < originPagePoint.y) {
				box.y = originPagePoint.y - box.h
			}
		}

		if (altKey) {
			box.w *= 2
			box.h *= 2
			box.x = originPagePoint.x - box.w / 2
			box.y = originPagePoint.y - box.h / 2
		}

		this.screenshotBox.set(box)
	}

	// [3]
	override onPointerUp() {
		const { editor } = this
		const box = this.screenshotBox.get()

		// get all shapes contained by or intersecting the box
		const shapes = editor.getCurrentPageShapes().filter((s) => {
			const pageBounds = editor.getShapeMaskedPageBounds(s)
			if (!pageBounds) return false
			return box.includes(pageBounds)
		})

		if (shapes.length) {
			if (editor.inputs.getCtrlKey()) {
				// Copy the shapes to the clipboard
				copyAs(
					editor,
					shapes.map((s) => s.id),
					{ format: 'png', bounds: box }
				)
			} else {
				// Export the shapes as a png
				exportAs(
					editor,
					shapes.map((s) => s.id),
					{
						format: 'png',
						name: 'Screenshot',
						bounds: box,
					}
				)
			}
		}

		this.editor.setCurrentTool('select')
	}

	// [4]
	override onCancel() {
		this.editor.setCurrentTool('select')
	}
}

/*
[1]
This state has a reactive property (an Atom) called "screenshotBox". This is the box
that the user is drawing on the screen as they drag their pointer. We use an Atom here
so that our UI can subscribe to this property using `useValue` (see the ScreenshotBox
component in ScreenshotToolExample).

[2]
When the user enters this state, or when they move their pointer, we update the
screenshotBox property to be drawn between the place where the user started pointing
and the place where their pointer is now. If the user is holding Shift, then we modify
the dimensions of this box so that it is in a 16:9 aspect ratio.

[3]
When the user makes a pointer up and stops dragging, we export the shapes contained by
the screenshot box as a png. If the user is holding the ctrl key, we copy the shapes
to the clipboard instead.

[4]
When the user cancels (esc key) or makes a pointer up event, we transition back to the
select tool.
*/
```

## Idle.ts

```ts
import { StateNode } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotIdle extends StateNode {
	static override id = 'idle'

	// [1]
	override onPointerDown() {
		this.parent.transition('pointing')
	}
}

/*
[1]
When we the user makes a pointer down event, we transition to the pointing state.
*/
```

## Pointing.ts

```ts
import { StateNode } from 'tldraw'

// There's a guide at the bottom of this file!

export class ScreenshotPointing extends StateNode {
	static override id = 'pointing'

	// [1]
	override onPointerMove() {
		if (this.editor.inputs.getIsDragging()) {
			this.parent.transition('dragging')
		}
	}

	// [2]
	override onPointerUp() {
		this.complete()
	}

	override onCancel() {
		this.complete()
	}

	private complete() {
		this.parent.transition('idle')
	}
}

/*
[1]
When the user makes a pointer move event, we check if they are dragging. If they are,
we transition to the dragging state. If they are not yet dragging, we stay in this state.

[2]
When the user cancelles or makes a pointer up event (while this state is still active,
so after the user has started pointing but before they've moved their pointer far enough
to start dragging), then we transition back to the idle state.
*/
```

--------

# Cubic bezier curve shape

Category: Shapes & tools

Keywords: shape, util, handles, geometry, pen

A custom shape with interactive bezier curve editing.

This example demonstrates how to create a cubic bezier curve shape with draggable control handles. It includes a custom pen tool for entering edit mode and shows how to customize handle behavior and snapping.

The shape features four handles (start, end, and two control points) that can be dragged to adjust the curve. Control points snap to the start and end positions, and moving the endpoints automatically shifts their associated control points to maintain smooth editing.

## App.tsx

```tsx
import {
	createShapeId,
	StateNode,
	TLAnyShapeUtilConstructor,
	Tldraw,
	TLPointerEventInfo,
} from 'tldraw'
import { BezierCurveShapeUtil } from './CubicBezierShape'
import { CustomHandles } from './CustomHandles'
import { SneakyUndoRedoWhileEditing } from './SneakyUndoRedoWhileEditing'

const customShapes: TLAnyShapeUtilConstructor[] = [BezierCurveShapeUtil]

export default function BezierCurveShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [9]
				components={{
					Handles: CustomHandles,
				}}
				shapeUtils={customShapes}
				onMount={(editor) => {
					editor.user.updateUserPreferences({ isSnapMode: true })

					const viewportPageBounds = editor.getViewportPageBounds()
					const centerX = viewportPageBounds.center.x
					const centerY = viewportPageBounds.center.y

					const id = createShapeId()
					editor.createShape({
						id,
						type: 'bezier-curve',
						x: centerX - 200,
						y: centerY - 150,
					})

					// Select and edit the shape on appear
					editor.select(id)
					editor.setEditingShape(id)

					// [10]
					// Get state nodes with proper type safety
					const pointingHandleState = editor.getStateDescendant<StateNode>('select.pointing_handle')
					const editingShapeState = editor.getStateDescendant<StateNode>('select.editing_shape')

					if (!pointingHandleState) {
						throw new Error('SelectTool pointing_handle state not found')
					}
					if (!editingShapeState) {
						throw new Error('SelectTool editing_shape state not found')
					}

					// store original handlers with proper binding
					const originalHandlers = {
						pointingHandle: {
							onPointerMove: pointingHandleState.onPointerMove?.bind(pointingHandleState),
							onPointerUp: pointingHandleState.onPointerUp?.bind(pointingHandleState),
						},
						editingShape: {
							onPointerDown: editingShapeState.onPointerDown?.bind(editingShapeState),
							onPointerMove: editingShapeState.onPointerMove?.bind(editingShapeState),
						},
					}

					// clicking on start or end point should not go to select.idle
					pointingHandleState.onPointerUp = (info: TLPointerEventInfo & { target: 'handle' }) => {
						if (!info.shape) return

						if (
							info.accelKey &&
							editor.isShapeOfType(info.shape, 'bezier-curve') &&
							info.target === 'handle'
						) {
							switch (info.handle.id) {
								case 'cp1': {
									editor.updateShape({
										id: info.shape.id,
										type: 'bezier-curve',
										props: {
											cp1: { x: info.shape.props.start.x, y: info.shape.props.start.y },
										},
									})

									editor.setEditingShape(info.shape.id)
									return
								}
								case 'cp2': {
									editor.updateShape({
										id: info.shape.id,
										type: 'bezier-curve',
										props: {
											cp2: { x: info.shape.props.end.x, y: info.shape.props.end.y },
										},
									})

									editor.setEditingShape(info.shape.id)
									return
								}
							}
						}

						if (editor.isShapeOfType(info.shape, 'bezier-curve') && info.target === 'handle') {
							editor.setEditingShape(info.shape.id)
							return
						}

						originalHandlers.pointingHandle.onPointerUp?.(info)
					}

					// return to editing state after dragging a handle
					pointingHandleState.onPointerMove = (info: TLPointerEventInfo) => {
						if (!info.shape) return

						if (editor.isShapeOfType(info.shape, 'bezier-curve')) {
							editor.updateInstanceState({ isToolLocked: true })
							editor.setCurrentTool('select.dragging_handle', {
								...info,
								onInteractionEnd: () => {
									editor.setEditingShape(info.shape.id)
								},
							})
							return
						}

						originalHandlers.pointingHandle.onPointerMove?.(info)
					}

					// allow translating in editing state
					editingShapeState.onPointerMove = (info: TLPointerEventInfo) => {
						if (editor.inputs.getIsDragging()) {
							const editingShape = editor.getEditingShape()
							if (editingShape && editor.isShapeOfType(editingShape, 'bezier-curve')) {
								editor.updateInstanceState({ isToolLocked: true })

								editor.setCurrentTool('select.translating', {
									...info,
									target: 'shape',
									shape: editingShape,
									onInteractionEnd: () => {
										editor.setEditingShape(editingShape.id)
									},
								})
								return
							}
						}

						originalHandlers.editingShape.onPointerMove?.(info)
					}
				}}
			>
				{/* 11 */}
				<SneakyUndoRedoWhileEditing />
			</Tldraw>
		</div>
	)
}

/*
Introduction:
This example demonstrates how to create a cubic bezier curve shape with interactive handles.

[9]
Use custom ControlHandles component to show handles for bezier curves when editing, translating, or
dragging handles.

[10]
Override state node methods to enable three custom interactions:
1. Meta + click on cp1/cp2 handles collapses them to their associated start/end points
2. After dragging any handle, stay in editing mode (instead of returning to select.idle)
3. Allow translating the curve while in editing mode by detecting drag and transitioning to select.translating

[11]
Add a sneaky undo/redo while editing. This is a hack to allow undo/redo while editing a shape.
It's not a perfect solution, but it's a workaround for the fact that tldraw doesn't support
undo/redo while editing a shape. Sometimes you gotta hack it.

These overrides maintain the editing context, allowing fluid adjustments without losing handle visibility.
*/
```

## CubicBezierShape.tsx

```tsx
import {
	BoundsSnapGeometry,
	CubicBezier2d,
	Geometry2d,
	getIndicesAbove,
	HandleSnapGeometry,
	HTMLContainer,
	RecordProps,
	ShapeUtil,
	TLHandle,
	TLHandleDragInfo,
	TLResizeInfo,
	TLShape,
	Vec,
	VecLike,
	vecModelValidator,
	ZERO_INDEX_KEY,
} from 'tldraw'

const BEZIER_CURVE_TYPE = 'bezier-curve'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[BEZIER_CURVE_TYPE]: { start: VecLike; cp1: VecLike; cp2: VecLike; end: VecLike }
	}
}

// [2]
export type MyBezierCurveShape = TLShape<typeof BEZIER_CURVE_TYPE>

// [3]
export class BezierCurveShapeUtil extends ShapeUtil<MyBezierCurveShape> {
	static override type = BEZIER_CURVE_TYPE
	static override props: RecordProps<MyBezierCurveShape> = {
		start: vecModelValidator,
		cp1: vecModelValidator,
		cp2: vecModelValidator,
		end: vecModelValidator,
	}

	private isMetaKeyOnTranslateStart = false
	private didHitCurveOnTranslateStart = false

	override getDefaultProps(): MyBezierCurveShape['props'] {
		return {
			start: { x: 0, y: 0 },
			cp1: { x: 0, y: 140 },
			cp2: { x: 350, y: 300 },
			end: { x: 400, y: 110 },
		}
	}

	override canEdit(): boolean {
		return true
	}

	// [4]
	getGeometry(shape: MyBezierCurveShape): Geometry2d {
		return new CubicBezier2d({
			start: new Vec(shape.props.start.x, shape.props.start.y),
			cp1: new Vec(shape.props.cp1.x, shape.props.cp1.y),
			cp2: new Vec(shape.props.cp2.x, shape.props.cp2.y),
			end: new Vec(shape.props.end.x, shape.props.end.y),
		})
	}

	override hideSelectionBoundsBg(shape: MyBezierCurveShape): boolean {
		return this.editor.getEditingShapeId() === shape.id
	}

	override hideSelectionBoundsFg(shape: MyBezierCurveShape): boolean {
		return this.editor.getEditingShapeId() === shape.id
	}

	override hideResizeHandles(shape: MyBezierCurveShape): boolean {
		return this.editor.getEditingShapeId() === shape.id
	}

	override onResize(shape: MyBezierCurveShape, info: TLResizeInfo<MyBezierCurveShape>) {
		const { scaleX, scaleY } = info
		return {
			props: {
				start: { x: shape.props.start.x * scaleX, y: shape.props.start.y * scaleY },
				cp1: { x: shape.props.cp1.x * scaleX, y: shape.props.cp1.y * scaleY },
				cp2: { x: shape.props.cp2.x * scaleX, y: shape.props.cp2.y * scaleY },
				end: { x: shape.props.end.x * scaleX, y: shape.props.end.y * scaleY },
			},
		}
	}

	override getBoundsSnapGeometry(shape: MyBezierCurveShape): BoundsSnapGeometry {
		return {
			points: [shape.props.start, shape.props.end],
		}
	}

	override toSvg(shape: MyBezierCurveShape) {
		const path = this.getGeometry(shape).getSvgPathData(true)
		return <path d={path} stroke="black" fill="transparent" strokeWidth={2} />
	}

	// [5]
	override getHandles(shape: MyBezierCurveShape): TLHandle[] {
		const indices = [ZERO_INDEX_KEY, ...getIndicesAbove(ZERO_INDEX_KEY, 3)]

		let handles: TLHandle[] = [
			{
				id: 'start',
				type: 'vertex',
				x: shape.props.start.x,
				y: shape.props.start.y,
				index: indices[0],
				snapType: 'align',
			},
			{
				id: 'cp1',
				type: 'vertex',
				x: shape.props.cp1.x,
				y: shape.props.cp1.y,
				index: indices[1],
				snapType: 'align',
				snapReferenceHandleId: 'start',
			},
			{
				id: 'cp2',
				type: 'vertex',
				x: shape.props.cp2.x,
				y: shape.props.cp2.y,
				index: indices[2],
				snapType: 'align',
			},
			{
				id: 'end',
				type: 'vertex',
				x: shape.props.end.x,
				y: shape.props.end.y,
				index: indices[3],
				snapType: 'align',
			},
		]

		if (Vec.Equals(shape.props.cp1, shape.props.start)) {
			handles = handles.filter((handle) => handle.id !== 'cp1')
		}

		if (Vec.Equals(shape.props.cp2, shape.props.end)) {
			handles = handles.filter((handle) => handle.id !== 'cp2')
		}

		return handles
	}

	// [6]
	override getHandleSnapGeometry(shape: MyBezierCurveShape): HandleSnapGeometry {
		return {
			points: [shape.props.start, shape.props.end],
			getSelfSnapPoints: (handle) => {
				if (handle.id === 'cp1' || handle.id === 'cp2') {
					return [shape.props.start, shape.props.end]
				}

				return handle.id === 'end' ? [shape.props.start] : [shape.props.end]
			},
		}
	}

	// [7]
	override onHandleDrag(shape: MyBezierCurveShape, info: TLHandleDragInfo<MyBezierCurveShape>) {
		const { handle } = info
		const { id, x, y } = handle

		let props = {}
		let newProps: any = {}

		// if you hold command or control key whilst dragging over a start or end handle,
		// move the associated control point to the new positions
		if (this.editor.inputs.getMetaKey()) {
			switch (id) {
				case 'start': {
					return {
						...shape,
						props: {
							...shape.props,
							cp1: { x, y },
						},
					}
				}
				case 'end': {
					return {
						...shape,
						props: {
							...shape.props,
							cp2: { x, y },
						},
					}
				}
			}
		}

		// move the handles
		switch (id) {
			case 'start': {
				const delta = Vec.Sub(handle, shape.props.start)

				newProps = {
					start: { x, y },
					cp1: { x: shape.props.cp1.x + delta.x, y: shape.props.cp1.y + delta.y },
				}
				break
			}
			case 'end': {
				const delta = Vec.Sub(handle, shape.props.end)

				newProps = {
					end: { x, y },
					cp2: { x: shape.props.cp2.x + delta.x, y: shape.props.cp2.y + delta.y },
				}
				break
			}
			default: {
				newProps = {
					[id]: { x, y },
				}
				break
			}
		}

		props = {
			...shape.props,
			...newProps,
		}

		return {
			...shape,
			props,
		}
	}

	// [8]
	override onTranslateStart(shape: MyBezierCurveShape) {
		// only bend if we start translating with the command or control key pressed
		// this avoids bending the curve midway through a translation where the user accidentally
		// holds the command or control key
		this.isMetaKeyOnTranslateStart = this.editor.inputs.getMetaKey()

		// we should bend the curve if we hit the curve but not the start or end handles,
		const handles = this.getHandles(shape)
		const startAndEndHandles = handles.filter(
			(handle) => handle.id === 'start' || handle.id === 'end'
		)
		if (!startAndEndHandles.length) return

		const hitStartOrEndHandle = startAndEndHandles.some((handle) => {
			const threshold = 8 / this.editor.getZoomLevel()
			const pageTransform = this.editor.getShapePageTransform(shape)
			const handleInPageSpace = pageTransform.applyToPoint(handle)

			if (Vec.Dist(handleInPageSpace, this.editor.inputs.getCurrentPagePoint()) < threshold) {
				return true
			}
			return false
		})

		const hitCurve = this.editor.isPointInShape(shape, this.editor.inputs.getCurrentPagePoint(), {
			margin: 10 / this.editor.getZoomLevel(),
		})

		this.didHitCurveOnTranslateStart = hitCurve && !hitStartOrEndHandle
	}

	override onTranslate(initial: MyBezierCurveShape, current: MyBezierCurveShape) {
		// bend the curve
		if (this.isMetaKeyOnTranslateStart && this.didHitCurveOnTranslateStart) {
			const delta = Vec.Sub(current, initial)
			const offsetX = Math.round(delta.x)
			const offsetY = Math.round(delta.y)

			return {
				...initial,
				props: {
					...initial.props,
					cp1: { x: initial.props.cp1.x + offsetX, y: initial.props.cp1.y + offsetY },
					cp2: { x: initial.props.cp2.x + offsetX, y: initial.props.cp2.y + offsetY },
				},
			}
		}

		return
	}

	// [9]
	component(shape: MyBezierCurveShape) {
		const path = this.getGeometry(shape).getSvgPathData(true)
		const { start, end, cp1, cp2 } = shape.props

		const zoomLevel = this.editor.getZoomLevel()

		return (
			<HTMLContainer>
				<svg className="tl-svg-container">
					<path d={path} stroke="black" fill="transparent" />
					<>
						{this.shouldShowControlLines(shape) && (
							<>
								<line
									x1={start.x}
									y1={start.y}
									x2={cp1.x}
									y2={cp1.y}
									stroke="black"
									strokeWidth={1 / zoomLevel}
									strokeDasharray={`${6 / zoomLevel} ${6 / zoomLevel}`}
									opacity={0.5}
								/>
								<line
									x1={end.x}
									y1={end.y}
									x2={cp2.x}
									y2={cp2.y}
									stroke="black"
									strokeWidth={1 / zoomLevel}
									strokeDasharray={`${6 / zoomLevel} ${6 / zoomLevel}`}
									opacity={0.5}
								/>
							</>
						)}
					</>
				</svg>
			</HTMLContainer>
		)
	}

	indicator(shape: MyBezierCurveShape) {
		const path = this.getGeometry(shape).getSvgPathData(true)
		return <path d={path} />
	}

	private shouldShowControlLines(shape: MyBezierCurveShape) {
		const selectedShape = this.editor.getOnlySelectedShape() === shape
		if (!selectedShape) return false

		return this.editor.isInAny(
			'select.editing_shape',
			'select.pointing_handle',
			'select.dragging_handle'
		)
	}
}

/*
This is our custom cubic bezier curve shape. A cubic bezier curve is defined by four points: start, end, and two control points (cp1, cp2).

[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape's properties. For this shape, we define four points (start, cp1, cp2, end)
that define the curve.

[2]
Define the shape type using TLShape with the shape's type as a type argument.

[3]
The BezierCurveShapeUtil extends ShapeUtil to define all behavior for our custom shape. We specify
the static 'type' and 'props' with validators.

[4]
The getGeometry method returns a CubicBezier2d geometry used for hit-testing, bounds calculations,
and rendering.

[5]
Define four interactive handles: start, end, cp1, and cp2. Each has an id, type, position, and index.
Control point handles are hidden when they're at the same position as their associated endpoints (collapsed).

[6]
Custom handle snapping via getHandleSnapGeometry: control points (cp1, cp2) can snap to start/end points.
The snap system automatically handles screen-space thresholds (consistent across zoom levels) and visual
snap indicators. When a control point is snapped to an endpoint, it effectively "collapses" the curve at
that end, creating a sharp corner.

[7]
Handle drag behaviors:
- Meta key + drag start/end handles repositions the associated control point (cp1 or cp2)
- Dragging start/end handles moves the associated control point to maintain curve shape
- Dragging cp1/cp2 directly moves only that control point

[8]
Translation with curve bending: Hold meta key while dragging the curve (not handles) to bend it
by moving both control points together. This is detected on translate start to avoid accidental bending.

[9]
Visual feedback: Display dashed lines from start→cp1 and end→cp2 when the shape is selected
and actively being edited or translated.
*/
```

## CustomHandles.tsx

```tsx
import { TLHandlesProps, useEditor, useValue } from 'tldraw'

export function CustomHandles({ children }: TLHandlesProps) {
	const editor = useEditor()

	const shouldDisplayDefaultHandles = useValue(
		'shouldDisplayDefaultHandles',
		() => {
			// bezier curve handles
			const onlySelectedShape = editor.getOnlySelectedShape()
			if (onlySelectedShape && editor.isShapeOfType(onlySelectedShape, 'bezier-curve')) {
				return editor.isInAny(
					'select.editing_shape',
					'select.pointing_handle',
					'select.dragging_handle'
				)
			}

			// default handle behavior
			if (editor.isInAny('select.idle', 'select.pointing_handle', 'select.pointing_shape')) {
				return true
			}
			if (editor.isInAny('select.editing_shape')) {
				const onlySelectedShape = editor.getOnlySelectedShape()
				if (!onlySelectedShape) return false
				return onlySelectedShape && editor.isShapeOfType(onlySelectedShape, 'note')
			}
			return false
		},
		[editor]
	)

	if (!shouldDisplayDefaultHandles) return null

	return (
		<svg className="tl-user-handles tl-overlays__item" aria-hidden="true">
			{children}
		</svg>
	)
}
```

## SneakyUndoRedoWhileEditing.tsx

```tsx
import { useEffect } from 'react'
import { useEditor } from 'tldraw'

export function SneakyUndoRedoWhileEditing() {
	const editor = useEditor()

	useEffect(() => {
		function handleKeydown(e: KeyboardEvent) {
			if (e.key === 'z' && (e.metaKey || e.ctrlKey)) {
				const editingShape = editor.getEditingShape()
				if (!editingShape) return

				if (e.shiftKey) {
					editor.redo()
					editor.setEditingShape(editingShape)
				} else {
					editor.undo()
					editor.setEditingShape(editingShape)
				}
			}
		}

		window.addEventListener('keydown', handleKeydown)
		return () => {
			window.removeEventListener('keydown', handleKeydown)
		}
	}, [editor])

	return null
}
```

--------

# Custom shape and tool

Category: Shapes & tools

Keywords: toolbar, migrations, icon, util, ui overrides, card shape

A custom shape and tool.

This example shows how to define a custom shape, as well as a custom tool that can be used to create that shape.

In this case, the card tool (select ⚫️ in the toolbar) can be used to create a card shape.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CardShapeTool } from './CardShape/CardShapeTool'
import { CardShapeUtil } from './CardShape/CardShapeUtil'
import { components, uiOverrides } from './ui-overrides'

// There's a guide at the bottom of this file!

// [1]
const customShapeUtils = [CardShapeUtil]
const customTools = [CardShapeTool]

// [2]
export default function CustomConfigExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Pass in the array of custom tool classes
				tools={customTools}
				// Pass in any overrides to the user interface
				overrides={uiOverrides}
				// Pass in the new Keybaord Shortcuts component
				components={components}
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a custom shape, and add your own icon for it to the toolbar.
Check out CardShapeUtil.tsx and CardShapeTool.tsx to see how we define the shape util and tool.
Check out ui-overrides.ts for more info on how to add your icon to the toolbar.

[1]
We define an array to hold the custom shape util and custom tool. It's important to do this outside of
any React component so that this array doesn't get redefined on every render.

[2]
Now we'll pass these arrays into the Tldraw component's props, along with our ui overrides.


*/
```

## ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.card = {
			id: 'card',
			icon: 'color',
			label: 'Card',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('card')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCardSelected = useIsToolSelected(tools['card'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['card']} isSelected={isCardSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['card']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/*

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools to
the toolbar and the keyboard shortcuts menu.

First we have to add our new tool to the tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.

Then, we replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.
*/
```

## CardShapeTool.tsx

```tsx
import { BaseBoxShapeTool, TLClickEventInfo } from 'tldraw'
export class CardShapeTool extends BaseBoxShapeTool {
	static override id = 'card'
	static override initial = 'idle'
	override shapeType = 'card' as const

	override onDoubleClick(_info: TLClickEventInfo) {
		// you can handle events in handlers like this one;
		// check the BaseBoxShapeTool source as an example
	}
}

/*
This file contains our custom tool. The tool is a StateNode with the `id` "card".

We get a lot of functionality for free by extending the BaseBoxShapeTool. but we can
handle events in out own way by overriding methods like onDoubleClick. For an example
of a tool with more custom functionality, check out the screenshot-tool example.

*/
```

## CardShapeUtil.tsx

```tsx
import { useState } from 'react'
import {
	HTMLContainer,
	Rectangle2d,
	ShapeUtil,
	TLDefaultColorStyle,
	TLResizeInfo,
	TLShape,
	getColorValue,
	getDefaultColorTheme,
	resizeBox,
} from 'tldraw'
import { cardShapeMigrations } from './card-shape-migrations'
import { cardShapeProps } from './card-shape-props'

const CARD_TYPE = 'card'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[CARD_TYPE]: { w: number; h: number; color: TLDefaultColorStyle }
	}
}

// A type for our custom card shape
export type ICardShape = TLShape<typeof CARD_TYPE>

// There's a guide at the bottom of this file!

export class CardShapeUtil extends ShapeUtil<ICardShape> {
	static override type = CARD_TYPE
	// [1]
	static override props = cardShapeProps
	// [2]
	static override migrations = cardShapeMigrations

	// [3]
	override isAspectRatioLocked(_shape: ICardShape) {
		return false
	}
	override canResize(_shape: ICardShape) {
		return true
	}

	// [4]
	getDefaultProps(): ICardShape['props'] {
		return {
			w: 300,
			h: 300,
			color: 'black',
		}
	}

	// [5]
	getGeometry(shape: ICardShape) {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	// [6]
	component(shape: ICardShape) {
		const bounds = this.editor.getShapeGeometry(shape).bounds
		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })

		//[a]
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const [count, setCount] = useState(0)

		return (
			<HTMLContainer
				id={shape.id}
				style={{
					border: '1px solid black',
					display: 'flex',
					flexDirection: 'column',
					alignItems: 'center',
					justifyContent: 'center',
					pointerEvents: 'all',
					backgroundColor: getColorValue(theme, shape.props.color, 'semi'),
					color: getColorValue(theme, shape.props.color, 'solid'),
				}}
			>
				<h2>Clicks: {count}</h2>
				<button
					// [b]
					onClick={() => setCount((count) => count + 1)}
					onPointerDown={(e) => e.stopPropagation()}
				>
					{bounds.w.toFixed()}x{bounds.h.toFixed()}
				</button>
			</HTMLContainer>
		)
	}

	// [7]
	indicator(shape: ICardShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	// [8]
	override onResize(shape: ICardShape, info: TLResizeInfo<ICardShape>) {
		return resizeBox(shape, info)
	}
}
/*
A utility class for the card shape. This is where you define the shape's behavior,
how it renders (its component and indicator), and how it handles different events.

[1]
A validation schema for the shape's props (optional)
Check out card-shape-props.ts for more info.

[2]
Migrations for upgrading shapes (optional)
Check out card-shape-migrations.ts for more info.

[3]
Letting the editor know if the shape's aspect ratio is locked, and whether it
can be resized or bound to other shapes.

[4]
The default props the shape will be rendered with when click-creating one.

[5]
We use this to calculate the shape's geometry for hit-testing, bindings and
doing other geometric calculations.

[6]
Render method — the React component that will be rendered for the shape. It takes the
shape as an argument. HTMLContainer is just a div that's being used to wrap our text
and button. We can get the shape's bounds using our own getGeometry method.

- [a] Check it out! We can do normal React stuff here like using setState.
   Annoying: eslint sometimes thinks this is a class component, but it's not.

- [b] You need to stop the pointer down event on buttons, otherwise the editor will
	   think you're trying to select drag the shape.

[7]
Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here

[8]
Resize handler — called when the shape is resized. Sometimes you'll want to do some
custom logic here, but for our purposes, this is fine.
*/
```

## card-shape-migrations.ts

```ts
import { createShapePropsMigrationIds, createShapePropsMigrationSequence } from 'tldraw'

const versions = createShapePropsMigrationIds(
	// this must match the shape type in the shape definition
	'card',
	{
		AddSomeProperty: 1,
	}
)

// Migrations for the custom card shape (optional but very helpful)
export const cardShapeMigrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: versions.AddSomeProperty,
			up(props) {
				// it is safe to mutate the props object here
				props.someProperty = 'some value'
			},
			down(props) {
				delete props.someProperty
			},
		},
	],
})
```

## card-shape-props.ts

```ts
import { DefaultColorStyle, RecordProps, T } from 'tldraw'
import { ICardShape } from './CardShapeUtil'

// Validation for our custom card shape's props, using one of tldraw's default styles
export const cardShapeProps: RecordProps<ICardShape> = {
	w: T.number,
	h: T.number,
	color: DefaultColorStyle,
}

// To generate your own custom styles, check out the custom styles example.
```

--------

# Custom shape with custom styles

Category: Shapes & tools

Keywords: style panel, rating

Use the custom styles API with your custom shapes.

This example shows how to create your own styles and use them in your own shapes.

To use tldraw's existing styles with your shapes, check the [tldraw styles example](https://tldraw.dev/examples/shape-with-tldraw-styles).

## App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	DefaultStylePanel,
	DefaultStylePanelContent,
	HTMLContainer,
	StyleProp,
	T,
	Tldraw,
	TLShape,
	useEditor,
	useRelevantStyles,
} from 'tldraw'
import 'tldraw/tldraw.css'

const MY_SHAPE_WITH_CUSTOM_STYLES_TYPE = 'myshapewithcustomstyles'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_SHAPE_WITH_CUSTOM_STYLES_TYPE]: {
			w: number
			h: number
			rating: MyRatingStyle
		}
	}
}

// [1]
const myRatingStyle = StyleProp.defineEnum('example:rating', {
	defaultValue: 1,
	values: [1, 2, 3, 4, 5],
})

// [2]
type MyRatingStyle = T.TypeOf<typeof myRatingStyle>

type IMyShape = TLShape<typeof MY_SHAPE_WITH_CUSTOM_STYLES_TYPE>

class MyShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = MY_SHAPE_WITH_CUSTOM_STYLES_TYPE

	// [3]
	static override props = {
		w: T.number,
		h: T.number,
		rating: myRatingStyle,
	}

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			rating: 4, // [4]
		}
	}

	component(shape: IMyShape) {
		// [5]
		const stars = ['☆', '☆', '☆', '☆', '☆']
		for (let i = 0; i < shape.props.rating; i++) {
			stars[i] = '★'
		}

		return (
			<HTMLContainer
				id={shape.id}
				style={{ backgroundColor: 'var(--tl-color-low-border)', overflow: 'hidden' }}
			>
				{stars}
			</HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [6]
function CustomStylePanel() {
	const editor = useEditor()
	const styles = useRelevantStyles()
	if (!styles) return null

	const rating = styles.get(myRatingStyle)

	return (
		<DefaultStylePanel>
			<DefaultStylePanelContent />
			{rating !== undefined && (
				<div>
					<select
						style={{ width: '100%', padding: 4 }}
						value={rating.type === 'mixed' ? '' : rating.value}
						onChange={(e) => {
							editor.markHistoryStoppingPoint()
							const value = myRatingStyle.validate(+e.currentTarget.value)
							editor.setStyleForSelectedShapes(myRatingStyle, value)
						}}
					>
						{rating.type === 'mixed' ? <option value="">Mixed</option> : null}
						<option value={1}>1</option>
						<option value={2}>2</option>
						<option value={3}>3</option>
						<option value={4}>4</option>
						<option value={5}>5</option>
					</select>
				</div>
			)}
		</DefaultStylePanel>
	)
}

export default function ShapeWithTldrawStylesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// [7]
				shapeUtils={[MyShapeUtil]}
				components={{
					StylePanel: CustomStylePanel,
				}}
				onMount={(editor) => {
					editor.createShape({ type: 'myshapewithcustomstyles', x: 100, y: 100 })
					editor.selectAll()
					editor.createShape({
						type: 'myshapewithcustomstyles',
						x: 450,
						y: 250,
						props: { rating: 5 },
					})
				}}
			/>
		</div>
	)
}

/*

This file shows a custom shape that uses a user-created styles

For more on custom shapes, see our Custom Shape example.

[1]
In this example, our custom shape will use a new style called "rating".
We'll need to create the style so that we can pass it to the shape's props.

[2]
Here's we extract the type of the style's values. We use it below when
we define the shape's props.

[3]
We pass the style to the shape's props.

[4]
Since this property uses one a style, whatever value we put here in the
shape's default props will be overwritten by the editor's current value
for that style, which will either be the default value or the most
recent value the user has set. This is special behavior just for styles.

[5]
We can use the styles in the component just like any other prop.

[6]
Here we create a custom style panel that includes the default style panel
and also a dropdown for the rating style. We use the useRelevantStyles hook
to get the styles of the user's selected shapes, and the useEditor hook to
set the style for the selected shapes. For more on customizing the style
panel, see our custom style panel example.

[7]
We pass the custom shape util and custom components in as props.

[8]
And for this example, we create two shapes: the first does not specify a
rating, so it will use the editor's current style value (in this example,
this will be the style's default value of 4). The second specifies a
rating of 5, so it will use that value.
*/
```

--------

# Custom shape with tldraw styles

Category: Shapes & tools

Keywords: default styles, style panel

Use the tldraw style panel with your custom shapes.

The default tldraw UI will display UI for the styles of your selection or your current tool. For example, when you have two shapes selected that both have the tldraw's "size" style, the size selector will be displayed. If all of your selected shapes have the same value for this style, that value will be shown as selected in the panel. If they have different values, the panel will show the value as "mixed".

You can use tldraw's default styles in your own shapes. This example shows how to do that.

To create your own custom styles, check the [custom styles example](https://tldraw.dev/examples/shape-with-custom-styles).

## App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	DefaultColorStyle,
	DefaultSizeStyle,
	getColorValue,
	HTMLContainer,
	T,
	TLDefaultColorStyle,
	TLDefaultSizeStyle,
	Tldraw,
	TLShape,
	useDefaultColorTheme,
} from 'tldraw'
import 'tldraw/tldraw.css'

const MY_SHAPE_WITH_TLDRAW_STYLES_TYPE = 'myshapewithtldrawstyles' as const

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_SHAPE_WITH_TLDRAW_STYLES_TYPE]: {
			w: number
			h: number
			size: TLDefaultSizeStyle
			color: TLDefaultColorStyle
		}
	}
}

// There's a guide at the bottom of this file!

const FONT_SIZES: Record<TLDefaultSizeStyle, number> = {
	s: 14,
	m: 25,
	l: 38,
	xl: 48,
}

type IMyShape = TLShape<typeof MY_SHAPE_WITH_TLDRAW_STYLES_TYPE>

class MyShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = MY_SHAPE_WITH_TLDRAW_STYLES_TYPE

	// [2]
	static override props = {
		w: T.number,
		h: T.number,
		size: DefaultSizeStyle,
		color: DefaultColorStyle,
	}

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			size: 'm',
			color: 'black',
		}
	}

	component(shape: IMyShape) {
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const theme = useDefaultColorTheme()

		return (
			<HTMLContainer
				id={shape.id}
				style={{ backgroundColor: 'var(--tl-color-low-border)', overflow: 'hidden' }}
			>
				<div
					style={{
						// [3]
						fontSize: FONT_SIZES[shape.props.size],
						color: getColorValue(theme, shape.props.color, 'solid'),
					}}
				>
					Select the shape and use the style panel to change the font size and color
				</div>
			</HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

const customShapeUtils = [MyShapeUtil]

export default function ShapeWithTldrawStylesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					editor.createShape({ type: 'myshapewithtldrawstyles', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*

This file shows a custom shape that uses tldraw's default styles.
For more on custom shapes, see our Custom Shape example.

[1]
In this example, our custom shape will use the size and color styles from the
default styles. When typing a custom shape, you can use our types for
these styles.

[2]
For the shape's props, we'll pass the DefaultSizeStyle and DefaultColorStyle
styles for the two properties, size and color. There's nothing special about
these styles except that the editor will notice when two shapes are selected
that share the same style. (You can use the useRelevantStyles hook to get the
styles of the user's selected shapes.)

[3]
Here in the component, we'll use the styles to change the way that our shape
appears. The style values themselves are just strings, like 'xl' or 'black',
so it's up to you to decide how to use them. In this example, we're using the
size to set the text's font-size property, and also using the default theme
(via the useDefaultColorTheme hook) to get the color for the text.
*/
```

--------

# Clickable custom shape

Category: Shapes & tools

Keywords: interaction, pointer events, stop propagation, click, input

A custom shape that has its own onClick interactions.

By default the editor handles pointer events, but sometimes you want to handle interactions on your shape in your own ways, for example via a button. You can do this by using the css property `pointer events: all` and stopping event propagation. In this example we want our todo shape to have a checkbox so the user can mark them as done.

Check out my-interactive-shape-util.tsx to see how we create the shape.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

import { myInteractiveShape } from './my-interactive-shape-util'

// There's a guide at the bottom of this file!

// [1]
const customShapeUtils = [myInteractiveShape]

// [2]
export default function InteractiveShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					editor.createShape({ type: 'my-interactive-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
[1]
By default the editor handles pointer events, but sometimes you want to handle
interactions on your shape in your own ways, for example via a button. You can do this
by using the css property `pointer events: all` and stopping event propagation. In
this example we want our todo shape to have a checkbox so the user can mark them as
done.

[2]
Check out my-interactive-shape-util.tsx to see how we create the shape.
 */
```

## my-interactive-shape-util.tsx

```tsx
import { BaseBoxShapeUtil, HTMLContainer, RecordProps, T, TLShape } from 'tldraw'

// There's a guide at the bottom of this file!

const MY_INTERACTIVE_SHAPE_TYPE = 'my-interactive-shape'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_INTERACTIVE_SHAPE_TYPE]: { w: number; h: number; checked: boolean; text: string }
	}
}

export type IMyInteractiveShape = TLShape<typeof MY_INTERACTIVE_SHAPE_TYPE>

export class myInteractiveShape extends BaseBoxShapeUtil<IMyInteractiveShape> {
	static override type = MY_INTERACTIVE_SHAPE_TYPE
	static override props: RecordProps<IMyInteractiveShape> = {
		w: T.number,
		h: T.number,
		checked: T.boolean,
		text: T.string,
	}

	getDefaultProps(): IMyInteractiveShape['props'] {
		return {
			w: 230,
			h: 230,
			checked: false,
			text: '',
		}
	}

	// [1]
	component(shape: IMyInteractiveShape) {
		return (
			<HTMLContainer
				style={{
					padding: 16,
					height: shape.props.h,
					width: shape.props.w,
					// [a] This is where we allow pointer events on our shape
					pointerEvents: 'all',
					backgroundColor: '#efefef',
					overflow: 'hidden',
				}}
			>
				<input
					type="checkbox"
					checked={shape.props.checked}
					onChange={() =>
						this.editor.updateShape({
							id: shape.id,
							type: MY_INTERACTIVE_SHAPE_TYPE,
							props: { checked: !shape.props.checked },
						})
					}
					// [b] This is where we stop event propagation
					onPointerDown={(e) => e.stopPropagation()}
					onTouchStart={(e) => e.stopPropagation()}
					onTouchEnd={(e) => e.stopPropagation()}
				/>
				<input
					type="text"
					placeholder="Enter a todo..."
					readOnly={shape.props.checked}
					value={shape.props.text}
					onChange={(e) =>
						this.editor.updateShape({
							id: shape.id,
							type: MY_INTERACTIVE_SHAPE_TYPE,
							props: { text: e.currentTarget.value },
						})
					}
					// [c]
					onPointerDown={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
					onTouchStart={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
					onTouchEnd={(e) => {
						if (!shape.props.checked) {
							e.stopPropagation()
						}
					}}
				/>
			</HTMLContainer>
		)
	}

	// [5]
	indicator(shape: IMyInteractiveShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/*
This is a custom shape, for a more in-depth look at how to create a custom shape,
see our custom shape example.

[1]
This is where we describe how our shape will render

	[a] We need to set pointer-events to all so that we can interact with our shape. This CSS property is
	set to "none" off by default. We need to manually opt-in to accepting pointer events by setting it to
	'all' or 'auto'.

	[b] We need to stop event propagation so that the editor doesn't select the shape
		when we click on the checkbox. The 'canvas container' forwards events that it receives
		on to the editor, so stopping propagation here prevents the event from reaching the canvas.

	[c] If the shape is not checked, we stop event propagation so that the editor doesn't
		select the shape when we click on the input. If the shape is checked then we allow that event to
		propagate to the canvas and then get sent to the editor, triggering clicks or drags as usual.

*/
```

--------

# Custom handle snap reference

Category: Shapes & tools

Keywords: handles, snapping, snap reference

An example demonstrating `snapReferenceHandleId` for control point angle snapping.

This example shows how to use the `snapReferenceHandleId` property to control which handle serves as the reference point for shift-modifier angle snapping.

## App.tsx

```tsx
import {
	Edge2d,
	Geometry2d,
	Group2d,
	HTMLContainer,
	RecordProps,
	ShapeUtil,
	TLHandle,
	TLHandleDragInfo,
	TLShape,
	Tldraw,
	Vec,
	VecLike,
	ZERO_INDEX_KEY,
	getIndicesAbove,
	vecModelValidator,
} from 'tldraw'
import 'tldraw/tldraw.css'

const Y_SHAPE_TYPE = 'y-shape'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[Y_SHAPE_TYPE]: {
			center: VecLike
			armTop: VecLike
			armLeft: VecLike
			armRight: VecLike
		}
	}
}

// [2]
type YShape = TLShape<typeof Y_SHAPE_TYPE>

// [3]
class YShapeUtil extends ShapeUtil<YShape> {
	static override type = Y_SHAPE_TYPE
	static override props: RecordProps<YShape> = {
		center: vecModelValidator,
		armTop: vecModelValidator,
		armLeft: vecModelValidator,
		armRight: vecModelValidator,
	}

	override getDefaultProps(): YShape['props'] {
		return {
			center: { x: 100, y: 100 },
			armTop: { x: 100, y: 180 },
			armLeft: { x: 30, y: 20 },
			armRight: { x: 170, y: 20 },
		}
	}

	override canEdit(): boolean {
		return true
	}

	override hideSelectionBoundsBg(): boolean {
		return true
	}

	override hideSelectionBoundsFg(): boolean {
		return true
	}

	override hideResizeHandles(): boolean {
		return true
	}

	override hideRotateHandle(): boolean {
		return true
	}

	// [4]
	getGeometry(shape: YShape): Geometry2d {
		const { center, armTop, armLeft, armRight } = shape.props
		const c = Vec.From(center)
		const t = Vec.From(armTop)
		const l = Vec.From(armLeft)
		const r = Vec.From(armRight)

		return new Group2d({
			children: [
				new Edge2d({ start: c, end: t }),
				new Edge2d({ start: c, end: l }),
				new Edge2d({ start: c, end: r }),
			],
		})
	}

	// [5]
	override getHandles(shape: YShape): TLHandle[] {
		const indices = [ZERO_INDEX_KEY, ...getIndicesAbove(ZERO_INDEX_KEY, 3)]

		return [
			{
				id: 'center',
				type: 'vertex',
				x: shape.props.center.x,
				y: shape.props.center.y,
				index: indices[0],
			},
			{
				id: 'armTop',
				type: 'vertex',
				x: shape.props.armTop.x,
				y: shape.props.armTop.y,
				index: indices[1],
				// [6]
				snapReferenceHandleId: 'center',
			},
			{
				id: 'armLeft',
				type: 'vertex',
				x: shape.props.armLeft.x,
				y: shape.props.armLeft.y,
				index: indices[2],
				// [7]
				snapReferenceHandleId: 'center',
			},
			{
				id: 'armRight',
				type: 'vertex',
				x: shape.props.armRight.x,
				y: shape.props.armRight.y,
				index: indices[3],
				// [8]
				snapReferenceHandleId: 'center',
			},
		]
	}

	override onHandleDrag(shape: YShape, info: TLHandleDragInfo<YShape>) {
		const { handle } = info
		return {
			...shape,
			props: {
				...shape.props,
				[handle.id]: { x: handle.x, y: handle.y },
			},
		}
	}

	// [9]
	component(shape: YShape) {
		const { center, armTop, armLeft, armRight } = shape.props

		return (
			<HTMLContainer>
				<svg className="tl-svg-container">
					<line
						x1={center.x}
						y1={center.y}
						x2={armTop.x}
						y2={armTop.y}
						stroke="black"
						strokeWidth={2}
					/>
					<line
						x1={center.x}
						y1={center.y}
						x2={armLeft.x}
						y2={armLeft.y}
						stroke="black"
						strokeWidth={2}
					/>
					<line
						x1={center.x}
						y1={center.y}
						x2={armRight.x}
						y2={armRight.y}
						stroke="black"
						strokeWidth={2}
					/>
				</svg>
			</HTMLContainer>
		)
	}

	indicator(shape: YShape) {
		const { center, armTop, armLeft, armRight } = shape.props
		return (
			<>
				<line x1={center.x} y1={center.y} x2={armTop.x} y2={armTop.y} />
				<line x1={center.x} y1={center.y} x2={armLeft.x} y2={armLeft.y} />
				<line x1={center.x} y1={center.y} x2={armRight.x} y2={armRight.y} />
			</>
		)
	}
}

const customShapes = [YShapeUtil]

export default function CustomRelativeSnappingYShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapes}
				onMount={(editor) => {
					const viewportPageBounds = editor.getViewportPageBounds()
					const centerX = viewportPageBounds.center.x
					const centerY = viewportPageBounds.center.y

					editor.createShape({
						type: Y_SHAPE_TYPE,
						x: centerX - 100,
						y: centerY - 100,
					})

					const shapeId = editor.getCurrentPageShapeIds().values().next().value
					if (shapeId) {
						editor.select(shapeId)
					}
				}}
			/>
		</div>
	)
}

/*
This example demonstrates the `snapReferenceHandleId` property using a Y-shaped connector.

The shape has three arms radiating from a center junction point:
- center (junction point)
- armTop (top arm endpoint)
- armLeft (bottom-left arm endpoint)
- armRight (bottom-right arm endpoint)

[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape type with four points representing a Y-shaped connector.

[2]
Define the shape type using TLShape with the shape's type as a type argument.

[3]
The shape util with validators for each point.

[4]
Use Group2d geometry containing three line segments from center to each arm.

[5]
Four handles in array order: [center, armTop, armLeft, armRight]

[6]
With `snapReferenceHandleId: 'center'`, when you shift+drag armTop, it will snap to the center point.

[7]
Similarly, armLeft would snap relative to the center point.

[8]
And armRight would snap to the center point.

[9]
The component method defines how our shape renders.

*/
```

--------

# Custom shape with handles

Category: Shapes & tools

Keywords: handles, handle, geometry, interaction, text label

A speech bubble shape with custom handles.

This example shows how to create a custom shape with custom handles.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { SpeechBubbleTool } from './SpeechBubble/SpeechBubbleTool'
import { SpeechBubbleUtil } from './SpeechBubble/SpeechBubbleUtil'
import { components, customAssetUrls, uiOverrides } from './SpeechBubble/ui-overrides'
import './customhandles.css'

// There's a guide at the bottom of this file!

// [1]
const shapeUtils = [SpeechBubbleUtil]
const tools = [SpeechBubbleTool]

// [2]
export default function CustomShapeWithHandles() {
	return (
		<div style={{ position: 'absolute', inset: 0 }}>
			<Tldraw
				shapeUtils={shapeUtils}
				tools={tools}
				overrides={uiOverrides}
				assetUrls={customAssetUrls}
				components={components}
				persistenceKey="whatever"
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a custom shape using handles. You can use handles when you want
user interaction to alter the geometry of a shape. In this example, we create a speech bubble shape
with a handle on the tail so the user can alter its position and length. Most of the interesting stuff
is in SpeechBubbleUtil.tsx and helpers.tsx.

[1]
We define an array to hold the custom shape util and cusom tool. It's important to do this outside of
any React component so that this array doesn't get redefined on every render. We'll pass this into the
Tldraw component's `shapeUtils` and `tools` props.

Check out SpeechBubbleUtil.tsx and SpeechBubbleTool.tsx to see how we define the shape util and tool.

[2]
We pass the custom shape util and tool into the Tldraw component's `shapeUtils` and `tools` props.
We also pass in the custom ui overrides and asset urls to make sure our icons render where we want them to.
Check out ui-overrides.ts for more details.

*/
```

## customhandles.css

```css
/* Resize handles are normally on top, but We're going to give shape handles priority */
.tl-user-handles {
	z-index: 101;
}

/* The text label doesn't normally deal with text that goes sideways,
 * so this accounts for that */
.tl-shape[data-shape-type='speech-bubble'] .tl-text-label {
	justify-content: flex-start !important;
}
```

## SpeechBubbleTool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'

export class SpeechBubbleTool extends BaseBoxShapeTool {
	static override id = 'speech-bubble'
	static override initial = 'idle'
	override shapeType = 'speech-bubble' as const
}

/*
This file contains our speech bubble tool. The tool is a StateNode with the `id` "speech-bubble".

We get a lot of functionality for free by extending the BaseBoxShapeTool. For an example of a tool
with more custom functionality, check out the screenshot-tool example.

*/
```

## SpeechBubbleUtil.tsx

```tsx
import {
	DefaultColorStyle,
	DefaultFontStyle,
	DefaultHorizontalAlignStyle,
	DefaultSizeStyle,
	DefaultVerticalAlignStyle,
	FONT_FAMILIES,
	Geometry2d,
	LABEL_FONT_SIZES,
	PlainTextLabel,
	Polygon2d,
	RecordPropsType,
	ShapeUtil,
	T,
	TEXT_PROPS,
	TLHandle,
	TLHandleDragInfo,
	TLResizeInfo,
	TLShape,
	Vec,
	ZERO_INDEX_KEY,
	getColorValue,
	resizeBox,
	structuredClone,
	useDefaultColorTheme,
	vecModelValidator,
} from 'tldraw'
import { getSpeechBubbleVertices, getTailIntersectionPoint } from './helpers'

const SPEECH_BUBBLE_TYPE = 'speech-bubble'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[SPEECH_BUBBLE_TYPE]: SpeechBubbleShapeProps
	}
}

// Copied from tldraw/tldraw
export const STROKE_SIZES = {
	s: 2,
	m: 3.5,
	l: 5,
	xl: 10,
}

// There's a guide at the bottom of this file!

export const speechBubbleShapeProps = {
	w: T.number,
	h: T.number,
	size: DefaultSizeStyle,
	color: DefaultColorStyle,
	font: DefaultFontStyle,
	align: DefaultHorizontalAlignStyle,
	verticalAlign: DefaultVerticalAlignStyle,
	growY: T.positiveNumber,
	text: T.string,
	tail: vecModelValidator,
}

export type SpeechBubbleShapeProps = RecordPropsType<typeof speechBubbleShapeProps>
// [2]
export type SpeechBubbleShape = TLShape<typeof SPEECH_BUBBLE_TYPE>

export class SpeechBubbleUtil extends ShapeUtil<SpeechBubbleShape> {
	static override type = SPEECH_BUBBLE_TYPE

	// [3]
	static override props = speechBubbleShapeProps

	override isAspectRatioLocked(_shape: SpeechBubbleShape) {
		return false
	}

	override canResize(_shape: SpeechBubbleShape) {
		return true
	}

	override canEdit() {
		return true
	}

	// [4]
	getDefaultProps(): SpeechBubbleShapeProps {
		return {
			w: 200,
			h: 130,
			color: 'black',
			size: 'm',
			font: 'draw',
			align: 'middle',
			verticalAlign: 'start',
			growY: 0,
			text: '',
			tail: { x: 0.5, y: 1.5 },
		}
	}

	getHeight(shape: SpeechBubbleShape) {
		return shape.props.h + shape.props.growY
	}

	getGeometry(shape: SpeechBubbleShape): Geometry2d {
		const speechBubbleGeometry = getSpeechBubbleVertices(shape)
		const body = new Polygon2d({
			points: speechBubbleGeometry,
			isFilled: true,
		})
		return body
	}

	// [5]
	override getHandles(shape: SpeechBubbleShape): TLHandle[] {
		const { tail, w } = shape.props

		return [
			{
				id: 'tail',
				type: 'vertex',
				label: 'Move tail',
				index: ZERO_INDEX_KEY,
				// props.tail coordinates are normalized
				// but here we need them in shape space
				x: tail.x * w,
				y: tail.y * this.getHeight(shape),
			},
		]
	}

	override onHandleDrag(shape: SpeechBubbleShape, { handle }: TLHandleDragInfo<SpeechBubbleShape>) {
		return {
			...shape,
			props: {
				tail: {
					x: handle.x / shape.props.w,
					y: handle.y / this.getHeight(shape),
				},
			},
		}
	}

	override onBeforeCreate(next: SpeechBubbleShape) {
		return this.getGrowY(next, next.props.growY)
	}

	// [6]
	override onBeforeUpdate(prev: SpeechBubbleShape, shape: SpeechBubbleShape) {
		const { w, tail } = shape.props
		const fullHeight = this.getHeight(shape)

		const { segmentsIntersection, insideShape } = getTailIntersectionPoint(shape)

		const slantedLength = Math.hypot(w, fullHeight)
		const MIN_DISTANCE = slantedLength / 5
		const MAX_DISTANCE = slantedLength / 1.5

		const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

		const distanceToIntersection = tailInShapeSpace.dist(segmentsIntersection)
		const center = new Vec(w / 2, fullHeight / 2)
		const tailDirection = Vec.Sub(tailInShapeSpace, center).uni()

		let newPoint = tailInShapeSpace

		if (insideShape) {
			newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MIN_DISTANCE))
		} else {
			if (distanceToIntersection <= MIN_DISTANCE) {
				newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MIN_DISTANCE))
			} else if (distanceToIntersection >= MAX_DISTANCE) {
				newPoint = Vec.Add(segmentsIntersection, tailDirection.mul(MAX_DISTANCE))
			}
		}

		const next = structuredClone(shape)
		next.props.tail.x = newPoint.x / w
		next.props.tail.y = newPoint.y / fullHeight

		return this.getGrowY(next, prev.props.growY)
	}

	component(shape: SpeechBubbleShape) {
		const {
			id,
			type,
			props: { color, font, size, align, text },
		} = shape
		const vertices = getSpeechBubbleVertices(shape)
		const pathData = 'M' + vertices[0] + 'L' + vertices.slice(1) + 'Z'
		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
		// eslint-disable-next-line react-hooks/rules-of-hooks
		const theme = useDefaultColorTheme()

		return (
			<>
				<svg className="tl-svg-container">
					<path
						d={pathData}
						strokeWidth={STROKE_SIZES[size]}
						stroke={getColorValue(theme, color, 'solid')}
						fill={'none'}
					/>
				</svg>
				<PlainTextLabel
					shapeId={id}
					type={type}
					font={font}
					textWidth={shape.props.w}
					fontSize={LABEL_FONT_SIZES[size]}
					lineHeight={TEXT_PROPS.lineHeight}
					align={align}
					verticalAlign="start"
					text={text}
					labelColor={getColorValue(theme, color, 'solid')}
					isSelected={isSelected}
					wrap
				/>
			</>
		)
	}

	indicator(shape: SpeechBubbleShape) {
		const vertices = getSpeechBubbleVertices(shape)
		const pathData = 'M' + vertices[0] + 'L' + vertices.slice(1) + 'Z'
		return <path d={pathData} />
	}

	override onResize(shape: SpeechBubbleShape, info: TLResizeInfo<SpeechBubbleShape>) {
		const resized = resizeBox(shape, info)
		const next = structuredClone(info.initialShape)
		next.x = resized.x
		next.y = resized.y
		next.props.w = resized.props.w
		next.props.h = resized.props.h
		return next
	}

	getGrowY(shape: SpeechBubbleShape, prevGrowY = 0) {
		const PADDING = 17

		const nextTextSize = this.editor.textMeasure.measureText(shape.props.text, {
			...TEXT_PROPS,
			fontFamily: FONT_FAMILIES[shape.props.font],
			fontSize: LABEL_FONT_SIZES[shape.props.size],
			maxWidth: shape.props.w - PADDING * 2,
		})

		const nextHeight = nextTextSize.h + PADDING * 2

		let growY = 0

		if (nextHeight > shape.props.h) {
			growY = nextHeight - shape.props.h
		} else {
			if (prevGrowY) {
				growY = 0
			}
		}

		return {
			...shape,
			props: {
				...shape.props,
				growY,
			},
		}
	}
}

/*
Introduction: This file contains our custom shape util. The shape util is a class that defines how
our shape behaves. Most of the logic for how the speech bubble shape works is in the onBeforeUpdate
handler [6]. Since this shape has a handle, we need to do some special stuff to make sure it updates
the way we want it to.

[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape's properties. For this shape, we define width (w), height (h),
size, color, font, alignment, text, and tail (using VecModel) as the shape's properties.

[2]
Define the shape type using TLShape with the shape's type as a type argument.

[3]
This is where we define the shape's props and a type validator for each key. tldraw exports a
bunch of handy validators for us to use. Props you define here will determine which style options
show up in the style menu, e.g. we define 'size' and 'color' props, but we could add 'dash', 'fill'
or any other of the default props.

[4]
Here is where we set the default props for our shape, this will determine how the shape looks
when we click-create it. You'll notice we don't store the tail's absolute position though, instead
we record its relative position. This is because we can also drag-create shapes. If we store the
tail's position absolutely it won't scale properly when drag-creating. Throughout the rest of the
util we'll need to convert the tail's relative position to an absolute position and vice versa.

[5]
`getHandles` tells tldraw how to turn our shape into a list of handles that'll show up when it's
selected. We only have one handle, the tail, which simplifies things for us a bit. In
`onHandleDrag`, we tell tldraw how our shape should be updated when the handle is dragged.

[6]
This is the last method that fires after a shape has been changed, we can use it to make sure
the tail stays the right length and position. Check out helpers.tsx to get into some of the more
specific geometry stuff.
*/
```

## helpers.tsx

```tsx
import { Vec, VecLike, lerp, pointInPolygon } from 'tldraw'
import { SpeechBubbleShape } from './SpeechBubbleUtil'

export const getSpeechBubbleVertices = (shape: SpeechBubbleShape): Vec[] => {
	const { w, tail } = shape.props

	const fullHeight = shape.props.h + shape.props.growY
	const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

	const [tl, tr, br, bl] = [
		new Vec(0, 0),
		new Vec(w, 0),
		new Vec(w, fullHeight),
		new Vec(0, fullHeight),
	]

	const offsetH = w / 10
	const offsetV = fullHeight / 10

	const { adjustedIntersection, intersectionSegmentIndex } = getTailIntersectionPoint(shape)

	let vertices: Vec[]

	// Inject the tail segments into the geometry of the shape
	switch (intersectionSegmentIndex) {
		case 0:
			// top
			vertices = [
				tl,
				new Vec(adjustedIntersection.x - offsetH, adjustedIntersection.y),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x + offsetH, adjustedIntersection.y),
				tr,
				br,
				bl,
			]
			break
		case 1:
			// right
			vertices = [
				tl,
				tr,
				new Vec(adjustedIntersection.x, adjustedIntersection.y - offsetV),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x, adjustedIntersection.y + offsetV),
				br,
				bl,
			]
			break
		case 2:
			// bottom
			vertices = [
				tl,
				tr,
				br,
				new Vec(adjustedIntersection.x + offsetH, adjustedIntersection.y),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x - offsetH, adjustedIntersection.y),
				bl,
			]
			break
		case 3:
			// left
			vertices = [
				tl,
				tr,
				br,
				bl,
				new Vec(adjustedIntersection.x, adjustedIntersection.y + offsetV),
				new Vec(tailInShapeSpace.x, tailInShapeSpace.y),
				new Vec(adjustedIntersection.x, adjustedIntersection.y - offsetV),
			]
			break
		default:
			throw Error("no intersection found, this shouldn't happen")
	}

	return vertices
}

export function getTailIntersectionPoint(shape: SpeechBubbleShape) {
	const { w, tail } = shape.props
	const fullHeight = shape.props.h + shape.props.growY
	const tailInShapeSpace = new Vec(tail.x * w, tail.y * fullHeight)

	const center = new Vec(w / 2, fullHeight / 2)
	const corners = [new Vec(0, 0), new Vec(w, 0), new Vec(w, fullHeight), new Vec(0, fullHeight)]
	const segments = [
		[corners[0], corners[1]],
		[corners[1], corners[2]],
		[corners[2], corners[3]],
		[corners[3], corners[0]],
	]

	let segmentsIntersection: Vec | null = null
	let intersectionSegment: Vec[] | null = null

	// If the point inside of the box's corners?
	const insideShape = pointInPolygon(tailInShapeSpace, corners)

	// We want to be sure we get an intersection, so if the point is
	// inside the shape, push it away from the center by a big distance
	const pointToCheck = insideShape
		? Vec.Add(tailInShapeSpace, Vec.Sub(tailInShapeSpace, center).uni().mul(1000000))
		: tailInShapeSpace

	// Test each segment for an intersection
	for (const segment of segments) {
		segmentsIntersection = intersectLineSegmentLineSegment(
			segment[0],
			segment[1],
			center,
			pointToCheck
		)

		if (segmentsIntersection) {
			intersectionSegment = segment
			break
		}
	}

	if (!(segmentsIntersection && intersectionSegment)) {
		throw Error("no intersection found, this shouldn't happen")
	}

	const [start, end] = intersectionSegment
	const intersectionSegmentIndex = segments.indexOf(intersectionSegment)

	// a normalised vector from start to end, so this can work in any direction
	const unit = Vec.Sub(end, start).uni()

	// Where is the intersection relative to the start?
	const totalDistance = Vec.Dist(start, end)
	const distance = Vec.Dist(segmentsIntersection, start)

	// make it stick to the middle
	const middleRelative = mapRange(0, totalDistance, -1, 1, distance) // absolute -> -1 to 1
	const squaredRelative = Math.abs(middleRelative) ** 2 * Math.sign(middleRelative) // square it and keep the sign
	const squared = mapRange(-1, 1, 0, totalDistance, squaredRelative) // -1 to 1 -> absolute

	//keep it away from the edges
	const offset = (segments.indexOf(intersectionSegment) % 2 === 0 ? w / 10 : fullHeight / 10) * 3
	const constrained = mapRange(0, totalDistance, offset, totalDistance - offset, distance)

	// combine the two
	const interpolated = lerp(constrained, squared, 0.5)

	const adjustedIntersection = unit.mul(interpolated).add(start)

	// We need the adjusted intersection to draw the tail, but the original intersection
	// for the onBeforeUpdate handler
	return {
		segmentsIntersection,
		adjustedIntersection,
		intersectionSegmentIndex,
		insideShape,
	}
}

// This function is copied from the tldraw codebase
function intersectLineSegmentLineSegment(a1: VecLike, a2: VecLike, b1: VecLike, b2: VecLike) {
	const ABx = a1.x - b1.x
	const ABy = a1.y - b1.y
	const BVx = b2.x - b1.x
	const BVy = b2.y - b1.y
	const AVx = a2.x - a1.x
	const AVy = a2.y - a1.y
	const ua_t = BVx * ABy - BVy * ABx
	const ub_t = AVx * ABy - AVy * ABx
	const u_b = BVy * AVx - BVx * AVy

	if (ua_t === 0 || ub_t === 0) return null // coincident

	if (u_b === 0) return null // parallel

	if (u_b !== 0) {
		const ua = ua_t / u_b
		const ub = ub_t / u_b
		if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
			return Vec.AddXY(a1, ua * AVx, ua * AVy)
		}
	}

	return null // no intersection
}

/**
 * Inverse linear interpolation
 */
function invLerp(a: number, b: number, v: number) {
	return (v - a) / (b - a)
}
/**
 * Maps a value from one range to another.
 * e.g. mapRange(10, 20, 50, 100, 15) => 75
 */
function mapRange(a1: number, b1: number, a2: number, b2: number, s: number) {
	return lerp(a2, b2, invLerp(a1, b1, s))
}
```

## ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiAssetUrlOverrides,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

// [1]
export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		tools.speech = {
			id: 'speech-bubble',
			icon: 'speech-bubble',
			label: 'Speech Bubble',
			kbd: 's',
			onSelect: () => {
				editor.setCurrentTool('speech-bubble')
			},
		}
		return tools
	},
}

// [2]
export const customAssetUrls: TLUiAssetUrlOverrides = {
	icons: {
		'speech-bubble': '/speech-bubble.svg',
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isSpeechBubbleSelected = useIsToolSelected(tools['speech'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['speech']} isSelected={isSpeechBubbleSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['speech']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/*

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools
to the toolbar and the keyboard shortcuts menu.

[1]
Here we add our new tool to the UI's tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.


[2]
Our toolbar item is using a custom icon, so we need to provide the asset url for it.
We do this by providing a custom assetUrls object to the Tldraw component.
This object is a map of icon ids to their urls. The icon ids are the same as the
icon prop on the toolbar item. We'll pass our assetUrls object into the Tldraw
component's `assetUrls` prop.

[3]
We replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.

*/
```

--------

# Custom tool with child states

Category: Shapes & tools

Keywords: state machine, custom tool, state node, interactions

You can implement more complex behaviour in a custom tool by using child states

Tools are nodes in tldraw's state machine. They are responsible for handling user input. You can create custom tools by extending the StateNode class and overriding its methods. In this example we expand on the sticker tool from the [custom tool example](https://tldraw.dev/examples/custom-tool) to show how to create a tool that can handle more complex interactions by using child states.

## App.tsx

```tsx
import {
	StateNode,
	TLClickEventInfo,
	TLPointerEventInfo,
	TLShapePartial,
	TLTextShape,
	Tldraw,
	createShapeId,
	toRichText,
} from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const OFFSET = -12

// [1]
class StickerTool extends StateNode {
	static override id = 'sticker'
	static override initial = 'idle'
	static override children() {
		return [Idle, Pointing, Dragging]
	}
}

// [2]
class Idle extends StateNode {
	static override id = 'idle'
	//[a]
	override onEnter() {
		this.editor.setCursor({ type: 'cross' })
	}
	//[b]
	override onPointerDown(info: TLPointerEventInfo) {
		const { editor } = this
		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.getCurrentPagePoint())
				if (hitShape) {
					this.onPointerDown({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				this.parent.transition('pointing', { shape: null })
				break
			}
			case 'shape': {
				if (editor.inputs.getShiftKey()) {
					editor.updateShape({
						id: info.shape.id,
						type: 'text',
						props: { richText: toRichText('👻 boo!') },
					})
				} else {
					this.parent.transition('pointing', { shape: info.shape })
				}
				break
			}
		}
	}
	//[c]
	override onDoubleClick(info: TLClickEventInfo) {
		const { editor } = this
		if (info.phase !== 'up') return
		switch (info.target) {
			case 'canvas': {
				const hitShape = editor.getShapeAtPoint(editor.inputs.getCurrentPagePoint())

				if (hitShape) {
					this.onDoubleClick({
						...info,
						shape: hitShape,
						target: 'shape',
					})
					return
				}
				const currentPagePoint = editor.inputs.getCurrentPagePoint()
				editor.createShape({
					type: 'text',
					x: currentPagePoint.x + OFFSET,
					y: currentPagePoint.y + OFFSET,
					props: { richText: toRichText('❤️') },
				})
				break
			}
			case 'shape': {
				editor.deleteShapes([info.shape.id])
				break
			}
		}
	}
}
// [3]
class Pointing extends StateNode {
	static override id = 'pointing'
	private shape: TLTextShape | null = null

	override onEnter(info: { shape: TLTextShape | null }) {
		this.shape = info.shape
	}
	override onPointerUp() {
		this.parent.transition('idle')
	}

	override onPointerMove() {
		if (this.editor.inputs.getIsDragging()) {
			this.parent.transition('dragging', { shape: this.shape })
		}
	}
}

// [4]
class Dragging extends StateNode {
	static override id = 'dragging'
	// [a]
	private shape: TLShapePartial | null = null
	private emojiArray = ['❤️', '🔥', '👍', '👎', '😭', '🤣']

	// [b]
	override onEnter(info: { shape: TLShapePartial }) {
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		const newShape: TLShapePartial<TLTextShape> = {
			id: createShapeId(),
			type: 'text',
			x: currentPagePoint.x + OFFSET,
			y: currentPagePoint.y + OFFSET,
			props: { richText: toRichText('❤️') },
		}
		if (info.shape) {
			this.shape = info.shape
		} else {
			this.editor.createShape(newShape)
			this.shape = { ...newShape }
		}
	}
	//[c]
	override onPointerUp() {
		this.parent.transition('idle')
	}
	//[d]

	override onPointerMove() {
		const { shape } = this
		const originPagePoint = this.editor.inputs.getOriginPagePoint()
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		const distance = originPagePoint.dist(currentPagePoint)
		if (shape) {
			this.editor.updateShape({
				id: shape.id,
				type: 'text',
				props: {
					richText: toRichText(this.emojiArray[Math.floor(distance / 20) % this.emojiArray.length]),
				},
			})
		}
	}
}

// [5]
const customTools = [StickerTool]
export default function ToolWithChildStatesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom tool classes
				tools={customTools}
				// Set the initial state to the sticker tool
				initialState="sticker"
				// hide the ui
				hideUi
				// Put some helpful text on the canvas
				onMount={(editor) => {
					editor.createShape({
						type: 'text',
						x: 50,
						y: 50,
						props: {
							richText: toRichText(
								'-Double click the canvas to add a sticker\n-Double click a sticker to delete it\n-Click and drag on a sticker to change it\n-Click and drag on the canvas to create a sticker\n-Shift click a sticker for a surprise!'
							),
							size: 's',
							textAlign: 'start',
						},
					})
				}}
			/>
		</div>
	)
}

/*
Introduction:

Tools are nodes in tldraw's state machine. They are responsible for handling user input.
You can create custom tools by extending the `StateNode` class and overriding its
methods. In this example we expand on the sticker tool from the custom tool example to
show how to create a tool that can handle more complex interactions by using child states.

[1]
This is our custom tool. It has three child states: `Idle`, `Pointing`, and `Dragging`.
We need to define the `id` and `initial` properties, the id is a unique string that
identifies the tool to the editor, and the initial property is the initial state of the
tool. We also need to define a `children` method that returns an array of the tool's
child states.

[2]
This is our Idle state. It is the initial state of the tool. It's job is to figure out
what the user is trying to do and transition to the appropriate state. When transitioning
between states we can use the second argument to pass data to the new state. It has three
methods:

	[a] `onEnter`
	When entering any state, the `onEnter` method is called. In this case, we set the cursor to
	a crosshair.

	[b] `onPointerDown`
	This method is called when the user presses the mouse button. The target parameter is always
	the canvas, so we can use an editor method to check if we're over a shape, and call the
	method again with the shape as the target. If we are over a shape, we transition to the
	`pointing` state with the shape in the info object. If we're over a shape and holding the
	shift key, we update the shape's text. If we're over the canvas, we transition to the
	`pointing` state with a null shape in the info object.

	[c] `onDoubleClick`
	This method is called when the user double clicks the mouse button. We're using some similar
	logic here to check if we're over a shape, and if we are, we delete it. If we're over the canvas,
	we create a new shape.

[3]
This is our `Pointing` state. It's a transitionary state, we use it to store the shape we're pointing
at, and transition to the dragging state if the user starts dragging. It has three methods:

	[a] `onEnter`
	When entering this state, we store the shape we're pointing at by getting it from the info object.

	[b] `onPointerUp`
	This method is called when the user releases the mouse button. We transition to the `idle` state.

	[c] `onPointerMove`
	This method is called when the user moves the mouse. If the user starts dragging, we transition to
	the `dragging` state and pass the shape we're pointing at.

[4]
This is our `Dragging` state. It's responsible for creating and updating the shape that the user is
dragging.

	[a] `onEnter`
	When entering this state, we create a new shape if we're not dragging an existing one. If we are,
	we store the shape we're dragging.

	[b] `onPointerUp`
	This method is called when the user releases the mouse button. We transition to the `idle` state.

	[c] `onPointerMove`
	This method is called when the user moves the mouse. We use the distance between the origin and
	current mouse position to cycle through an array of emojis and update the shape's text.

[5]
We pass our custom tool to the `Tldraw` component as an array. We also set the initial state to our
custom tool. For the purposes of this demo, we're also hiding the UI and adding some helpful text to
the canvas.
*/
```

--------

# Editable custom shape

Category: Shapes & tools

Keywords: custom

A custom shape that you can edit by double-clicking it.

In tldraw, the Editor can have one editing shape at a time. When in its editing state, the editor will ignore events until the user exits the editing state by pressing Escape or clicking on the canvas.

Only shapes with a `canEdit` flag that returns true may become editable. A user may begin editing a shape by double clicking on the editable shape, or selecting the editable shape and pressing enter.

Many of our shapes use editing to allow for interactions inside of the shape. For example, a text shape behaves like a text graphic until the user begins editing it—and only then can the user use their keyboard to edit the text. Note that a shape can be interactive regardless of whether it's the editor's editing shape—the "editing" mechanic is just a way of managing a common pattern in canvas applications.

In this example we'll create a shape that renders an emoji and allows the user to change the emoji when the shape is in the editing state.
Most of the relevant code for this is in the EditableShapeUtil.tsx file. If you want a more in-depth explanation of the shape util, check out the custom shape example.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { EditableShapeUtil } from './EditableShapeUtil'

const customShapeUtils = [EditableShapeUtil]

export default function EditableShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Create a shape when the editor mounts
				onMount={(editor) => {
					editor.createShape({ type: 'my-editable-shape', x: 100, y: 100 })
				}}
			/>
		</div>
	)
}

/*
Introduction:

In tldraw, shapes can exist in an editing state. When shapes are in the editing state
they are focused and can't be dragged, resized or rotated. Shapes enter this state
when they are double-clicked. In our default shapes we mostly use this for editing text.
In this example we'll create a shape that renders an emoji and allows the user to change
the emoji when the shape is in the editing state.

Most of the relevant code for this is in the EditableShapeUtil.tsx file. If you want a more
in-depth explanation of the shape util, check out the custom shape example.
 */
```

## EditableShapeUtil.tsx

```tsx
import { BaseBoxShapeUtil, HTMLContainer, RecordProps, T, TLShape } from 'tldraw'

// There's a guide at the bottom of this file!

const MY_EDITABLE_SHAPE_TYPE = 'my-editable-shape'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_EDITABLE_SHAPE_TYPE]: {
			w: number
			h: number
			animal: number
		}
	}
}

const ANIMAL_EMOJIS = ['🐶', '🐱', '🐨', '🐮', '🐴']

export type IMyEditableShape = TLShape<typeof MY_EDITABLE_SHAPE_TYPE>

export class EditableShapeUtil extends BaseBoxShapeUtil<IMyEditableShape> {
	static override type = MY_EDITABLE_SHAPE_TYPE
	static override props: RecordProps<IMyEditableShape> = {
		w: T.number,
		h: T.number,
		animal: T.number,
	}

	// [1]
	override canEdit() {
		return true
	}

	// [1b]
	override canEditWhileLocked() {
		return true
	}

	getDefaultProps(): IMyEditableShape['props'] {
		return {
			w: 200,
			h: 200,
			animal: 0,
		}
	}

	// [2]
	component(shape: IMyEditableShape) {
		// [a]
		const isEditing = this.editor.getEditingShapeId() === shape.id

		return (
			<HTMLContainer
				id={shape.id}
				// [b]
				onPointerDown={isEditing ? this.editor.markEventAsHandled : undefined}
				style={{
					pointerEvents: isEditing ? 'all' : 'none',
					backgroundColor: '#efefef',
					fontSize: 24,
					padding: 16,
				}}
			>
				{ANIMAL_EMOJIS[shape.props.animal]}
				{/* [c] */}
				{isEditing ? (
					<button
						onClick={() => {
							this.editor.updateShape({
								id: shape.id,
								type: shape.type,
								props: {
									...shape.props,
									animal: (shape.props.animal + 1) % ANIMAL_EMOJIS.length,
								},
							})
						}}
					>
						Next
					</button>
				) : (
					// [d] when not editing...
					<p style={{ fontSize: 12 }}>Double Click to Edit</p>
				)}
			</HTMLContainer>
		)
	}

	indicator(shape: IMyEditableShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	// [3]
	override onEditEnd(shape: IMyEditableShape) {
		this.editor.animateShape(
			{ ...shape, rotation: shape.rotation + Math.PI * 2 },
			{ animation: { duration: 250 } }
		)
	}
}

/*

This is our shape util, which defines how our shape renders and behaves. For
more information on the shape util, check out the custom shape example.

[1]
We override the canEdit method to allow the shape to enter the editing state.

	[1b] We override canEditWhileLocked to allow the shape to be edited even
		when it is locked. This is useful for shapes that need to remain
		interactive despite being locked in place, preventing accidental
		movement while still allowing content changes.

[2]
We want to conditionally render the component based on whether it is being
edited or not.

	[a] We can check whether our shape is being edited by comparing the
		editing shape id to the shape's id.

	[b] We want to allow pointer events when the shape is being edited,
		and stop event propagation on pointer down. Check out the interactive
		shape example for more information on this.

	[c] We render a button to change the animal emoji when the shape is being
		edited.

	[e]	We also render a message when the shape is not being edited.

[3]
The onEditEnd method is called when the shape exits the editing state. In this
case we rotate the shape 360 degrees.

*/
```

--------

# Arrow binding options

Category: Shapes & tools

Keywords: arrow, binding, precise, exact, anchor, snap

Demonstrate arrow binding options for precise positioning.

This example shows the different arrow binding options that control how arrows connect to shapes:

- **isPrecise: false** - Arrow always targets the center of the shape (default safe behavior)
- **isPrecise: true** - Arrow respects the `normalizedAnchor` and targets the specified position
- **isExact: false** - Arrow stops at the shape's edge (default)
- **isExact: true** - Arrow passes through the shape to reach the exact target point

The `normalizedAnchor` property specifies where on the shape the arrow connects using normalized coordinates (0-1 on each axis). For example, `{x: 0.5, y: 0.5}` is the center, `{x: 0, y: 0}` is top-left, and `{x: 1, y: 1}` is bottom-right.

These options provide fine-grained control over arrow positioning for technical diagrams, architectural drawings, and other use cases requiring precise arrow placement.

## App.tsx

```tsx
import { Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ArrowBindingOptionsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					const spacing = 300

					// [1]
					const shape1Id = createShapeId()
					editor.createShape({
						id: shape1Id,
						type: 'geo',
						x: 100,
						y: 100,
						props: {
							w: 150,
							h: 150,
							richText: toRichText('isPrecise: false\n(always center)'),
							color: 'blue',
						},
					})

					// [2]
					const arrow1Id = createShapeId()
					editor.createShape({
						id: arrow1Id,
						type: 'arrow',
						props: {
							start: { x: 50, y: 175 },
							end: { x: 100, y: 175 },
						},
					})
					editor.createBindings([
						{
							fromId: arrow1Id,
							toId: shape1Id,
							type: 'arrow',
							props: {
								terminal: 'end',
								normalizedAnchor: { x: 0.25, y: 0.5 },
								isPrecise: false,
								isExact: false,
							},
						},
					])

					// [3]
					const shape2Id = createShapeId()
					editor.createShape({
						id: shape2Id,
						type: 'geo',
						x: 100 + spacing,
						y: 100,
						props: {
							w: 150,
							h: 150,
							richText: toRichText('isPrecise: true\n(custom anchor)'),
							color: 'green',
						},
					})

					// [4]
					const arrow2Id = createShapeId()
					editor.createShape({
						id: arrow2Id,
						type: 'arrow',
						props: {
							start: { x: 50 + spacing, y: 175 },
							end: { x: 100 + spacing, y: 175 },
						},
					})
					editor.createBindings([
						{
							fromId: arrow2Id,
							toId: shape2Id,
							type: 'arrow',
							props: {
								terminal: 'end',
								normalizedAnchor: { x: 0.25, y: 0.5 },
								isPrecise: true,
								isExact: false,
							},
						},
					])

					// [5]
					const shape3Id = createShapeId()
					editor.createShape({
						id: shape3Id,
						type: 'geo',
						x: 100,
						y: 100 + spacing,
						props: {
							w: 150,
							h: 150,
							richText: toRichText('isExact: true\n(passes through)'),
							color: 'orange',
						},
					})

					// [6]
					const arrow3Id = createShapeId()
					editor.createShape({
						id: arrow3Id,
						type: 'arrow',
						props: {
							start: { x: 50, y: 175 + spacing },
							end: { x: 100, y: 175 + spacing },
						},
					})
					editor.createBindings([
						{
							fromId: arrow3Id,
							toId: shape3Id,
							type: 'arrow',
							props: {
								terminal: 'end',
								normalizedAnchor: { x: 0.5, y: 0.5 },
								isPrecise: true,
								isExact: true,
							},
						},
					])

					// [7]
					const shape4Id = createShapeId()
					editor.createShape({
						id: shape4Id,
						type: 'geo',
						x: 100 + spacing,
						y: 100 + spacing,
						props: {
							w: 150,
							h: 150,
							richText: toRichText('Combined\n(precise + exact)'),
							color: 'red',
						},
					})

					const arrow4Id = createShapeId()
					editor.createShape({
						id: arrow4Id,
						type: 'arrow',
						props: {
							start: { x: 50 + spacing, y: 175 + spacing },
							end: { x: 100 + spacing, y: 175 + spacing },
						},
					})
					editor.createBindings([
						{
							fromId: arrow4Id,
							toId: shape4Id,
							type: 'arrow',
							props: {
								terminal: 'end',
								normalizedAnchor: { x: 0.75, y: 0.75 },
								isPrecise: true,
								isExact: true,
							},
						},
					])

					editor.zoomToFit()
				}}
			/>
		</div>
	)
}

/*
[1]
Create the first shape demonstrating isPrecise: false. When isPrecise is false, the arrow
always targets the center of the shape, regardless of the normalizedAnchor value provided.

[2]
Create an arrow with isPrecise: false. Even though we specify normalizedAnchor at (0.25, 0.5)
(left side of the shape), the arrow will point to the center because isPrecise is false.
The arrow stops at the shape's edge.

[3]
Create the second shape demonstrating isPrecise: true. When isPrecise is true, the arrow
respects the normalizedAnchor and targets the specified position within the shape.

[4]
Create an arrow with isPrecise: true and the same normalizedAnchor at (0.25, 0.5). This time,
the arrow will actually target the left side of the shape as specified by the anchor. The arrow
still stops at the shape's edge (isExact: false).

[5]
Create the third shape demonstrating isExact: true. When isExact is true, the arrow passes
through the shape to reach its exact target point instead of stopping at the edge.

[6]
Create an arrow with both isPrecise: true and isExact: true. The normalizedAnchor at (0.5, 0.5)
targets the center of the shape, and isExact: true makes the arrow pass through the shape to
reach that exact point. This is useful for diagrams where arrows need to cross through shapes.

[7]
Create the fourth shape demonstrating the combination of precise and exact targeting. The arrow
targets the bottom-right quadrant (0.75, 0.75) and passes through the shape to that exact point.
This shows fine-grained control over arrow positioning.

Key takeaways:
- isPrecise: false = arrow always points to center (default safe behavior)
- isPrecise: true = arrow respects normalizedAnchor position
- isExact: false = arrow stops at shape edge (default)
- isExact: true = arrow passes through to exact target point
*/
```

--------

# Custom shape geometry

Category: Shapes & tools

Keywords: svg, path, house, door

A shape with custom geometry.

This example demonstrates how to create a shape with custom geometry in tldraw. The
shape we're creating is a simple house shape with a door.

## App.tsx

```tsx
import {
	Group2d,
	Polygon2d,
	RecordPropsType,
	Rectangle2d,
	ShapeUtil,
	T,
	TLResizeInfo,
	TLShape,
	Tldraw,
	Vec,
	resizeBox,
	structuredClone,
} from 'tldraw'
import 'tldraw/tldraw.css'

const HOUSE_TYPE = 'house'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[HOUSE_TYPE]: HouseShapeProps
	}
}

const houseShapeProps = {
	w: T.number,
	h: T.number,
}

type HouseShapeProps = RecordPropsType<typeof houseShapeProps>
type HouseShape = TLShape<typeof HOUSE_TYPE>
class HouseShapeUtil extends ShapeUtil<HouseShape> {
	static override type = HOUSE_TYPE
	static override props = houseShapeProps

	override canResize() {
		return true
	}
	override getDefaultProps() {
		return {
			w: 100,
			h: 100,
		}
	}
	//[1]
	override getGeometry(shape: HouseShape) {
		const { house: houseGeometry } = getHouseVertices(shape)
		const house = new Polygon2d({
			points: houseGeometry,
			isFilled: true,
		})
		const door = new Rectangle2d({
			x: shape.props.w / 2 - shape.props.w / 10,
			y: shape.props.h - shape.props.h / 4,
			width: shape.props.w / 5,
			height: shape.props.h / 4,
			isFilled: true,
		})
		const geometry = new Group2d({
			children: [house, door],
		})
		return geometry
	}
	// [2]
	override component(shape: HouseShape) {
		const { house: houseVertices, door: doorVertices } = getHouseVertices(shape)
		const housePathData = 'M' + houseVertices[0] + 'L' + houseVertices.slice(1) + 'Z'
		const doorPathData = 'M' + doorVertices[0] + 'L' + doorVertices.slice(1) + 'Z'
		return (
			<svg className="tl-svg-container">
				<path strokeWidth={3} stroke="black" d={housePathData + doorPathData} fill="none" />
			</svg>
		)
	}
	// [3]
	override indicator(shape: HouseShape) {
		const { house: houseVertices, door: doorVertices } = getHouseVertices(shape)
		const housePathData = 'M' + houseVertices[0] + 'L' + houseVertices.slice(1) + 'Z'
		const doorPathData = 'M' + doorVertices[0] + 'L' + doorVertices.slice(1) + 'Z'
		return <path d={housePathData + doorPathData} />
	}
	override onResize(shape: HouseShape, info: TLResizeInfo<HouseShape>) {
		const resized = resizeBox(shape, info)
		const next = structuredClone(info.initialShape)
		next.x = resized.x
		next.y = resized.y
		next.props.w = resized.props.w
		next.props.h = resized.props.h
		return next
	}
}
// [4]
function getHouseVertices(shape: HouseShape): { house: Vec[]; door: Vec[] } {
	const { w, h } = shape.props
	const halfW = w / 2
	const roofStart = h / 2.5
	const house = [
		new Vec(0, roofStart), // Roof start (left)
		new Vec(w, roofStart), // Roof start (right)
		new Vec(w, h), // Bottom-right corner
		new Vec(0, h), // Bottom-left corner
		new Vec(0, roofStart), // Roof start (left)
		new Vec(halfW, 0), // Roof peak
		new Vec(w, roofStart), // Roof start (right)
	]
	const door = [
		new Vec(halfW - w / 10, h), // Bottom-left corner
		new Vec(halfW + w / 10, h), // Bottom-right corner
		new Vec(halfW + w / 10, h - h / 4), // Top-right corner
		new Vec(halfW - w / 10, h - h / 4), // Top-left corner
		new Vec(halfW - w / 10, h), // Bottom-left corner
	]
	return { house, door }
}

const shapeUtils = [HouseShapeUtil]

export default function ShapeWithGeometryExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					editor.createShape({
						type: 'house',
						x: 100,
						y: 100,
						props: {
							w: 100,
							h: 100,
						},
					})
				}}
				shapeUtils={shapeUtils}
			/>
		</div>
	)
}

/*
Introduction:
This file demonstrates how to create a shape with custom geometry in tldraw. The
shape we're creating is a simple house shape with a door. The HouseShapeUtil class
defines the behavior and appearance of our custom house shape.

[1]
The getGeometry method defines the geometric representation of our shape. This geometry
is used for hit-testing, intersection checking and other geometric calculations. We use
Polygon2d for the house body and Rectangle2d for the door. These are combined into a
Group2d to form the complete house geometry.

[2]
The component method determines how our shape is rendered. We create SVG paths for
both the house body and the door, combining them into a single path element. This
method is called when the shape needs to be drawn on the canvas. The tl-svg-container
class contains some helpful styles for rendering the svg correctly.

[3]
The indicator method renders the same path as a thin blue line when the shape is selected.

[4]
The getHouseVertices function calculates the vertices for both the house body and the door
based on the shape's dimensions. This is used by both the geometry and rendering methods
to ensure consistency in the shape's appearance.

*/
```

--------

# Custom shape migrations

Category: Shapes & tools

Keywords: version, update

Migrate your shapes and their data between versions

Sometimes you'll want to update the way a shape works in your application. When this happens there can be a risk of errors and bugs. For example, users with an old version of a shape in their documents might encounter errors when the editor tries to access a property that doesn't exist. This example shows how you can use our migrations system to preserve your users' data between versions. It uses a snapshot to load a document with a shape that is missing a "color" prop, and uses the migrations method of the shape util to update it.

## App.tsx

```tsx
import {
	BaseBoxShapeUtil,
	HTMLContainer,
	T,
	TLResizeInfo,
	TLShape,
	TLStoreSnapshot,
	Tldraw,
	createShapePropsMigrationIds,
	createShapePropsMigrationSequence,
	resizeBox,
} from 'tldraw'
import 'tldraw/tldraw.css'
import snapshot from './snapshot.json'

const MY_SHAPE_WITH_MIGRATIONS_TYPE = 'myshapewithmigrations' as const

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_SHAPE_WITH_MIGRATIONS_TYPE]: { w: number; h: number; color: string }
	}
}

// There's a guide at the bottom of this file!

export type IMyShape = TLShape<typeof MY_SHAPE_WITH_MIGRATIONS_TYPE>

// [1]
const versions = createShapePropsMigrationIds(
	// this must match the shape type in the shape definition
	MY_SHAPE_WITH_MIGRATIONS_TYPE,
	{
		AddColor: 1,
	}
)

// [2]
export const cardShapeMigrations = createShapePropsMigrationSequence({
	sequence: [
		{
			id: versions.AddColor,
			up(props) {
				// it is safe to mutate the props object here
				props.color = 'lightblue'
			},
			down(props) {
				delete props.color
			},
		},
	],
})

export class MigratedShapeUtil extends BaseBoxShapeUtil<IMyShape> {
	static override type = MY_SHAPE_WITH_MIGRATIONS_TYPE

	static override props = {
		w: T.number,
		h: T.number,
		color: T.string,
	}

	// [3]
	static override migrations = cardShapeMigrations

	getDefaultProps(): IMyShape['props'] {
		return {
			w: 300,
			h: 300,
			color: 'lightblue',
		}
	}

	component(shape: IMyShape) {
		return (
			<HTMLContainer
				id={shape.id}
				style={{
					backgroundColor: shape.props.color,
					boxShadow: '0 0 10px rgba(0,0,0,0.5)',
				}}
			></HTMLContainer>
		)
	}

	indicator(shape: IMyShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}

	override onResize(shape: IMyShape, info: TLResizeInfo<IMyShape>) {
		return resizeBox(shape, info)
	}
}

const customShapeUtils = [MigratedShapeUtil]

export default function ShapeWithMigrationsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the array of custom shape classes
				shapeUtils={customShapeUtils}
				// Use a snapshot to load an old version of the shape
				snapshot={snapshot as TLStoreSnapshot}
			/>
		</div>
	)
}

/*
Introduction:

Sometimes you'll want to update the way a shape works in your application without breaking older
versions of the shape that a user may have stored or persisted in memory.

This example shows how you can use our migrations system to upgrade (or downgrade) user's data
between different versions. Most of the code above is general "custom shape" code—see our custom
shape example for more details.

[1] First, we need IDs for each migration. List each change with its version number. Once you've
added a migration, it should not change again.

[2] Next, we create a migration sequence. This is where we actually write our migration logic. Each
migration had three parts: an `id` (created in [1]), an `up` migration and `down` migration. In this
case, the `up` migration adds the `color` prop to the shape, and the `down` migration removes it.

In some cases (mainly in multiplayer sessions) a peer or server may need to take a later version of
a shape and migrate it down to an older version—in this case, it would run the down migrations in
order to get it to the needed version.

[3] Finally, we add our migrations to the ShapeUtil. This tells tldraw about the migrations so they
can be used with your shapes.

How it works:

Each time the editor's store creates a snapshot (`editor.store.createSnapshot`), it serializes all
of the records (the snapshot's `store`) as well as versions of each record that it contains (the
snapshot's `schema`). When the editor loads a snapshot, it compares its current schema with the
snapshot's schema to determine which migrations to apply to each record.

In this example, we have a snapshot (snapshot.json) that we created in version 0, however our shape
now has a 'color' prop that was added in version 1.

The snapshot looks something like this:

```json{
{
    "store": {
        "shape:BqG5uIAa9ig2-ukfnxwBX": {
            ...,
            "props": {
                "w": 300,
                "h": 300
            },
        },
	},
	"schema": {
		...,
		"sequences": {
			...,
			"com.tldraw.shape.arrow": 4,
			"com.tldraw.shape.myshape": 0
		}
	}
}
```

Note that the shape in the snapshot doesn't have a 'color' prop.

Note also that the schema's version for this shape is 0.

When the editor loads the snapshot, it will compare the serialized schema's version with its current
schema's version for the shape, which is 1 as defined in our shape's migrations. Since the
serialized version is older than its current version, it will use our migration to bring it up to
date: it will run the migration's `up` function, which will add the 'color' prop to the shape.
*/
```

--------

# Custom shape SVG export

Category: Shapes & tools

Keywords: basic, svg, custom, export, copy

Determine how your custom shapes look when copied/exported as an image.

The "export as SVG/PNG" and "copy as SVG/PNG" actions use the `toSvg` or `toBackgroundSvg` methods of a shape util. If a shape does not have a `toSvg` or `toBackgroundSvg` method defined, it will default to placing the shape's component inside a `<foreignObject>` element.

## App.tsx

```tsx
import { ReactElement } from 'react'
import {
	Geometry2d,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	SvgExportContext,
	T,
	Tldraw,
	TLShape,
} from 'tldraw'
import 'tldraw/tldraw.css'

const MY_CUSTOM_SHAPE_TO_SVG_TYPE = 'my-custom-shape-to-svg'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_CUSTOM_SHAPE_TO_SVG_TYPE]: { w: number; h: number }
	}
}

// There's a guide at the bottom of this file!

type ICustomShape = TLShape<typeof MY_CUSTOM_SHAPE_TO_SVG_TYPE>

const LIGHT_FILL = '#ff8888'
const DARK_FILL = '#ffcccc'

export class MyShapeUtil extends ShapeUtil<ICustomShape> {
	static override type = MY_CUSTOM_SHAPE_TO_SVG_TYPE
	static override props: RecordProps<ICustomShape> = {
		w: T.number,
		h: T.number,
	}

	getDefaultProps(): ICustomShape['props'] {
		return {
			w: 200,
			h: 200,
		}
	}

	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override isAspectRatioLocked() {
		return false
	}

	getGeometry(shape: ICustomShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: true,
		})
	}

	component(_shape: ICustomShape) {
		const isDarkmode = this.editor.user.getIsDarkMode()
		return <HTMLContainer style={{ backgroundColor: isDarkmode ? DARK_FILL : LIGHT_FILL }} />
	}

	indicator(shape: ICustomShape) {
		return this.getSvgRect(shape)
	}

	// [1]
	override toSvg(
		shape: ICustomShape,
		ctx: SvgExportContext
	): ReactElement | null | Promise<ReactElement | null> {
		// ctx.addExportDef(getFontDef(shape))
		const isDarkmode = ctx.isDarkMode
		const fill = isDarkmode ? DARK_FILL : LIGHT_FILL
		return this.getSvgRect(shape, { fill })
	}

	getSvgRect(shape: ICustomShape, props?: { fill: string }) {
		return <rect width={shape.props.w} height={shape.props.h} {...props} />
	}

	// [2]

	// override toBackgroundSvg(
	// 	shape: ICustomShape,
	// 	ctx: SvgExportContext
	// ): ReactElement | null | Promise<ReactElement | null> {
	// 	const isDarkmode = ctx.isDarkMode
	// 	const fill = isDarkmode ? '#333' : '#efefef'
	// 	return <rect width={shape.props.w} height={shape.props.h} fill={fill} />
	// }
}

// [3]

// function getFontDef(shape: ICustomShape): SvgExportDef {
// 	//
// 	return {
// 		some unique key,
// 		key: 'my-custom-shape-font',
// 		getElement: async () => {
// 			return <style></style> element
// 			check out the defaultStyleDefs.tsx file for an example of how
// 			we do this for tldraw fonts
// 		},
// 	}
// }

const customShape = [MyShapeUtil]
export default function CustomShapeToSvgExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShape}
				onMount={(editor) => {
					editor.createShape({ type: MY_CUSTOM_SHAPE_TO_SVG_TYPE, x: 100, y: 100 })
				}}
			/>
		</div>
	)
}
/*
 The "export as SVG/PNG" and "copy as SVG/PNG" actions use the `toSvg` or `toBackgroundSvg`
 methods of a shape util. If a shape does not have a `toSvg` or `toBackgroundSvg` method
 defined, it will default to an empty box.

 For more information on creating a custom shape, check out the custom shape example.

 [1]
    This method should return a React element that represents the shape as an SVG element.
    If your shape is HTML, then you will need to convert it to an SVG representation. In this
    example we've used a `rect` element to represent the shape. Other shapes may require more
    complex work to render them as SVGs, especially if they contain text. Check out [3] for more
	info.

[2]
    The `toBackgroundSvg` method is used to render a layer behind the shape when exporting as SVG.
    We use this in the tldraw codebase to make the highlighter shape. It's commented out here as
    we don't need it for this example.

[3]
	If your shape contains text, you may need to add a font definition to the SVG. This is done
	using the `addExportDef` method of the `SvgExportContext`. Your font def must contain a unique
	key and a function that returns a React element. Check out the `` function
	in the `defaultStyleDefs.tsx` file for an example of how this is done for tldraw fonts.

 */
```

--------

# Custom snapping

Category: Shapes & tools

Keywords: geometry, custom

Custom shapes with special bounds snapping behaviour.

This example shows how to create a shape with custom snapping geometry. When shapes are moved around in snap mode, they will snap to the bounds of other shapes by default. However, a shape can return custom snapping geometry to snap to instead.

In this case, we've created a custom playing card shape. The cards are designed to snap together so that the top-left icon remains visible when stacked, similar to a hand of cards in a game.

## App.tsx

```tsx
import { Editor, TLStoreSnapshot, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { PlayingCardTool } from './PlayingCardShape/playing-card-tool'
import { PlayingCardUtil } from './PlayingCardShape/playing-card-util'
import snapshot from './snapshot.json'
import { components, uiOverrides } from './ui-overrides'
// There's a guide at the bottom of this file!

// [1]
const customShapes = [PlayingCardUtil]
const customTools = [PlayingCardTool]

export default function BoundsSnappingShapeExample() {
	// [2]
	const handleMount = (editor: Editor) => {
		editor.user.updateUserPreferences({ isSnapMode: true })
	}
	// [3]
	return (
		<div className="tldraw__editor">
			<Tldraw
				//[a]
				shapeUtils={customShapes}
				tools={customTools}
				// [b]
				overrides={uiOverrides}
				components={components}
				// [c]
				onMount={handleMount}
				// [d]
				snapshot={snapshot as TLStoreSnapshot}
			/>
		</div>
	)
}

/*
Introduction:

This example shows how to create a shape with custom snapping geometry. When shapes are moved around
in snap mode, they will snap to the bounds of other shapes by default. A shape can return custom
snapping geometry to snap to instead. This example creates a playing card shape. The cards are
designed to snap together so that the top-left icon remains visible when stacked, similar to a hand
of cards in a game. The most relevant code for this customisation is in playing-card-util.tsx.

[1]
We define the custom shape and util arrays we'll pass to the Tldraw component. It's important to do
this outside of the component so that the arrays don't change on every render.

This is where we define the Tldraw component and pass in all our customisations.

[2]

We define a handleMount function that will be called when the editor mounts. We're using it to set
the snap mode to true in the user preferences. This is just to help demonstrate the custom snapping
geometry feature. Without snap mode being set in this way the user can still enter it by holding
cmd/ctrl while dragging.

[3]
This is where we're passing in all our customisations to the Tldraw component. Check out the
associated files for more information on what's being passed in.

    [a] Firstly, our custom shape (playing-card-util.tsx) and tool (playing-card-tool.tsx)
        This tells the editor about our custom shape and tool.
    [b] Then our the uiOverrides and custom keyboard shortcuts component (ui-overrides.tsx),
        this makes sure that an icon for our tool appears in the toolbar and the shortcut
        for it appears in the dialog.
    [c] We pass in our handleMount function so that it's called when the editor mounts.

    [d] Finally we pass in a snapshot so that the editor starts with some shapes in it.
        This isn't necessary, it just makes the example clearer on first glance.

*/
```

## ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.PlayingCard = {
			id: 'PlayingCard',
			icon: <span style={{ fontSize: '2em' }}>🃏</span>,
			label: 'Playing Card',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('PlayingCard')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCardSelected = useIsToolSelected(tools['PlayingCard'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['PlayingCard']} isSelected={isCardSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['PlayingCard']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/*

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools to
the toolbar and the keyboard shortcuts menu.

First we have to add our new tool to the tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.

Then, we replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.
*/
```

## playing-card-tool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'
export class PlayingCardTool extends BaseBoxShapeTool {
	static override id = 'PlayingCard'
	static override initial = 'idle'
	override shapeType = 'PlayingCard' as const
}

/*
This file contains our custom tool. The tool is a StateNode with the `id` "PlayingCard".

We get a lot of functionality for free by extending the BaseBoxShapeTool. but we can
handle events in our own way by overriding methods like onDoubleClick. For an example
of a tool with more custom functionality, check out the screenshot-tool example.

*/
```

## playing-card-util.tsx

```tsx
import {
	BaseBoxShapeUtil,
	BoundsSnapGeometry,
	HTMLContainer,
	RecordProps,
	Rectangle2d,
	T,
	TLShape,
} from 'tldraw'

// There's a guide at the bottom of this file!

const PLAYING_CARD_TYPE = 'PlayingCard'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[PLAYING_CARD_TYPE]: {
			w: number
			h: number
			suit: string
		}
	}
}

// [2]
export type IPlayingCard = TLShape<typeof PLAYING_CARD_TYPE>

export class PlayingCardUtil extends BaseBoxShapeUtil<IPlayingCard> {
	// [3]
	static override type = PLAYING_CARD_TYPE
	static override props: RecordProps<IPlayingCard> = {
		w: T.number,
		h: T.number,
		suit: T.string,
	}

	// [4]
	override isAspectRatioLocked(_shape: IPlayingCard) {
		return true
	}

	// [5]
	getDefaultProps(): IPlayingCard['props'] {
		const cardSuitsArray: string[] = ['♠️', '♣️', '♥️', '♦️']
		const randomSuit = cardSuitsArray[Math.floor(Math.random() * cardSuitsArray.length)]
		return {
			w: 270,
			h: 370,
			suit: randomSuit,
		}
	}

	// [6]
	override getBoundsSnapGeometry(shape: IPlayingCard): BoundsSnapGeometry {
		return {
			points: new Rectangle2d({
				width: shape.props.h / 4.5,
				height: shape.props.h / 4.5,
				isFilled: true,
			}).bounds.cornersAndCenter,
		}
	}

	// [7]
	component(shape: IPlayingCard) {
		return (
			<HTMLContainer
				style={{
					height: shape.props.h,
					width: shape.props.w,
					backgroundColor: 'white',
					boxShadow: '0 0 10px 0 rgba(0, 0, 0, 0.2)',
					position: 'relative',
					display: 'flex',
					justifyContent: 'center',
					alignItems: 'center',
					padding: 8,
				}}
				id={shape.id}
			>
				<span
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						display: 'flex',
						justifyContent: 'center',
						alignItems: 'center',
						height: shape.props.h / 4.5,
						width: shape.props.h / 4.5,
						fontSize: shape.props.h / 5,
					}}
				>
					{shape.props.suit}
				</span>
				<div style={{ fontSize: shape.props.h / 3 }}>{shape.props.suit}</div>
			</HTMLContainer>
		)
	}

	// [8]
	indicator(shape: IPlayingCard) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

/*
This is a utility class for the PlayingCard shape. This is where you define the shape's behavior,
how it renders (its component and indicator), and how it handles different events. The most relevant
part of the code to custom snapping can be found in [7].

[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape's properties. For this shape, we define width (w), height (h),
and suit as the shape's properties.

[2]
Define the shape type using TLShape with the shape's type as a type argument.

[3]
We define the shape's type and props for the editor. We can use tldraw's validator library to
make sure that the store always has shape data we can trust. In this case, we define the width
and height properties as numbers and assign a validator from tldraw's library to them.

[4]
We're going to lock the aspect ratio of this shape.

[5]
getDefaultProps determines what our shape looks like when click-creating one. In this case, we
want the shape to be 270x370 pixels and generate a suit for the card at random.

[6]
This is the important part for custom snapping. We define the getBoundsSnapGeometry method. This
method returns the geometry that the shape will snap to. In this case, we want the shape to snap
to a rectangle in the top left that contains the suit of the card. We can use the Rectangle2d helper
again here and set it to the same width and height as the span containing the suit which is defined
in [7].

[7]
We define the component method. This controls what the shape looks like and it returns JSX. It
generates a random suit for the card and returns a div with the suit in the center and a span with
the suit in the top left. The HTMLContainer component is a helpful wrapper that the tldraw library
exports, it's a div that comes with a css class.

[8]
The indicator is the blue box that appears around the shape when it's selected. We're just returning
a rectangle with the same width and height as the shape here.


*/
```

--------

# Custom validators for shape props

Category: Shapes & tools

Keywords: validation, validators, check, refine, constraints, props, custom, shape

Demonstrates using custom validators with `.check()` and `.refine()` methods to add validation constraints to shape props.

This example shows how to create custom validators for shape properties using `@tldraw/validate`. It demonstrates:

- Chaining `.check()` calls to add validation constraints without transforming values
- Using `.refine()` to validate and transform values

The example creates a custom shape with two validated properties:

1. **Percentage** - Chains multiple `.check()` calls to validate that the value is between 0 and 100. Invalid values throw an error.
2. **Rating** - Uses `.refine()` to clamp values to the 1-5 range. Invalid values are transformed rather than rejected.

When the example loads, it demonstrates both behaviors: attempting to create a shape with percentage=150 throws an error, while creating a shape with rating=10 succeeds but the value is clamped to 5.

## App.tsx

```tsx
import { HTMLContainer, RecordProps, Rectangle2d, ShapeUtil, T, TLShape, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		'validated-shape': {
			w: number
			h: number
			percentage: number
			rating: number
		}
	}
}

type ValidatedShape = TLShape<'validated-shape'>

// [2]
const validatedShapeProps: RecordProps<ValidatedShape> = {
	w: T.positiveNumber,
	h: T.positiveNumber,
	// [3]
	percentage: T.nonZeroFiniteNumber.check('max-value', (value) => {
		if (value > 100) throw new Error('Percentage cannot exceed 100')
	}),
	// [4]
	rating: T.integer.refine((value) => {
		return Math.max(1, Math.min(5, value))
	}),
}

class ValidatedShapeUtil extends ShapeUtil<ValidatedShape> {
	static override type = 'validated-shape' as const
	static override props = validatedShapeProps

	getDefaultProps(): ValidatedShape['props'] {
		return { w: 300, h: 150, percentage: 50, rating: 3 }
	}

	getGeometry(shape: ValidatedShape) {
		return new Rectangle2d({ width: shape.props.w, height: shape.props.h, isFilled: true })
	}

	component(shape: ValidatedShape) {
		return (
			<HTMLContainer id={shape.id} style={{ padding: 16, pointerEvents: 'all' }}>
				<div>Percentage: {shape.props.percentage}%</div>
				<div>Rating: {shape.props.rating}/5</div>
			</HTMLContainer>
		)
	}

	indicator(shape: ValidatedShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [5]
const customShapeUtils = [ValidatedShapeUtil]

export default function CustomValidatorsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					// [6]
					editor.createShape({ type: 'validated-shape', x: 100, y: 100 })

					// [7]
					try {
						editor.createShape({
							type: 'validated-shape',
							x: 100,
							y: 300,
							props: { percentage: 150 },
						})
					} catch (error: any) {
						console.error('Validation failed:', error.message)
					}

					// [8]
					editor.createShape({
						type: 'validated-shape',
						x: 450,
						y: 100,
						props: { rating: 10 }, // Will be clamped to 5
					})
				}}
			/>
		</div>
	)
}

/*
This example demonstrates custom validators using .check() and .refine() methods.

[1]
Extend TLGlobalShapePropsMap to register your custom shape's props with the type system.

[2]
Define validators for each prop. Each validator adds constraints beyond basic type checking.

[3]
Use .check() to add validation constraints. Each check validates without
transforming the value. The name (e.g. 'max-value') appears in error messages for debugging.

[4]
Use .refine() to transform values. Unlike .check(), refine() returns a (possibly modified)
value rather than just validating. Here it clamps the rating to 1-5 instead of throwing.

[5]
Create the shape utils array outside the component to prevent recreation on each render.

[6]
Create a valid shape on mount to show the default values.

[7]
Demonstrate .check() validation by attempting to create a shape with an invalid percentage.
Open your browser console to see the validation error.

[8]
Demonstrate .refine() transformation - this shape is created successfully with rating=10,
but the stored value is clamped to 5.
*/
```

--------

# Programmatic text shape creation

Category: Shapes & tools

Keywords: text, create, programmatic, autoSize, font, textAlign, richText, toRichText, bold, marks

Create and configure text shapes programmatically.

This example demonstrates how to create text shapes programmatically with various configuration options:

- **Auto-sized text** - Text shapes that automatically adjust width to fit content (`autoSize: true`)
- **Fixed-width text** - Text shapes with specified width that wrap content (`autoSize: false`, `w: number`)
- **Text alignment** - Horizontal alignment: `start` (left), `middle` (center), `end` (right)
- **Font styles** - Different fonts: `draw` (handdrawn), `sans`, `serif`, `mono`
- **Sizes** - Font sizes: `s`, `m`, `l`, `xl`
- **Rich text formatting** - Bold, italic, and other formatting using marks

Text shapes use rich text format internally. Use `toRichText('your text')` to convert plain text strings. For formatting like bold or italic, construct the rich text document with marks as shown in the example.

## App.tsx

```tsx
import { Tldraw, createShapeId, toRichText } from 'tldraw'
import 'tldraw/tldraw.css'

export default function ProgrammaticTextShapeCreationAndConfigurationExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// [1]
					editor.createShape({
						id: createShapeId(),
						type: 'text',
						x: 100,
						y: 100,
						props: {
							richText: toRichText('Auto-sized text'),
							size: 'l',
							color: 'blue',
							autoSize: true,
						},
					})

					// [2]
					editor.createShape({
						id: createShapeId(),
						type: 'text',
						x: 100,
						y: 200,
						props: {
							richText: toRichText(
								'Fixed-width text that wraps when it reaches the specified width. This text will wrap to multiple lines.'
							),
							size: 'm',
							color: 'green',
							w: 300,
							autoSize: false,
						},
					})

					// [3]
					editor.createShape({
						id: createShapeId(),
						type: 'text',
						x: 100,
						y: 400,
						props: {
							richText: toRichText('Center aligned'),
							size: 's',
							color: 'red',
							textAlign: 'middle',
							w: 200,
							autoSize: false,
						},
					})

					// [4]
					editor.createShape({
						id: createShapeId(),
						type: 'text',
						x: 100,
						y: 500,
						props: {
							// Rich text with bold formatting using marks
							richText: {
								type: 'doc',
								content: [
									{
										type: 'paragraph',
										content: [{ type: 'text', text: 'Bold text', marks: [{ type: 'bold' }] }],
									},
								],
							},
							size: 'xl',
							color: 'orange',
							autoSize: true,
						},
					})

					// [5]
					editor.createShape({
						id: createShapeId(),
						type: 'text',
						x: 100,
						y: 600,
						props: {
							richText: toRichText('Monospace font'),
							size: 'm',
							color: 'violet',
							font: 'mono',
							autoSize: true,
						},
					})

					editor.zoomToFit({ animation: { duration: 0 } })
				}}
			/>
		</div>
	)
}

/*
[1]
Create an auto-sized text shape. When autoSize is true, the text shape automatically
adjusts its width to fit the content. This is the default behavior for text shapes.
Use toRichText() to convert plain text strings to the required rich text format.

[2]
Create a fixed-width text shape by setting autoSize to false and specifying a width.
The text will wrap when it reaches the specified width. This is useful for creating
text blocks with consistent formatting.

[3]
Create a text shape with center alignment. The textAlign property controls horizontal
text alignment within the shape: 'start' (left), 'middle' (center), or 'end' (right).

[4]
Create a text shape with bold formatting. To apply formatting like bold, italic, or
code, you need to construct the rich text document manually with marks. The marks array
on a text node specifies which formatting to apply. Available marks include 'bold',
'italic', 'code', 'link', and 'highlight'.

[5]
Create a text shape with a specific font. The font property supports 'draw' (handdrawn),
'sans' (sans-serif), 'serif' (serif), and 'mono' (monospace). The size property controls
the font size: 's', 'm', 'l', or 'xl'.

Note: The richText property requires a TLRichText object. Use toRichText('your text')
to convert plain text strings. For rich formatting with marks, construct the document
structure directly as shown in example [4].
*/
```

--------

# Data grid shape

Category: Shapes & tools

Keywords: data grid ag grid

A custom shape that renders AG Grid.

This example shows how to create a custom shape that renders AG Grid.

## App.tsx

```tsx
/* eslint-disable react-hooks/rules-of-hooks */
import { AgGridReact } from 'ag-grid-react'
import { BaseBoxShapeUtil, TLShape, Tldraw, createShapeId, useDelaySvgExport } from 'tldraw'

import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-quartz.css'
import 'tldraw/tldraw.css'

const AG_GRID_TYPE = 'ag-grid'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[AG_GRID_TYPE]: { w: number; h: number; rowData: any[]; columnDefs: any[] }
	}
}

type AgGridShape = TLShape<typeof AG_GRID_TYPE>

class AgGridShapeUtil extends BaseBoxShapeUtil<AgGridShape> {
	static override type = AG_GRID_TYPE

	override canScroll(): boolean {
		return true
	}

	override canEdit(): boolean {
		return true
	}

	override getDefaultProps() {
		return {
			w: 300,
			h: 200,
			rowData: [],
			columnDefs: [],
		}
	}
	override component(shape: AgGridShape) {
		const isEditing = this.editor.getEditingShapeId() === shape.id
		const isReady = useDelaySvgExport()

		return (
			<div
				style={{
					width: shape.props.w,
					height: shape.props.h,
					pointerEvents: isEditing ? 'all' : undefined,
				}}
				className="ag-theme-quartz"
			>
				<AgGridReact
					onGridReady={isReady}
					rowData={shape.props.rowData}
					columnDefs={shape.props.columnDefs}
					// autoSizeStrategy={{ type: 'f', width: shape.props.w }}
				/>
			</div>
		)
	}
	override indicator(shape: AgGridShape) {
		return <rect width={shape.props.w} height={shape.props.h} rx={8} ry={8} />
	}
}

export default function DataGridExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="ag-grid-example"
				shapeUtils={[AgGridShapeUtil]}
				onMount={(editor) => {
					const agGridShapeId = createShapeId('ag-grid')

					if (!editor.getShape(agGridShapeId)) {
						editor.createShape({
							id: agGridShapeId,
							type: AG_GRID_TYPE,
							props: {
								w: 400,
								h: 300,
								rowData: [
									{ make: 'Tesla', model: 'Model Y', price: 64950, electric: true },
									{ make: 'Ford', model: 'F-Series', price: 33850, electric: false },
									{ make: 'Toyota', model: 'Corolla', price: 29600, electric: false },
								],
								columnDefs: [
									{ field: 'make', filter: true, floatingFilter: true, flex: 1 },
									{ field: 'model', flex: 1 },
									{ field: 'price', filter: true, floatingFilter: true, flex: 1 },
									{ field: 'electric', flex: 1 },
								],
							},
						})
						editor.select(agGridShapeId)
						editor.zoomToSelection()
					}
				}}
			/>
		</div>
	)
}
```

--------

# Drag and drop shape

Category: Shapes & tools

Keywords: reparent, shapes, grid, counter

Custom shapes that can be dragged and dropped onto each other.

This example shows how to create custom shapes that can be dragged and dropped onto each other.

## App.tsx

```tsx
import {
	Circle2d,
	Geometry2d,
	HTMLContainer,
	Rectangle2d,
	ShapeUtil,
	TLDragShapesOutInfo,
	TLShape,
	Tldraw,
} from 'tldraw'
import 'tldraw/tldraw.css'

const MY_GRID_SHAPE_TYPE = 'my-grid-shape'
const MY_COUNTER_SHAPE_TYPE = 'my-counter-shape'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_GRID_SHAPE_TYPE]: Record<string, never>
		[MY_COUNTER_SHAPE_TYPE]: Record<string, never>
	}
}

// [2]
type MyGridShape = TLShape<typeof MY_GRID_SHAPE_TYPE>
type MyCounterShape = TLShape<typeof MY_COUNTER_SHAPE_TYPE>

// [3]
const SLOT_SIZE = 100
class MyCounterShapeUtil extends ShapeUtil<MyCounterShape> {
	static override type = MY_COUNTER_SHAPE_TYPE

	override canResize() {
		return false
	}
	override hideResizeHandles() {
		return true
	}

	getDefaultProps(): MyCounterShape['props'] {
		return {}
	}

	getGeometry(): Geometry2d {
		return new Circle2d({ radius: SLOT_SIZE / 2 - 10, isFilled: true })
	}

	component() {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#e03131',
					border: '1px solid #ff8787',
					borderRadius: '50%',
				}}
			/>
		)
	}

	indicator() {
		return <circle r={SLOT_SIZE / 2 - 10} cx={SLOT_SIZE / 2 - 10} cy={SLOT_SIZE / 2 - 10} />
	}
}

// [4]
class MyGridShapeUtil extends ShapeUtil<MyGridShape> {
	static override type = MY_GRID_SHAPE_TYPE

	getDefaultProps(): MyGridShape['props'] {
		return {}
	}

	getGeometry(): Geometry2d {
		return new Rectangle2d({
			width: SLOT_SIZE * 5,
			height: SLOT_SIZE * 2,
			isFilled: true,
		})
	}

	override canResize() {
		return false
	}
	override hideResizeHandles() {
		return true
	}

	// [5]
	override onDragShapesIn(shape: MyGridShape, draggingShapes: TLShape[]): void {
		const { editor } = this
		const reparentingShapes = draggingShapes.filter(
			(s) => s.parentId !== shape.id && s.type === 'my-counter-shape'
		)
		if (reparentingShapes.length === 0) return
		editor.reparentShapes(reparentingShapes, shape.id)
	}

	// [6]
	override onDragShapesOut(
		shape: MyGridShape,
		draggingShapes: TLShape[],
		info: TLDragShapesOutInfo
	): void {
		const { editor } = this
		const reparentingShapes = draggingShapes.filter((s) => s.parentId !== shape.id)
		if (!info.nextDraggingOverShapeId) {
			editor.reparentShapes(reparentingShapes, editor.getCurrentPageId())
		}
	}

	component() {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#efefef',
					borderRight: '1px solid #ccc',
					borderBottom: '1px solid #ccc',
					backgroundSize: `${SLOT_SIZE}px ${SLOT_SIZE}px`,
					backgroundImage: `
						linear-gradient(to right, #ccc 1px, transparent 1px),
						linear-gradient(to bottom, #ccc 1px, transparent 1px)
					`,
				}}
			/>
		)
	}

	indicator() {
		return <rect width={SLOT_SIZE * 5} height={SLOT_SIZE * 2} />
	}
}

export default function DragAndDropExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={[MyGridShapeUtil, MyCounterShapeUtil]}
				onMount={(editor) => {
					if (editor.getCurrentPageShapeIds().size > 0) return
					editor.createShape({ type: 'my-grid-shape', x: 100, y: 100 })
					editor.createShape({ type: 'my-counter-shape', x: 700, y: 100 })
					editor.createShape({ type: 'my-counter-shape', x: 750, y: 200 })
					editor.createShape({ type: 'my-counter-shape', x: 770, y: 300 })
				}}
			/>
		</div>
	)
}

/*
[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape's properties. Here we use Record<string, never> since our shapes
don't need any custom properties. These are very basic custom shapes: see the custom shape examples for
more complex examples.

[2]
Define the shape types using TLShape with each shape's type as a type argument.

[3]
Create a ShapeUtil for the counter shape. This defines how the shape behaves and renders. We disable resizing
and use Circle2d geometry for collision detection. The component renders as a red circle using HTMLContainer.

[4]
Create a ShapeUtil for the grid shape. This creates a rectangular grid that can accept dropped shapes. We use
Rectangle2d geometry and render it with CSS grid lines using background gradients.

[5]
Override onDragShapesIn to handle when shapes are dragged into the grid. We filter for counter shapes that
aren't already children of this grid, then reparent them to become children. This makes them move with the grid.

[6]
Override onDragShapesOut to handle when shapes are dragged out of the grid. If they're not being dragged to
another shape, we reparent them back to the page level, making them independent again.
*/
```

--------

# Attach shapes together (bindings)

Category: Shapes & tools

Keywords: attach

A sticker shape, using bindings to attach shapes to one and other

This example shows how to use bindings to attach shapes together. In this case, we've created a sticker that can be stuck onto other shapes.

## App.tsx

```tsx
import {
	BindingOnShapeChangeOptions,
	BindingOnShapeDeleteOptions,
	BindingUtil,
	Box,
	DefaultToolbar,
	DefaultToolbarContent,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	StateNode,
	TLBinding,
	TLPointerEventInfo,
	TLShape,
	TLUiComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	VecModel,
	createShapeId,
	invLerp,
	lerp,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

const STICKER_TYPE = 'sticker'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[STICKER_TYPE]: Record<string, never>
	}
}

type StickerShape = TLShape<typeof STICKER_TYPE>

const offsetX = -16
const offsetY = -26
class StickerShapeUtil extends ShapeUtil<StickerShape> {
	static override type = STICKER_TYPE
	static override props: RecordProps<StickerShape> = {}

	override getDefaultProps() {
		return {}
	}

	override canBind() {
		// stickers can bind to anything
		return true
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override canSnap() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 32,
			height: 32,
			x: offsetX,
			y: offsetY,
			isFilled: true,
		})
	}

	override component() {
		return (
			<div
				style={{
					width: '100%',
					height: '100%',
					marginLeft: offsetX,
					marginTop: offsetY,
					fontSize: '26px',
					textAlign: 'center',
				}}
			>
				❤️
			</div>
		)
	}

	override indicator() {
		return <rect width={32} height={32} x={offsetX} y={offsetY} />
	}

	override onTranslateStart(shape: StickerShape) {
		const bindings = this.editor.getBindingsFromShape(shape, STICKER_TYPE)
		this.editor.deleteBindings(bindings)
	}

	override onTranslateEnd(_initial: StickerShape, sticker: StickerShape) {
		const pageAnchor = this.editor.getShapePageTransform(sticker).applyToPoint({ x: 0, y: 0 })
		const target = this.editor.getShapeAtPoint(pageAnchor, {
			hitInside: true,
			filter: (shape) =>
				shape.id !== sticker.id &&
				this.editor.canBindShapes({ fromShape: sticker, toShape: shape, binding: STICKER_TYPE }),
		})

		if (!target) return

		const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(target)!.bounds)
		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pageAnchor)

		const anchor = {
			x: invLerp(targetBounds.minX, targetBounds.maxX, pointInTargetSpace.x),
			y: invLerp(targetBounds.minY, targetBounds.maxY, pointInTargetSpace.y),
		}

		this.editor.createBinding({
			type: STICKER_TYPE,
			fromId: sticker.id,
			toId: target.id,
			props: {
				anchor,
			},
		})
	}
}

declare module 'tldraw' {
	export interface TLGlobalBindingPropsMap {
		[STICKER_TYPE]: {
			anchor: VecModel
		}
	}
}

type StickerBinding = TLBinding<typeof STICKER_TYPE>

class StickerBindingUtil extends BindingUtil<StickerBinding> {
	static override type = STICKER_TYPE

	override getDefaultProps() {
		return {
			anchor: { x: 0.5, y: 0.5 },
		}
	}

	// when the shape we're stuck to changes, update the sticker's position
	override onAfterChangeToShape({
		binding,
		shapeAfter,
	}: BindingOnShapeChangeOptions<StickerBinding>): void {
		const sticker = this.editor.getShape<StickerShape>(binding.fromId)!

		const shapeBounds = this.editor.getShapeGeometry(shapeAfter)!.bounds
		const shapeAnchor = {
			x: lerp(shapeBounds.minX, shapeBounds.maxX, binding.props.anchor.x),
			y: lerp(shapeBounds.minY, shapeBounds.maxY, binding.props.anchor.y),
		}
		const pageAnchor = this.editor.getShapePageTransform(shapeAfter).applyToPoint(shapeAnchor)

		const stickerParentAnchor = this.editor
			.getShapeParentTransform(sticker)
			.invert()
			.applyToPoint(pageAnchor)

		this.editor.updateShape({
			id: sticker.id,
			type: STICKER_TYPE,
			x: stickerParentAnchor.x,
			y: stickerParentAnchor.y,
		})
	}

	// when the thing we're stuck to is deleted, delete the sticker too
	override onBeforeDeleteToShape({ binding }: BindingOnShapeDeleteOptions<StickerBinding>): void {
		this.editor.deleteShape(binding.fromId)
	}
}

class StickerTool extends StateNode {
	static override id = 'sticker'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: TLPointerEventInfo) {
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		const stickerId = createShapeId()
		this.editor.markHistoryStoppingPoint()
		this.editor.createShape({
			id: stickerId,
			type: STICKER_TYPE,
			x: currentPagePoint.x,
			y: currentPagePoint.y,
		})
		this.editor.setSelectedShapes([stickerId])
		this.editor.setCurrentTool('select.translating', {
			...info,
			target: 'shape',
			shape: this.editor.getShape(stickerId),
			isCreating: true,
			onInteractionEnd: 'sticker',
			onCreate: () => {
				this.editor.setCurrentTool('sticker')
			},
		})
	}
}

const overrides: TLUiOverrides = {
	tools(editor, schema) {
		schema['sticker'] = {
			id: 'sticker',
			label: 'Sticker',
			icon: 'heart-icon',
			kbd: 'p',
			onSelect: () => {
				editor.setCurrentTool('sticker')
			},
		}
		return schema
	},
}

const components: TLUiComponents = {
	Toolbar: (...props) => {
		const sticker = useTools().sticker
		const isStickerSelected = useIsToolSelected(sticker)
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...sticker} isSelected={isStickerSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}

export default function StickerExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					;(window as any).editor = editor
				}}
				shapeUtils={[StickerShapeUtil]}
				bindingUtils={[StickerBindingUtil]}
				tools={[StickerTool]}
				overrides={overrides}
				components={components}
			/>
		</div>
	)
}
```

--------

# DOM-based shape size

Category: Shapes & tools

Keywords: dom, size, custom, dynamic, shape

A custom shape who's size is derived from it's rendered DOM.



## App.tsx

```tsx
/* eslint-disable react-hooks/rules-of-hooks */
import { useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react'
import {
	AtomMap,
	EditorAtom,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	Tldraw,
	TLShape,
	TLShapeId,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { contents } from './contents'

const DYNAMIC_SIZE_TYPE = 'dynamic-size'

// [1]
declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[DYNAMIC_SIZE_TYPE]: { contents: string[] }
	}
}

// There's a guide at the bottom of this file!

const SHAPE_WIDTH_PX = 150

// [2]
type DynamicSizeShape = TLShape<typeof DYNAMIC_SIZE_TYPE>

// [3]
const ShapeSizes = new EditorAtom('shape sizes', (editor) => {
	const map = new AtomMap<TLShapeId, { width: number; height: number }>('shape sizes')

	// [a] Clean up sizes when shapes are deleted
	editor.sideEffects.registerAfterDeleteHandler('shape', (shape) => {
		map.delete(shape.id)
	})

	return map
})

// [4]
function useDynamicShapeSize(shape: DynamicSizeShape) {
	const ref = useRef<HTMLDivElement>(null)
	const editor = useEditor()

	const updateShapeSize = useCallback(() => {
		if (!ref.current) return

		// [a] Get actual DOM dimensions
		const width = ref.current.offsetWidth
		const height = ref.current.offsetHeight

		// [b] Update the shape size in our global atom
		ShapeSizes.update(editor, (map) => {
			const existing = map.get(shape.id)
			if (existing && existing.width === width && existing.height === height) return map
			return map.set(shape.id, { width, height })
		})
	}, [editor, shape.id])

	// [c] Update size immediately on render
	useLayoutEffect(() => {
		updateShapeSize()
	})

	// [d] Watch for DOM size changes using ResizeObserver
	useLayoutEffect(() => {
		if (!ref.current) return
		const observer = new ResizeObserver(updateShapeSize)
		observer.observe(ref.current)
		return () => {
			observer.disconnect()
		}
	}, [updateShapeSize])

	return ref
}

// [5]
export class DynamicSizeShapeUtil extends ShapeUtil<DynamicSizeShape> {
	// [a]
	static override type = DYNAMIC_SIZE_TYPE
	static override props: RecordProps<DynamicSizeShape> = {
		contents: T.arrayOf(T.string),
	}

	// [b]
	getDefaultProps(): DynamicSizeShape['props'] {
		return {
			contents,
		}
	}

	// [c]
	override canCull() {
		return false
	}

	// [d]
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override isAspectRatioLocked() {
		return true
	}

	// [e]
	getGeometry(shape: DynamicSizeShape) {
		const size = ShapeSizes.get(this.editor).get(shape.id)
		return new Rectangle2d({
			width: SHAPE_WIDTH_PX,
			height: size?.height ?? 50,
			isFilled: true,
		})
	}

	// [f]
	component(shape: DynamicSizeShape) {
		const ref = useDynamicShapeSize(shape)

		const [contentsToShow, setContentsToShow] = useState<string>('')

		// [i] Animate text content to demonstrate dynamic sizing
		useEffect(() => {
			const animationDuration = 6000
			const tick = (time: number) => {
				const progress = (time % animationDuration) / animationDuration
				const amountToShow = progress < 0.5 ? progress * 2 : 1 - (progress - 0.5) * 2

				setContentsToShow(
					shape.props.contents
						.slice(0, Math.floor(amountToShow * shape.props.contents.length))
						.join(' ')
				)

				frame = requestAnimationFrame(tick)
			}

			let frame = requestAnimationFrame(tick)

			return () => {
				cancelAnimationFrame(frame)
			}
		}, [shape.props.contents])

		// [ii] Return DOM element that will be measured
		return (
			<div ref={ref} style={{ width: SHAPE_WIDTH_PX }}>
				{contentsToShow}
			</div>
		)
	}

	// [g]
	indicator(shape: DynamicSizeShape) {
		const { width, height } = this.editor.getShapeGeometry(shape).bounds

		return <rect width={width} height={height} />
	}
}

// [6]
const shapeUtils = [DynamicSizeShapeUtil]

export default function SizeFromDomExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={shapeUtils}
				onMount={(editor) => {
					editor.selectAll()
					editor.deleteShapes(editor.getSelectedShapeIds())

					editor.createShape({
						type: DYNAMIC_SIZE_TYPE,
						x: 100,
						y: 100,
					})

					editor.selectAll().zoomToSelection()
				}}
			/>
		</div>
	)
}

/*
Introduction:

This example demonstrates how to create a shape whose size is determined by its DOM content rather than
shape props. It showcases two potentially reusable utilities: ShapeSizes and useDynamicShapeSize, which
can be adapted for other shapes that need DOM-driven sizing.

[1]
First, we need to extend TLGlobalShapePropsMap to add our shape's props to the global type system.
This tells TypeScript about the shape's properties.

[2]
Define the shape type. This shape only stores content data - its size is determined dynamically by
measuring the DOM element that renders the content.

[3]
ShapeSizes is a global EditorAtom that stores size information for shapes by their ID. This is the key
piece that makes DOM-driven sizing work:

	[a] We register a cleanup handler to remove size data when shapes are deleted, preventing memory leaks.

[4]
useDynamicShapeSize is a reusable hook that measures DOM elements and updates the shape size data:

	[a] We measure the actual DOM dimensions using offsetWidth/offsetHeight

	[b] We store these dimensions in our global ShapeSizes atom. The atom will trigger re-renders of
	    components that depend on this data when the size changes.

	[c] We measure immediately on every render to ensure we have current size data

	[d] We use ResizeObserver to watch for size changes and update accordingly. This is what makes
	    the shape truly dynamic - it will update whenever the DOM content changes size.

[5]
The shape util defines how our dynamic-size shape behaves:

	[a] Standard shape type and props definition. Note we only store content, not size.

	[b] Default props with some sample content

	[c] Prevent the shape from being culled when it's outside the viewport, which would break our measurements

	[d] Shape behavior: not editable, not resizable (since size comes from DOM), aspect ratio locked

	[e] getGeometry uses the size from our ShapeSizes atom. This is where the DOM-measured size gets
	    used by the editor for hit-testing, selection bounds, etc.

	[f] The component renders the content and uses our hook to measure it:

		[i] We animate the text content to demonstrate the dynamic sizing in action

		[ii] The ref from useDynamicShapeSize is attached to the DOM element we want to measure

	[g] Standard indicator for selection outline

[6]
Standard setup - pass our custom shape util to Tldraw and create an instance on mount.

Reusability:

The ShapeSizes atom and useDynamicShapeSize hook are designed to be reusable. To use them with other
shapes, you just need to:
1. Call useDynamicShapeSize(shape) in your component and attach the returned ref
2. Use ShapeSizes.get(editor).get(shapeId) in your getGeometry method
3. Ensure your shape doesn't have conflicting size props (or handle the conflict appropriately)

*/
```

## contents.ts

```ts
export const contents = `
Have five minutes? Let's try out the tldraw SDK in a React project. If you're new to React, we recommend using a Vite template as a starter. We'll assume your project is already running locally.

Prefer to jump straight to some code? Try this sandbox.

First, install the tldraw package from NPM:

npm install tldraw

Next, in your React project, import the Tldraw component and tldraw's CSS styles. Then render the Tldraw component inside a full screen container:

That's pretty much it! At this point, you should have a complete working single-user canvas. You can draw and write on the canvas, add images and video, zoom and pan, copy and paste, undo and redo, and do just about everything else you'd expect to do on a canvas.

You'll be starting from our default shapes, tools, and user interface, but you can customize all of these things for your project if you wish. For now, let's show off a few more features.
`
	.replace(/\n/g, '')
	.replace(/\s+/g, ' ')
	.split(' ')
```

--------

# Layout constraints (bindings)

Category: Shapes & tools

Keywords: constraints, group, shape, custom, bindings, drag, drop, position

How to constrain shapes to a layout using bindings.

You can use bindings to make shapes respond to changes to other shapes. This is useful for enforcing layout constraints

## App.tsx

```tsx
import {
	BindingOnChangeOptions,
	BindingOnCreateOptions,
	BindingOnDeleteOptions,
	BindingOnShapeChangeOptions,
	BindingUtil,
	HTMLContainer,
	IndexKey,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	T,
	TLBinding,
	TLShape,
	Tldraw,
	Vec,
	clamp,
	createBindingId,
	getIndexBetween,
} from 'tldraw'
import 'tldraw/tldraw.css'
import snapShot from './snapshot.json'

const CONTAINER_TYPE = 'container'
const ELEMENT_TYPE = 'element'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[CONTAINER_TYPE]: { height: number; width: number }
		[ELEMENT_TYPE]: { color: string }
	}
}

// The container shapes that can contain element shapes

const CONTAINER_PADDING = 24

type ContainerShape = TLShape<typeof CONTAINER_TYPE>

class ContainerShapeUtil extends ShapeUtil<ContainerShape> {
	static override type = CONTAINER_TYPE
	static override props: RecordProps<ContainerShape> = { height: T.number, width: T.number }

	override getDefaultProps() {
		return {
			width: 100 + CONTAINER_PADDING * 2,
			height: 100 + CONTAINER_PADDING * 2,
		}
	}

	override canBind({
		fromShapeType,
		toShapeType,
		bindingType,
	}: {
		fromShapeType: string
		toShapeType: string
		bindingType: string
	}) {
		return fromShapeType === 'container' && toShapeType === 'element' && bindingType === LAYOUT_TYPE
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry(shape: ContainerShape) {
		return new Rectangle2d({
			width: shape.props.width,
			height: shape.props.height,
			isFilled: true,
		})
	}

	override component(shape: ContainerShape) {
		return (
			<HTMLContainer
				style={{
					backgroundColor: '#efefef',
					width: shape.props.width,
					height: shape.props.height,
				}}
			/>
		)
	}

	override indicator(shape: ContainerShape) {
		return <rect width={shape.props.width} height={shape.props.height} />
	}
}

// The element shapes that can be placed inside the container shapes

type ElementShape = TLShape<typeof ELEMENT_TYPE>

class ElementShapeUtil extends ShapeUtil<ElementShape> {
	static override type = ELEMENT_TYPE
	static override props: RecordProps<ElementShape> = {
		color: T.string,
	}

	override getDefaultProps() {
		return {
			color: '#AEC6CF',
		}
	}

	override canBind({
		fromShapeType,
		toShapeType,
		bindingType,
	}: {
		fromShapeType: string
		toShapeType: string
		bindingType: string
	}) {
		return fromShapeType === 'container' && toShapeType === 'element' && bindingType === LAYOUT_TYPE
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 100,
			height: 100,
			isFilled: true,
		})
	}

	override component(shape: ElementShape) {
		return <HTMLContainer style={{ backgroundColor: shape.props.color }}></HTMLContainer>
	}

	override indicator() {
		return <rect width={100} height={100} />
	}

	private getTargetContainer(shape: ElementShape, pageAnchor: Vec) {
		// Find the container shape that the element is being dropped on
		return this.editor.getShapeAtPoint(pageAnchor, {
			hitInside: true,
			filter: (otherShape) =>
				this.editor.canBindShapes({ fromShape: otherShape, toShape: shape, binding: LAYOUT_TYPE }),
		}) as ContainerShape | undefined
	}

	getBindingIndexForPosition(shape: ElementShape, container: ContainerShape, pageAnchor: Vec) {
		// All the layout bindings from the container
		const allBindings = this.editor
			.getBindingsFromShape(container, LAYOUT_TYPE)
			.sort((a, b) => (a.props.index > b.props.index ? 1 : -1))

		// Those bindings that don't involve the element
		const siblings = allBindings.filter((b) => b.toId !== shape.id)

		// Get the relative x position of the element center in the container
		// Where should the element be placed? min index at left, max index + 1
		const order = clamp(
			Math.round((pageAnchor.x - container.x - CONTAINER_PADDING) / (100 + CONTAINER_PADDING)),
			0,
			siblings.length + 1
		)

		// Get a fractional index between the two siblings
		const belowSib = allBindings[order - 1]
		const aboveSib = allBindings[order]
		let index: IndexKey

		if (belowSib?.toId === shape.id) {
			index = belowSib.props.index
		} else if (aboveSib?.toId === shape.id) {
			index = aboveSib.props.index
		} else {
			index = getIndexBetween(belowSib?.props.index, aboveSib?.props.index)
		}

		return index
	}

	override onTranslateStart(shape: ElementShape) {
		// Update all the layout bindings for this shape to be placeholders
		this.editor.updateBindings(
			this.editor.getBindingsToShape(shape, LAYOUT_TYPE).map((binding) => ({
				...binding,
				props: { ...binding.props, placeholder: true },
			}))
		)
	}

	override onTranslate(_: ElementShape, shape: ElementShape) {
		// Find the center of the element shape
		const pageAnchor = this.editor.getShapePageTransform(shape).applyToPoint({ x: 50, y: 50 })

		// Find the container shape that the element is being dropped on
		const targetContainer = this.getTargetContainer(shape, pageAnchor)

		if (!targetContainer) {
			// Delete all the bindings to the element
			const bindings = this.editor.getBindingsToShape(shape, LAYOUT_TYPE)
			this.editor.deleteBindings(bindings)
			return
		}

		// Get the index for the new binding
		const index = this.getBindingIndexForPosition(shape, targetContainer, pageAnchor)

		// Is there an existing binding already between the container and the shape?
		const existingBinding = this.editor
			.getBindingsFromShape(targetContainer, LAYOUT_TYPE)
			.find((b) => b.toId === shape.id)

		if (existingBinding) {
			// If a binding already exists, update it
			if (existingBinding.props.index === index) return
			this.editor.updateBinding({
				...existingBinding,
				props: {
					...existingBinding.props,
					placeholder: true,
					index,
				},
			})
		} else {
			// ...otherwise, create a new one
			this.editor.createBinding({
				id: createBindingId(),
				type: LAYOUT_TYPE,
				fromId: targetContainer.id,
				toId: shape.id,
				props: {
					index,
					placeholder: true,
				},
			})
		}
	}

	override onTranslateEnd(_: ElementShape, shape: ElementShape) {
		// Find the center of the element shape
		const pageAnchor = this.editor.getShapePageTransform(shape).applyToPoint({ x: 50, y: 50 })

		// Find the container shape that the element is being dropped on
		const targetContainer = this.getTargetContainer(shape, pageAnchor)

		// No target container? no problem
		if (!targetContainer) return

		// get the index for the new binding
		const index = this.getBindingIndexForPosition(shape, targetContainer, pageAnchor)

		// delete all the previous bindings for this shape
		this.editor.deleteBindings(this.editor.getBindingsToShape(shape, LAYOUT_TYPE))

		// ...and then create a new one
		this.editor.createBinding({
			id: createBindingId(),
			type: LAYOUT_TYPE,
			fromId: targetContainer.id,
			toId: shape.id,
			props: {
				index,
				placeholder: false,
			},
		})
	}
}

// The binding between the element shapes and the container shapes

const LAYOUT_TYPE = 'layout'

declare module 'tldraw' {
	export interface TLGlobalBindingPropsMap {
		[LAYOUT_TYPE]: {
			index: IndexKey
			placeholder: boolean
		}
	}
}

type LayoutBinding = TLBinding<typeof LAYOUT_TYPE>

class LayoutBindingUtil extends BindingUtil<LayoutBinding> {
	static override type = LAYOUT_TYPE

	override getDefaultProps() {
		return {
			index: 'a1' as IndexKey,
			placeholder: true,
		}
	}

	override onAfterCreate({ binding }: BindingOnCreateOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	override onAfterChange({ bindingAfter }: BindingOnChangeOptions<LayoutBinding>): void {
		this.updateElementsForContainer(bindingAfter)
	}

	override onAfterChangeFromShape({ binding }: BindingOnShapeChangeOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	override onAfterDelete({ binding }: BindingOnDeleteOptions<LayoutBinding>): void {
		this.updateElementsForContainer(binding)
	}

	private updateElementsForContainer({
		props: { placeholder },
		fromId: containerId,
		toId,
	}: LayoutBinding) {
		// Get all of the bindings from the layout container
		const container = this.editor.getShape<ContainerShape>(containerId)
		if (!container) return

		const bindings = this.editor
			.getBindingsFromShape(container, LAYOUT_TYPE)
			.sort((a, b) => (a.props.index > b.props.index ? 1 : -1))
		if (bindings.length === 0) return

		for (let i = 0; i < bindings.length; i++) {
			const binding = bindings[i]

			if (toId === binding.toId && placeholder) continue

			const offset = new Vec(CONTAINER_PADDING + i * (100 + CONTAINER_PADDING), CONTAINER_PADDING)

			const shape = this.editor.getShape<ElementShape>(binding.toId)
			if (!shape) continue

			const point = this.editor.getPointInParentSpace(
				shape,
				this.editor.getShapePageTransform(container)!.applyToPoint(offset)
			)

			if (shape.x !== point.x || shape.y !== point.y) {
				this.editor.updateShape({
					id: binding.toId,
					type: 'element',
					x: point.x,
					y: point.y,
				})
			}
		}

		const width =
			CONTAINER_PADDING +
			(bindings.length * 100 + (bindings.length - 1) * CONTAINER_PADDING) +
			CONTAINER_PADDING

		const height = CONTAINER_PADDING + 100 + CONTAINER_PADDING

		if (width !== container.props.width || height !== container.props.height) {
			this.editor.updateShape({
				id: container.id,
				type: 'container',
				props: { width, height },
			})
		}
	}
}

export default function LayoutExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// @ts-ignore
				snapshot={snapShot}
				onMount={(editor) => {
					;(window as any).editor = editor
				}}
				shapeUtils={[ContainerShapeUtil, ElementShapeUtil]}
				bindingUtils={[LayoutBindingUtil]}
			/>
		</div>
	)
}
```

--------

# Pin (bindings)

Category: Shapes & tools

Keywords:

A pin, using bindings to pin together networks of shapes.

This example shows how to use bindings to connect a network of shapes together.

To try it out, select the pin tool, then click over two overlapping shapes to pin them together.

## App.tsx

```tsx
import {
	BindingOnShapeChangeOptions,
	BindingOnShapeDeleteOptions,
	BindingUtil,
	Box,
	DefaultFillStyle,
	DefaultToolbar,
	DefaultToolbarContent,
	RecordProps,
	Rectangle2d,
	ShapeUtil,
	StateNode,
	TLBinding,
	TLEditorComponents,
	TLPointerEventInfo,
	TLShape,
	TLShapeId,
	TLShapePartial,
	TLShapeUtilCanBindOpts,
	TLUiComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	Vec,
	VecModel,
	createShapeId,
	invLerp,
	lerp,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'

const PIN_TYPE = 'pin'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[PIN_TYPE]: Record<string, never>
	}
}

type PinShape = TLShape<typeof PIN_TYPE>

const offsetX = -16
const offsetY = -26
class PinShapeUtil extends ShapeUtil<PinShape> {
	static override type = PIN_TYPE
	static override props: RecordProps<PinShape> = {}

	override getDefaultProps() {
		return {}
	}

	override canBind({ toShapeType, bindingType }: TLShapeUtilCanBindOpts<PinShape>) {
		if (bindingType === PIN_TYPE) {
			// pins cannot bind to other pins!
			return toShapeType !== PIN_TYPE
		}
		// Allow pins to participate in other bindings, e.g. arrows
		return true
	}
	override canEdit() {
		return false
	}
	override canResize() {
		return false
	}
	override hideRotateHandle() {
		return true
	}
	override isAspectRatioLocked() {
		return true
	}

	override getGeometry() {
		return new Rectangle2d({
			width: 32,
			height: 32,
			x: offsetX,
			y: offsetY,
			isFilled: true,
		})
	}

	override component() {
		return (
			<div
				style={{
					width: '100%',
					height: '100%',
					marginLeft: offsetX,
					marginTop: offsetY,
					fontSize: '26px',
					textAlign: 'center',
				}}
			>
				📍
			</div>
		)
	}

	override indicator() {
		return <rect width={32} height={32} x={offsetX} y={offsetY} />
	}

	override onTranslateStart(shape: PinShape) {
		const bindings = this.editor.getBindingsFromShape(shape, PIN_TYPE)
		this.editor.deleteBindings(bindings)
	}

	override onTranslateEnd(_initial: PinShape, pin: PinShape) {
		const pageAnchor = this.editor.getShapePageTransform(pin).applyToPoint({ x: 0, y: 0 })

		const targets = this.editor
			.getShapesAtPoint(pageAnchor, { hitInside: true })
			.filter(
				(shape) =>
					this.editor.canBindShapes({ fromShape: pin, toShape: shape, binding: PIN_TYPE }) &&
					shape.parentId === pin.parentId &&
					shape.index < pin.index
			)

		for (const target of targets) {
			const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(target)!.bounds)
			const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pageAnchor)

			const anchor = {
				x: invLerp(targetBounds.minX, targetBounds.maxX, pointInTargetSpace.x),
				y: invLerp(targetBounds.minY, targetBounds.maxY, pointInTargetSpace.y),
			}

			this.editor.createBinding({
				type: PIN_TYPE,
				fromId: pin.id,
				toId: target.id,
				props: {
					anchor,
				},
			})
		}
	}
}

declare module 'tldraw' {
	export interface TLGlobalBindingPropsMap {
		[PIN_TYPE]: {
			anchor: VecModel
		}
	}
}

type PinBinding = TLBinding<typeof PIN_TYPE>

class PinBindingUtil extends BindingUtil<PinBinding> {
	static override type = PIN_TYPE

	override getDefaultProps() {
		return {
			anchor: { x: 0.5, y: 0.5 },
		}
	}

	private changedToShapes = new Set<TLShapeId>()

	override onOperationComplete(): void {
		if (this.changedToShapes.size === 0) return

		const fixedShapes = this.changedToShapes
		const toCheck = [...this.changedToShapes]

		const initialPositions = new Map<TLShapeId, VecModel>()
		const targetDeltas = new Map<TLShapeId, Map<TLShapeId, VecModel>>()

		const addTargetDelta = (fromId: TLShapeId, toId: TLShapeId, delta: VecModel) => {
			if (!targetDeltas.has(fromId)) targetDeltas.set(fromId, new Map())
			targetDeltas.get(fromId)!.set(toId, delta)

			if (!targetDeltas.has(toId)) targetDeltas.set(toId, new Map())
			targetDeltas.get(toId)!.set(fromId, { x: -delta.x, y: -delta.y })
		}

		const allShapes = new Set<TLShapeId>()
		while (toCheck.length) {
			const shapeId = toCheck.pop()!

			const shape = this.editor.getShape(shapeId)
			if (!shape) continue

			if (allShapes.has(shapeId)) continue
			allShapes.add(shapeId)

			const bindings = this.editor.getBindingsToShape(shape, PIN_TYPE)
			for (const binding of bindings) {
				if (allShapes.has(binding.fromId)) continue
				allShapes.add(binding.fromId)

				const pin = this.editor.getShape<PinShape>(binding.fromId)
				if (!pin) continue

				const pinPosition = this.editor.getShapePageTransform(pin).applyToPoint({ x: 0, y: 0 })
				initialPositions.set(pin.id, pinPosition)

				for (const binding of this.editor.getBindingsFromShape(pin.id, PIN_TYPE)) {
					const shapeBounds = this.editor.getShapeGeometry(binding.toId)!.bounds
					const shapeAnchor = {
						x: lerp(shapeBounds.minX, shapeBounds.maxX, binding.props.anchor.x),
						y: lerp(shapeBounds.minY, shapeBounds.maxY, binding.props.anchor.y),
					}
					const currentPageAnchor = this.editor
						.getShapePageTransform(binding.toId)
						.applyToPoint(shapeAnchor)

					const shapeOrigin = this.editor
						.getShapePageTransform(binding.toId)
						.applyToPoint({ x: 0, y: 0 })
					initialPositions.set(binding.toId, shapeOrigin)

					addTargetDelta(pin.id, binding.toId, {
						x: currentPageAnchor.x - shapeOrigin.x,
						y: currentPageAnchor.y - shapeOrigin.y,
					})

					if (!allShapes.has(binding.toId)) toCheck.push(binding.toId)
				}
			}
		}

		const currentPositions = new Map(initialPositions)

		const iterations = 30
		for (let i = 0; i < iterations; i++) {
			const movements = new Map<TLShapeId, VecModel[]>()
			for (const [aId, deltas] of targetDeltas) {
				if (fixedShapes.has(aId)) continue
				const aPosition = currentPositions.get(aId)!
				for (const [bId, targetDelta] of deltas) {
					const bPosition = currentPositions.get(bId)!

					const adjustmentDelta = {
						x: targetDelta.x - (aPosition.x - bPosition.x),
						y: targetDelta.y - (aPosition.y - bPosition.y),
					}

					if (!movements.has(aId)) movements.set(aId, [])
					movements.get(aId)!.push(adjustmentDelta)
				}
			}

			for (const [shapeId, deltas] of movements) {
				const currentPosition = currentPositions.get(shapeId)!
				currentPositions.set(shapeId, Vec.Average(deltas).add(currentPosition))
			}
		}

		const updates: TLShapePartial[] = []
		for (const [shapeId, position] of currentPositions) {
			const delta = Vec.Sub(position, initialPositions.get(shapeId)!)
			if (delta.len2() <= 0.01) continue

			const newPosition = this.editor.getPointInParentSpace(shapeId, position)
			updates.push({
				...this.editor.getShape(shapeId)!,
				id: shapeId,
				x: newPosition.x,
				y: newPosition.y,
			})
		}

		if (updates.length === 0) {
			this.changedToShapes.clear()
		} else {
			this.editor.updateShapes(updates)
		}
	}

	// when the shape we're stuck to changes, update the pin's position
	override onAfterChangeToShape({
		binding,
		shapeAfter,
	}: BindingOnShapeChangeOptions<PinBinding>): void {
		this.changedToShapes.add(binding.toId)
		const pin = this.editor.getShape(binding.fromId)
		if (!pin) return

		// If the bound shape changed parents, reparent the pin to follow
		if (pin.parentId !== shapeAfter.parentId) {
			this.editor.reparentShapes([pin.id], shapeAfter.parentId)
		}
	}

	// when the thing we're stuck to is deleted, delete the pin too
	override onBeforeDeleteToShape({ binding }: BindingOnShapeDeleteOptions<PinBinding>): void {
		this.editor.deleteShape(binding.fromId)
	}
}

class PinTool extends StateNode {
	static override id = PIN_TYPE

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerDown(info: TLPointerEventInfo) {
		const currentPagePoint = this.editor.inputs.getCurrentPagePoint()
		const pinId = createShapeId()
		this.editor.markHistoryStoppingPoint()
		this.editor.createShape({
			id: pinId,
			type: PIN_TYPE,
			x: currentPagePoint.x,
			y: currentPagePoint.y,
		})
		this.editor.setSelectedShapes([pinId])
		this.editor.setCurrentTool('select.translating', {
			...info,
			target: 'shape',
			shape: this.editor.getShape(pinId),
			isCreating: true,
			onInteractionEnd: 'pin',
			onCreate: () => {
				this.editor.setCurrentTool('pin')
			},
		})
	}
}

const overrides: TLUiOverrides = {
	tools(editor, schema) {
		schema['pin'] = {
			id: 'pin',
			label: 'Pin',
			icon: 'heart-icon',
			kbd: 'p',
			onSelect: () => {
				editor.setCurrentTool('pin')
			},
		}
		return schema
	},
}

const components: TLUiComponents & TLEditorComponents = {
	Toolbar: (...props) => {
		const pin = useTools().pin
		const isPinSelected = useIsToolSelected(pin)
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...pin} isSelected={isPinSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}

export default function PinExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="pin-example"
				onMount={(editor) => {
					;(window as any).editor = editor
					editor.setStyleForNextShapes(DefaultFillStyle, 'semi')
				}}
				shapeUtils={[PinShapeUtil]}
				bindingUtils={[PinBindingUtil]}
				tools={[PinTool]}
				overrides={overrides}
				components={components}
			/>
		</div>
	)
}
```

--------

# Rich text with custom extension and toolbar

Category: Shapes & tools

Keywords: text, tip, tap, extension, toolbar

Extend the TipTap text editor by adding a custom extension and toolbar.

This example shows how to add a custom extension and toolbar to the TipTap text editor by setting the `textOptions` prop.

## App.tsx

```tsx
import { Mark, mergeAttributes } from '@tiptap/core'
import { StarterKit } from '@tiptap/starter-kit'
import {
	DefaultRichTextToolbar,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	preventDefault,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './RichTextCustomExtension.css'

interface WavyExtensionOptions {
	HTMLAttributes: object
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		wavy: {
			setWavy(): ReturnType
			toggleWavy(): ReturnType
			unsetWavy(): ReturnType
		}
	}
}

const Wavy = Mark.create<WavyExtensionOptions>({
	name: 'wavy',

	addOptions() {
		return {
			HTMLAttributes: {},
		}
	},

	parseHTML() {
		return [
			{
				tag: 'span.wavy',
			},
		]
	},

	renderHTML({ HTMLAttributes }) {
		return [
			'span',
			mergeAttributes(this.options.HTMLAttributes, { class: 'wavy' }, HTMLAttributes),
			0,
		]
	},

	addCommands() {
		return {
			setWavy:
				() =>
				({ commands }) =>
					commands.setMark(this.name),
			toggleWavy:
				() =>
				({ commands }: any) =>
					commands.toggleMark(this.name),
			unsetWavy:
				() =>
				({ commands }) =>
					commands.unsetMark(this.name),
		}
	},
})

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])

		return (
			<DefaultRichTextToolbar>
				<TldrawUiButton
					type="icon"
					onClick={() => {
						textEditor?.chain().focus().toggleWavy().run()
					}}
					isActive={textEditor?.isActive('wavy')}
					onPointerDown={preventDefault}
				>
					〰️
				</TldrawUiButton>
				{/* Add the DefaultRichTextToolbarContent if you want to add more items. */}
				{/* <DefaultRichTextToolbarContent textEditor={textEditor} onEditLinkIntent={() => {}} /> */}
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions = {
	tipTapConfig: {
		extensions: [StarterKit, Wavy],
	},
}

export default function RichTextCustomExtensionExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-custom-extension"
				components={components}
				textOptions={textOptions}
			/>
		</div>
	)
}

/*
This example shows how to set custom properties on the TipTap editor.
*/
```

## RichTextCustomExtension.css

```css
.wavy {
	text-decoration: wavy underline hotpink;
}
```

--------

# Rich text with font options

Category: Shapes & tools

Keywords: text, tip, tap, extension, toolbar, font

Extend the TipTap text editor by adding font-family and font-size options.

This example shows how to add font-family and font-size options to the TipTap text editor by setting the `textOptions` prop.

## App.tsx

```tsx
import { EditorEvents as TextEditorEvents } from '@tiptap/core'
import { FontFamily } from '@tiptap/extension-font-family'
import { TextStyleKit } from '@tiptap/extension-text-style'
import { EditorState as TextEditorState } from '@tiptap/pm/state'
import { useEffect, useState } from 'react'
import {
	DefaultRichTextToolbar,
	DefaultRichTextToolbarContent,
	Editor,
	TLComponents,
	TLTextOptions,
	Tldraw,
	defaultAddFontsFromNode,
	tipTapDefaultExtensions,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { FontSize } from './FontSizeExtension'
import './RichTextFontExtension.css'
import { extensionFontFamilies } from './fonts'

const fontOptions = [
	{ label: 'Default', value: 'DEFAULT' },
	{ label: 'Inter', value: 'Inter' },
	{ label: 'Comic Sans MS', value: 'Comic Sans MS' },
	{ label: 'serif', value: 'serif' },
	{ label: 'monospace', value: 'monospace' },
	{ label: 'cursive', value: 'cursive' },
	{ label: 'Exo 2 (Google Font)', value: "'Exo 2'" },
]

const fontSizeOptions = [
	{ label: 'Small', value: '12px' },
	{ label: 'Normal', value: '16px' },
	{ label: 'Large', value: '20px' },
	{ label: 'X-Large', value: '24px' },
	{ label: 'XX-Large', value: '28px' },
	{ label: 'Huge', value: '32px' },
]

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])
		const [_, setTextEditorState] = useState<TextEditorState | null>(textEditor?.state ?? null)

		// Set up text editor transaction listener.
		useEffect(() => {
			if (!textEditor) {
				setTextEditorState(null)
				return
			}

			const handleTransaction = ({ editor: textEditor }: TextEditorEvents['transaction']) => {
				setTextEditorState(textEditor.state)
			}

			textEditor.on('transaction', handleTransaction)
			return () => {
				textEditor.off('transaction', handleTransaction)
				setTextEditorState(null)
			}
		}, [textEditor])

		if (!textEditor) return null

		const currentFontFamily = textEditor?.getAttributes('textStyle').fontFamily ?? 'DEFAULT'
		const currentFontSize = textEditor?.getAttributes('textStyle').fontSize

		return (
			<DefaultRichTextToolbar>
				<select
					className="rich-text-font-extension-select"
					value={currentFontFamily}
					onPointerDown={editor.markEventAsHandled}
					onChange={(e) => {
						textEditor?.chain().focus().setFontFamily(e.target.value).run()
					}}
				>
					{fontOptions.map((option) => (
						<option key={option.value} value={option.value}>
							{option.label}
						</option>
					))}
				</select>
				<select
					className="rich-text-font-extension-select"
					value={currentFontSize}
					onPointerDown={editor.markEventAsHandled}
					onChange={(e) => {
						textEditor?.chain().focus().setFontSize(e.target.value).run()
					}}
				>
					{fontSizeOptions.map((option) => (
						<option key={option.value} value={option.value}>
							{option.label}
						</option>
					))}
				</select>
				{/* Add the DefaultRichTextToolbarContent if you want to add more items. */}
				<DefaultRichTextToolbarContent textEditor={textEditor} />
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions: Partial<TLTextOptions> = {
	tipTapConfig: {
		extensions: [...tipTapDefaultExtensions, FontFamily, FontSize, TextStyleKit],
	},
	addFontsFromNode(node, state, addFont) {
		state = defaultAddFontsFromNode(node, state, addFont)

		// if we have a font-family attribute, keep track of that in the state so it applies to children
		for (const mark of node.marks) {
			if (
				mark.type.name === 'textStyle' &&
				mark.attrs.fontFamily &&
				mark.attrs.fontFamily !== 'DEFAULT' &&
				mark.attrs.fontFamily !== state.family
			) {
				state = { ...state, family: mark.attrs.fontFamily }
			}
		}

		// if one of our extension font families matches the current state, add that font to the document.
		const font = extensionFontFamilies[state.family]?.[state.style]?.[state.weight]
		if (font) addFont(font)

		return state
	},
}

export default function RichTextFontExtensionExample() {
	const fontFaces = Object.values(extensionFontFamilies)
		.map((fontFamily) => Object.values(fontFamily))
		.flat()
		.map((fontStyle) => Object.values(fontStyle))
		.flat()

	// We need to preload the fonts so that they are available when
	// making font changes. This is to avoid any FOUC as you change the
	// font families.
	const onMount = (editor: Editor) => {
		editor.fonts.requestFonts(fontFaces)
	}

	const exoFont = extensionFontFamilies["'Exo 2'"].normal.normal.src.url

	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="rich-text-font-extension"
				components={components}
				textOptions={textOptions}
				// If you want to override one of the custom fonts,
				// you can do so by providing an assetUrls prop.
				assetUrls={{
					fonts: {
						tldraw_mono: exoFont,
					},
				}}
				onMount={onMount}
			/>
		</div>
	)
}

/*
This example shows how to set font family and font size properties on the TipTap editor.
*/
```

## FontSizeExtension.ts

```ts
import '@tiptap/extension-text-style'

import { Extension } from '@tiptap/core'

export interface FontSizeOptions {
	/**
	 * A list of node names where the font size can be applied.
	 * @default ['textStyle']
	 * @example ['heading', 'paragraph']
	 */
	types: string[]
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		fontSize: {
			/**
			 * Set the font size
			 * @param fontSize The font size
			 * @example editor.commands.setFontSize('32px')
			 */
			setFontSize(fontSize: string): ReturnType
			/**
			 * Unset the font size
			 * @example editor.commands.unsetFontSize()
			 */
			unsetFontSize(): ReturnType
		}
	}
}

/**
 * This extension allows you to set a font size for text.
 */
export const FontSize = Extension.create<FontSizeOptions>({
	name: 'fontSize',

	addOptions() {
		return {
			types: ['textStyle'],
		}
	},

	addGlobalAttributes() {
		return [
			{
				types: this.options.types,
				attributes: {
					fontSize: {
						default: null,
						parseHTML: (element) => element.style.fontSize,
						renderHTML: (attributes) => {
							if (!attributes.fontSize) {
								return {}
							}

							return {
								style: `font-size: ${attributes.fontSize}`,
							}
						},
					},
				},
			},
		]
	},

	addCommands() {
		return {
			setFontSize:
				(fontSize) =>
				({ chain }) => {
					return chain().setMark('textStyle', { fontSize }).run()
				},
			unsetFontSize:
				() =>
				({ chain }) => {
					return chain().setMark('textStyle', { fontSize: null }).removeEmptyTextStyle().run()
				},
		}
	},
})
```

## RichTextFontExtension.css

```css
.rich-text-font-extension-select {
	border: 0;
	background: transparent;
	margin: 0 8px;
}
```

## fonts.ts

```ts
import { TLDefaultFont, TLFontFace } from 'tldraw'

// NOTE: these fonts only support the latin character set. To support other languages, you'll add
// each one as a new font-family, similar to how you would with @font-face.
export const extensionFontFamilies: {
	[key: string]: { [key: string]: { [key: string]: TLFontFace } }
} = {
	Inter: {
		normal: {
			normal: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuI6fAZ9hiJ-Ek-_EeA.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuFuYAZ9hiJ-Ek-_EeA.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
		italic: {
			normal: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCM3FwrK3iLTcvneQg7Ca725JhhKnNqk4j1ebLhAm8SrXTc69tRipWFsevceSGM.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Inter',
				src: {
					url: 'https://fonts.gstatic.com/s/inter/v18/UcCM3FwrK3iLTcvneQg7Ca725JhhKnNqk4j1ebLhAm8SrXTcPtxRipWFsevceSGM.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
	},
	"'Exo 2'": {
		normal: {
			normal: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH1v4okm5zmbvwkAx_sfcEuiD8jjPKsOdC_jJ7bpAhL.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH1v4okm5zmbvwkAx_sfcEuiD8jWfWsOdC_jJ7bpAhL.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
		italic: {
			normal: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH3v4okm5zmbtYtMeA0FKq0Jjg2drFGfeC9hp_5oBBKRrs.woff2',
					format: 'woff2',
				},
				weight: '500',
				style: 'normal',
			},
			bold: {
				family: 'Exo 2',
				src: {
					url: 'https://fonts.gstatic.com/s/exo2/v24/7cH3v4okm5zmbtYtMeA0FKq0Jjg2drGTeuC9hp_5oBBKRrs.woff2',
					format: 'woff2',
				},
				weight: '700',
				style: 'normal',
			},
		},
	},
} satisfies Record<string, TLDefaultFont>
```

--------

# Outlined text example

Category: Shapes & tools

Keywords: text, outline, stroke, extension, toolbar, styling

Add outlined text styling to the TipTap text editor with a custom extension.

This example shows how to add a text outline effect by creating a custom TipTap extension that applies CSS text-stroke styling to selected text. The example includes a custom toolbar button to toggle the outline effect on and off.

## App.tsx

```tsx
import { Mark, mergeAttributes } from '@tiptap/core'
import { StarterKit } from '@tiptap/starter-kit'
import {
	DefaultRichTextToolbar,
	TLComponents,
	Tldraw,
	TldrawUiButton,
	preventDefault,
	useEditor,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './OutlinedTextExample.css'

interface OutlineExtensionOptions {
	HTMLAttributes: object
}

declare module '@tiptap/core' {
	interface Commands<ReturnType> {
		outline: {
			setOutline(): ReturnType
			toggleOutline(): ReturnType
			unsetOutline(): ReturnType
		}
	}
}

const Outline = Mark.create<OutlineExtensionOptions>({
	name: 'outline',

	addOptions() {
		return {
			HTMLAttributes: {},
		}
	},

	parseHTML() {
		return [
			{
				tag: 'span.outlined',
			},
		]
	},

	renderHTML({ HTMLAttributes }) {
		return [
			'span',
			mergeAttributes(this.options.HTMLAttributes, { class: 'outlined filled' }, HTMLAttributes),
			0,
		]
	},

	addCommands() {
		return {
			setOutline:
				() =>
				({ commands }) =>
					commands.setMark(this.name),
			toggleOutline:
				() =>
				({ commands }: any) =>
					commands.toggleMark(this.name),
			unsetOutline:
				() =>
				({ commands }) =>
					commands.unsetMark(this.name),
		}
	},

	onCreate() {
		this.editor.commands.toggleMark('outline')
	},
})

const components: TLComponents = {
	RichTextToolbar: () => {
		const editor = useEditor()
		const textEditor = useValue('textEditor', () => editor.getRichTextEditor(), [editor])

		return (
			<DefaultRichTextToolbar>
				<TldrawUiButton
					type="icon"
					onClick={() => {
						textEditor?.chain().focus().toggleOutline().run()
					}}
					isActive={textEditor?.isActive('outline')}
					onPointerDown={preventDefault}
					title="Toggle text outline"
				>
					⬜
				</TldrawUiButton>
			</DefaultRichTextToolbar>
		)
	},
}

const textOptions = {
	tipTapConfig: {
		extensions: [StarterKit, Outline],
	},
}

export default function OutlinedTextExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="outlined-text-example"
				components={components}
				textOptions={textOptions}
			/>
		</div>
	)
}

/*
This example shows how to add outlined text styling using a custom TipTap extension.
The outline effect is created using CSS text-stroke properties.
*/
```

## OutlinedTextExample.css

```css
.outlined {
	-webkit-text-stroke: 2px #000000;
	text-stroke: 2px #000000;
	color: transparent;
	font-weight: bold;
}

.outlined.filled {
	color: #ffffff;
}
```

--------

# Popup shape

Category: Shapes & tools

Keywords: dynamic shadows, css

Create a 3D illusion of depth with dynamic shadows and CSS transforms.

Create a 3D illusion of depth with dynamic shadows and CSS transforms.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { PopupShapeUtil } from './PopupShapeUtil'

const customShapeUtils = [PopupShapeUtil]

export default function PopupShapeExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				shapeUtils={customShapeUtils}
				onMount={(editor) => {
					for (let i = 0; i < 9; i++) {
						editor.createShape({
							type: 'my-popup-shape',
							x: (i % 3) * 220,
							y: Math.floor(i / 3) * 220,
						})
					}
					editor.zoomToBounds(editor.getCurrentPageBounds()!, { animation: { duration: 0 } })
				}}
			/>
		</div>
	)
}
```

## PopupShapeUtil.tsx

```tsx
/* eslint-disable react-hooks/rules-of-hooks */
import { useEffect, useRef, useState } from 'react'
import { BaseBoxShapeUtil, HTMLContainer, RecordProps, T, TLShape } from 'tldraw'

const MY_POPUP_SHAPE_TYPE = 'my-popup-shape'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[MY_POPUP_SHAPE_TYPE]: { w: number; h: number; animal: number }
	}
}

export type IMyPopupShape = TLShape<typeof MY_POPUP_SHAPE_TYPE>

export class PopupShapeUtil extends BaseBoxShapeUtil<IMyPopupShape> {
	static override type = MY_POPUP_SHAPE_TYPE
	static override props: RecordProps<IMyPopupShape> = {
		w: T.number,
		h: T.number,
		animal: T.number,
	}

	getDefaultProps(): IMyPopupShape['props'] {
		return {
			w: 200,
			h: 200,
			animal: 0,
		}
	}

	component(shape: IMyPopupShape) {
		const [popped, setPopped] = useState(false)

		const ref = useRef<HTMLDivElement>(null)
		const ref2 = useRef<HTMLDivElement>(null)

		useEffect(() => {
			const elm = ref.current
			if (!elm) return
			const elm2 = ref2.current
			if (!elm2) return
			if (popped) {
				// man
				// elm2.style.transform = `rotateX(0deg) translateY(0px) translateZ(0px)`
				// note
				elm.style.transform = `rotateX(0deg) translateY(0px) translateZ(0px)`
			} else {
				// man
				// elm.style.transform = `rotateX(-50deg) translateY(5px) translateZ(0px)`
				// elm2.style.transform = `scaleY(.8)`
				// note
				elm.style.transform = `rotateX(20deg)`
			}
		}, [popped])

		const vpb = this.editor.getViewportPageBounds()
		const spb = this.editor.getShapePageBounds(shape)!
		const px = vpb.midX - spb.midX + spb.w / 2
		const py = vpb.midY - spb.midY + spb.h / 2

		return (
			<HTMLContainer
				style={{
					pointerEvents: 'all',
					perspective: `${Math.max(vpb.w, vpb.h)}px`,
					perspectiveOrigin: `${px}px ${py}px`,
				}}
				onPointerDown={this.editor.markEventAsHandled}
				onDoubleClick={(e) => {
					setPopped((p) => !p)
					this.editor.markEventAsHandled(e)
				}}
			>
				<div
					ref={ref2}
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						transition: `all .5s`,
						backgroundSize: 'contain',
						backgroundRepeat: 'no-repeat',
						backgroundPosition: 'center',
						// man
						// transformOrigin: 'bottom center',
						// backgroundImage: `url(/shadow-man.png)`,
						// note
						backgroundColor: 'rgba(0,0,0,.5)',
					}}
				/>
				<div
					ref={ref}
					style={{
						position: 'absolute',
						top: 0,
						left: 0,
						width: '100%',
						height: '100%',
						transition: `all .5s`,
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						padding: 16,
						overflow: 'hidden',
						fontFamily: 'tldraw_draw',
						color: '#333',
						fontSize: 24,
						backgroundSize: 'contain',
						backgroundRepeat: 'no-repeat',
						backgroundPosition: 'center',
						transformOrigin: 'top center',
						// man
						// backgroundImage: `url(/man.png)`,
						// transformOrigin: 'bottom center',
						// transform: `rotateX(20deg) translateY(5px) translateZ(40px)`,
						// note
						background: `gold`,
						border: '1px solid goldenrod',
					}}
				>
					{/* {shape.id.slice(-1).toUpperCase()} */}
				</div>
			</HTMLContainer>
		)
	}

	indicator(shape: IMyPopupShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

--------

# Multiplayer sync

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration

Use tldraw sync for multiplayer collaboration.

The `useSyncDemo` hook can be used to quickly prototype multiplayer experiences in tldraw using a demo backend that we host. Data is wiped after one day.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncDemoExample({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId })
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} deepLinks />
		</div>
	)
}
```

--------

# Multiplayer sync with a custom shape

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, custom shape

Use a custom shape in combination with tldraw sync.

This example shows a custom shape in combination with tldraw sync.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { CounterShapeTool, CounterShapeUtil } from './CounterShape'
import { components, uiOverrides } from './ui'

const customShapes = [CounterShapeUtil]
const customTools = [CounterShapeTool]

export default function SyncDemoShapeExample({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId, shapeUtils: customShapes })
	return (
		<div className="tldraw__editor">
			<Tldraw
				store={store}
				shapeUtils={customShapes}
				tools={customTools}
				overrides={uiOverrides}
				components={components}
				deepLinks
			/>
		</div>
	)
}
```

## CounterShape.tsx

```tsx
import { MouseEvent } from 'react'
import { BaseBoxShapeTool, BaseBoxShapeUtil, HTMLContainer, T, TLShape } from 'tldraw'

const COUNTER_TYPE = 'counter'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[COUNTER_TYPE]: { w: number; h: number; count: number }
	}
}

export type CounterShape = TLShape<typeof COUNTER_TYPE>

export class CounterShapeUtil extends BaseBoxShapeUtil<CounterShape> {
	static override type = COUNTER_TYPE
	static override props = {
		w: T.positiveNumber,
		h: T.positiveNumber,
		count: T.number,
	}

	override getDefaultProps() {
		return {
			w: 200,
			h: 200,
			count: 0,
		}
	}

	override component(shape: CounterShape) {
		const onClick = (event: MouseEvent, change: number) => {
			event.stopPropagation()
			this.editor.updateShape({
				id: shape.id,
				type: COUNTER_TYPE,
				props: { count: shape.props.count + change },
			})
		}

		return (
			<HTMLContainer
				style={{
					pointerEvents: 'all',
					background: '#efefef',
					display: 'flex',
					alignItems: 'center',
					justifyContent: 'center',
					gap: 8,
				}}
			>
				<button onClick={(e) => onClick(e, -1)} onPointerDown={this.editor.markEventAsHandled}>
					-
				</button>
				<span>{shape.props.count}</span>
				<button onClick={(e) => onClick(e, 1)} onPointerDown={this.editor.markEventAsHandled}>
					+
				</button>
			</HTMLContainer>
		)
	}

	override indicator(shape: CounterShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

export class CounterShapeTool extends BaseBoxShapeTool {
	static override id = 'counter'
	override shapeType = 'counter' as const
}
```

## ui.tsx

```tsx
import {
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	TldrawUiMenuItem,
	useIsToolSelected,
	useTools,
} from 'tldraw'

export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.counter = {
			id: 'counter',
			icon: 'color',
			label: 'counter',
			kbd: 'c',
			onSelect: () => {
				editor.setCurrentTool('counter')
			},
		}
		return tools
	},
}

export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isCounterSelected = useIsToolSelected(tools['counter'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['counter']} isSelected={isCounterSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
}
```

--------

# Multiplayer sync with custom people menu

Category: Collaboration

Keywords: multiplayer, sync, collaboration, custom shape, presence, people, ui, facepile

A custom multiplayer people menu / facepile that displays connected collaborators.

This example demonstrates how to build a custom people menu (or facepile) that shows information about all users in a multiplayer session.

This is useful when you want to create a more detailed or custom-styled presence indicator than the default tldraw provides. This example shows user's names, ids, colors, and cursor position, all information provided in the `TLInstancePresence` returned by `editor.getCollaborators()`.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { Tldraw, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import './sync-custom-people-menu.css'

// [1]
const components = {
	SharePanel: () => (
		<div className="tlui-share-zone" draggable={false}>
			<CustomPeopleMenu />
		</div>
	),
}

// [2]
export default function SyncCustomPeopleMenuExample({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId })
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} deepLinks components={components} />
		</div>
	)
}

// [3]
function CustomPeopleMenu() {
	const editor = useEditor()

	// [a]
	const myUserColor = useValue('user', () => editor.user.getColor(), [editor])
	const myUserName = useValue('user', () => editor.user.getName() || 'Guest', [editor])
	const myUserId = useValue('user', () => editor.user.getId(), [editor])

	// [b]
	const allOtherPresences = useValue('presences', () => editor.getCollaborators(), [editor])

	return (
		<div className="custom-people-menu">
			{/* [c] */}
			<div className="user-section">
				<h4 className="section-title">Me</h4>
				<div className="user-info">
					<div className="user-avatar" style={{ background: myUserColor }} />
					<span className="user-name" style={{ color: myUserColor }}>
						{myUserName}, ID: {myUserId}
					</span>
				</div>
			</div>

			{/* [d] */}
			{allOtherPresences.length > 0 && (
				<div className="other-users-section">
					<h4 className="section-title">Other connected users:</h4>
					<div className="other-users-list">
						{allOtherPresences.map(({ userId, userName, color, cursor }) => (
							<div key={userId} className="other-user-item">
								<div className="other-user-avatar" style={{ background: color }} />
								<span className="other-user-name" style={{ color: color }}>
									{userName || `ID: ${userId}`}
								</span>
								<span className="cursor-info">
									Cursor
									<br />
									{cursor && Number.isFinite(cursor.x) && Number.isFinite(cursor.y)
										? `(${Math.round(cursor.x)}, ${Math.round(cursor.y)})`
										: 'cursor data unavailable'}
								</span>
							</div>
						))}
					</div>
				</div>
			)}
		</div>
	)
}

/*
[1]
We define custom components to override tldraw's default UI. Here we're replacing the SharePanel with our own CustomPeopleMenu component.

[2]
This is the main component that sets up a synced tldraw editor. It uses the useSyncDemo hook to create a multiplayer store and passes our custom components to replace the default UI elements.

[3]
The CustomPeopleMenu component displays information about all connected users. It uses tldraw's collaboration hooks to access real-time presence data. You can do whatever you like in here, see the TLInstancePresence interface to see what informatino you have access to.

	[a]
	We use the useValue hook to reactively get the current user's information (color, name, and ID). These values will automatically update if the user changes their name or the system assigns a new color (note: the examlpe doesn't allow for name changing).

	[b]
	We get the live presence of all other users information using the editor's getCollaborators() method. We need to call getCollaborators() in a useValue hook in order for the presence info to be reactive.

	[c]
	Display the current user's information with their color indicator and name. We show both the display name and the internal user ID for debugging purposes.

	[d]
	For each connected collaborator, we display their name (or ID if no name is set), their color indicator, and their current cursor position.
*/
```

## sync-custom-people-menu.css

```css
/* Custom People Menu Styles */
.custom-people-menu {
	background: #f5f5f5;
	padding: 4px;
	display: flex;
	flex-direction: column;
	gap: 12px;
	width: 320px;
}

.user-section {
	display: flex;
	flex-direction: column;
	gap: 8px;
}

.section-title {
	margin: 0;
}

.user-info {
	display: flex;
	align-items: center;
	padding: 8px 12px;
	gap: 8px;
}

.user-avatar {
	width: 16px;
	height: 16px;
	border-radius: 50%;
	margin-right: 8px;
}

.user-name {
	word-break: break-word;
}

.other-users-section {
	display: flex;
	flex-direction: column;
	gap: 8px;
}

.other-users-list {
	display: flex;
	flex-direction: column;
	gap: 6px;
}

.other-user-item {
	display: flex;
	align-items: start;
	padding: 6px 12px;
}

.other-user-avatar {
	width: 16px;
	height: 16px;
	border-radius: 50%;
	margin-right: 8px;
}

.other-user-name {
	word-break: break-word;
	width: 170px;
}

.cursor-info {
	width: 80px;
	color: #aaa;
	font-size: 12px;
	margin-left: 8px;
}
```

--------

# Multiplayer sync with custom presence

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, presence

Customize the presence data synced between different tldraw instances.

This example shows how to customize the presence data synced between different tldraw instances.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { useEffect } from 'react'
import { Tldraw, getDefaultUserPresence, useAtom } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncCustomUserExample({ roomId }: { roomId: string }) {
	// [1]
	const timer = useAtom('timer', Date.now())
	useEffect(() => {
		const tick = () => {
			timer.set(Date.now())
			frame = requestAnimationFrame(tick)
		}
		let frame = requestAnimationFrame(tick)
		return () => cancelAnimationFrame(frame)
	}, [timer])

	// [2]
	const store = useSyncDemo({
		roomId,
		getUserPresence(store, user) {
			// [2.1]
			const defaults = getDefaultUserPresence(store, user)
			if (!defaults) return null

			return {
				...defaults,

				// [2.2]
				camera: undefined,

				// [2.3]
				cursor: {
					...defaults.cursor,
					x: (defaults.cursor.x ?? 0) + 20 * Math.sin(timer.get() / 200),
					y: (defaults.cursor.y ?? 0) + 20 * Math.cos(timer.get() / 200),
				},
			}
		},
	})

	// [3]
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} deepLinks />
		</div>
	)
}

/**
 * # Sync Custom User
 *
 * This example demonstrates how to use the sync demo server with custom presence state. The
 * presence state is synchronized to all other clients and used for multiplayer features like
 * cursors and viewport following. You can use custom presence state to change the data that's
 * synced to other clients, or remove parts you don't need for your app.
 *
 * 1. We create a timer that updates every frame. You don't need to do this in your app, it's just
 *    to power an animation. We store it in an `atom` so that changes to it will cause the presence
 *    info to update.
 *
 * 2. We create a multiplayer store using the userSyncDemo hook, and pass in a custom
 *    `getUserPresence` function to change the presence state that gets sent.
 *
 * 2.1. We get the default presence state using the `getDefaultUserPresence` function. If you wanted
 *    to send a very minimal set of presence data, you could avoid this part.
 *
 * 2.2. We remove the camera from the presence state. This means that the camera position won't be
 *    sent to other clients. Attempting to follow this users viewport will not work.
 *
 * 2.3. We update the cursor position and rotation based on the current time. This will make the
 *    cursor spin around in a circle.
 *
 * 3. We create a Tldraw component and pass in the multiplayer store. This will render the editor.
 */
```

--------

# Multiplayer sync with custom user data

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration, custom shape

Integrate your own user data into tldraw sync.

This example shows how to integrate your own user data into tldraw sync.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import { useState } from 'react'
import { TLUserPreferences, Tldraw, useTldrawUser } from 'tldraw'
import 'tldraw/tldraw.css'

export default function SyncCustomUserExample({ roomId }: { roomId: string }) {
	// [1]
	const [userPreferences, setUserPreferences] = useState<TLUserPreferences>({
		id: 'user-' + Math.random(),
		name: 'Jimmothy',
		color: 'palevioletred',
		colorScheme: 'dark',
	})

	// [2]
	const store = useSyncDemo({ roomId, userInfo: userPreferences })

	// [3]
	const user = useTldrawUser({ userPreferences, setUserPreferences })

	// [4]
	return (
		<div className="tldraw__editor">
			<Tldraw store={store} user={user} deepLinks />
		</div>
	)
}

/**
 * # Sync Custom User
 *
 * This example demonstrates how to use the sync demo server with a custom user.
 *
 * You need access to two things to do this integration:
 *
 * - The user info
 * - A function to set the user info
 *
 * In this example we create an in-memory state for the user info, but in your system it's probably synchronized with a backend database somehow.
 *
 * 1. We get our user info and a function to set it from a `useState` hook. In your app this might come from a context provider or you might hook it up manually to your backend.
 * 2. We use the `useSyncDemo` hook to create the multiplayer store, and pass in the current user state as `userInfo`, which is a subset of the `userPreferences` type.
 * 3. We use the `useTLUser` hook to create a TLUser object, which allows the Editor to both read and update the user info and preferences.
 * 4. We render the `Tldraw` component with the multiplayer store and the user object.
 *
 * You can pass the same `user` object into the `useSync` hook if you're using your own server.
 */
```

--------

# Multiplayer sync with private content

Category: Collaboration

Keywords: basic, intro, simple, quick, start, multiplayer, sync, collaboration

Show and hide private content in a multiplayer session.

This is a simple example of how to show and hide private content in a multiplayer session based on a simple
data ownership model. Try it out by opening the example in two different tabs, toggling the private mode, and
drawing some shapes.

## App.tsx

```tsx
import { useSyncDemo } from '@tldraw/sync'
import React from 'react'
import {
	Atom,
	TLComponents,
	Tldraw,
	react,
	useAtom,
	useEditor,
	useIsToolSelected,
	useTools,
	useValue,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { VisibilityOff, VisibilityOn } from '../../icons/icons'
import { Toggle } from './Toggle'
import './style.css'

// There's a guide at the bottom of this file!

// [1]
const PrivateModeContext = React.createContext<null | Atom<boolean>>(null)

const components: TLComponents = {
	// [2]
	InFrontOfTheCanvas: () => {
		const editor = useEditor()
		const isInSelectTool = useIsToolSelected(useTools().select)
		const userId = useValue('userId', () => editor.user.getId(), [])
		const myPrivateSelectedShapes = useValue(
			'private shapes',
			() =>
				editor
					.getSelectedShapes()
					.filter((shape) => !!shape.meta.private && shape.meta.ownerId === userId),
			[editor, userId]
		)

		// [3]
		const isPrivateMode$ = React.useContext(PrivateModeContext)!
		const isPrivateMode = useValue(isPrivateMode$)

		return (
			<>
				{isInSelectTool && myPrivateSelectedShapes.length > 0 ? (
					<div className="toggle-panel">
						<div>
							Make {myPrivateSelectedShapes.length} selected shape
							{myPrivateSelectedShapes.length > 1 ? 's' : ''} public?{' '}
						</div>
						<button
							onClick={() => {
								editor.markHistoryStoppingPoint()
								// [7]
								const allAffectedShapes = [
									...editor.getShapeAndDescendantIds(myPrivateSelectedShapes.map((s) => s.id)),
								].map((id) => editor.getShape(id)!)
								editor.updateShapes(
									allAffectedShapes.map((shape) => ({
										...shape,
										meta: { ...shape.meta, private: false },
									}))
								)
							}}
						>
							Yes
						</button>
					</div>
				) : (
					<div className="toggle-panel pointer" onClick={() => isPrivateMode$.update((v) => !v)}>
						{isPrivateMode ? <VisibilityOff fill="#444" /> : <VisibilityOn fill="#444" />}
						<div>Private mode</div>
						<Toggle isChecked={isPrivateMode} />
					</div>
				)}
			</>
		)
	},
}
function App({ roomId }: { roomId: string }) {
	const store = useSyncDemo({ roomId })
	const isPrivateMode$ = React.useContext(PrivateModeContext)!
	return (
		<div className="tldraw__editor">
			<Tldraw
				store={store}
				deepLinks
				// [4]
				getShapeVisibility={(shape, editor) => {
					const userId = editor.user.getId()
					if (!!shape.meta.private && shape.meta.ownerId !== userId) {
						return 'hidden'
					}
					return 'inherit'
				}}
				onMount={(editor) => {
					// [5]
					editor.store.sideEffects.registerBeforeCreateHandler('shape', (shape) => {
						if ('private' in shape.meta) return shape
						return {
							...shape,
							meta: {
								...shape.meta,
								private: isPrivateMode$.get(),
								ownerId: editor.user.getId(),
							},
						}
					})

					// [6]
					return react('clean up selection', () => {
						const selectedShapes = editor.getSelectedShapes()
						const filteredSelectedShapes = selectedShapes.filter((s) => !editor.isShapeHidden(s))
						if (filteredSelectedShapes.length !== selectedShapes.length) {
							editor.select(...filteredSelectedShapes)
						}
					})
				}}
				components={components}
			/>
		</div>
	)
}

export default function SyncPrivateContentExample({ roomId }: { roomId: string }) {
	return (
		<PrivateModeContext.Provider value={useAtom('isPrivateDrawingMode', false)}>
			<App roomId={roomId} />
		</PrivateModeContext.Provider>
	)
}

/**
 * This example demonstrates how to create a 'private' drawing mode where any shapes created by one person cannot be seen by another.
 * It sets up a simple ownership system where each shape created is tagged with the id of the user who created it.
 * It also adds a boolean flag to each shape called 'private' which is set to true if the shape is created in private mode.
 * If the user selects one or more private shapes, they will be given the option to make them public.
 *
 * 1. We create a context to store the atom that will hold the state of the private drawing mode. We are using signals here but you can use any state management library you like.
 * 2. We override the `InFrontOfTheCanvas` component to add a tool panel at the top of the screen that allows the user to toggle private drawing mode on and off, and to make private shapes public.
 * 3. We use the context to get the atom that holds the state of the private drawing mode. We then have to call 'useValue' on the atom to get the current value in a reactive way.
 * 4. We override the `getShapeVisibility` function to hide shapes that are private and not owned by the current user.
 * 5. We register a side effect that adds the 'private' and 'ownerId' meta fields to each shape created. We set the 'private' field to the current value of the private drawing mode atom.
 * 6. We register a side effect that cleans up the selection by removing any hidden shapes from the selection. This re-runs whenever the selection or the hidden state of a selected shape changes.
 * 7. Child shapes (e.g inside groups and frames) do not inherit the 'private' meta property from their parent. So when making a shape public, we decide to also make all descendant shapes public since this is most likely what the user intended.
 */
```

## Toggle.tsx

```tsx
export function Toggle({ isChecked }: { isChecked: boolean }) {
	const height = 20
	const width = 40
	const pillSize = height - 4
	return (
		<div
			style={{
				cursor: 'pointer',
				width,
				height,
				borderRadius: height / 2,
				backgroundColor: isChecked ? '#4bb05e' : '#999',
				display: 'flex',
				alignItems: 'center',
				justifyContent: isChecked ? 'flex-end' : 'flex-start',
				padding: 2,
			}}
		>
			{isChecked && (
				<div
					style={{ fontSize: 9, fontWeight: 600, color: 'white', position: 'relative', left: -3 }}
				>
					ON
				</div>
			)}
			<div
				style={{
					width: pillSize,
					height: pillSize,
					borderRadius: pillSize / 2,
					backgroundColor: 'white',
				}}
			/>
			{!isChecked && (
				<div
					style={{ fontSize: 9, fontWeight: 600, color: 'white', position: 'relative', right: -1 }}
				>
					OFF
				</div>
			)}
		</div>
	)
}
```

## style.css

```css
.toggle-panel {
	position: absolute;
	top: 10px;
	left: 50%;
	transform: translateX(-50%);
	border-radius: 8px;
	background: #efefef;
	box-shadow:
		0 0 0 1px rgba(0, 0, 0, 0.1),
		0 4px 8px rgba(0, 0, 0, 0.1);
	padding: 9px 10px 9px 15px;
	display: flex;
	align-items: center;
	gap: 10px;
}

.toggle-panel button {
	cursor: pointer;
}

.toggle-panel.pointer {
	cursor: pointer;
}
```

--------

# Manually update user presence

Category: Collaboration

Keywords: cursor

Manually show other users editing the same document.

Here, we add fake `InstancePresence` records to the store to simulate other users. If you have your own presence system, you could add real records to the store in the same way.

## App.tsx

```tsx
import { useRef } from 'react'
import { InstancePresenceRecordType, Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

// [1]
const USER_NAME = 'huppy da arrow'
const MOVING_CURSOR_SPEED = 0.25 // 0 is stopped, 1 is full send
const MOVING_CURSOR_RADIUS = 100
const CURSOR_CHAT_MESSAGE = 'Hey, I think this is just great.'

// [2]
export default function UserPresenceExample() {
	const rRaf = useRef<any>(-1)
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="user-presence-example"
				onMount={(editor) => {
					// [a]
					const peerPresence = InstancePresenceRecordType.create({
						id: InstancePresenceRecordType.createId(editor.store.id),
						currentPageId: editor.getCurrentPageId(),
						userId: 'peer-1',
						userName: USER_NAME,
						cursor: { x: 0, y: 0, type: 'default', rotation: 0 },
						chatMessage: CURSOR_CHAT_MESSAGE,
					})

					editor.store.mergeRemoteChanges(() => {
						editor.store.put([peerPresence])
					})

					// [b]
					const raf = rRaf.current
					cancelAnimationFrame(raf)

					if (MOVING_CURSOR_SPEED > 0 || CURSOR_CHAT_MESSAGE) {
						function loop() {
							let cursor = peerPresence.cursor
							if (!cursor) return
							let chatMessage = peerPresence.chatMessage

							const now = Date.now()

							if (MOVING_CURSOR_SPEED > 0) {
								const k = 1000 / MOVING_CURSOR_SPEED
								const t = (now % k) / k

								cursor = {
									...cursor,
									x: 150 + Math.cos(t * Math.PI * 2) * MOVING_CURSOR_RADIUS,
									y: 150 + Math.sin(t * Math.PI * 2) * MOVING_CURSOR_RADIUS,
								}
							}

							if (CURSOR_CHAT_MESSAGE) {
								const k = 1000
								const t = (now % (k * 3)) / k
								chatMessage =
									t < 1
										? ''
										: t > 2
											? CURSOR_CHAT_MESSAGE
											: CURSOR_CHAT_MESSAGE.slice(
													0,
													Math.ceil((t - 1) * CURSOR_CHAT_MESSAGE.length)
												)
							}

							editor.store.mergeRemoteChanges(() => {
								editor.store.put([
									{
										...peerPresence,
										cursor,
										chatMessage,
										lastActivityTimestamp: now,
									},
								])
							})

							rRaf.current = editor.timers.requestAnimationFrame(loop)
						}

						rRaf.current = editor.timers.requestAnimationFrame(loop)
					} else {
						editor.store.mergeRemoteChanges(() => {
							editor.store.put([{ ...peerPresence, lastActivityTimestamp: Date.now() }])
						})
						rRaf.current = editor.timers.setInterval(() => {
							editor.store.mergeRemoteChanges(() => {
								editor.store.put([{ ...peerPresence, lastActivityTimestamp: Date.now() }])
							})
						}, 1000)
					}
				}}
			/>
		</div>
	)
}

/*
This example shows how to add instance presence records to the store to show other users' cursors.
It is not an example of how to implement user presence, check out the collaboration examples for that:
https://tldraw.dev/examples/sync-demo

[1]
We're going to a fake a user's cursor and chat message, these are the values we'll use.

[2]
This is where we'll render the Tldraw component. We'll use the onMount callback to access the editor
instance.
	[a] For every connected peer we need to add an instance presence record to the store. We can do
		this using the InstancePresenceRecordType.create function and add it to the store using the
		store.put method.
	[b] We'll use the requestAnimationFrame function to update the cursor position and chat message.
		This is just for demonstration purposes.
*/
```

--------

# Persist to storage

Category: Data & assets

Keywords: store, snapshot, debounce

Manually persist the contents of the editor to storage.

In this example, we load the contents of the editor from your browser's `localStorage`, and save it there when you make changes.

## App.tsx

```tsx
import { throttle } from 'lodash'
import { useLayoutEffect, useMemo, useState } from 'react'
import { DefaultSpinner, Tldraw, createTLStore, getSnapshot, loadSnapshot } from 'tldraw'
import 'tldraw/tldraw.css'

// There's a guide at the bottom of this file!

const PERSISTENCE_KEY = 'example-3'

export default function PersistenceExample() {
	//[1]
	const store = useMemo(() => createTLStore(), [])
	//[2]
	const [loadingState, setLoadingState] = useState<
		{ status: 'loading' } | { status: 'ready' } | { status: 'error'; error: string }
	>({
		status: 'loading',
	})
	//[3]
	useLayoutEffect(() => {
		setLoadingState({ status: 'loading' })

		// Get persisted data from local storage
		const persistedSnapshot = localStorage.getItem(PERSISTENCE_KEY)

		if (persistedSnapshot) {
			try {
				const snapshot = JSON.parse(persistedSnapshot)
				loadSnapshot(store, snapshot)
				setLoadingState({ status: 'ready' })
			} catch (error: any) {
				setLoadingState({ status: 'error', error: error.message }) // Something went wrong
			}
		} else {
			setLoadingState({ status: 'ready' }) // Nothing persisted, continue with the empty store
		}

		// Each time the store changes, run the (debounced) persist function
		const cleanupFn = store.listen(
			throttle(() => {
				const snapshot = getSnapshot(store)
				localStorage.setItem(PERSISTENCE_KEY, JSON.stringify(snapshot))
			}, 500)
		)

		return () => {
			cleanupFn()
		}
	}, [store])

	// [4]
	if (loadingState.status === 'loading') {
		return (
			<div className="tldraw__editor">
				<h2>
					<DefaultSpinner />
				</h2>
			</div>
		)
	}

	if (loadingState.status === 'error') {
		return (
			<div className="tldraw__editor">
				<h2>Error!</h2>
				<p>{loadingState.error}</p>
			</div>
		)
	}

	return (
		<div className="tldraw__editor">
			<Tldraw store={store} />
		</div>
	)
}

/*
This example shows how to implement persistence in the Tldraw component. We do
this by saving the editor's state to local storage each time it changes. You
should replace this in your app with some sort of backend storage solution. If
you just want to save to local storage, you can use the `persistenceKey` prop
instead. Simply pass any string to this prop and the editor will automatically
save to local storage.

[1]
We create a new store using the `createTLStore` helper function. We pass in the
default shape utils so that the store knows how to handle the built-in shapes.

[2]
This is a cool pattern that uses Typescript to help keep track of our app's
loading state.

[3]
We use the `useLayoutEffect` hook to run our persistence code after the first
render. First we grab the persisted snapshot from local storage. If there is
one, we load it into the store and set the loading state to ready. If there
isn't one, we just set the loading state to ready.

Then we setup a listener on the store that will run our persistence code each
time the store changes. We use the `throttle` helper function to debounce the
listener so that it doesn't run too often. We also return a cleanup function
that will remove the listener when the component unmounts.

[4]
This is where we render our application depending on the loading state. If the
loading state is `loading`, we render a loading message. If the loading state
is `error`, we render an error message. If the loading state is `ready`, we
render the Tldraw component.
*/
```

--------

# Static assets

Category: Data & assets

Keywords: icons, fonts, pre-load

Use custom fonts, icons, and preload them using the `Tldraw` component.

The `Tldraw` component relies on static assets for fonts and icons. These must be pre-loaded in order that the component runs properly.

## App.tsx

```tsx
import { Tldraw, TldrawProps } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const assetUrls: TldrawProps['assetUrls'] = {
	fonts: {
		tldraw_draw: '/ComicMono.woff',
	},
	icons: {
		'tool-arrow': '/custom-arrow-icon.svg',
	},
}

export default function StaticAssetsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="static-assets" assetUrls={assetUrls} />
		</div>
	)
}

/**
[1]
By default, the Tldraw component will pull in assets from tldraw's asset CDN.
You can override this behavior by providing your own asset URLs. These URLs can
be relative or absolute URLs.

In this case, we are using a relative URL to a custom arrow icon and a custom font.
Because this is a Vite project, these files are stored in this project's public folder.
Check your framework documentation for how to serve static assets.

Important! This object needs to be created outside of a React component, or else
memoized using a useMemo hook, otherwise it will cause the Tldraw component to
receive a new `asserUrls` object every time the component re-renders.

```tsx

export default function StaticAssetsExample() {
	const assetUrls = useMemo<TldrawProps['assetUrls']>(() => ({
		fonts: {
			tldraw_draw: '/ComicMono.woff',
		},
		icons: {
			'tool-arrow': '/custom-arrow-icon.svg',
		},
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="static-assets" assetUrls={assetUrls} />
		</div>
	)
}
```
*/
```

--------

# Export canvas as image

Category: Data & assets

Keywords: basic, assets, svg, png, blob

Export the entire canvas as an image file.

This example shows how you can use the `Editor.toImage()` function to create an image of all shapes on the canvas and then download it. The easiest way to download an image is to use the download attribute of a link element.

## App.tsx

```tsx
import { Tldraw, TLUiComponents, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

function ExportCanvasButton() {
	const editor = useEditor()
	return (
		<button
			style={{ pointerEvents: 'all', fontSize: 18, backgroundColor: 'thistle' }}
			onClick={async () => {
				const shapeIds = editor.getCurrentPageShapeIds()
				if (shapeIds.size === 0) return alert('No shapes on the canvas')
				const { blob } = await editor.toImage([...shapeIds], { format: 'png', background: false })

				const link = document.createElement('a')
				link.href = URL.createObjectURL(blob)
				link.download = 'every-shape-on-the-canvas.jpg'
				link.click()
				URL.revokeObjectURL(link.href)
			}}
		>
			Export canvas as image
		</button>
	)
}
const components: TLUiComponents = {
	SharePanel: ExportCanvasButton,
}
export default function ExportCanvasImageExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

/*
This example shows how you can use the `Editor.toImage()` function to create an image with all the shapes
on the canvas in it and then download it. The easiest way to download an image is to use the download
attribute of a link element.

To learn more about overriding UI you can check out our various custom menu examples. For more on handling
assets, check out our Local/Hosted images examples.
*/
```

--------

# Export canvas as image (with settings)

Category: Data & assets

Keywords: basic, assets, svg, png, blob, image, settings

Export the entire canvas as an image file, with configurable settings.

This example shows how you can use the `Editor.toImage()` function to create an image of all shapes on the canvas and then download it. It also shows options for the different settings you can pass to the `toImage` function.

## App.tsx

```tsx
import { useState } from 'react'
import { Box, Tldraw, TLImageExportOptions, TLUiComponents, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'

const components: TLUiComponents = {
	SharePanel: ExportCanvasButton,
}

export default function ExportCanvasImageExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw components={components} />
		</div>
	)
}

function ExportCanvasButton() {
	const editor = useEditor()

	// [1]
	const [opts, setOpts] = useState<TLImageExportOptions>({
		scale: 1,
		background: false,
		padding: editor.options.defaultSvgPadding,
	})

	// [2]
	const [box, setBox] = useState({ x: 0, y: 0, w: 0, h: 0 })

	return (
		<div
			style={{
				pointerEvents: 'all',
				border: '1px solid black',
				borderRadius: 5,
				padding: 12,
				position: 'absolute',
				display: 'flex',
				flexDirection: 'column',
				right: 164,
				top: 8,
			}}
		>
			<div
				style={{
					display: 'grid',
					gridTemplateColumns: '1fr auto',
					gridAutoFlow: 'row',
					rowGap: 4,
					columnGap: 16,
				}}
			>
				<Control
					type="checkbox"
					name="background"
					checked={opts.background}
					onChange={(e) => {
						setOpts({ ...opts, background: e.target.checked })
					}}
				/>
				<Control
					type="checkbox"
					name="darkmode"
					checked={opts.darkMode}
					onChange={(e) => {
						setOpts({ ...opts, darkMode: e.target.checked })
					}}
				/>
				<Control
					type="number"
					name="padding"
					value={opts.padding}
					onChange={(e) => {
						setOpts({ ...opts, padding: Math.ceil(Number(e.target.value)) })
					}}
				/>
				<Control
					type="number"
					name="scale"
					value={opts.scale}
					onChange={(e) => {
						setOpts({ ...opts, scale: Math.ceil(Number(e.target.value)) })
					}}
				/>
				<p style={{ gridColumn: '1 / span 2' }}>Box</p>
				{['x', 'y', 'w', 'h'].map((key) => (
					<div key={key} style={{ display: 'flex', gap: 4 }}>
						<Control
							type="number"
							name={key}
							value={box[key as keyof typeof box]}
							onChange={(event) => {
								setBox({
									...box,
									[key]: Math.ceil(Number(event.target.value)),
								})
							}}
						/>
					</div>
				))}
			</div>
			<button
				style={{ pointerEvents: 'all', marginTop: 16 }}
				onClick={async () => {
					const shapeIds = editor.getCurrentPageShapeIds()
					if (shapeIds.size === 0) return alert('No shapes on the canvas')

					const { blob } = await editor.toImage([...shapeIds], {
						format: 'png',
						...opts,
						// If we have numbers for all of the box values, we can use them as bounds
						bounds: Object.values(box).every((b) => !Number.isNaN(b))
							? new Box(box.x, box.y, box.w, box.h)
							: undefined,
					})

					const link = document.createElement('a')
					link.href = window.URL.createObjectURL(blob)
					link.download = 'every-shape-on-the-canvas.jpg'
					link.click()
				}}
			>
				Export canvas as image
			</button>
		</div>
	)
}

const Control = ({
	name,
	type,
	value,
	checked,
	onChange,
}: {
	name: string
	type?: React.HTMLInputTypeAttribute
	value?: string | number | readonly string[]
	checked?: boolean
	onChange?: React.ChangeEventHandler<HTMLInputElement>
}) => {
	return (
		<>
			<label htmlFor={`opt-${name}`} style={{ flexGrow: 2 }}>
				{name}
			</label>
			<input
				id={`opt-${name}`}
				name={name}
				type={type}
				style={{ maxWidth: 64, justifySelf: 'flex-end' }}
				value={value ?? ''}
				checked={!!checked}
				onChange={onChange}
			/>
		</>
	)
}

/*
This example shows how you can use the image export settings in tldraw when generating an image.

1.
These are our defaults, though the rest of export / copy features use the user preferences,
e.g. editor.user.getIsDarkMode() for whether the user has enabled dark mode or not. But if
you're calling the image functions yourself, you can provide whatever options you wish.

2.
The bounding box is an optional argument that you can use to export a specific part of the canvas
or selection.
*/
```

--------

# Hosted images

Category: Data & assets

Keywords: assets, video, image, png, jpg, file

How to handle images uploaded by the user.

This example shows how to handle images uploaded by the user. To do this we'll need to
create a `TLAssetStore`, which tells the editor how to handle uploaded assets.

## App.tsx

```tsx
import { TLAssetStore, Tldraw, uniqueId } from 'tldraw'
import 'tldraw/tldraw.css'

// [1]
const UPLOAD_URL = '/SOME_ENDPOINT'

// [2]
const myAssetStore: TLAssetStore = {
	// [a]
	async upload(asset, file) {
		const id = uniqueId()

		const objectName = `${id}-${file.name}`.replaceAll(/\W/g, '-')
		const url = `${UPLOAD_URL}/${objectName}`

		await fetch(url, {
			method: 'POST',
			body: file,
		})

		return { src: url }
	},

	// [b]
	resolve(asset) {
		return asset.props.src
	},
}

// [3]
export default function HostedImagesExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw assets={myAssetStore} />
		</div>
	)
}
/*

Introduction: This example shows how to handle images uploaded by the user. to do this we'll need to
create a TLAssetStore, which tells the editor how to handle uploaded assets.

[1] You'll want to have an endpoint on your server that accepts file uploads, and returns URLs.

[2] We define our asset store, which has two methods: upload for saving assets, and resolve for
retrieving them.

    [a] The upload method is called when the user creates a file. It should take a `File` object,
    and return a URL that can be used to reference the file in the future.

    [b] After the file has been uploaded, whenever we want to refer to it again the editor will
    call the `resolve` method with the asset. Here, we just do the default and return the `src`
    prop. If you wanted to, you could return a different URL - for example, to serve optimized
    images, or to add an authentication token. The implementation here is the default, and could
	have been omitted.

[3] Finally, we have our actual instance. We pass our asset store to the `assets` prop of the
`Tldraw` component so it becomes part of the store.

*/
```

--------

# Custom paste behavior

Category: Data & assets

Keywords:

Change how pasting works by registering an external content handler.

This example adds a special rule for pasting single frame shapes, so they'll try to find an empty space instead of always pasting in the location they were copied from.

## App.tsx

```tsx
import {
	defaultHandleExternalTldrawContent,
	Editor,
	Tldraw,
	TLFrameShape,
	TLTldrawExternalContent,
} from 'tldraw'

// this example adds special behavior when pasting a single frame shape, matching the behavior of figma
export default function CustomPasteExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				onMount={(editor) => {
					// on mount, override the default tldraw handler
					editor.registerExternalContentHandler('tldraw', (content) =>
						handleCustomTldrawPaste(editor, content)
					)
				}}
			/>
		</div>
	)
}

const SPACING_BETWEEN_FRAMES = 50

function handleCustomTldrawPaste(editor: Editor, { content, point }: TLTldrawExternalContent) {
	// find the only shape in the pasted content
	const onlyCopiedShape =
		content.rootShapeIds.length === 1
			? content.shapes.find((shape) => shape.id === content.rootShapeIds[0])
			: null

	// make sure that the shape is a frame. if it is, retrieve the current version of that frame
	// from the document.
	const onlyCopiedFrame =
		onlyCopiedShape?.type === 'frame' ? (onlyCopiedShape as TLFrameShape) : null

	// we only want to use our special behavior if the frame (current & pasted) will be a direct
	// descendant of the current page.
	const willPasteOnCurrentPage = onlyCopiedFrame
		? !editor.getShape(onlyCopiedFrame.parentId)
		: false

	// if the paste is happening at a specific point, or we didn't copy a single frame that belongs
	// to this page, fall back to the default paste behavior
	if (point || !onlyCopiedFrame || !willPasteOnCurrentPage) {
		defaultHandleExternalTldrawContent(editor, { content, point })
		return
	}

	// if we are pasting a single frame, and that frame is still in the document, we want to find a
	// free space to the right of the frame to put this one.
	editor.putContentOntoCurrentPage(content, { select: true })
	const newlyPastedFrame = editor.getOnlySelectedShape()
	if (!newlyPastedFrame || !editor.isShapeOfType(newlyPastedFrame, 'frame')) return

	const siblingIds = editor.getSortedChildIdsForParent(newlyPastedFrame.parentId)
	const pastedBounds = editor.getShapePageBounds(newlyPastedFrame.id)!
	let targetPosition = pastedBounds.minX

	const siblingBounds = siblingIds
		.map((id) => ({ id, bounds: editor.getShapePageBounds(id)! }))
		.sort((a, b) => a.bounds.minX - b.bounds.minX)

	for (const sibling of siblingBounds) {
		if (sibling.id === newlyPastedFrame.id) continue

		// if this sibling is above or below the copied frame, we don't need to take it into account
		if (sibling.bounds.minY > pastedBounds.maxY || sibling.bounds.maxY < pastedBounds.minY) continue

		// if the sibling is to the left of the copied frame, we don't need to take it into account
		if (sibling.bounds.maxX < targetPosition) continue

		// if the sibling is to the right of where the pasted frame would end up, we don't care about it
		if (sibling.bounds.minX > targetPosition + pastedBounds.w) continue

		// otherwise, we need to shift our target right edge to the right of this sibling
		targetPosition = sibling.bounds.maxX + SPACING_BETWEEN_FRAMES
	}

	// translate the pasted frame into position:
	editor.nudgeShapes([newlyPastedFrame.id], {
		x: targetPosition - pastedBounds.minX,
		y: 0,
	})
}
```

--------

# External content sources

Category: Data & assets

Keywords: copy, paste, html

Handle different types of content when pasting into tldraw.

In this example, we register a special handler for when the user pastes in `'text/html'` content. We add it to a special shape type that renders the HTML content directly. Try copying and pasting some code from a VSCode file.

## App.tsx

```tsx
import { useCallback } from 'react'
import {
	BaseBoxShapeUtil,
	defaultHandleExternalTextContent,
	Editor,
	HTMLContainer,
	Tldraw,
	TLShape,
} from 'tldraw'
import 'tldraw/tldraw.css'

const DANGEROUS_HTML_TYPE = 'dangerous-html'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[DANGEROUS_HTML_TYPE]: { w: number; h: number; html: string }
	}
}

// There's a guide at the bottom of this page!

// [1]
export type IDangerousHtmlShape = TLShape<typeof DANGEROUS_HTML_TYPE>

// [2]
class DangerousHtmlExample extends BaseBoxShapeUtil<IDangerousHtmlShape> {
	static override type = DANGEROUS_HTML_TYPE

	override getDefaultProps() {
		return {
			w: 500,
			h: 300,
			html: '<div>hello</div>',
		}
	}

	override component(shape: IDangerousHtmlShape) {
		return (
			<HTMLContainer style={{ overflow: 'auto' }}>
				<div dangerouslySetInnerHTML={{ __html: shape.props.html }}></div>
			</HTMLContainer>
		)
	}

	override indicator(shape: IDangerousHtmlShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}

// [3]

export default function ExternalContentSourcesExample() {
	const handleMount = useCallback((editor: Editor) => {
		// We will register a new handler for text content. When a user pastes `text/html` content into the editor,
		// we will create a new shape with that html content.
		// To test this copy some html content from VS Code or some other text editor.
		editor.registerExternalContentHandler('text', async (content) => {
			const htmlSource = content.sources?.find((s) => s.type === 'text' && s.subtype === 'html')

			if (htmlSource) {
				const center = content.point ?? editor.getViewportPageBounds().center

				editor.createShape({
					type: 'dangerous-html',
					x: center.x - 250,
					y: center.y - 150,
					props: {
						html: htmlSource.data,
					},
				})
			} else {
				// otherwise, we'll fall back to the default handler
				await defaultHandleExternalTextContent(editor, content)
			}
		})
	}, [])

	return (
		<div className="tldraw__editor">
			<Tldraw onMount={handleMount} shapeUtils={[DangerousHtmlExample]} />
		</div>
	)
}

/*
Introduction:
This example shows how to handle content pasted from external sources, this could be
embeds, files, svgs, text, images, or urls. In this case we will handle text/html content.

[1]
We want to render our html on the canvas, the best way to do that is to create a new shape util.
Here's where we define the type for our shape.

[2]
This is our shape util. It's a class that extends BaseBoxShapeUtil. For a more detailed
example of how to create a custom shape, see the custom config example.

[3]
We use the onMount prop to get access to the editor instance via
the handleMount callback (check out the API example for a more detailed look at this). Then we
call the registerExternalContentHandler method, we could choose to handle embeds, files, svgs,
text, images, or urls. For this example we will handle text/html content. The handler is called
with the point where the user pasted the content and an array of sources. We will find and
return the html source, then create a new shape with that html content.

*/
```

--------

# Meta migrations

Category: Data & assets

Keywords: records, snapshot, sequence

Create custom migrations for `meta` properties.

You can add arbitrary data migrations for tldraw snapshot data. This is mainly useful for updating the `meta` property of a record as your data types evolve.

## App.tsx

```tsx
import { Tldraw, createMigrationIds, createMigrationSequence } from 'tldraw'
import 'tldraw/tldraw.css'
import { snapshot } from './snapshot'
import { components } from './ui-overrides'

/**
 * This example demonstrates how to add custom migrations for `meta` properties, or any other
 * data in your store snapshots.
 *
 * If you have a custom shape type and you want to add migrations for its `props` object,
 * there is a simpler dedicated API for that. Check out [the docs](https://tldraw.dev/docs/persistence#Shape-props-migrations) for more info.
 */

/**
 * Let's say you added some page metadata, e.g. to allow setting the background color of a page independently.
 */
interface _PageMetaV1 {
	backgroundTheme?: 'red' | 'blue' | 'green' | 'purple'
}

/**
 * And then perhaps later on you decided to remove support for 'purple' because it's an ugly color.
 * So all purple pages will become blue.
 */
export interface PageMetaV2 {
	backgroundTheme?: 'red' | 'blue' | 'green'
}

/**
 * You would then create a migration to update the metadata from v1 to v2.
 */

// First pick a 'sequence id' that is unique to your app
const sequenceId = 'com.example.my-app'
// Then create a 'migration id' for each version of your metadata
const versions = createMigrationIds(sequenceId, {
	// the numbers must start at 1 and increment by 1
	RemovePurple: 1,
})
const migrations = createMigrationSequence({
	sequenceId,
	sequence: [
		{
			id: versions.RemovePurple,
			// `scope: 'record` tells the schema to call this migration on individual records.
			// `scope: 'storage'` would pass a storage object with get/set/delete methods, to allow for actions like deleting/creating records.
			scope: 'record',
			// When `scope` is 'record', you can specify a filter function to only apply the migration to records that match the filter.
			filter: (record) => record.typeName === 'page',
			// This up function will be called on all records that match the filter
			up(page: any) {
				if (page.meta.backgroundTheme === 'purple') {
					page.meta.backgroundTheme = 'blue'
					page.name += ' (was purple)'
				}
			},
		},
	],
})

export default function MetaMigrationsExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw
				// Pass in the custom migrations
				migrations={[migrations]}
				// When you load a snapshot from a previous version, the migrations will be applied automatically
				snapshot={snapshot}
				// This adds a dropdown to the canvas for changing the backgroundTheme property
				components={components}
			/>
		</div>
	)
}
```

## snapshot.ts

```ts
import { TLStoreSnapshot } from 'tldraw'

export const snapshot = {
	store: {
		'document:document': {
			gridSize: 10,
			name: '',
			meta: {},
			id: 'document:document',
			typeName: 'document',
		},
		'page:red': {
			meta: {
				backgroundTheme: 'red',
			},
			id: 'page:red',
			name: 'Red',
			index: 'a1',
			typeName: 'page',
		},
		'page:green': {
			meta: {
				backgroundTheme: 'green',
			},
			id: 'page:green',
			name: 'Green',
			index: 'a2',
			typeName: 'page',
		},
		'page:blue': {
			meta: {
				backgroundTheme: 'blue',
			},
			id: 'page:blue',
			name: 'Blue',
			index: 'a3',
			typeName: 'page',
		},
		'page:purple': {
			meta: {
				backgroundTheme: 'purple',
			},
			id: 'page:purple',
			name: 'Purple',
			index: 'a0',
			typeName: 'page',
		},
	},
	schema: {
		schemaVersion: 2,
		sequences: {
			'com.tldraw.store': 4,
			'com.tldraw.document': 2,
			'com.tldraw.page': 1,
		},
	},
} as TLStoreSnapshot
```

## ui-overrides.tsx

```tsx
import { useLayoutEffect } from 'react'
import { TLComponents, track, useEditor } from 'tldraw'
import { PageMetaV2 } from './MetaMigrations'

export const components: TLComponents = {
	TopPanel: track(() => {
		const editor = useEditor()
		const currentPage = editor.getCurrentPage()
		const meta: PageMetaV2 = currentPage.meta

		useLayoutEffect(() => {
			const elem = document.querySelector('.tl-background') as HTMLElement
			if (!elem) return
			elem.style.backgroundColor = meta.backgroundTheme ?? 'unset'
		}, [meta.backgroundTheme])

		return (
			<span style={{ pointerEvents: 'all', padding: '5px 15px', margin: 10, fontSize: 18 }}>
				bg: &nbsp;
				<select
					value={meta.backgroundTheme ?? 'none'}
					onChange={(e) => {
						if (e.currentTarget.value === 'none') {
							editor.updatePage({ ...currentPage, meta: {} })
						} else {
							editor.updatePage({
								...currentPage,
								meta: { backgroundTheme: e.currentTarget.value },
							})
						}
					}}
				>
					<option value="none">None</option>
					<option value="red">Red</option>
					<option value="blue">Blue</option>
					<option value="green">Green</option>
				</select>
			</span>
		)
	}),
}
```

--------

# Slideshow (fixed camera)

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll, slides, presentation

A simple slideshow app with a fixed camera.

This example shows one way of making a simple slideshow app with a fixed camera, using camera options.

## App.tsx

```tsx
import { useEffect, useState } from 'react'
import { Editor, TLFrameShape, Tldraw, createShapeId, transact, useEditor, useValue } from 'tldraw'
import 'tldraw/tldraw.css'
import { SLIDE_MARGIN, SLIDE_SIZE, SlidesProvider, useSlides } from './SlidesManager'

export default function SlideShowExample() {
	return (
		<div className="tldraw__editor">
			<SlidesProvider>
				<InsideSlidesContext />
			</SlidesProvider>
		</div>
	)
}

function InsideSlidesContext() {
	const [editor, setEditor] = useState<Editor | null>(null)
	const slides = useSlides()

	const currentSlide = useValue('currentSlide', () => slides.getCurrentSlide(), [slides])

	useEffect(() => {
		if (!editor) return

		const nextBounds = {
			x: currentSlide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
			y: 0,
			w: SLIDE_SIZE.w,
			h: SLIDE_SIZE.h,
		}

		editor.setCameraOptions({
			constraints: {
				bounds: nextBounds,
				behavior: 'contain',
				initialZoom: 'fit-max',
				baseZoom: 'fit-max',
				origin: { x: 0.5, y: 0.5 },
				padding: { x: 50, y: 50 },
			},
		})

		editor.zoomToBounds(nextBounds, { force: true, animation: { duration: 500 } })
	}, [editor, currentSlide])

	const currentSlides = useValue('slides', () => slides.getCurrentSlides(), [slides])

	useEffect(() => {
		if (!editor) return

		const ids = currentSlides.map((slide) => createShapeId(slide.id))

		transact(() => {
			for (let i = 0; i < currentSlides.length; i++) {
				const shapeId = ids[i]
				const slide = currentSlides[i]
				const shape = editor.getShape(shapeId)
				if (shape) {
					if (shape.x === slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN)) continue

					// if name is still Slide and number, e.g Slide 1, update it. Use regex to test

					const regex = /Slide \d+/
					let name = (shape as TLFrameShape).props.name
					if (regex.test((shape as TLFrameShape).props.name)) {
						name = `Slide ${slide.index + 1}`
					}

					editor.updateShape({
						id: shapeId,
						type: 'frame',
						x: slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
						props: {
							name,
						},
					})
				} else {
					editor.createShape({
						id: shapeId,
						parentId: editor.getCurrentPageId(),
						type: 'frame',
						x: slide.index * (SLIDE_SIZE.w + SLIDE_MARGIN),
						y: 0,
						props: {
							name: `Slide ${slide.index + 1}`,
							w: SLIDE_SIZE.w,
							h: SLIDE_SIZE.h,
						},
					})
				}
			}
		})

		const unsubs: (() => void)[] = []

		unsubs.push(
			editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
				if (
					ids.includes(next.id) &&
					(next as TLFrameShape).props.name === (prev as TLFrameShape).props.name
				)
					return prev
				return next
			})
		)

		unsubs.push(
			editor.sideEffects.registerBeforeChangeHandler('instance_page_state', (prev, next) => {
				next.selectedShapeIds = next.selectedShapeIds.filter((id) => !ids.includes(id))
				if (next.hoveredShapeId && ids.includes(next.hoveredShapeId)) next.hoveredShapeId = null
				return next
			})
		)

		return () => {
			unsubs.forEach((fn) => fn())
		}
	}, [currentSlides, editor])

	const handleMount = (editor: Editor) => {
		setEditor(editor)
	}

	return <Tldraw onMount={handleMount} components={components} />
}

function Slides() {
	const editor = useEditor()
	const slides = useSlides()
	const currentSlides = useValue('slides', () => slides.getCurrentSlides(), [slides])
	const lowestIndex = currentSlides[0].index
	const highestIndex = currentSlides[currentSlides.length - 1].index

	return (
		<>
			{/* {currentSlides.map((slide) => (
				<div
					key={slide.id}
					style={{
						position: 'absolute',
						top: 0,
						left: (SLIDE_SIZE.w + SLIDE_MARGIN) * slide.index,
						width: SLIDE_SIZE.w,
						height: SLIDE_SIZE.h,
						backgroundColor: 'white',
						border: '1px solid black',
						pointerEvents: 'all',
					}}
					onPointerDown={(e) => {
						if (slide.id !== slides.getCurrentSlideId()) {
							markEventAsHandled(e)
							slides.setCurrentSlide(slide.id)
						}
					}}
				/>
			))} */}
			{currentSlides.slice(0, -1).map((slide) => (
				<button
					key={slide.id + 'between'}
					style={{
						position: 'absolute',
						top: SLIDE_SIZE.h / 2,
						left: (slide.index + 1) * (SLIDE_SIZE.w + SLIDE_MARGIN) - (SLIDE_MARGIN + 40) / 2,
						width: 40,
						height: 40,
						pointerEvents: 'all',
					}}
					onPointerDown={editor.markEventAsHandled}
					onClick={() => {
						const newSlide = slides.newSlide(slide.index + 1)
						slides.setCurrentSlide(newSlide.id)
					}}
				>
					|
				</button>
			))}
			<button
				style={{
					position: 'absolute',
					top: SLIDE_SIZE.h / 2,
					left: lowestIndex * (SLIDE_SIZE.w + SLIDE_MARGIN) - (40 + SLIDE_MARGIN * 0.1),
					width: 40,
					height: 40,
					pointerEvents: 'all',
				}}
				onPointerDown={editor.markEventAsHandled}
				onClick={() => {
					const slide = slides.newSlide(lowestIndex - 1)
					slides.setCurrentSlide(slide.id)
				}}
			>
				{`+`}
			</button>
			<button
				style={{
					position: 'absolute',
					top: SLIDE_SIZE.h / 2,
					left: highestIndex * (SLIDE_SIZE.w + SLIDE_MARGIN) + (SLIDE_SIZE.w + SLIDE_MARGIN * 0.1),
					width: 40,
					height: 40,
					pointerEvents: 'all',
				}}
				onPointerDown={editor.markEventAsHandled}
				onClick={() => {
					const slide = slides.newSlide(highestIndex + 1)
					slides.setCurrentSlide(slide.id)
				}}
			>
				{`+`}
			</button>
		</>
	)
}

function SlideControls() {
	const slides = useSlides()
	const editor = useEditor()

	return (
		<>
			<button
				style={{
					pointerEvents: 'all',
					position: 'absolute',
					top: '50%',
					left: 0,
					width: 50,
					height: 50,
				}}
				onPointerDown={editor.markEventAsHandled}
				onClick={() => slides.prevSlide()}
			>
				{`<`}
			</button>
			<button
				style={{
					pointerEvents: 'all',
					position: 'absolute',
					top: '50%',
					right: 0,
					width: 50,
					height: 50,
				}}
				onPointerDown={editor.markEventAsHandled}
				onClick={() => slides.nextSlide()}
			>
				{`>`}
			</button>
		</>
	)
}

const components = {
	OnTheCanvas: Slides,
	InFrontOfTheCanvas: SlideControls,
}
```

## SlidesManager.tsx

```tsx
import { createContext, ReactNode, useContext, useState } from 'react'
import { atom, computed, structuredClone, uniqueId } from 'tldraw'

export const SLIDE_SIZE = { x: 0, y: 0, w: 1600, h: 900 }
export const SLIDE_MARGIN = 100

interface Slide {
	id: string
	index: number
	name: string
}

class SlidesManager {
	private _slides = atom<Slide[]>('slide', [
		{
			id: '1',
			index: 0,
			name: 'Slide 1',
		},
		{
			id: '2',
			index: 1,
			name: 'Slide 2',
		},
		{
			id: '3',
			index: 2,
			name: 'Slide 3',
		},
	])

	@computed getCurrentSlides() {
		return this._slides.get().sort((a, b) => (a.index < b.index ? -1 : 1))
	}

	private _currentSlideId = atom('currentSlide', '1')

	@computed getCurrentSlideId() {
		return this._currentSlideId.get()
	}

	@computed getCurrentSlide() {
		return this._slides.get().find((slide) => slide.id === this.getCurrentSlideId())!
	}

	setCurrentSlide(id: string) {
		this._currentSlideId.set(id)
	}

	moveBy(delta: number) {
		const slides = this.getCurrentSlides()
		const currentIndex = slides.findIndex((slide) => slide.id === this.getCurrentSlideId())
		const next = slides[currentIndex + delta]
		if (!next) return
		this._currentSlideId.set(next.id)
	}

	nextSlide() {
		this.moveBy(1)
	}

	prevSlide() {
		this.moveBy(-1)
	}

	newSlide(index: number) {
		const slides = structuredClone(this.getCurrentSlides())

		let bumping = false
		for (const slide of slides) {
			if (slide.index === index) {
				bumping = true
			}
			if (bumping) {
				slide.index++
			}
		}

		const newSlide = {
			id: uniqueId(),
			index,
			name: `Slide ${slides.length + 1}`,
		}

		this._slides.set([...slides, newSlide])

		return newSlide
	}
}

const slidesContext = createContext({} as SlidesManager)

export const SlidesProvider = ({ children }: { children: ReactNode }) => {
	const [slideManager] = useState(() => new SlidesManager())
	return <slidesContext.Provider value={slideManager}>{children}</slidesContext.Provider>
}

export function useSlides() {
	return useContext(slidesContext)
}
```

--------

# Slideshow (free camera)

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll, slides, presentation

A simple slideshow app with a moving camera.

This example shows one way of making a simple slideshow app with a moving camera.

## App.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TLUiOverrides,
	Tldraw,
	TldrawUiMenuItem,
	computed,
	createShapeId,
	track,
	useIsToolSelected,
	useTools,
} from 'tldraw'
import 'tldraw/tldraw.css'
import { SlideShapeTool } from './SlideShapeTool'
import { SlideShapeUtil } from './SlideShapeUtil'
import { SlidesPanel } from './SlidesPanel'
import './slides.css'
import { $currentSlide, getSlides, moveToSlide } from './useSlides'

const components: TLComponents = {
	HelperButtons: SlidesPanel,
	Minimap: null,
	Toolbar: (props) => {
		const tools = useTools()
		const isSlideSelected = useIsToolSelected(tools['slide'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['slide']} isSelected={isSlideSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['slide']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

const overrides: TLUiOverrides = {
	actions(editor, actions) {
		const $slides = computed('slides', () => getSlides(editor))
		return {
			...actions,
			'next-slide': {
				id: 'next-slide',
				label: 'Next slide',
				kbd: 'right',
				onSelect() {
					const slides = $slides.get()
					const currentSlide = $currentSlide.get()
					const index = slides.findIndex((s) => s.id === currentSlide?.id)
					const nextSlide = slides[index + 1] ?? currentSlide ?? slides[0]
					if (nextSlide) {
						editor.stopCameraAnimation()
						moveToSlide(editor, nextSlide)
					}
				},
			},
			'previous-slide': {
				id: 'previous-slide',
				label: 'Previous slide',
				kbd: 'left',
				onSelect() {
					const slides = $slides.get()
					const currentSlide = $currentSlide.get()
					const index = slides.findIndex((s) => s.id === currentSlide?.id)
					const previousSlide = slides[index - 1] ?? currentSlide ?? slides[slides.length - 1]
					if (previousSlide) {
						editor.stopCameraAnimation()
						moveToSlide(editor, previousSlide)
					}
				},
			},
		}
	},
	tools(editor, tools) {
		tools.slide = {
			id: 'slide',
			icon: 'group',
			label: 'Slide',
			kbd: 's',
			onSelect: () => editor.setCurrentTool('slide'),
		}
		return tools
	},
}

const SlidesExample = track(() => {
	return (
		<div className="tldraw__editor">
			<Tldraw
				persistenceKey="slideshow_example"
				shapeUtils={[SlideShapeUtil]}
				tools={[SlideShapeTool]}
				components={components}
				overrides={overrides}
				onMount={(editor) => {
					const existingSlides = getSlides(editor)
					if (existingSlides.length === 0) {
						editor.createShape({
							id: createShapeId(),
							type: 'slide',
							x: 100,
							y: 100,
							props: { w: 720, h: 480 },
						})
						editor.createShape({
							id: createShapeId(),
							type: 'slide',
							x: 900,
							y: 100,
							props: { w: 720, h: 480 },
						})
					}
				}}
			/>
		</div>
	)
})

export default SlidesExample
```

## SlideShapeTool.tsx

```tsx
import { BaseBoxShapeTool } from 'tldraw'

export class SlideShapeTool extends BaseBoxShapeTool {
	static override id = 'slide'
	static override initial = 'idle'
	override shapeType = 'slide' as const
}
```

## SlideShapeUtil.tsx

```tsx
import { useCallback } from 'react'
import {
	Geometry2d,
	RecordProps,
	Rectangle2d,
	SVGContainer,
	ShapeUtil,
	T,
	TLResizeInfo,
	TLShape,
	getPerfectDashProps,
	resizeBox,
	useValue,
} from 'tldraw'
import { moveToSlide, useSlides } from './useSlides'

const SLIDE_TYPE = 'slide'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[SLIDE_TYPE]: {
			w: number
			h: number
		}
	}
}

export type SlideShape = TLShape<typeof SLIDE_TYPE>

export class SlideShapeUtil extends ShapeUtil<SlideShape> {
	static override type = SLIDE_TYPE
	static override props: RecordProps<SlideShape> = {
		w: T.number,
		h: T.number,
	}

	override canBind() {
		return false
	}
	override hideRotateHandle() {
		return true
	}

	getDefaultProps(): SlideShape['props'] {
		return {
			w: 720,
			h: 480,
		}
	}

	getGeometry(shape: SlideShape): Geometry2d {
		return new Rectangle2d({
			width: shape.props.w,
			height: shape.props.h,
			isFilled: false,
		})
	}

	override onRotate(initial: SlideShape) {
		return initial
	}

	override onResize(shape: SlideShape, info: TLResizeInfo<SlideShape>) {
		return resizeBox(shape, info)
	}

	override onDoubleClick(shape: SlideShape) {
		moveToSlide(this.editor, shape)
		this.editor.selectNone()
	}

	override onDoubleClickEdge(shape: SlideShape) {
		moveToSlide(this.editor, shape)
		this.editor.selectNone()
	}

	component(shape: SlideShape) {
		const bounds = this.editor.getShapeGeometry(shape).bounds

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const zoomLevel = useValue('zoom level', () => this.editor.getZoomLevel(), [this.editor])

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const slides = useSlides()
		const index = slides.findIndex((s) => s.id === shape.id)

		// eslint-disable-next-line react-hooks/rules-of-hooks
		const handleLabelPointerDown = useCallback(() => this.editor.select(shape.id), [shape.id])

		if (!bounds) return null

		return (
			<>
				<div onPointerDown={handleLabelPointerDown} className="slide-shape-label">
					{`Slide ${index + 1}`}
				</div>
				<SVGContainer>
					<g
						style={{
							stroke: 'var(--tl-color-text)',
							strokeWidth: 'calc(1px * var(--tl-scale))',
							opacity: 0.25,
						}}
						pointerEvents="none"
						strokeLinecap="round"
						strokeLinejoin="round"
					>
						{bounds.sides.map((side, i) => {
							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
								side[0].dist(side[1]),
								1 / zoomLevel,
								{
									style: 'dashed',
									lengthRatio: 6,
									forceSolid: zoomLevel < 0.2,
								}
							)

							return (
								<line
									key={i}
									x1={side[0].x}
									y1={side[0].y}
									x2={side[1].x}
									y2={side[1].y}
									strokeDasharray={strokeDasharray}
									strokeDashoffset={strokeDashoffset}
								/>
							)
						})}
					</g>
				</SVGContainer>
			</>
		)
	}

	indicator(shape: SlideShape) {
		return <rect width={shape.props.w} height={shape.props.h} />
	}
}
```

## SlidesPanel.tsx

```tsx
import { TldrawUiButton, track, useEditor, useValue } from 'tldraw'
import { moveToSlide, useCurrentSlide, useSlides } from './useSlides'

export const SlidesPanel = track(() => {
	const editor = useEditor()
	const slides = useSlides()
	const currentSlide = useCurrentSlide()
	const selectedShapes = useValue('selected shapes', () => editor.getSelectedShapes(), [editor])

	if (slides.length === 0) return null
	return (
		<div className="slides-panel scroll-light" onPointerDown={editor.markEventAsHandled}>
			{slides.map((slide, i) => {
				const isSelected = selectedShapes.includes(slide)
				return (
					<TldrawUiButton
						key={'slides-panel-button:' + slide.id}
						type="normal"
						className="slides-panel-button"
						onClick={() => moveToSlide(editor, slide)}
						style={{
							background:
								currentSlide?.id === slide.id ? 'var(--tl-color-background)' : 'transparent',
							outline: isSelected ? 'var(--tl-color-selection-stroke) solid 1.5px' : 'none',
						}}
					>
						{`Slide ${i + 1}`}
					</TldrawUiButton>
				)
			})}
		</div>
	)
})
```

## slides.css

```css
.slides-panel {
	display: flex;
	flex-direction: column;
	gap: 4px;
	max-height: calc(100% - 110px);
	margin: 50px 0px;
	padding: 4px;
	background-color: var(--tl-color-low);
	pointer-events: all;
	border-top-right-radius: var(--tl-radius-4);
	border-bottom-right-radius: var(--tl-radius-4);
	overflow: auto;
	border-right: 2px solid var(--tl-color-background);
	border-bottom: 2px solid var(--tl-color-background);
	border-top: 2px solid var(--tl-color-background);
}

.slides-panel-button {
	border-radius: var(--tl-radius-4);
	outline-offset: -1px;
}

.slide-shape-label {
	pointer-events: all;
	position: absolute;
	background: var(--tl-color-low);
	padding: calc(12px * var(--tl-scale));
	border-bottom-right-radius: calc(var(--tl-radius-4) * var(--tl-scale));
	font-size: calc(12px * var(--tl-scale));
	color: var(--tl-color-text);
	white-space: nowrap;
}
```

## useSlides.tsx

```tsx
import { EASINGS, Editor, atom, useEditor, useValue } from 'tldraw'
import { SlideShape } from './SlideShapeUtil'

export const $currentSlide = atom<SlideShape | null>('current slide', null)

export function moveToSlide(editor: Editor, slide: SlideShape) {
	const bounds = editor.getShapePageBounds(slide.id)
	if (!bounds) return
	$currentSlide.set(slide)
	editor.selectNone()
	editor.zoomToBounds(bounds, {
		inset: 0,
		animation: { duration: 500, easing: EASINGS.easeInOutCubic },
	})
}

export function useSlides() {
	const editor = useEditor()
	return useValue<SlideShape[]>('slide shapes', () => getSlides(editor), [editor])
}

export function useCurrentSlide() {
	return useValue($currentSlide)
}

export function getSlides(editor: Editor) {
	return editor
		.getSortedChildIdsForParent(editor.getCurrentPageId())
		.map((id) => editor.getShape(id))
		.filter((s) => s?.type === 'slide') as SlideShape[]
}
```

--------

# Education canvas

Category: Use cases

Keywords: education, math, geometry, GCSE, teaching, learning, canvas, fixed camera

An educational application template with a math question on the left and a drawing canvas on the right.

This example demonstrates how to create an educational application using tldraw. It features:

- **Split Layout**: Question panel on the left, drawing canvas on the right
- **Fixed Camera**: Canvas has constrained bounds to keep students focused on the drawing area
- **GCSE Math Question**: A geometry problem suitable for GCSE-level mathematics
- **Grid Background**: Coordinate grid to help with plotting points and shapes
- **Educational Styling**: Clean, professional styling suitable for educational environments

Perfect for creating interactive math worksheets, geometry exercises, or any educational content that requires visual problem-solving.

## App.tsx

```tsx
import { memo, useCallback, useEffect, useRef, useState } from 'react'
import { Box, Editor, TLCameraOptions, TLComponents, Tldraw, track, useEditor } from 'tldraw'
import 'tldraw/tldraw.css'
import './education-canvas.css'

// Fixed camera options to prevent zooming/panning
const CAMERA_OPTIONS: Partial<TLCameraOptions> = {
	isLocked: false,
	constraints: {
		initialZoom: 'fit-max',
		baseZoom: 'fit-max',
		bounds: {
			x: 0,
			y: 0,
			w: 600,
			h: 600,
		},
		behavior: { x: 'contain', y: 'contain' },
		padding: { x: 100, y: 100 },
		origin: { x: 0.5, y: 0.5 },
	},
}

const CameraSetup = track(() => {
	const editor = useEditor()

	useEffect(() => {
		if (!editor) return
		editor.run(() => {
			editor.zoomToBounds(new Box(0, 0, 600, 600), {
				inset: 150,
			})
			editor.setCameraOptions(CAMERA_OPTIONS)
			editor.setCamera(editor.getCamera(), {
				immediate: true,
			})
			// editor.updateInstanceState({
			// 	isGridMode: true,
			// })
		})
	}, [editor])

	return null
})

const TICKS = 8

const CartesianGrid = memo(function CartesianGrid() {
	return (
		<svg
			className="cartesian-grid"
			width="600"
			height="600"
			viewBox="0 0 600 600"
			stroke="#aaa"
			color="#aaa"
		>
			{Array.from({ length: TICKS * 2 + 1 }).map((_, i) => {
				const step = 600 / (TICKS * 2)
				const opacity = i === TICKS ? 1 : 0.16
				return (
					<g key={i + '_line'}>
						<line x1={0} y1={i * step} x2={600} y2={i * step} strokeWidth="1" opacity={opacity} />
						<line x1={i * step} y1={0} x2={i * step} y2={600} strokeWidth="1" opacity={opacity} />
					</g>
				)
			})}
			<g>
				{Array.from({ length: TICKS * 2 + 1 }).map((_, i) => {
					const index = i
					if (i - TICKS === 0) return null
					const y = 600 - index * (600 / (TICKS * 2))
					return (
						<g key={i + '_textx'}>
							<text
								key={index}
								x={312}
								y={y}
								dy="0.3em"
								fontFamily="Arial"
								textAnchor="start"
								letterSpacing=".25em"
								stroke="none"
								fill="#aaa"
								fontWeight="bold"
							>
								{-TICKS + index}
							</text>
							<line x1={295} y1={y} x2={305} y2={y} strokeWidth="2" />
						</g>
					)
				})}
				{Array.from({ length: TICKS * 2 + 1 }).map((_, i) => {
					const index = i
					if (i - TICKS === 0) return null
					const x = index * (600 / (TICKS * 2))
					return (
						<g key={i + '_texty'}>
							<text
								key={index}
								x={x}
								y={320}
								dy="0.3em"
								fontFamily="Arial"
								textAnchor="middle"
								stroke="none"
								fill="#aaa"
								fontWeight="bold"
							>
								{-TICKS + index}
							</text>
							<line x1={x} y1={295} x2={x} y2={305} strokeWidth="2" strokeLinecap="round" />
						</g>
					)
				})}
			</g>
		</svg>
	)
})

const components: TLComponents = {
	OnTheCanvas: CartesianGrid,
}

export default function EducationCanvasExample() {
	const [answers, setAnswers] = useState({
		partB: '',
		partC: '',
	})

	const handleAnswerChange = (part: keyof typeof answers, value: string) => {
		setAnswers((prev) => ({ ...prev, [part]: value }))
	}

	const rEditor = useRef<Editor | null>(null)
	const handleMount = useCallback((editor: Editor) => {
		rEditor.current = editor
	}, [])

	const handleSubmit = useCallback(async () => {
		// Normalize answers for comparison
		const normalizeAnswer = (answer: string) => {
			return answer.toLowerCase().replace(/[^a-z0-9(),.-]/g, '')
		}

		// Check Part B - Area (accept 8, 8 square units, 8 units², etc.)
		const normalizedB = normalizeAnswer(answers.partB)
		const isPartBCorrect =
			normalizedB.includes('8') &&
			(normalizedB.includes('square') || normalizedB.includes('unit') || normalizedB === '8')

		// Check Part C - Coordinates (accept (0,7), (0, 7), 0,7, etc.)
		const normalizedC = normalizeAnswer(answers.partC)
		const isPartCCorrect =
			normalizedC.includes('0') &&
			normalizedC.includes('7') &&
			(normalizedC.includes('(0,7)') ||
				normalizedC.includes('0,7') ||
				normalizedC.match(/0.*7/) ||
				normalizedC.match(/7.*0/))

		if (isPartBCorrect && isPartCCorrect) {
			alert('Good job! Both answers are correct!')
		} else if (isPartBCorrect || isPartCCorrect) {
			let message = 'Good progress! '
			if (isPartBCorrect) message += 'Part B is correct. '
			if (isPartCCorrect) message += 'Part C is correct. '
			if (!isPartBCorrect) message += 'Check your area calculation for Part B.'
			if (!isPartCCorrect) message += 'Check your coordinates for Part C.'
			alert(message)
		} else {
			alert('Please check your answers and try again.')
		}

		// Do something with the answers
		const editor = rEditor.current
		if (editor) {
			// For example, get the canvas content and the answers and send it to the server.
			// const result = {
			// 	answers: {
			// 		partA: await editor.toImage(editor.getCurrentPageShapes()),
			// 		partB: answers.partB,
			// 		partC: answers.partC,
			// 	},
			// }
			// console.log(result)
		}
	}, [answers])

	return (
		<div className="education-container">
			{/* Question Panel - Left Half */}
			<div className="question-panel">
				<div className="question-content">
					<h1 className="main-title">Mathematics - Geometry</h1>

					<div className="question-card">
						<h2 className="question-title">Question 1</h2>
						<p className="question-text">
							A triangle ABC has vertices at A(2, 3), B(6, 3), and C(4, 7).
						</p>

						<div className="question-part">
							<p className="question-text">
								<strong>Part A:</strong> Draw triangle ABC on the coordinate grid.
							</p>
						</div>

						<div className="question-part">
							<p className="question-text">
								<strong>Part B:</strong> Calculate the area of triangle ABC.
							</p>
							<div className="answer-input-group">
								<label className="answer-label">
									<strong>Answer:</strong>
								</label>
								<input
									type="text"
									className="answer-input"
									placeholder="Enter the area"
									value={answers.partB}
									onChange={(e) => handleAnswerChange('partB', e.target.value)}
								/>
							</div>
						</div>

						<div className="question-part">
							<p className="question-text">
								<strong>Part C:</strong> Find the coordinates of point D such that ABCD forms a
								parallelogram.
							</p>
							<div className="answer-input-group">
								<label className="answer-label">
									<strong>Answer:</strong>
								</label>
								<input
									type="text"
									className="answer-input"
									placeholder="Enter coordinates as (x, y)"
									value={answers.partC}
									onChange={(e) => handleAnswerChange('partC', e.target.value)}
								/>
							</div>
						</div>

						<button className="submit-button" onClick={handleSubmit}>
							Submit Answers
						</button>
					</div>

					<div className="instructions-card">
						<h3 className="instructions-title">Instructions:</h3>
						<ul className="instructions-list">
							<li>Use the drawing canvas on the right to sketch your solution</li>
							<li>
								You can use the draw tool <kbd>D</kbd> to draw points and the line tool <kbd>L</kbd>{' '}
								to draw lines
							</li>
							<li>
								Use the text tool <kbd>T</kbd> to label points and write calculations
							</li>
							<li>Show all your working clearly</li>
							<li>Enter your final answers in the answer boxes above</li>
						</ul>
					</div>
				</div>
			</div>

			{/* Canvas Panel - Right Half */}
			<div className="canvas-panel">
				<div className="canvas-container">
					<Tldraw
						options={{ maxPages: 1 }}
						persistenceKey="education-canvas"
						components={components}
						onMount={handleMount}
						overrides={{
							tools: (_editor, tools) => {
								// These are the tool ids that are allowed to be used in the education canvas...
								const allowedTools = ['select', 'hand', 'draw', 'eraser', 'line', 'text']
								// Tools are keyed by their id, so we can delete off all the tools that are not in the allowedTools array
								for (const key in tools) {
									if (!allowedTools.includes(key)) {
										delete tools[key]
									}
								}
								// Return the mutated tools
								return tools
							},
						}}
					>
						<CameraSetup />
					</Tldraw>
				</div>
			</div>
		</div>
	)
}
```

## education-canvas.css

```css
/* Education Canvas Example Styles */

.education-container {
	display: flex;
	min-height: 100vh;
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
	gap: 40px;
}

.question-panel {
	width: 100%;
	max-width: 500px;
	flex-shrink: 0;
	padding: 2rem;
	background-color: #f8fafc;
	border-right: 2px solid #e2e8f0;
	display: flex;
	flex-direction: column;
	justify-content: flex-start;
	overflow: auto;
}

.question-content {
	max-width: 500px;
}

.main-title {
	font-size: 1.5rem;
	font-weight: bold;
	margin-bottom: 1.5rem;
	color: #1e293b;
}

.question-card {
	background-color: white;
	padding: 1.5rem;
	border-radius: 8px;
	border: 1px solid #e2e8f0;
	margin-bottom: 1.5rem;
}

.question-title {
	font-size: 1.2rem;
	font-weight: 600;
	margin-bottom: 1rem;
	color: #374151;
}

.question-text {
	line-height: 1.6;
	margin-bottom: 1rem;
	color: #4b5563;
}

.question-text:last-child {
	margin-bottom: 0;
}

.instructions-card {
	background-color: #e0f2fe;
	padding: 1rem;
	border-radius: 6px;
	border: 1px solid #0284c7;
}

.instructions-title {
	margin: 0;
	font-size: 1rem;
	font-weight: 600;
	margin-bottom: 0.5rem;
	color: #0c4a6e;
}

.instructions-list {
	margin: 0;
	padding-left: 1.2rem;
	color: #0c4a6e;
}

.hint-card {
	background-color: #fef3c7;
	padding: 1rem;
	border-radius: 6px;
	border: 1px solid #f59e0b;
	margin-top: 1rem;
}

.hint-text {
	margin: 0;
	font-size: 0.9rem;
	color: #92400e;
}

.canvas-panel {
	flex: 1;
	position: relative;
	background-color: #ffffff;
	min-width: 0; /* Allows flex item to shrink below content size */
}

.canvas-container {
	position: absolute;
	top: 1rem;
	left: 1rem;
	right: 1rem;
	bottom: 1rem;
	border: 2px solid #e2e8f0;
	border-radius: 8px;
	overflow: hidden;
}

.cartesian-grid {
	position: absolute;
	top: 0px;
	left: 0px;
	right: 0;
	bottom: 0;
	width: 600px;
	height: 600px;
	overflow: visible;
}

.mask-fg {
	position: absolute;
	inset: 0px;
	background-color: black;
	opacity: 0.5;
	pointer-events: none;
}

/* Answer Section Styles */
.answer-section {
	padding: 1rem;
	background-color: #f8fafc;
	border-top: 2px solid #e2e8f0;
	max-height: 300px;
	overflow-y: auto;
}

.answer-title {
	font-size: 1.1rem;
	font-weight: 600;
	margin-bottom: 1rem;
	color: #374151;
}

.answer-input-group {
	margin-bottom: 1rem;
}

.answer-input-group:last-child {
	margin-bottom: 0;
}

.answer-label {
	display: block;
	font-size: 0.9rem;
	font-weight: 500;
	margin-bottom: 0.5rem;
	color: #4b5563;
}

.answer-input {
	width: 100%;
	padding: 0.5rem;
	border: 1px solid #d1d5db;
	border-radius: 4px;
	font-size: 0.9rem;
	color: #374151;
	background-color: white;
	box-sizing: border-box;
}

.answer-input:focus {
	outline: none;
	border-color: #3b82f6;
	box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.answer-input::placeholder {
	color: #9ca3af;
}

.submit-button {
	width: 100%;
	padding: 0.75rem;
	margin-top: 1rem;
	background-color: #3b82f6;
	color: white;
	border: none;
	border-radius: 6px;
	font-size: 1rem;
	font-weight: 600;
	cursor: pointer;
	transition: background-color 0.2s ease;
}

.submit-button:hover {
	background-color: #2563eb;
}

.submit-button:active {
	background-color: #1d4ed8;
}

/* Question Part Styles */
.question-part {
	margin-bottom: 1.5rem;
}

.question-part:last-of-type {
	margin-bottom: 1rem;
}

/* Answer input styles within question card */
.question-card .answer-input-group {
	margin-top: 0.75rem;
	margin-bottom: 0;
}

.question-card .answer-input {
	width: 100%;
	padding: 0.5rem;
	border: 1px solid #d1d5db;
	border-radius: 4px;
	font-size: 0.9rem;
	color: #374151;
	background-color: white;
	box-sizing: border-box;
}

.question-card .answer-input:focus {
	outline: none;
	border-color: #3b82f6;
	box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.question-card .answer-input::placeholder {
	color: #9ca3af;
}

.question-card .submit-button {
	width: 100%;
	padding: 0.75rem;
	margin-top: 1rem;
	background-color: #3b82f6;
	color: white;
	border: none;
	border-radius: 6px;
	font-size: 1rem;
	font-weight: 600;
	cursor: pointer;
	transition: background-color 0.2s ease;
}

.question-card .submit-button:hover {
	background-color: #2563eb;
}

.question-card .submit-button:active {
	background-color: #1d4ed8;
}

/* Mobile responsiveness */
@media (max-width: 1000px) {
	.education-container {
		flex-direction: column;
		gap: 0;
		min-height: auto;
	}

	.question-panel {
		max-width: none;
		border-right: none;
		border-bottom: 2px solid #e2e8f0;
	}

	.canvas-panel {
		min-height: 60vh;
	}

	.canvas-container {
		overflow: hidden;
		position: relative !important;
		top: auto !important;
		left: auto !important;
		right: auto !important;
		bottom: auto !important;
		height: 60vh;
		margin: 1rem;
	}
}
```

--------

# Image annotator

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed

An image annotator built with tldraw.

This example shows how you might want to configure `cameraOptions` to make an image annotation app.

## App.tsx

```tsx
import { useState } from 'react'
import 'tldraw/tldraw.css'
import { ImageAnnotationEditor } from './ImageAnnotationEditor'
import { ImageExport } from './ImageExport'
import { ImagePicker } from './ImagePicker'
import './image-annotator.css'
import { AnnotatorImage } from './types'

type State =
	| {
			phase: 'pick'
	  }
	| {
			phase: 'annotate'
			id: string
			image: AnnotatorImage
	  }
	| {
			phase: 'export'
			result: Blob
	  }

export default function ImageAnnotatorWrapper() {
	const [state, setState] = useState<State>({ phase: 'pick' })

	switch (state.phase) {
		case 'pick':
			return (
				<div className="ImageAnnotator">
					<ImagePicker
						onChooseImage={(image) =>
							setState({ phase: 'annotate', image, id: Math.random().toString(36) })
						}
					/>
				</div>
			)
		case 'annotate':
			return (
				<div className="ImageAnnotator">
					<ImageAnnotationEditor
						// remount tldraw if the image/id changes:
						key={state.id}
						image={state.image}
						onDone={(result) => setState({ phase: 'export', result })}
					/>
				</div>
			)
		case 'export':
			return (
				<div className="ImageAnnotator">
					<ImageExport result={state.result} onStartAgain={() => setState({ phase: 'pick' })} />
				</div>
			)
	}
}
```

## ImageAnnotationEditor.tsx

```tsx
import { useCallback, useEffect, useState } from 'react'
import {
	AssetRecordType,
	Editor,
	SVGContainer,
	TLImageShape,
	TLShapeId,
	Tldraw,
	createShapeId,
	track,
	useEditor,
} from 'tldraw'
import { AnnotatorImage } from './types'

// TODO:
// - prevent changing pages (create page, change page, move shapes to new page)
// - prevent locked shape context menu
// - inertial scrolling for constrained camera
export function ImageAnnotationEditor({
	image,
	onDone,
}: {
	image: AnnotatorImage
	onDone(result: Blob): void
}) {
	const [imageShapeId, setImageShapeId] = useState<TLShapeId | null>(null)
	const [editor, setEditor] = useState(null as Editor | null)

	function onMount(editor: Editor) {
		setEditor(editor)
	}

	useEffect(() => {
		if (!editor) return

		// Create the asset and image shape
		const assetId = AssetRecordType.createId()
		editor.createAssets([
			{
				id: assetId,
				typeName: 'asset',
				type: 'image',
				meta: {},
				props: {
					w: image.width,
					h: image.height,
					mimeType: image.type,
					src: image.src,
					name: 'image',
					isAnimated: false,
				},
			},
		])
		const shapeId = createShapeId()
		editor.createShape({
			id: shapeId,
			type: 'image',
			x: 0,
			y: 0,
			isLocked: true,
			props: {
				w: image.width,
				h: image.height,
				assetId,
			},
		})

		// Make sure the shape is at the bottom of the page
		function makeSureShapeIsAtBottom() {
			if (!editor) return

			const shape = editor.getShape(shapeId)
			if (!shape) return

			const pageId = editor.getCurrentPageId()

			// The shape should always be the child of the current page
			if (shape.parentId !== pageId) {
				editor.moveShapesToPage([shape], pageId)
			}

			// The shape should always be at the bottom of the page's children
			const siblings = editor.getSortedChildIdsForParent(pageId)
			const currentBottomShape = editor.getShape(siblings[0])!
			if (currentBottomShape.id !== shapeId) {
				editor.sendToBack([shape])
			}
		}

		makeSureShapeIsAtBottom()

		const removeOnCreate = editor.sideEffects.registerAfterCreateHandler(
			'shape',
			makeSureShapeIsAtBottom
		)

		const removeOnChange = editor.sideEffects.registerAfterChangeHandler(
			'shape',
			makeSureShapeIsAtBottom
		)

		// The shape should always be locked
		const cleanupKeepShapeLocked = editor.sideEffects.registerBeforeChangeHandler(
			'shape',
			(prev, next) => {
				if (next.id !== shapeId) return next
				if (next.isLocked) return next
				return { ...prev, isLocked: true }
			}
		)

		// Reset the history
		editor.clearHistory()
		setImageShapeId(shapeId)

		return () => {
			removeOnChange()
			removeOnCreate()
			cleanupKeepShapeLocked()
		}
	}, [image, editor])

	useEffect(() => {
		if (!editor) return
		if (!imageShapeId) return

		/**
		 * We don't want the user to be able to scroll away from the image, or zoom it all the way out. This
		 * component hooks into camera updates to keep the camera constrained - try uploading a very long,
		 * thin image and seeing how the camera behaves.
		 */
		editor.setCameraOptions({
			constraints: {
				initialZoom: 'default',
				baseZoom: 'fit-min-100',
				bounds: { w: image.width, h: image.height, x: 0, y: 0 },
				padding: { x: 32, y: 64 },
				origin: { x: 0.5, y: 0.5 },
				behavior: 'contain',
			},
		})
		editor.setCamera(editor.getCamera(), { reset: true })
	}, [editor, imageShapeId, image])

	return (
		<Tldraw
			onMount={onMount}
			components={{
				// we don't need pages for this use-case
				PageMenu: null,
				// grey-out the area outside of the image
				InFrontOfTheCanvas: useCallback(() => {
					if (!imageShapeId) return null
					return <ImageBoundsOverlay imageShapeId={imageShapeId} />
				}, [imageShapeId]),
				// add a "done" button in the top right for when the user is ready to export
				SharePanel: useCallback(() => {
					if (!imageShapeId) return null
					return <DoneButton imageShapeId={imageShapeId} onClick={onDone} />
				}, [imageShapeId, onDone]),
			}}
		/>
	)
}

/**
 * When we export, we'll only include the bounds of the image itself, so show an overlay on top of
 * the canvas to make it clear what will/won't be included. Check `image-annotator.css` for more on
 * how this works.
 */
const ImageBoundsOverlay = track(function ImageBoundsOverlay({
	imageShapeId,
}: {
	imageShapeId: TLShapeId
}) {
	const editor = useEditor()
	const image = editor.getShape(imageShapeId) as TLImageShape
	if (!image) return null

	const imagePageBounds = editor.getShapePageBounds(imageShapeId)!
	const viewport = editor.getViewportScreenBounds()
	const topLeft = editor.pageToViewport(imagePageBounds)
	const bottomRight = editor.pageToViewport({ x: imagePageBounds.maxX, y: imagePageBounds.maxY })

	const path = [
		// start by tracing around the viewport itself:
		`M ${-10} ${-10}`,
		`L ${viewport.maxX + 10} ${-10}`,
		`L ${viewport.maxX + 10} ${viewport.maxY + 10}`,
		`L ${-10} ${viewport.maxY + 10}`,
		`Z`,

		// then cut out a hole for the image:
		`M ${topLeft.x} ${topLeft.y}`,
		`L ${bottomRight.x} ${topLeft.y}`,
		`L ${bottomRight.x} ${bottomRight.y}`,
		`L ${topLeft.x} ${bottomRight.y}`,
		`Z`,
	].join(' ')

	return (
		<SVGContainer className="ImageOverlayScreen">
			<path d={path} fillRule="evenodd" />
		</SVGContainer>
	)
})

function DoneButton({
	imageShapeId,
	onClick,
}: {
	imageShapeId: TLShapeId
	onClick(result: Blob): void
}) {
	const editor = useEditor()
	return (
		<button
			className="DoneButton"
			onClick={async () => {
				const { blob } = await editor.toImage([...editor.getCurrentPageShapeIds()], {
					format: 'png',
					background: true,
					bounds: editor.getShapePageBounds(imageShapeId)!,
					padding: 0,
					scale: 1,
				})

				onClick(blob)
			}}
		>
			Done
		</button>
	)
}
```

## ImageExport.tsx

```tsx
import { useEffect, useLayoutEffect, useState } from 'react'

export function ImageExport({ result, onStartAgain }: { result: Blob; onStartAgain(): void }) {
	const [src, setSrc] = useState<string | null>(null)
	useLayoutEffect(() => {
		const url = URL.createObjectURL(result)
		setSrc(url)
		return () => URL.revokeObjectURL(url)
	}, [result])

	function onDownload() {
		if (!src) return

		const a = document.createElement('a')
		a.href = src
		a.download = 'annotated-image.png'
		a.click()
	}

	const [didCopy, setDidCopy] = useState(false)
	function onCopy() {
		navigator.clipboard.write([new ClipboardItem({ [result.type]: result })])
		setDidCopy(true)
	}
	useEffect(() => {
		if (!didCopy) return
		const t = setTimeout(() => setDidCopy(false), 2000)
		return () => clearTimeout(t)
	}, [didCopy])

	return (
		<div className="ImageExport">
			{src && <img src={src} />}
			<div className="ImageExport-buttons">
				<button onClick={onCopy}>{didCopy ? 'Copied!' : 'Copy'}</button>
				<button onClick={onDownload}>Download</button>
			</div>
			<button onClick={onStartAgain}>Start Again</button>
		</div>
	)
}
```

## ImagePicker.tsx

```tsx
import { useState } from 'react'
import { DEFAULT_SUPPORTED_MEDIA_TYPE_LIST, FileHelpers, MediaHelpers } from 'tldraw'
import anakin from './assets/anakin.jpeg'
import distractedBf from './assets/distracted-bf.jpeg'
import expandingBrain from './assets/expanding-brain.png'

export function ImagePicker({
	onChooseImage,
}: {
	onChooseImage(image: { src: string; width: number; height: number; type: string }): void
}) {
	const [isLoading, setIsLoading] = useState(false)
	function onClickChooseImage() {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = DEFAULT_SUPPORTED_MEDIA_TYPE_LIST
		input.addEventListener('change', async (e) => {
			const fileList = (e.target as HTMLInputElement).files
			if (!fileList || fileList.length === 0) return
			const file = fileList[0]

			setIsLoading(true)
			try {
				const dataUrl = await FileHelpers.blobToDataUrl(file)
				const { w, h } = await MediaHelpers.getImageSize(file)
				onChooseImage({ src: dataUrl, width: w, height: h, type: file.type })
			} finally {
				setIsLoading(false)
			}
		})
		input.click()
	}

	async function onChooseExample(src: string) {
		setIsLoading(true)
		try {
			const image = await fetch(src)
			const blob = await image.blob()
			const { w, h } = await MediaHelpers.getImageSize(blob)
			onChooseImage({ src, width: w, height: h, type: blob.type })
		} finally {
			setIsLoading(false)
		}
	}

	if (isLoading) {
		return <div className="ImagePicker">Loading...</div>
	}

	return (
		<div className="ImagePicker">
			<button onClick={onClickChooseImage}>Choose an image</button>
			<div className="ImagePicker-exampleLabel">or use an example:</div>
			<div className="ImagePicker-examples">
				<img src={anakin} alt="anakin" onClick={() => onChooseExample(anakin)} />
				<img
					src={distractedBf}
					alt="distracted boyfriend"
					onClick={() => onChooseExample(distractedBf)}
				/>
				<img
					src={expandingBrain}
					alt="expanding brain"
					onClick={() => onChooseExample(expandingBrain)}
				/>
			</div>
		</div>
	)
}
```

## image-annotator.css

```css
.ImageAnnotator {
	position: absolute;
	inset: 0;
}

.ImageAnnotator .ImagePicker {
	position: absolute;
	inset: 1rem;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
	flex-direction: column;
	gap: 1rem;
}
.ImageAnnotator .ImagePicker button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.ImageAnnotator .ImagePicker button:hover {
	opacity: 0.9;
}
.ImageAnnotator .ImagePicker-exampleLabel {
	padding-top: 1rem;
	opacity: 0.7;
	font-size: 14px;
}
.ImageAnnotator .ImagePicker-examples {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	width: 100%;
	max-width: 780px;
	gap: 1rem;
}
.ImageAnnotator .ImagePicker-examples img {
	width: 100%;
	height: auto;
	object-fit: contain;
	aspect-ratio: 1;
	cursor: pointer;
}
.ImageAnnotator .ImagePicker-examples img:hover {
	opacity: 0.9;
}

.ImageAnnotator .ImageOverlayScreen {
	pointer-events: none;
	fill: var(--tl-color-background);
	fill-opacity: 0.8;
	stroke: none;
}

.ImageAnnotator .DoneButton {
	font: inherit;
	background: var(--tl-color-primary);
	border: none;
	color: var(--tl-color-selected-contrast);
	font-size: 1rem;
	padding: 0.5rem 1rem;
	border-radius: 6px;
	margin: 6px;
	pointer-events: all;
	z-index: var(--tl-layer-panels);
	border: 2px solid var(--tl-color-background);
	cursor: pointer;
}
.ImageAnnotator .DoneButton:hover {
	filter: brightness(1.1);
}

.ImageAnnotator .ImageExport {
	padding: 1rem;
	display: flex;
	flex-direction: column;
	gap: 1rem;
	align-items: center;
	height: 100%;
}
.ImageAnnotator .ImageExport img {
	width: 100%;
	max-height: 50vh;
	object-fit: contain;
}
.ImageAnnotator .ImageExport button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.ImageAnnotator .ImageExport button:hover {
	opacity: 0.9;
}
.ImageAnnotator .ImageExport-buttons {
	display: flex;
	gap: 1rem;
	align-items: center;
	justify-content: center;
	margin-bottom: auto;
}
.ImageAnnotator .ImageExport-buttons button {
	background-color: hsl(214, 84%, 56%);
	color: white;
}
```

## types.tsx

```tsx
export interface AnnotatorImage {
	src: string
	width: number
	height: number
	type: string
}
```

--------

# PDF editor

Category: Use cases

Keywords: annotation, camera options, constraints, zoom, pan, camera bounds, pan speed, zoom speed, scroll

A very basic PDF editor built with tldraw.

This example shows how you might want to configure `cameraOptions` to make a PDF editor.

## App.tsx

```tsx
import { useState } from 'react'
import 'tldraw/tldraw.css'
import { PdfEditor } from './PdfEditor'
import { Pdf, PdfPicker } from './PdfPicker'
import './pdf-editor.css'

type State =
	| {
			phase: 'pick'
	  }
	| {
			phase: 'edit'
			pdf: Pdf
	  }

export default function PdfEditorWrapper() {
	const [state, setState] = useState<State>({ phase: 'pick' })

	switch (state.phase) {
		case 'pick':
			return (
				<div className="PdfEditor">
					<PdfPicker onOpenPdf={(pdf) => setState({ phase: 'edit', pdf })} />
				</div>
			)
		case 'edit':
			return (
				<div className="PdfEditor">
					<PdfEditor pdf={state.pdf} />
				</div>
			)
	}
}
```

## ExportPdfButton.tsx

```tsx
import { PDFDocument } from 'pdf-lib'
import { useState } from 'react'
import { Editor, useEditor } from 'tldraw'
import { Pdf } from './PdfPicker'

export function ExportPdfButton({ pdf }: { pdf: Pdf }) {
	const [exportProgress, setExportProgress] = useState<number | null>(null)
	const editor = useEditor()

	return (
		<button
			className="ExportPdfButton"
			onClick={async () => {
				setExportProgress(0)
				try {
					await exportPdf(editor, pdf, setExportProgress)
				} finally {
					setExportProgress(null)
				}
			}}
		>
			{exportProgress ? `Exporting... ${Math.round(exportProgress * 100)}%` : 'Export PDF'}
		</button>
	)
}

async function exportPdf(
	editor: Editor,
	{ name, source, pages }: Pdf,
	onProgress: (progress: number) => void
) {
	const totalThings = pages.length * 2 + 2
	let progressCount = 0
	const tickProgress = () => {
		progressCount++
		onProgress(progressCount / totalThings)
	}

	const pdf = await PDFDocument.load(source)
	tickProgress()

	const pdfPages = pdf.getPages()
	if (pdfPages.length !== pages.length) {
		throw new Error('PDF page count mismatch')
	}

	const pageShapeIds = new Set(pages.map((page) => page.shapeId))
	const allIds = Array.from(editor.getCurrentPageShapeIds()).filter((id) => !pageShapeIds.has(id))

	for (let i = 0; i < pages.length; i++) {
		const page = pages[i]
		const pdfPage = pdfPages[i]

		const bounds = page.bounds
		const shapesInBounds = allIds.filter((id) => {
			const shapePageBounds = editor.getShapePageBounds(id)
			if (!shapePageBounds) return false
			return shapePageBounds.collides(bounds)
		})

		if (shapesInBounds.length === 0) {
			tickProgress()
			tickProgress()
			continue
		}

		const exportedPng = await editor.toImage(allIds, {
			format: 'png',
			background: false,
			bounds: page.bounds,
			padding: 0,
			scale: 1,
		})
		tickProgress()

		pdfPage.drawImage(await pdf.embedPng(await exportedPng.blob.arrayBuffer()), {
			x: 0,
			y: 0,
			width: pdfPage.getWidth(),
			height: pdfPage.getHeight(),
		})
		tickProgress()
	}

	const url = URL.createObjectURL(new Blob([await pdf.save()], { type: 'application/pdf' }))
	tickProgress()
	const a = document.createElement('a')
	a.href = url
	a.download = name
	a.click()
	URL.revokeObjectURL(url)
}
```

## PdfEditor.tsx

```tsx
import { useMemo } from 'react'
import {
	Box,
	SVGContainer,
	TLComponents,
	TLImageShape,
	TLShapePartial,
	Tldraw,
	getIndicesBetween,
	react,
	sortByIndex,
	track,
	useEditor,
} from 'tldraw'
import { ExportPdfButton } from './ExportPdfButton'
import { Pdf } from './PdfPicker'

// TODO:
// - prevent changing pages (create page, change page, move shapes to new page)
// - prevent locked shape context menu
// - inertial scrolling for constrained camera
// - render pages on-demand instead of all at once.
export function PdfEditor({ pdf }: { pdf: Pdf }) {
	const components = useMemo<TLComponents>(
		() => ({
			PageMenu: null,
			Overlays: () => <PageOverlayScreen pdf={pdf} />,
			SharePanel: () => <ExportPdfButton pdf={pdf} />,
		}),
		[pdf]
	)

	return (
		<Tldraw
			onMount={(editor) => {
				editor.createAssets(
					pdf.pages.map((page) => ({
						id: page.assetId,
						typeName: 'asset',
						type: 'image',
						meta: {},
						props: {
							w: page.bounds.w,
							h: page.bounds.h,
							mimeType: 'image/png',
							src: page.src,
							name: 'page',
							isAnimated: false,
						},
					}))
				)
				editor.createShapes(
					pdf.pages.map(
						(page): TLShapePartial<TLImageShape> => ({
							id: page.shapeId,
							type: 'image',
							x: page.bounds.x,
							y: page.bounds.y,
							isLocked: true,
							props: {
								assetId: page.assetId,
								w: page.bounds.w,
								h: page.bounds.h,
							},
						})
					)
				)

				const shapeIds = pdf.pages.map((page) => page.shapeId)
				const shapeIdSet = new Set(shapeIds)

				// Don't let the user unlock the pages
				editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
					if (!shapeIdSet.has(next.id)) return next
					if (next.isLocked) return next
					return { ...prev, isLocked: true }
				})

				// Make sure the shapes are below any of the other shapes
				function makeSureShapesAreAtBottom() {
					const shapes = shapeIds.map((id) => editor.getShape(id)!).sort(sortByIndex)
					const pageId = editor.getCurrentPageId()

					const siblings = editor.getSortedChildIdsForParent(pageId)
					const currentBottomShapes = siblings
						.slice(0, shapes.length)
						.map((id) => editor.getShape(id)!)

					if (currentBottomShapes.every((shape, i) => shape.id === shapes[i].id)) return

					const otherSiblings = siblings.filter((id) => !shapeIdSet.has(id))
					const bottomSibling = otherSiblings[0]
					const lowestIndex = editor.getShape(bottomSibling)!.index

					const indexes = getIndicesBetween(undefined, lowestIndex, shapes.length)
					editor.updateShapes(
						shapes.map((shape, i) => ({
							...shape,
							id: shape.id,
							isLocked: shape.isLocked,
							index: indexes[i],
						}))
					)
				}

				makeSureShapesAreAtBottom()
				editor.sideEffects.registerAfterCreateHandler('shape', makeSureShapesAreAtBottom)
				editor.sideEffects.registerAfterChangeHandler('shape', makeSureShapesAreAtBottom)

				// Constrain the camera to the bounds of the pages
				const targetBounds = pdf.pages.reduce(
					(acc, page) => acc.union(page.bounds),
					pdf.pages[0].bounds.clone()
				)

				function updateCameraBounds(isMobile: boolean) {
					editor.setCameraOptions({
						constraints: {
							bounds: targetBounds,
							padding: { x: isMobile ? 16 : 164, y: 64 },
							origin: { x: 0.5, y: 0 },
							initialZoom: 'fit-x-100',
							baseZoom: 'default',
							behavior: 'contain',
						},
					})
					editor.setCamera(editor.getCamera(), { reset: true })
				}

				let isMobile = editor.getViewportScreenBounds().width < 840

				react('update camera', () => {
					const isMobileNow = editor.getViewportScreenBounds().width < 840
					if (isMobileNow === isMobile) return
					isMobile = isMobileNow
					updateCameraBounds(isMobile)
				})

				updateCameraBounds(isMobile)
			}}
			components={components}
		/>
	)
}

const PageOverlayScreen = track(function PageOverlayScreen({ pdf }: { pdf: Pdf }) {
	const editor = useEditor()

	const viewportPageBounds = editor.getViewportPageBounds()

	const relevantPageBounds = pdf.pages
		.map((page) => {
			if (!viewportPageBounds.collides(page.bounds)) return null
			return page.bounds
		})
		.filter((bounds): bounds is Box => bounds !== null)

	function pathForPageBounds(bounds: Box) {
		return `M ${bounds.x} ${bounds.y} L ${bounds.maxX} ${bounds.y} L ${bounds.maxX} ${bounds.maxY} L ${bounds.x} ${bounds.maxY} Z`
	}

	const viewportPath = `M ${viewportPageBounds.x} ${viewportPageBounds.y} L ${viewportPageBounds.maxX} ${viewportPageBounds.y} L ${viewportPageBounds.maxX} ${viewportPageBounds.maxY} L ${viewportPageBounds.x} ${viewportPageBounds.maxY} Z`

	return (
		<>
			<SVGContainer className="PageOverlayScreen-screen">
				<path
					d={`${viewportPath} ${relevantPageBounds.map(pathForPageBounds).join(' ')}`}
					fillRule="evenodd"
				/>
			</SVGContainer>
			{relevantPageBounds.map((bounds, i) => (
				<div
					key={i}
					className="PageOverlayScreen-outline"
					style={{
						width: bounds.w,
						height: bounds.h,
						transform: `translate(${bounds.x}px, ${bounds.y}px)`,
					}}
				/>
			))}
		</>
	)
})
```

## PdfPicker.tsx

```tsx
import PdfJSWorkerSrc from 'pdfjs-dist/build/pdf.worker.min.mjs?url'

import { useState } from 'react'
import { AssetRecordType, Box, TLAssetId, TLShapeId, createShapeId } from 'tldraw'
import tldrawPdf from './assets/tldraw.pdf'

export interface PdfPage {
	src: string
	bounds: Box
	assetId: TLAssetId
	shapeId: TLShapeId
}

export interface Pdf {
	name: string
	pages: PdfPage[]
	source: string | ArrayBuffer
}

const pageSpacing = 32

export function PdfPicker({ onOpenPdf }: { onOpenPdf(pdf: Pdf): void }) {
	const [isLoading, setIsLoading] = useState(false)

	async function loadPdf(name: string, source: ArrayBuffer): Promise<Pdf> {
		const PdfJS = await import('pdfjs-dist')
		PdfJS.GlobalWorkerOptions.workerSrc = PdfJSWorkerSrc

		const pdf = await PdfJS.getDocument(source.slice(0)).promise
		const pages: PdfPage[] = []

		const canvas = window.document.createElement('canvas')
		const context = canvas.getContext('2d')
		if (!context) throw new Error('Failed to create canvas context')

		const visualScale = 1.5
		const scale = window.devicePixelRatio

		let top = 0
		let widest = 0
		for (let i = 1; i <= pdf.numPages; i++) {
			const page = await pdf.getPage(i)
			const viewport = page.getViewport({ scale: scale * visualScale })
			canvas.width = viewport.width
			canvas.height = viewport.height
			const renderContext = {
				canvasContext: context,
				viewport,
			}
			await page.render(renderContext).promise

			const width = viewport.width / scale
			const height = viewport.height / scale
			pages.push({
				src: canvas.toDataURL(),
				bounds: new Box(0, top, width, height),
				assetId: AssetRecordType.createId(),
				shapeId: createShapeId(),
			})
			top += height + pageSpacing
			widest = Math.max(widest, width)
		}
		canvas.width = 0
		canvas.height = 0

		for (const page of pages) {
			page.bounds.x = (widest - page.bounds.width) / 2
		}

		return {
			name,
			pages,
			source,
		}
	}

	function onClickOpenPdf() {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = 'application/pdf'
		input.addEventListener('change', async (e) => {
			const fileList = (e.target as HTMLInputElement).files
			if (!fileList || fileList.length === 0) return
			const file = fileList[0]

			setIsLoading(true)
			try {
				const pdf = await loadPdf(file.name, await file.arrayBuffer())
				onOpenPdf(pdf)
			} finally {
				setIsLoading(false)
			}
		})
		input.click()
	}

	async function onClickUseExample() {
		setIsLoading(true)
		try {
			const result = await fetch(tldrawPdf)
			const pdf = await loadPdf('tldraw.pdf', await result.arrayBuffer())
			onOpenPdf(pdf)
		} finally {
			setIsLoading(false)
		}
	}

	if (isLoading) {
		return <div className="PdfPicker">Loading...</div>
	}

	return (
		<div className="PdfPicker">
			<button onClick={onClickOpenPdf}>Open PDF</button>
			<div>or</div>
			<button onClick={onClickUseExample}>Use an example</button>
		</div>
	)
}
```

## pdf-editor.css

```css
.PdfEditor {
	position: absolute;
	inset: 0;
}

.PdfEditor .PdfPicker {
	position: absolute;
	inset: 1rem;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
	flex-direction: column;
	gap: 1rem;
}
.PdfEditor .PdfPicker button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.PdfEditor .PdfPicker button:hover {
	opacity: 0.9;
}

.PdfEditor .PdfBgRenderer {
	position: absolute;
	pointer-events: none;
}
.PdfEditor .PdfBgRenderer img {
	position: absolute;
}

.PdfEditor .PageOverlayScreen-screen {
	pointer-events: none;
	fill: var(--tl-color-background);
	fill-opacity: 0.8;
	stroke: none;
}
.PdfEditor .PageOverlayScreen-outline {
	position: absolute;
	pointer-events: none;
	box-shadow: var(--tl-shadow-2);
}
.PdfEditor .ExportPdfButton {
	font: inherit;
	background: var(--tl-color-primary);
	border: none;
	color: var(--tl-color-selected-contrast);
	font-size: 1rem;
	padding: 0.5rem 1rem;
	border-radius: 6px;
	margin: 6px;
	margin-bottom: 0;
	pointer-events: all;
	z-index: var(--tl-layer-panels);
	border: 2px solid var(--tl-color-background);
	cursor: pointer;
}
.PdfEditor .ExportPdfButton:hover {
	filter: brightness(1.1);
}
```

--------

# Canvas mask

Category: Use cases

Keywords: mask, window, clip

This example shows how you can mask the canvas.

The canvas has a white overlay. When you have a shape selected, the shape's bounds will be used as a mask through the overlay.

## App.tsx

```tsx
import { useEffect, useRef } from 'react'
import { TLComponents, TLShape, Tldraw, createShapeId, useEditor, useQuickReactor } from 'tldraw'
import 'tldraw/tldraw.css'
import './mask-window.css'

function MaskWindow() {
	const editor = useEditor()
	const ref = useRef<HTMLDivElement>(null)

	useQuickReactor(
		'clip',
		() => {
			const elm = ref.current
			if (!elm) return

			const rotation = editor.getSelectionRotation()
			const box = editor.getSelectionRotatedScreenBounds()

			if (!box) {
				// If there's nothing selected, clear the clip path
				elm.style.clipPath = ''
				return
			}

			const vsb = editor.getViewportScreenBounds()

			// Expand the box, offset it by the viewport screen bounds, and get the corners
			const { corners } = box.clone().translate(vsb.point.clone().neg()).expandBy(20)

			// Account for rotation by rotating the points of the rectangle
			const [tl, tr, br, bl] = corners.map((p) => p.rotWith(box.point, rotation))

			// Since there's no reliable "reverse clip path", we wind around the corners in order to turn our clip into a mask
			elm.style.clipPath = `polygon(0% 0%, ${tl.x}px 0%, ${tl.x}px ${tl.y}px, ${bl.x}px ${bl.y}px, ${br.x}px ${br.y}px, ${tr.x}px ${tr.y}px, ${tl.x}px ${tl.y}px, ${tl.x}px 0%, 100% 0%, 100% 100%, 0% 100%)`
		},
		[editor]
	)

	useExtraBonusStuff()

	return <div ref={ref} className="mask-fg" />
}

const components: TLComponents = {
	InFrontOfTheCanvas: () => {
		return <MaskWindow />
	},
}

export default function MaskWindowExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="mask" components={components} />
		</div>
	)
}

// Some extra stuff that isnt necessary but good for this demo
function useExtraBonusStuff() {
	const editor = useEditor()

	useEffect(() => {
		if (editor.getCurrentPageShapeIds().size === 0) {
			const vpb = editor.getViewportPageBounds()

			// if the canvas is empty, create some shapes for the demo
			for (let i = 0; i < 50; i++) {
				const x = vpb.x + Math.random() * vpb.w
				const y = vpb.y + Math.random() * vpb.h
				editor.createShape({ type: 'geo', x, y })
			}

			const id = createShapeId()
			const { center } = editor.getViewportPageBounds()
			editor.createShape({
				id,
				type: 'geo',
				x: center.x - 100,
				y: center.y - 100,
				props: {
					w: 200,
					h: 200,
				},
			})
			editor.select(id)
		}

		// As a (fragile) treat, press J to save positions for the selected shape, then press Ctrl+J to animate between positions
		const positions: TLShape[] = []

		const handleKeydown = (e: any) => {
			if (e.key === 'j') {
				e.preventDefault()
				e.stopPropagation()
				if (e.metaKey || e.ctrlKey) {
					const shape = positions.shift()
					if (!shape) return
					editor.animateShape(shape, { animation: { duration: 1000 } })
				} else {
					const shape = editor.getOnlySelectedShape()
					if (!shape) return
					positions.push(shape)
				}
			}
		}
		document.addEventListener('keydown', handleKeydown)
		return () => {
			document.removeEventListener('keydown', handleKeydown)
		}
	}, [editor])
}
```

## mask-window.css

```css
.mask-svg {
	position: absolute;
	top: 0px;
	left: 0px;
}

.mask-fg {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 100%;
	pointer-events: none;
	background-color: rgba(255, 255, 255, 0.9);
	/* -webkit-mask:
		url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" preserveAspectRatio="none"><rect x="100" y="100" width="20" height="20"/></svg>')
			0/100% 100%,
		linear-gradient(#fff, #fff);
	-webkit-mask-composite: destination-out;
	mask-composite: exclude; */
}
```

--------

# Fog of war

Category: Use cases

Keywords: ui, fog, overlay

Create a fog of war effect by keeping an HTML canvas in sync with canvas content.

This example shows how you might keep an HTML canvas in sync with canvas content. It implements a simple "fog of war" effect, where the canvas is covered by a black overlay that can be cleared by drawing shapes on the canvas.

## App.tsx

```tsx
import { useEffect, useRef } from 'react'
import { Box, TLComponents, Tldraw, Vec, useEditor, useReactor } from 'tldraw'
import 'tldraw/tldraw.css'

const CELL_SIZE = 32
const COUNT = 100

const boxes: Box[][] = []
const cells: boolean[][] = []
for (let i = 0; i < COUNT; i++) {
	cells[i] = []
	boxes[i] = []
	for (let j = 0; j < COUNT; j++) {
		cells[i].push(false)
		boxes[i].push(
			new Box((i - COUNT / 2) * CELL_SIZE, (j - COUNT / 2) * CELL_SIZE, CELL_SIZE, CELL_SIZE)
		)
	}
}

export function Fog() {
	const rCanvas = useRef<HTMLCanvasElement>(null)
	const rVisibility = useRef<boolean[][]>(cells)
	const editor = useEditor()

	useEffect(() => {
		const cvs = rCanvas.current!
		const rect = cvs.getBoundingClientRect()
		cvs.width = rect.width
		cvs.height = rect.height
	}, [editor])

	useReactor(
		'update fog',
		() => {
			const cells = rVisibility.current
			const shapes = editor.getCurrentPageShapes()
			for (const shape of shapes) {
				const point = editor.getShapePageBounds(shape)!.point
				const geometry = editor.getShapeGeometry(shape)
				const adjustedPoint = Vec.Sub(point, geometry.bounds.point)
				for (let i = 0; i < boxes.length; i++) {
					for (let j = 0; j < boxes[i].length; j++) {
						const box = boxes[i][j]
						box.translate(Vec.Neg(adjustedPoint))
						if (geometry.bounds.collides(box)) {
							cells[i][j] = true
						}
						box.translate(adjustedPoint)
					}
				}
			}
			const cvs = rCanvas.current!
			const ctx = cvs.getContext('2d')!

			cvs.style.filter = `blur(${editor.getCamera().z * 15}px)`

			ctx.resetTransform()
			const camera = editor.getCamera()

			ctx.clearRect(0, 0, cvs.width, cvs.height)
			ctx.fillStyle = 'rgba(0,0,0,0.9)'
			ctx.fillRect(0, 0, cvs.width, cvs.height)

			ctx.translate(100, 100)
			ctx.scale(camera.z, camera.z)
			ctx.translate(camera.x, camera.y)

			for (let i = 0; i < boxes.length; i++) {
				for (let j = 0; j < boxes[i].length; j++) {
					if (!cells[i][j]) continue
					const box = boxes[i][j]
					ctx.clearRect(box.x, box.y, box.width, box.height)
				}
			}
		},
		[editor]
	)

	return (
		<canvas
			ref={rCanvas}
			style={{
				position: 'absolute',
				top: -100,
				left: -100,
				width: 'calc(100% + 200px)',
				height: 'calc(100% + 200px)',
				WebkitFilter: 'blur(15px)',
				filter: 'blur(15px)',
				pointerEvents: 'none',
			}}
		/>
	)
}

const components: TLComponents = {
	InFrontOfTheCanvas: Fog,
}

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example" components={components} />
		</div>
	)
}
```

--------

# Mark exams

Category: Use cases

Keywords: education, pdf, annotation, toolbar, util, ui overrides

A tool for marking exams. It includes common pdf annotation tools, as well as a built in tool for marking individual questions and tallying the total score of the exam.

This example, built on top of the [pdf-editor](https://examples.tldraw.com/pdf-editor) example, shows how you might take a more tailored approach to building a pdf editor experience. It includes:

- A custom shape called `exam-mark` that allows you to add marks on a per question basis.
- A custom tool to place the `exam-mark` shape.
- A widget that shows the total exam score (the sum of all `exam-mark` scores in the document), useful if you wanted to export it the total score to a database.

## App.tsx

```tsx
import { useState } from 'react'
import 'tldraw/tldraw.css'
import './pdf-editor/pdf-editor.css'
import { PdfEditor } from './pdf-editor/PdfEditor'
import { Pdf, PdfPicker } from './pdf-editor/PdfPicker'

type State =
	| {
			phase: 'pick'
	  }
	| {
			phase: 'edit'
			pdf: Pdf
	  }

export default function ExamMarkingExample() {
	const [state, setState] = useState<State>({ phase: 'pick' })

	switch (state.phase) {
		case 'pick':
			return (
				<div className="PdfEditor">
					<PdfPicker onOpenPdf={(pdf) => setState({ phase: 'edit', pdf })} />
				</div>
			)
		case 'edit':
			return (
				<div className="PdfEditor">
					<PdfEditor pdf={state.pdf} />
				</div>
			)
	}
}

/*
Introduction:

This example of an exam marking tool is built on top of the `pdf-editor` example. The files specific to the pdf-editor live in the `pdf-editor` folder in this directory.
What this adds on top of the pdf editor is a custom shape that allows you mark individual questions and have their score tallied, and a custom tool that allows you create that shape.

File structure:
`add-mark-util.tsx` is a shape utility that defines the exam mark shape.
`add-mark-tool.tsx` is a custom tool that allows you to add the exam mark shape to the page.
`ExamScoreLabel.tsx` is a widget that shows the total exam score.
`ui-overrides.tsx` is a file that overrides the default toolbar and keyboard shortcuts menu to add the exam mark tool.

*/
```

## ExamScoreLabel.tsx

```tsx
import { useEditor, useValue } from 'tldraw'

// [1]
export function ExamScoreLabel() {
	const editor = useEditor()

	const score = useValue(
		'score',
		() => {
			let score = 0
			for (const shape of editor.getCurrentPageShapes()) {
				if (!editor.isShapeOfType(shape, 'exam-mark')) continue
				score += shape.props.score
			}
			return score
		},
		[editor]
	)

	return (
		<div
			style={{
				background: 'var(--tl-color-panel)',

				display: 'flex',
				alignItems: 'center',
				justifyContent: 'center',
				padding: '0.5rem 1rem',
				borderRadius: '6px',
				margin: '6px 0px 0px 0px',
				borderWidth: '2px',
				borderStyle: 'solid',
				borderColor: 'var(--tl-color-background-contrast)',
				zIndex: 'var(--tl-layer-panels)',
			}}
		>
			<p style={{ fontSize: '1.25em', margin: 0 }}>Total exam score: {score}</p>
		</div>
	)
}

/*

[1]
This is a simple widget that shows the total exam score. It's an example of how to use the editor instance to compute a value that depends on the shapes on the page.

[a]
We listen for changes to the document using the editor.store.listen method inside of a useEffect hook.

[b]
We define a function that calculates the score based on the shapes on the page. We filter all shapes on the current page to only include `exam-mark` shapes, and then access the score prop of each shape and add them all to get the total score.

*/
```

## add-mark-tool.tsx

```tsx
import { StateNode } from 'tldraw'
import { EXAM_MARK_HEIGHT, EXAM_MARK_WIDTH } from './add-mark-util'

// Check out the custom tool example for a more detailed explanation of the StateNode class.

export class MarkingTool extends StateNode {
	static override id = 'mark'

	override onEnter() {
		this.editor.setCursor({ type: 'cross', rotation: 0 })
	}

	override onPointerUp() {
		const pagePoint = this.editor.inputs.getCurrentPagePoint()
		this.editor.createShape({
			type: 'exam-mark',
			x: pagePoint.x - EXAM_MARK_WIDTH / 2,
			y: pagePoint.y - EXAM_MARK_HEIGHT / 2,
		})

		if (!this.editor.getInstanceState().isToolLocked) {
			this.editor.setCurrentTool('select')
		}
	}
}
```

## add-mark-util.tsx

```tsx
import { useEffect, useRef, useState } from 'react'
import { HTMLContainer, RecordProps, Rectangle2d, ShapeUtil, T, TLShape } from 'tldraw'

export const EXAM_MARK_WIDTH = 80
export const EXAM_MARK_HEIGHT = 40

const EXAM_MARK_TYPE = 'exam-mark'

declare module 'tldraw' {
	export interface TLGlobalShapePropsMap {
		[EXAM_MARK_TYPE]: {
			score: number
		}
	}
}

export type IExamMarkShape = TLShape<typeof EXAM_MARK_TYPE>

export const examMarkShapeDefaultProps: IExamMarkShape['props'] = {
	score: 0,
}

export class ExamMarkUtil extends ShapeUtil<IExamMarkShape> {
	static override type = EXAM_MARK_TYPE
	static override props: RecordProps<IExamMarkShape> = {
		score: T.number,
	}

	override getDefaultProps(): IExamMarkShape['props'] {
		return examMarkShapeDefaultProps
	}

	// [1]
	override canEdit(_shape: IExamMarkShape): boolean {
		return true
	}

	// [2]
	override component(shape: IExamMarkShape) {
		// [a]
		const isEditing = this.editor.getEditingShapeId() === shape.id

		// [b]
		/* eslint-disable react-hooks/rules-of-hooks */
		const [score, setScore] = useState<number | string>(shape.props.score)

		const inputRef = useRef<HTMLInputElement>(null)

		// [c]
		useEffect(() => {
			this.editor.setEditingShape(shape.id)
		}, [shape.id])

		// [d]
		useEffect(() => {
			if (isEditing && inputRef.current) {
				inputRef.current.focus()
				inputRef.current.select()
			}
		}, [isEditing])
		/* eslint-enable react-hooks/rules-of-hooks */

		// [e]
		const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
			const value = e.target.value
			setScore(value)
			const num = Number(value)
			if (!isNaN(num)) {
				this.editor.updateShape({
					id: shape.id,
					type: EXAM_MARK_TYPE,
					props: {
						score: num,
					},
				})
			}
		}

		return (
			<HTMLContainer id={shape.id}>
				<div
					style={{
						height: '100%',
						fontSize: '1.5em',
						display: 'flex',
						alignItems: 'center',
					}}
				>
					<input
						ref={inputRef}
						type="number"
						value={score}
						style={{
							width: '100%',
							fontSize: '1.25em',
							padding: '6px 10px',
							borderRadius: 4,
							border: '1px solid blue',
							opacity: 0.7,
							pointerEvents: isEditing ? 'all' : 'none',
						}}
						onChange={handleChange}
						onBlur={() => {
							this.editor.setEditingShape(null)
						}}
						onPointerDown={isEditing ? this.editor.markEventAsHandled : undefined}
						onPointerUp={isEditing ? this.editor.markEventAsHandled : undefined}
						onPointerMove={isEditing ? this.editor.markEventAsHandled : undefined}
					/>
				</div>
			</HTMLContainer>
		)
	}

	override indicator() {
		return <rect width={EXAM_MARK_WIDTH} height={EXAM_MARK_HEIGHT} rx={4} />
	}

	getGeometry() {
		return new Rectangle2d({
			width: EXAM_MARK_WIDTH,
			height: EXAM_MARK_HEIGHT,
			isFilled: true,
		})
	}

	override hideSelectionBoundsBg() {
		return true
	}
	override hideSelectionBoundsFg() {
		return true
	}

	override canResize(_shape: IExamMarkShape): boolean {
		return false
	}
}

/*
A utility class for the exam mark shape. This is where you define the shape's behavior, how it renders (its component and indicator), and how it handles different events. For more details on how to create a custom shape utility, check out the `custom-config` example.

[1] We allow this component to be editable. This gives us some behavior for free, namely double clicking the shape will start editing the shape, which we can access using `editor.getEditingShapeId()`. With this, we can focus the input when the shape is double clicked. See [1][a] and [1][c] for more details.

[2] Render method — the React component that will be rendered for the shape. It takes the shape as an argument. HTMLContainer is just a div that's being used to wrap the input.

 - [a] To control behavior, we need to know if the shape is being edited. We can access this using `editor.getEditingShapeId()`.

 - [b] The important part of this shape utility is how it handles the score input. We know we want the ExamScoreLabel component to be able to access the score of the shape, so we want the score to be a prop for the shape.
 Annoying: eslint sometimes thinks this is a class component, but it's not.

 - [c] When the shape is mounted, we set it to be in editing mode.

 - [d] Focus the input when the the shape is being edited, i.e. when it's double clicked or when it's mounted. This means that when a shape is created, the text is immediately focused and selected.

 - [e] We want to be able to edit the score of the shape, so we need to be able to update the shape's props. We do this by using the editor.updateShape method when we detect that the score is a number.

For notes on the other parts of this shape utility, check out the `custom-config` example.
*/
```

## ui-overrides.tsx

```tsx
import {
	DefaultKeyboardShortcutsDialog,
	DefaultKeyboardShortcutsDialogContent,
	DefaultToolbar,
	DefaultToolbarContent,
	TLComponents,
	TldrawUiMenuItem,
	TLUiOverrides,
	useIsToolSelected,
	useTools,
} from 'tldraw'

// There's a guide at the bottom of this file!

// [1]
export const uiOverrides: TLUiOverrides = {
	tools(editor, tools) {
		// Create a tool item in the ui's context.
		tools.mark = {
			id: 'mark',
			icon: <span style={{ fontSize: '2em' }}>📝</span>,
			label: 'Mark Exam',
			kbd: 'm',
			onSelect: () => {
				editor.setCurrentTool('mark')
			},
		}
		return tools
	},
}

// [2]
export const components: TLComponents = {
	Toolbar: (props) => {
		const tools = useTools()
		const isMarkingToolSelected = useIsToolSelected(tools['mark'])
		return (
			<DefaultToolbar {...props}>
				<TldrawUiMenuItem {...tools['mark']} isSelected={isMarkingToolSelected} />
				<DefaultToolbarContent />
			</DefaultToolbar>
		)
	},
	KeyboardShortcutsDialog: (props) => {
		const tools = useTools()
		return (
			<DefaultKeyboardShortcutsDialog {...props}>
				<TldrawUiMenuItem {...tools['mark']} />
				<DefaultKeyboardShortcutsDialogContent />
			</DefaultKeyboardShortcutsDialog>
		)
	},
}

/*

This file contains overrides for the Tldraw UI. These overrides are used to add your custom tools to
the toolbar and the keyboard shortcuts menu.

[1]
First we have to add our new tool to the tools object in the tools override. This is where we define
all the basic information about our new tool - its icon, label, keyboard shortcut, what happens when
we select it, etc.

[2]
Then, we replace the UI components for the toolbar and keyboard shortcut dialog with our own, that
add our new tool to the existing default content. Ideally, we'd interleave our new tool into the
ideal place among the default tools, but for now we're just adding it at the start to keep things
simple.
*/
```

## ExportPdfButton.tsx

```tsx
import { PDFDocument } from 'pdf-lib'
import { useState } from 'react'
import { Editor, useEditor } from 'tldraw'
import { Pdf } from './PdfPicker'

export function ExportPdfButton({ pdf }: { pdf: Pdf }) {
	const [exportProgress, setExportProgress] = useState<number | null>(null)
	const editor = useEditor()

	return (
		<button
			style={{
				font: 'inherit',
				background: 'var(--tl-color-primary)',
				border: 'none',
				color: 'var(--tl-color-selected-contrast)',
				fontSize: '1rem',
				padding: '0.5rem 1rem',
				borderRadius: '6px',
				margin: '6px 0px',
				marginBottom: 0,
				pointerEvents: 'all',
				zIndex: 'var(--tl-layer-panels)',
				borderWidth: '2px',
				borderStyle: 'solid',
				borderColor: 'var(--tl-color-background)',
				cursor: 'pointer',
			}}
			onClick={async () => {
				setExportProgress(0)
				try {
					await exportPdf(editor, pdf, setExportProgress)
				} finally {
					setExportProgress(null)
				}
			}}
		>
			{exportProgress ? `Exporting... ${Math.round(exportProgress * 100)}%` : 'Export PDF'}
		</button>
	)
}

async function exportPdf(
	editor: Editor,
	{ name, source, pages }: Pdf,
	onProgress: (progress: number) => void
) {
	const totalThings = pages.length * 2 + 2
	let progressCount = 0
	const tickProgress = () => {
		progressCount++
		onProgress(progressCount / totalThings)
	}

	const pdf = await PDFDocument.load(source)
	tickProgress()

	const pdfPages = pdf.getPages()
	if (pdfPages.length !== pages.length) {
		throw new Error('PDF page count mismatch')
	}

	const pageShapeIds = new Set(pages.map((page) => page.shapeId))
	const allIds = Array.from(editor.getCurrentPageShapeIds()).filter((id) => !pageShapeIds.has(id))

	for (let i = 0; i < pages.length; i++) {
		const page = pages[i]
		const pdfPage = pdfPages[i]

		const bounds = page.bounds
		const shapesInBounds = allIds.filter((id) => {
			const shapePageBounds = editor.getShapePageBounds(id)
			if (!shapePageBounds) return false
			return shapePageBounds.collides(bounds)
		})

		if (shapesInBounds.length === 0) {
			tickProgress()
			tickProgress()
			continue
		}

		const exportedPng = await editor.toImage(shapesInBounds, {
			format: 'png',
			background: false,
			bounds: page.bounds,
			padding: 0,
			scale: 1,
		})
		tickProgress()

		pdfPage.drawImage(await pdf.embedPng(await exportedPng.blob.arrayBuffer()), {
			x: 0,
			y: 0,
			width: pdfPage.getWidth(),
			height: pdfPage.getHeight(),
		})
		tickProgress()
	}

	const url = URL.createObjectURL(new Blob([await pdf.save()], { type: 'application/pdf' }))
	tickProgress()
	const a = document.createElement('a')
	a.href = url
	a.download = name
	a.click()
	URL.revokeObjectURL(url)
}
```

## PdfEditor.tsx

```tsx
import { useMemo } from 'react'
import {
	Box,
	SVGContainer,
	StateNode,
	TLClickEventInfo,
	TLComponents,
	TLImageShape,
	TLShapePartial,
	Tldraw,
	getIndicesBetween,
	react,
	sortByIndex,
	track,
	useEditor,
} from 'tldraw'
import { MarkingTool } from '../add-mark-tool'
import { EXAM_MARK_HEIGHT, EXAM_MARK_WIDTH, ExamMarkUtil } from '../add-mark-util'
import { ExamScoreLabel } from '../ExamScoreLabel'
import { components, uiOverrides } from '../ui-overrides'
import { ExportPdfButton } from './ExportPdfButton'
import { Pdf } from './PdfPicker'

const customShapeUtils = [ExamMarkUtil]
const customTools = [MarkingTool]

export function PdfEditor({ pdf }: { pdf: Pdf }) {
	const pdfEditorComponents = useMemo<TLComponents>(
		() => ({
			PageMenu: null,
			Overlays: () => <PageOverlayScreen pdf={pdf} />,
			SharePanel: () => (
				<div
					style={{
						display: 'flex',
						flexDirection: 'row',
						alignItems: 'center',
						gap: 8,
						justifyContent: 'normal',
						padding: '0px 6px',
					}}
				>
					<ExamScoreLabel />
					<ExportPdfButton pdf={pdf} />
				</div>
			),
			...components,
		}),
		[pdf]
	)

	return (
		<Tldraw
			onMount={(editor) => {
				// See the custom-double-click-behavior example for more details on this
				type IdleStateNode = StateNode & {
					handleDoubleClickOnCanvas(info: TLClickEventInfo): void
				}

				const selectIdleState = editor.getStateDescendant<IdleStateNode>('select.idle')
				if (!selectIdleState) throw Error('SelectTool Idle state not found')

				function customDoubleClickOnCanvasHandler(_info: TLClickEventInfo) {
					const pagePoint = editor.inputs.getCurrentPagePoint()
					editor.createShape({
						type: 'exam-mark',
						x: pagePoint.x - EXAM_MARK_WIDTH / 2,
						y: pagePoint.y - EXAM_MARK_HEIGHT / 2,
					})
				}

				selectIdleState.handleDoubleClickOnCanvas =
					customDoubleClickOnCanvasHandler.bind(selectIdleState)

				editor.createAssets(
					pdf.pages.map((page) => ({
						id: page.assetId,
						typeName: 'asset',
						type: 'image',
						meta: {},
						props: {
							w: page.bounds.w,
							h: page.bounds.h,
							mimeType: 'image/png',
							src: page.src,
							name: 'page',
							isAnimated: false,
						},
					}))
				)
				editor.createShapes(
					pdf.pages.map(
						(page): TLShapePartial<TLImageShape> => ({
							id: page.shapeId,
							type: 'image',
							x: page.bounds.x,
							y: page.bounds.y,
							isLocked: true,
							props: {
								assetId: page.assetId,
								w: page.bounds.w,
								h: page.bounds.h,
							},
						})
					)
				)

				const shapeIds = pdf.pages.map((page) => page.shapeId)
				const shapeIdSet = new Set(shapeIds)

				// Don't let the user unlock the pages
				editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next) => {
					if (!shapeIdSet.has(next.id)) return next
					if (next.isLocked) return next
					return { ...prev, isLocked: true }
				})

				// Make sure the shapes are below any of the other shapes
				function makeSureShapesAreAtBottom() {
					const shapes = shapeIds.map((id) => editor.getShape(id)!).sort(sortByIndex)
					const pageId = editor.getCurrentPageId()

					const siblings = editor.getSortedChildIdsForParent(pageId)
					const currentBottomShapes = siblings
						.slice(0, shapes.length)
						.map((id) => editor.getShape(id)!)

					if (currentBottomShapes.every((shape, i) => shape.id === shapes[i].id)) return

					const otherSiblings = siblings.filter((id) => !shapeIdSet.has(id))
					const bottomSibling = otherSiblings[0]
					const lowestIndex = editor.getShape(bottomSibling)!.index

					const indexes = getIndicesBetween(undefined, lowestIndex, shapes.length)
					editor.updateShapes(
						shapes.map((shape, i) => ({
							...shape,
							id: shape.id,
							isLocked: shape.isLocked,
							index: indexes[i],
						}))
					)
				}

				makeSureShapesAreAtBottom()
				editor.sideEffects.registerAfterCreateHandler('shape', makeSureShapesAreAtBottom)
				editor.sideEffects.registerAfterChangeHandler('shape', makeSureShapesAreAtBottom)

				// Constrain the camera to the bounds of the pages
				const targetBounds = pdf.pages.reduce(
					(acc, page) => acc.union(page.bounds),
					pdf.pages[0].bounds.clone()
				)

				function updateCameraBounds(isMobile: boolean) {
					editor.setCameraOptions({
						constraints: {
							bounds: targetBounds,
							padding: { x: isMobile ? 16 : 164, y: 64 },
							origin: { x: 0.5, y: 0 },
							initialZoom: 'fit-x-100',
							baseZoom: 'default',
							behavior: 'contain',
						},
					})
					editor.setCamera(editor.getCamera(), { reset: true })
				}

				let isMobile = editor.getViewportScreenBounds().width < 840

				react('update camera', () => {
					const isMobileNow = editor.getViewportScreenBounds().width < 840
					if (isMobileNow === isMobile) return
					isMobile = isMobileNow
					updateCameraBounds(isMobile)
				})

				updateCameraBounds(isMobile)
			}}
			components={pdfEditorComponents}
			tools={customTools}
			initialState="mark" // set the initial tool to the exam marking tool
			shapeUtils={customShapeUtils}
			overrides={uiOverrides}
		/>
	)
}

const PageOverlayScreen = track(function PageOverlayScreen({ pdf }: { pdf: Pdf }) {
	const editor = useEditor()

	const viewportPageBounds = editor.getViewportPageBounds()

	const relevantPageBounds = pdf.pages
		.map((page) => {
			if (!viewportPageBounds.collides(page.bounds)) return null
			return page.bounds
		})
		.filter((bounds): bounds is Box => bounds !== null)

	function pathForPageBounds(bounds: Box) {
		return `M ${bounds.x} ${bounds.y} L ${bounds.maxX} ${bounds.y} L ${bounds.maxX} ${bounds.maxY} L ${bounds.x} ${bounds.maxY} Z`
	}

	const viewportPath = `M ${viewportPageBounds.x} ${viewportPageBounds.y} L ${viewportPageBounds.maxX} ${viewportPageBounds.y} L ${viewportPageBounds.maxX} ${viewportPageBounds.maxY} L ${viewportPageBounds.x} ${viewportPageBounds.maxY} Z`

	return (
		<>
			<SVGContainer className="PageOverlayScreen-screen">
				<path
					d={`${viewportPath} ${relevantPageBounds.map(pathForPageBounds).join(' ')}`}
					fillRule="evenodd"
				/>
			</SVGContainer>
			{relevantPageBounds.map((bounds, i) => (
				<div
					key={i}
					className="PageOverlayScreen-outline"
					style={{
						width: bounds.w,
						height: bounds.h,
						transform: `translate(${bounds.x}px, ${bounds.y}px)`,
					}}
				/>
			))}
		</>
	)
})
```

## PdfPicker.tsx

```tsx
import PdfJSWorkerSrc from 'pdfjs-dist/build/pdf.worker.min.mjs?url'
import { useState } from 'react'
import { AssetRecordType, Box, TLAssetId, TLShapeId, createShapeId } from 'tldraw'
import examPdf from '../assets/biologyExamExample.pdf'

export interface PdfPage {
	src: string
	bounds: Box
	assetId: TLAssetId
	shapeId: TLShapeId
}

export interface Pdf {
	name: string
	pages: PdfPage[]
	source: string | ArrayBuffer
}

const pageSpacing = 32

export function PdfPicker({ onOpenPdf }: { onOpenPdf(pdf: Pdf): void }) {
	const [isLoading, setIsLoading] = useState(false)

	async function loadPdf(name: string, source: ArrayBuffer): Promise<Pdf> {
		const PdfJS = await import('pdfjs-dist')
		PdfJS.GlobalWorkerOptions.workerSrc = PdfJSWorkerSrc
		const pdf = await PdfJS.getDocument(source.slice(0)).promise
		const pages: PdfPage[] = []

		const canvas = window.document.createElement('canvas')
		const context = canvas.getContext('2d')
		if (!context) throw new Error('Failed to create canvas context')

		const visualScale = 1.5
		const scale = window.devicePixelRatio

		let top = 0
		let widest = 0
		for (let i = 1; i <= pdf.numPages; i++) {
			const page = await pdf.getPage(i)
			const viewport = page.getViewport({ scale: scale * visualScale })
			canvas.width = viewport.width
			canvas.height = viewport.height
			const renderContext = {
				canvasContext: context,
				viewport,
			}
			await page.render(renderContext).promise

			const width = viewport.width / scale
			const height = viewport.height / scale
			pages.push({
				src: canvas.toDataURL(),
				bounds: new Box(0, top, width, height),
				assetId: AssetRecordType.createId(),
				shapeId: createShapeId(),
			})
			top += height + pageSpacing
			widest = Math.max(widest, width)
		}
		canvas.width = 0
		canvas.height = 0

		for (const page of pages) {
			page.bounds.x = (widest - page.bounds.width) / 2
		}

		return {
			name,
			pages,
			source,
		}
	}

	function onClickOpenPdf() {
		const input = window.document.createElement('input')
		input.type = 'file'
		input.accept = 'application/pdf'
		input.addEventListener('change', async (e) => {
			const fileList = (e.target as HTMLInputElement).files
			if (!fileList || fileList.length === 0) return
			const file = fileList[0]

			setIsLoading(true)
			try {
				const pdf = await loadPdf(file.name, await file.arrayBuffer())
				onOpenPdf(pdf)
			} finally {
				setIsLoading(false)
			}
		})
		input.click()
	}

	async function onClickUseExample() {
		setIsLoading(true)
		try {
			const result = await fetch(examPdf)
			const pdf = await loadPdf('biologyExamExample.pdf', await result.arrayBuffer())
			onOpenPdf(pdf)
		} finally {
			setIsLoading(false)
		}
	}

	if (isLoading) {
		return <div className="PdfPicker">Loading...</div>
	}

	return (
		<div className="PdfPicker">
			<button onClick={onClickOpenPdf}>Open PDF</button>
			<div>or</div>
			<button onClick={onClickUseExample}>Use an example</button>
		</div>
	)
}
```

## pdf-editor.css

```css
.PdfEditor {
	position: absolute;
	inset: 0;
}

.PdfEditor .PdfPicker {
	position: absolute;
	inset: 1rem;
	display: flex;
	align-items: center;
	justify-content: center;
	text-align: center;
	flex-direction: column;
	gap: 1rem;
}
.PdfEditor .PdfPicker button {
	padding: 0.5rem 1rem;
	border: none;
	background: #eee;
	cursor: pointer;
	font: inherit;
}
.PdfEditor .PdfPicker button:hover {
	opacity: 0.9;
}

.PdfEditor .PdfBgRenderer {
	position: absolute;
	pointer-events: none;
}
.PdfEditor .PdfBgRenderer img {
	position: absolute;
}

.PdfEditor .PageOverlayScreen-screen {
	pointer-events: none;
	fill: var(--tl-color-background);
	fill-opacity: 0.8;
	stroke: none;
}
.PdfEditor .PageOverlayScreen-outline {
	position: absolute;
	pointer-events: none;
	box-shadow: var(--tl-shadow-2);
}
.PdfEditor .ExportPdfButton {
	font: inherit;
	background: var(--tl-color-primary);
	border: none;
	color: var(--tl-color-selected-contrast);
	font-size: 1rem;
	padding: 0.5rem 1rem;
	border-radius: 6px;
	margin: 6px;
	margin-bottom: 0;
	pointer-events: all;
	z-index: var(--tl-layer-panels);
	border: 2px solid var(--tl-color-background);
	cursor: pointer;
}
.PdfEditor .ExportPdfButton:hover {
	filter: brightness(1.1);
}
```

--------

# Snowstorm

Category: Use cases

Keywords: snowstorm, front

Show a visual effect in front of the canvas.

This example shows how you can display a visual effect (a snowstorm) in front of the canvas.

## App.tsx

```tsx
import { Tldraw } from 'tldraw'
import 'tldraw/tldraw.css'
import { SnowStorm } from './SnowStorm'
import './snowstorm.css'

export default function BasicExample() {
	return (
		<div className="tldraw__editor">
			<Tldraw persistenceKey="example">
				<SnowStorm />
			</Tldraw>
		</div>
	)
}
```

## SnowStorm.tsx

```tsx
import { useEffect, useRef } from 'react'
import { Vec, useEditor, usePrefersReducedMotion } from 'tldraw'

const MAX_GUST_SPEED = 2
const GUST_ROTATION_DURATION = 30_000

const MAX_PIXELS_SCROLL_EFFECT = 18
const MAX_SCROLL_SPEED = 2

const MIN_POINTER_DISTANCE_SQUARED = 10_000
const SNOWFLAKE_VELOCITY_DECAY = 0.82

interface Snowflake {
	element: HTMLElement
	x: number
	y: number
	vx: number
	vy: number
	pvx: number
	pvy: number
	size: number
}

function rnd(min: number, max: number): number {
	return Math.random() * (max - min) + min
}

class Snowstorm {
	private flakes: Snowflake[] = []
	private active: boolean = false
	private container: HTMLElement
	private width: number
	private height: number

	windX = 0
	windY = 0

	baseWindX = 0

	// Configuration options
	private readonly config = {
		flakesMax: 128,
		flakeSizeMin: 2,
		flakeSizeMax: 5,
		flakeSpeedMinY: 1,
		flakeSpeedMaxY: 3,
		flakeSpeedX: 2,
	}

	constructor(container: HTMLElement = document.body) {
		this.container = container
		this.width = container.clientWidth
		this.height = container.clientHeight
	}

	private createSnowflake(): Snowflake {
		const element = document.createElement('div')
		element.classList.add('snowflake')
		this.container.appendChild(element)

		return {
			element,
			x: 0,
			y: 0,
			vx: 0,
			vy: 0,
			pvx: 0,
			pvy: 0,
			size: 1,
		}
	}

	configureSnowflake(flake: Snowflake) {
		const size = rnd(this.config.flakeSizeMin, this.config.flakeSizeMax)
		flake.x = rnd(0, this.width)
		flake.y = rnd(-this.height, 0)
		flake.vx = rnd(-this.config.flakeSpeedX, this.config.flakeSpeedX)
		flake.vy = rnd(this.config.flakeSpeedMinY, this.config.flakeSpeedMaxY)
		flake.element.style.width = `${size}px`
		flake.element.style.height = `${size}px`
		flake.element.style.opacity = rnd(0.5, 1).toString()
	}

	// Main render loop
	render(screenPoint: Vec, pointerVelocity: Vec, time: number) {
		if (!this.active) return

		const q = Math.sin(time / GUST_ROTATION_DURATION)

		// make wind gradually cycle between 0 and 10, maybe a bit randomly, like gusts of wind
		this.baseWindX = q * MAX_GUST_SPEED

		const pointerLen = pointerVelocity.len2()

		for (const flake of this.flakes) {
			const dist2 = Vec.Dist2(screenPoint, new Vec(flake.x, flake.y))

			// if the pointer is moving quickly, give nearby snowflakes a little boost based on the pointer velocity
			if (dist2 < MIN_POINTER_DISTANCE_SQUARED) {
				if (pointerLen > 1) {
					flake.pvx = pointerVelocity.x
					flake.pvy = pointerVelocity.y < 0 ? pointerVelocity.y / 2 : pointerVelocity.y // don't push up as easily
				}
			} else {
				// otherwise, declay down other snowflakes that have been boosted
				if (flake.pvx !== 0) {
					flake.pvx *= SNOWFLAKE_VELOCITY_DECAY
					if (Math.abs(flake.pvx) < 0.01) {
						flake.pvx = 0
					}

					if (flake.pvy !== 0) {
						flake.pvy *= SNOWFLAKE_VELOCITY_DECAY
						if (Math.abs(flake.pvy) < 0.01) {
							flake.pvy = 0
						}
					}
				}
			}

			// Move the flake based on the wind, the base wind, the pointer velocity, and some random wobble
			flake.x += flake.vx + this.windX + this.baseWindX + flake.pvx
			flake.y += flake.vy + this.windY + flake.pvy

			// Wrap the snowflakes around the screen horizontally
			if (flake.x < 0) {
				flake.x += this.width
				flake.pvx = 0
			} else if (flake.x > this.width) {
				flake.x -= this.width
				flake.pvx = 0
			}

			// Wrap the snowflakes around the screen vertically
			if (flake.y < 0) {
				flake.y += this.height
				flake.pvy = 0
			} else if (flake.y > this.height) {
				flake.y -= this.height
				flake.pvy = 0
			}

			flake.element.style.transform = `translate(${flake.x}px, ${flake.y}px)`
		}
	}

	resize() {
		this.width = this.container.clientWidth
		this.height = this.container.clientHeight
	}

	start() {
		this.active = true
		while (this.flakes.length < this.config.flakesMax) {
			const flake = this.createSnowflake()
			this.configureSnowflake(flake)
			this.flakes.push(flake)
		}
		window.addEventListener('resize', this.resize)
	}

	stop() {
		this.active = false
		for (const flake of this.flakes) {
			this.container.removeChild(flake.element)
		}
		this.flakes = []
	}

	dispose() {
		this.stop()
		window.removeEventListener('resize', this.resize)
	}
}

export function SnowStorm() {
	const editor = useEditor()
	const rElm = useRef<HTMLDivElement>(null)
	const prefersReducedMotion = usePrefersReducedMotion()

	useEffect(() => {
		if (prefersReducedMotion) return
		if (!rElm.current) return
		const snowstorm = new Snowstorm(rElm.current)
		const velocity = new Vec(0, 0)
		const camera = Vec.From(editor.getCamera())

		const start = Date.now()

		function updateOnTick() {
			const time = Date.now() - start

			const newCamera = editor.getCamera()

			// Apply camera movement effect only when zoom isn't changing
			if (newCamera.z === camera.z) {
				const dx = (newCamera.x - camera.x) * camera.z
				const dy = (newCamera.y - camera.y) * camera.z

				// add the camera movement to the velocity
				velocity.addXY(
					Math.min(dx / MAX_PIXELS_SCROLL_EFFECT, MAX_SCROLL_SPEED),
					Math.min(dy / MAX_PIXELS_SCROLL_EFFECT, MAX_SCROLL_SPEED)
				)

				// decay velocity
				velocity.mul(SNOWFLAKE_VELOCITY_DECAY)

				// stop the snowflakes from moving if the camera is not moving
				if (velocity.len2() < 1) {
					velocity.x = 0
					velocity.y = 0
				}

				snowstorm.windX = velocity.x
				snowstorm.windY = velocity.y
			}

			camera.setTo(newCamera)
			snowstorm.render(
				editor.inputs.getCurrentScreenPoint(),
				editor.inputs.getPointerVelocity(),
				time
			)
		}

		snowstorm.start()
		editor.on('tick', updateOnTick)

		return () => {
			editor.off('tick', updateOnTick)
			snowstorm.dispose()
		}
	}, [editor, prefersReducedMotion])

	return <div ref={rElm} className="snowstorm" />
}
```

## snowstorm.css

```css
.snowflake {
	position: absolute;
	background-color: #ccc;
	border-radius: 100%;
	pointer-events: none;
}

.snowstorm {
	position: absolute;
	width: 100%;
	height: 100%;
	pointer-events: none;
}
```

--------

# Timeline scrubber

Category: Use cases

Keywords: timeline, history, undo, redo, time travel, scrubber

A timeline scrubber that records document changes and allows time travel through editor history.

This example demonstrates how to create a timeline scrubber that records all document changes using `store.listen` and enables time travel through the editing history. Users can scrub backwards and forwards through time using a slider control at the bottom of the editor. If changes are made while scrubbed back in time, a new timeline branch is created from that point.

## App.tsx

```tsx
import { useCallback, useEffect, useState } from 'react'
import {
	RecordsDiff,
	reverseRecordsDiff,
	squashRecordDiffs,
	Tldraw,
	TldrawUiSlider,
	track,
	useEditor,
} from 'tldraw'
import 'tldraw/tldraw.css'
import './timeline-scrubber.css'

interface TimelineEntry {
	timestamp: number
	diff: RecordsDiff<any>
}

interface TimelineState {
	entries: TimelineEntry[]
	currentIndex: number
}

export default function TimelineScrubberExample() {
	return (
		<div className="timeline-scrubber-example">
			<Tldraw>
				<TimelineScrubber />
			</Tldraw>
		</div>
	)
}

const TimelineScrubber = track(() => {
	const editor = useEditor()

	const [timeline, setTimeline] = useState<TimelineState>({
		entries: [],
		currentIndex: 0,
	})

	// [1]
	const recordChange = useCallback((diff: RecordsDiff<any>) => {
		const newEntry: TimelineEntry = {
			timestamp: Date.now(),
			diff,
		}

		setTimeline((prev) => {
			// [2]
			if (prev.currentIndex < prev.entries.length) {
				// We're scrubbed back in time, create new timeline branch
				const newEntries = prev.entries.slice(0, prev.currentIndex)
				newEntries.push(newEntry)
				return {
					entries: newEntries,
					currentIndex: newEntries.length,
				}
			} else {
				// Normal forward progression
				const newEntries = [...prev.entries, newEntry]
				return {
					entries: newEntries,
					currentIndex: newEntries.length,
				}
			}
		})
	}, [])

	// [3]
	useEffect(() => {
		if (!editor) return

		const cleanupFn = editor.store.listen(
			({ changes }) => {
				recordChange(changes)
			},
			{ scope: 'document', source: 'user' }
		)

		return cleanupFn
	}, [editor, recordChange])

	// [4]
	const navigateToIndex = useCallback(
		(targetIndex: number) => {
			if (!editor || targetIndex === timeline.currentIndex) return

			const { entries, currentIndex } = timeline

			const isForward = targetIndex > currentIndex
			const diffsToApply = entries
				.slice(Math.min(currentIndex, targetIndex), Math.max(currentIndex, targetIndex))
				.map((entry) => entry.diff)

			if (diffsToApply.length > 0) {
				if (!isForward) diffsToApply.reverse()

				let diffToApply =
					diffsToApply.length === 1 ? diffsToApply[0] : squashRecordDiffs(diffsToApply)

				if (!isForward) {
					diffToApply = reverseRecordsDiff(diffToApply)
				}

				editor.store.mergeRemoteChanges(() => {
					editor.store.applyDiff(diffToApply)
				})
			}

			setTimeline((prev) => ({ ...prev, currentIndex: targetIndex }))
		},
		[timeline, editor]
	)

	const handleSliderChange = useCallback(
		(newIndex: number) => {
			navigateToIndex(newIndex)
		},
		[navigateToIndex]
	)

	const isEmpty = timeline.entries.length === 0

	const length = Math.max(3, String(timeline.entries.length).length)

	return (
		<div className="timeline-scrubber-controls">
			<div className="timeline-scrubber-info">
				{isEmpty
					? '000 / 000'
					: `${timeline.currentIndex.toString().padStart(length, '0')} / ${timeline.entries.length.toString().padStart(length, '0')}`}
			</div>
			<TldrawUiSlider
				steps={timeline.entries.length}
				value={isEmpty ? 1 : timeline.currentIndex}
				label="History"
				title={
					timeline.currentIndex === 0
						? 'Empty canvas'
						: new Date(
								timeline.entries[timeline.currentIndex - 1]?.timestamp ?? Date.now()
							).toLocaleString()
				}
				onValueChange={handleSliderChange}
			/>
		</div>
	)
})

/*
[1]
The recordChange function handles new changes from the store. It creates a new timeline entry
and manages timeline branching logic.

[2]
If we're not at the latest point in time (currentIndex < entries.length), it means the user
made a change while scrubbed back. We truncate the future timeline and create a new branch.
Timeline indexing: 0 = empty canvas, 1 = first change applied, 2 = second change, etc.

[3]
We listen to document changes from user actions only, filtering out changes we make during
navigation to avoid recording our own time travel operations.

[4]
Navigation collects the required diffs, squashes them into a single optimized diff, then
applies it (reversing first if going backward). Uses mergeRemoteChanges to ensure changes
are treated as remote and don't trigger our listener.
*/
```

## timeline-scrubber.css

```css
.timeline-scrubber-example {
	height: 100vh;
	width: 100%;
}

.timeline-scrubber-controls {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	display: flex;
	align-items: center;
	gap: 12px;
	padding: 0 16px;
	background: var(--color-panel);
	border-top: 1px solid var(--color-muted-1);
	font-size: 12px;
	color: var(--color-text-1);
}

.timeline-scrubber-info {
	flex-shrink: 0;
	font-variant: tabular-nums;
}

.timeline-scrubber-controls .tlui-slider__container {
	flex: 1;
}

.timeline-scrubber-example .tl-canvas {
	top: 44px;
}
.timeline-scrubber-example .tlui-layout {
	top: 44px;
	height: calc(100% - 44px);
}
```
